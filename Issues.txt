1. Keepalive (Option A): move orchestrator concurrency to the job; resolve PR/agent at job start; remove top‑level env.* usage that broke validation

Labels: agents, agents:keepalive, agent:codex, ci, automation, enhancement, bug

Why

The current workflow‑level concurrency in .github/workflows/agents-70-orchestrator.yml references env.* during parse time, which caused a fatal error (“Unrecognized named‑value: env”), blocking all orchestrator runs. Keepalive can’t fire if the orchestrator workflow is invalid.
Option A fixes this by:

moving concurrency down to the orchestrator job (where env.* and step outputs are valid), and

resolving PR number and agent alias inside the job across all triggers (issue_comment, workflow_run for Gate, repository_dispatch, workflow_dispatch).

This change keeps your design: cap‑aware parallelism enforced by the gate (not by concurrency), and support for multi‑trigger activation.

Scope

Implement only the following in .github/workflows/agents-70-orchestrator.yml:

- Remove the workflow‑level concurrency: block (the one at the top of the file).

- Add a Resolve context step early in the orchestrator job to compute:

  - pr_number (from event payloads / inputs),

  - agent_alias (from labels or options payloads).

- Add job‑level concurrency that uses those values:

  - group key: keepalive-orchestrator-pr-${PR_NUMBER}-agent-${AGENT_ALIAS}-run-${github.run_id}

  - cancel-in-progress: false (so runs aren’t cancelled)

- Do not change run‑cap logic, PR‑meta locks, or branch‑sync in this issue.

Non‑Goals

No edits to PR‑meta (reaction lock, dispatch scoping, run‑cap)

No changes to branch‑sync or connector behavior

No change to acceptance‑criteria content or Gate internals

Tasks

- Delete workflow‑level concurrency

  - Remove any concurrency: defined at the top level of agents-70-orchestrator.yml.

- Resolve context (job step)

  - Add a step (e.g., id: resolve) that sets pr_number and agent_alias covering all triggers:

    - issue_comment: github.event.issue.number

    - workflow_run (Gate): github.event.workflow_run.pull_requests[0].number (if present)

    - repository_dispatch: github.event.client_payload.pr || pr_number || issue

    - workflow_dispatch: inputs.pr_number

    - Fallback to github.run_id (only as a last resort, to avoid null keys)

    - For agent_alias, prefer:

      - from inputs.options_json or client_payload (agent / agent_alias), else

      - from PR labels agent:* (strip prefix), else default 'codex'.

Example (github‑script)

- name: Resolve PR number and agent alias
  id: resolve
  uses: actions/github-script@v7
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    script: |
      const ev = context.payload || {};
      let prNumber =
        ev.pull_request?.number ??
        ev.issue?.number ??
        ev.workflow_run?.pull_requests?.[0]?.number ??
        ev.inputs?.pr_number ??
        ev.client_payload?.pr ??
        ev.client_payload?.pr_number ??
        ev.client_payload?.issue ??
        null;

      // Try labels only if we have a PR
      async function agentFromLabels(n) {
        if (!n) return null;
        const {owner, repo} = context.repo;
        const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {owner, repo, issue_number: n, per_page: 100});
        const a = labels.find(l => /^agent:/i.test(l.name));
        return a ? a.name.replace(/^agent:/i, '').trim() : null;
      }

      const fromPayload =
        ev.client_payload?.agent ||
        ev.client_payload?.agent_alias ||
        (ev.client_payload?.options && (ev.client_payload.options.agent || ev.client_payload.options.agent_alias)) ||
        (ev.inputs?.options_json ? (JSON.parse(ev.inputs.options_json).agent || JSON.parse(ev.inputs.options_json).agent_alias) : null);

      let agentAlias = fromPayload || null;
      if (!agentAlias) agentAlias = await agentFromLabels(prNumber);
      if (!agentAlias) agentAlias = 'codex';

      // Fallback PR number if truly missing
      if (!prNumber) prNumber = String(context.runId);

      core.setOutput('pr_number', String(prNumber));
      core.setOutput('agent_alias', String(agentAlias));

- Add job‑level concurrency

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    concurrency:
      group: keepalive-orchestrator-pr-${{ steps.resolve.outputs.pr_number }}-agent-${{ steps.resolve.outputs.agent_alias }}-run-${{ github.run_id }}
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v4
      - name: Resolve PR number and agent alias
        id: resolve
        # (script from Task 2)
      # … existing steps (gate, cap, post instruction, ack, branch-sync, etc.) …


- Set env (optional)

  - If later steps need PR_NUMBER/AGENT_ALIAS, export them:

    - name: Export resolved values
      run: |
        echo "PR_NUMBER=${{ steps.resolve.outputs.pr_number }}" >> $GITHUB_ENV
        echo "AGENT_ALIAS=${{ steps.resolve.outputs.agent_alias }}" >> $GITHUB_ENV


- Sanity check

  - Push the change; ensure the orchestrator no longer shows “Invalid workflow file … Unrecognized named‑value: env”.

  - Trigger from each path (comment / Gate / repo‑dispatch) and confirm the same PR maps to a stable group prefix (keepalive-orchestrator-pr-<PR>-agent-<alias>-run-<run_id>).

Acceptance criteria

- Parsing succeeds: The orchestrator workflow loads cleanly; no “Unrecognized named‑value: env” (or similar top‑level parse errors) appear on push.

- Job‑level concurrency is active: Orchestrator runs show a concurrency.group that starts with keepalive-orchestrator-pr-<PR>-agent-<alias>-run-<run_id>.

- Multi‑trigger correctness: For a single PR, activations via issue_comment.created, workflow_run (Gate success), and repository_dispatch all produce the same pr-<PR>-agent-<alias> prefix (final run-<id> differs), proving consistent resolution.

- Parallelism preserved: Starting two orchestrators for the same PR/agent (within the configured cap, enforced elsewhere) results in two active runs; concurrency does not serialize them (cap remains enforced by the gate, not by concurrency).

- No regressions: Existing gate checks, run‑cap enforcement, reaction lock, ACK, and branch‑sync behavior are unchanged.

Implementation notes

Do not re‑introduce workflow‑level concurrency. Keep it only on the orchestrator job.

Concurrency is not your cap; it’s there to avoid cancellation and accidental same‑millisecond duplicates. Your parallelism limit remains enforced by the run‑cap gate in PR‑meta and the pre‑post gate in the orchestrator job.

If you later need the alias from labels earlier, you can move the label lookup to PR‑meta and pass it through options_json / client_payload. For Option A, the in‑job resolution above is sufficient.
