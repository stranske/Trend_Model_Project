1. Keepalive finishing fixes: post instruction as stranske; autoâ€‘apply agents:activated; enforce preâ€‘gate in Orchestrator; wire branchâ€‘sync as a blocking gate; strict Gate=success; oneâ€‘line run summaries; no PR noise when blocked

Labels: agents, agents:keepalive, agent:codex, ci, automation, enhancement, bug

Why

Recent merges brought keepalive very close to spec, but a few gaps remain that can still make it stall or misbehave:

Instruction comment is sometimes authored by the bot instead of stranske; we must prefer ACTIONS_BOT_PAT so thirdâ€‘party agents treat it as a human comment.

Firstâ€‘activation persistence isnâ€™t guaranteed: the system should autoâ€‘label agents:activated on first valid human @agent so later rounds donâ€™t reâ€‘require a human mention.

Preâ€‘gate enforcement exists in PRâ€‘meta; it also needs to run in Orchestrator before posting the next instruction to avoid posting when gates arenâ€™t satisfied.

Branchâ€‘sync must be a hard gate before Round N+1: if the agent â€œfinishedâ€ but the PR head SHA didnâ€™t move, try updateâ€‘branch, else createâ€‘pr+autoâ€‘merge, else set agents:sync-required and do not post the next instruction.

Gate policy must be strictly conclusion='success' for the PRâ€™s current head SHA (not merely â€œcompletedâ€).

Observability: every gate evaluation should emit a singleâ€‘line run summary; when gates fail, no PR comment should be posted.

These adjustments make the pipeline deterministic while preserving the protocol (label + human @agent for first run only + Gate success + perâ€‘PR runâ€‘cap + quiet when blocked).

Scope

Implement the following, and only the following:

Instruction author preference: In the poster, always use ACTIONS_BOT_PAT (posts as stranske) to create the instruction comment; fallback to SERVICE_BOT_PAT only if needed.

Autoâ€‘activation: When the preâ€‘gate passes for the first time on a PR and agents:activated is absent, add agents:activated automatically. Subsequent rounds must not require a new human @agent.

Orchestrator preâ€‘gate: Before posting any next instruction, call the same preâ€‘gate as PRâ€‘meta with requireHumanActivation=false; if gates fail, do nothing (no comment/dispatch) and write a run summary only.

Branchâ€‘sync gate (blocking): After an agent round reports â€œdoneâ€ and before posting Round N+1: if head SHA unchanged, attempt (a) updateâ€‘branch; if still unchanged, (b) createâ€‘pr + autoâ€‘merge; if still unchanged, label agents:sync-required and exit (no instruction).

Strict Gate success: Where we evaluate Gate, require status='completed' && conclusion='success' for the current head SHA.

Oneâ€‘line summaries; no PR noise when blocked: Every gate evaluation writes a single line to $GITHUB_STEP_SUMMARY. No PR comments are posted on gate failures (unless you already gate such diagnostics behind a debug label).

Nonâ€‘Goals

Changing acceptanceâ€‘criteria content or Gateâ€™s internal tests

Altering belt/worker logic beyond the preâ€‘gate call and branchâ€‘sync step placement

Introducing new secrets or tokens (use existing: ACTIONS_BOT_PAT, SERVICE_BOT_PAT)

Replacing the existing ğŸš€ ack/dedupe or the separate status/checklist updater

Tasks
- Instruction comment posts as stranske

  - In the keepalive poster (within Agentsâ€‘70 Orchestrator), select token:
    - token = secrets.ACTIONS_BOT_PAT ?? secrets.SERVICE_BOT_PAT

  - Use that token to create a new instruction comment (never edit) whose body begins with:
    <!-- keepalive-round: {N} -->
    <!-- codex-keepalive-marker -->
    <!-- keepalive-trace: {TRACE} -->
    @<agent> Continue with the remaining tasks. Reâ€‘post Scope/Tasks/Acceptance and only check off when acceptance criteria are satisfied.

    <Scope/Tasks/Acceptance block>


  - Record Round, Trace, Author, CommentId to $GITHUB_STEP_SUMMARY.

- Autoâ€‘apply agents:activated on first valid activation

  - In Agents PR meta manager, right after the preâ€‘gate returns ok=true and has_activated_label=false, add label agents:activated using ACTIONS_BOT_PAT.

  - Logic: requireHumanActivation == true only when agents:activated is absent.

- Orchestrator enforces preâ€‘gate before next instruction

  - Before posting any next instruction, call the same preâ€‘gate with:

    - requireHumanActivation=false (later rounds donâ€™t need a new human mention)

  - If ok=false, exit quietly (no comment/dispatch) and write the oneâ€‘line summary; if ok=true, proceed to post the instruction (Task A).

- Branchâ€‘sync as a blocking gate

  - After an agent round finishes and before posting the next instruction:

    - Compare the PR head SHA with the one captured when the instruction was posted.

    - If unchanged, run updateâ€‘branch via your connector hook (repoâ€‘dispatch or recognized comment command), poll for head change (short TTL).

    - If still unchanged, run createâ€‘pr via the connector, autoâ€‘merge it into the working branch, and poll for head change.

    - If still unchanged, apply agents:sync-required and do not post the next instruction; note the escalation in the run summary.

- Strict Gate result + oneâ€‘line run summaries

  - In both PRâ€‘meta and Orchestrator gate calls, enforce:

    - Gate run on current head SHA exists and status='completed' && conclusion='success'

  - Each gate evaluation writes exactly one line to $GITHUB_STEP_SUMMARY, e.g.:
    - GATE: ok=<bool> reason=<code> pr=#<n> agent=<alias> cap=<cap> active=<active> head=<sha7>

Acceptance criteria

- Instruction author: Instruction comments now appear authored by stranske (when ACTIONS_BOT_PAT is configured); bot is used only as fallback.

- Autoâ€‘activation: On first valid human @agent, the system automatically adds agents:activated. Subsequent rounds do not require a new human comment.

- Orchestrator preâ€‘gate: When labels/Gate/cap donâ€™t permit a next round, no instruction is posted from Orchestrator; only the oneâ€‘line run summary is produced.

- Branchâ€‘sync blocking: When the agent reports â€œdoneâ€ but the PR head SHA is unchanged, the system:
  - attempts updateâ€‘branch,
  - else createâ€‘pr + autoâ€‘merge,
  - else labels agents:sync-required and does not post a next instruction.
    In all three paths, the run summary reflects the outcome and the same TRACE.

- Strict Gate: Keepalive posts/dispatches occur only when Gate succeeds (conclusion='success') for the current head SHA. If Gate is missing/cancelled/failing, the gate summary shows the reason and no PR comments are posted.

- No PR noise when blocked: For missing label, missing firstâ€‘run human @agent, Gate not success, cap reached, or branchâ€‘sync unresolved, no instruction comments are posted; only the oneâ€‘line summary is written.

- Two consecutive rounds on a test PR show:
    - instruction authored as stranske,
    - distinct TRACEs,
    - Gate summaries present,
    - no duplicate dispatches or selfâ€‘cancellation.

Implementation notes

Files likely touched:

.github/workflows/agents-pr-meta.yml

Call preâ€‘gate first; on first activation add agents:activated; keep detection (markers + ğŸš€ dedupe); dispatch orchestrator & connector; write the summary line.

.github/workflows/agents-70-orchestrator.yml

Call preâ€‘gate before posting the next instruction; if pass, create instruction comment with ACTIONS_BOT_PATâ†’SERVICE_BOT_PAT; include markers + TRACE + @<agent>; then ack/fallback as already implemented; write the summary line.

.github/scripts/keepalive_gate.js

Ensure conclusion==='success' check on current head SHA; expose has_activated_label, requireHumanActivation; compute perâ€‘PR cap and active count.

.github/scripts/keepalive_post_work.js (or equivalent)

Ensure it runs before next instruction; implement updateâ€‘branch â†’ createâ€‘pr+autoâ€‘merge â†’ agents:sync-required escalation flow (no PR comment unless you already gate such diagnostics behind a debug label).

Secrets: use existing ACTIONS_BOT_PAT (preferred) and SERVICE_BOT_PAT only.

Agent aliasing: derive @<agent> dynamically from current agent:* label(s) (no hardâ€‘coding).

Runâ€‘cap: default 2, override by label agents:max-runs:X (1..5). Count only this PRâ€™s Orchestrator/Worker runs with status âˆˆ {queued, in_progress}.

Quiet by default: do not post gate failures to the PR; use $GITHUB_STEP_SUMMARY (you may already have a debug label if you want optional oneâ€‘liners in PR).

- Orchestrator â€” post the instruction as stranske (ACTIONS_BOT_PAT â†’ SERVICE_BOT_PAT fallback)
Where to paste: in .github/workflows/agents-70-orchestrator.yml, inside the job that posts the keepalive instruction comment (right before your ack/ğŸš€ logic).
Assumptions: you already resolved PR_NUMBER, ROUND, and TRACE earlier in the job (e.g., from inputs.options_json). If not, add a small â€œresolve contextâ€ step first.

# --- BEGIN: token selection (prefer ACTIONS_BOT_PAT) ---
- name: Detect author token (prefer ACTIONS_BOT_PAT â†’ fallback SERVICE_BOT_PAT)
  id: author_token
  shell: bash
  env:
    HAS_ACTIONS_PAT: ${{ secrets.ACTIONS_BOT_PAT != '' }}
  run: |
    if [ "${HAS_ACTIONS_PAT}" = "true" ]; then
      echo "token=ACTIONS_BOT_PAT" >> "$GITHUB_OUTPUT"
      echo "author=stranske"        >> "$GITHUB_OUTPUT"
    else
      echo "token=SERVICE_BOT_PAT"  >> "$GITHUB_OUTPUT"
      echo "author=stranske-automation-bot" >> "$GITHUB_OUTPUT"
    fi
# --- END: token selection ---

# --- BEGIN: render instruction body with required markers + TRACE + dynamic @agent ---
- name: Render keepalive instruction body
  id: render_instruction
  uses: actions/github-script@v7
  env:
    PR_NUMBER: ${{ env.PR_NUMBER }}     # <- set earlier in your job (from inputs.options_json.pr)
    ROUND:     ${{ env.ROUND }}         # <- set earlier (next round integer)
    TRACE:     ${{ env.TRACE }}         # <- set earlier (unique trace id)
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    script: |
      const {owner, repo} = context.repo;
      const prNumber = process.env.PR_NUMBER;

      // Derive agent alias from PR labels (labels like "agent:codex", "agent:claude")
      const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {owner, repo, issue_number: prNumber, per_page: 100});
      const agentLabels = labels.filter(l => /^agent:/i.test(l.name));
      const agentAlias = agentLabels.length ? agentLabels[0].name.replace(/^agent:/i, '').trim() : 'codex';

      // If you already computed the Scope/Tasks/Acceptance block, inject it here.
      // Otherwise put a small placeholder and let the existing code fill it.
      const staBlock = process.env.SCOPE_TASKS_ACCEPTANCE || '*(scope/tasks/acceptance inserted here by orchestrator)*';

      const body = [
        `<!-- keepalive-round: ${process.env.ROUND} -->`,
        `<!-- codex-keepalive-marker -->`,
        `<!-- keepalive-trace: ${process.env.TRACE} -->`,
        `@${agentAlias} Continue with the remaining tasks. Reâ€‘post Scope/Tasks/Acceptance and only check off when acceptance criteria are satisfied.`,
        ``,
        staBlock
      ].join('\n');

      core.setOutput('agent', agentAlias);
      core.setOutput('body', body);
# --- END: render body ---

# --- BEGIN: create the instruction comment (as `stranske` if ACTIONS_BOT_PAT exists) ---
- name: Post keepalive instruction (as stranske if possible)
  id: post_instruction_primary
  if: steps.author_token.outputs.token == 'ACTIONS_BOT_PAT'
  uses: peter-evans/create-issue-comment@v3
  with:
    token: ${{ secrets.ACTIONS_BOT_PAT }}
    issue-number: ${{ env.PR_NUMBER }}
    body: ${{ steps.render_instruction.outputs.body }}

- name: Post keepalive instruction (fallback: automation bot)
  id: post_instruction_fallback
  if: steps.author_token.outputs.token == 'SERVICE_BOT_PAT'
  uses: peter-evans/create-issue-comment@v3
  with:
    token: ${{ secrets.SERVICE_BOT_PAT }}
    issue-number: ${{ env.PR_NUMBER }}
    body: ${{ steps.render_instruction.outputs.body }}
# --- END: create comment ---

# --- BEGIN: capture comment id/url and write run summary line ---
- name: Capture instruction comment metadata
  id: capture_comment
  run: |
    if [ "${{ steps.post_instruction_primary.outcome }}" = "success" ]; then
      echo "COMMENT_ID=${{ steps.post_instruction_primary.outputs.comment-id }}" >> $GITHUB_ENV
      echo "COMMENT_URL=${{ steps.post_instruction_primary.outputs.comment-url }}" >> $GITHUB_ENV
      echo "AUTHOR=${{ steps.author_token.outputs.author }}" >> $GITHUB_ENV
    else
      echo "COMMENT_ID=${{ steps.post_instruction_fallback.outputs.comment-id }}" >> $GITHUB_ENV
      echo "COMMENT_URL=${{ steps.post_instruction_fallback.outputs.comment-url }}" >> $GITHUB_ENV
      echo "AUTHOR=${{ steps.author_token.outputs.author }}" >> $GITHUB_ENV
    fi
- name: Keepalive poster summary
  shell: bash
  run: |
    echo "Posted instruction: round=${ROUND} trace=${TRACE} author=${AUTHOR} comment=${COMMENT_URL}" >> $GITHUB_STEP_SUMMARY
# --- END: metadata & summary ---

- PRâ€‘meta â€” autoâ€‘apply agents:activated on the first valid activation
  - Where to paste: in .github/workflows/agents-pr-meta.yml, after your preâ€‘gate step returns ok=true and before you dispatch Orchestrator/Connector.
  - Assumptions: your gate step outputs ok, has_activated_label (or equivalent), and youâ€™re on the issue_comment.created path for a PR.

# --- BEGIN: auto-apply agents:activated on first valid activation ---
- name: Auto-apply `agents:activated` (first activation only)
  if: |
    steps.keepalive_gate.outputs.ok == 'true' &&
    (steps.keepalive_gate.outputs.has_activated_label == 'false' || steps.keepalive_gate.outputs.has_activated_label == '')
  uses: actions/github-script@v7
  with:
    github-token: ${{ secrets.ACTIONS_BOT_PAT }}   # post label change as `stranske`
    script: |
      const {owner, repo} = context.repo;
      const prNumber = context.payload.issue.number; // event is issue_comment on a PR
      await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: ['agents:activated'] });
# --- END: auto-apply label ---

# (optional but recommended) record a terse gate summary for operability
- name: Gate summary (PR-meta)
  if: always()
  run: |
    echo "GATE: ok=${{ steps.keepalive_gate.outputs.ok }} reason=${{ steps.keepalive_gate.outputs.reason }} pr=#${{ github.event.issue.number }}" >> $GITHUB_STEP_SUMMARY

2. Keepalive branchâ€‘sync wiring: emit /update-branch as stranske when unsynced, and guarantee fallback dispatch to agents-keepalive-branch-sync.yml with full observability

Labels: agents, agents:keepalive, agent:codex, ci, automation, enhancement, bug

Why
We added the branchâ€‘sync components (commentâ€‘first command and a fallback Keepalive Branch Sync workflow) but, in the latest test PR, the commentâ€‘first path didnâ€™t post and the fallback workflow did not run, so the PR head didnâ€™t advance before the next keepalive round. That leads to â€œrepeat old work.â€ This issue finishes the wiring so that when an agent says â€œdoneâ€ but the PR head SHA is unchanged, we (1) always ask the agent to update the branch via a visible comment command as stranske, and (2) if that doesnâ€™t land within a short TTL, we reliably dispatch the alreadyâ€‘merged fallback workflow and prove the result in run summariesâ€”before allowing the next round.

Scope

Add unsynced detection (previous vs. current PR head SHA) in the Orchestratorâ€™s keepalive postâ€‘work phase.

When unsynced: create a new PR comment (not edit) with body **exactly**

/update-branch trace:{TRACE}

posted as stranske (token: ACTIONS_BOT_PAT; fallback SERVICE_BOT_PAT). Add ğŸ‘€ to the comment and record comment id/URL in the step summary.

Wait TTL_short (e.g., 60â€“120s) while polling for a head SHA move; if unchanged, dispatch the fallback workflow agents-keepalive-branch-sync.yml via createWorkflowDispatch using a token with workflow scope and permissions: actions: write. Pass the inputs you already defined (PR number, trace, base, head, head_sha, agent, round, comment metadata, idempotency key).

Poll up to TTL_long (e.g., 2â€“5 minutes) for the PR head to advance (either from the commentâ€‘first path or fallback).

If still unchanged, apply agents:sync-required and do not post the next keepalive instruction (summaryâ€‘only; no PR noise unless debug label present).

Write concise $GITHUB_STEP_SUMMARY lines for each action (comment posted, dispatch HTTP status, run URL when available, merged SHA, final outcome).

Nonâ€‘Goals

Changing acceptance criteria, Gate rules, or the existing preâ€‘gates (label present, human @agent derived from agent:*, Gate concluded, runâ€‘cap).

Adding new secrets or external services.

Relying on nonâ€‘documented connector APIs; this issue uses PR comments and a GitHubâ€‘side fallback only.

Tasks

- Persist & compare PR head SHA

  - At instruction time, persist {PR, round, trace, head_sha} (simple, durable mechanisms are fineâ€”e.g., a hidden HTML comment on the PR <!-- keepalive-last-sha:{SHA} --> keyed by trace, or a tiny JSON artifact).

  - In the postâ€‘work phase, read the previous value and compute unsynced = (prev_head_sha === current_head_sha).

- Commentâ€‘first command (Optionâ€¯1) â€” must be visible and authored by stranske

  - Select token: TOKEN = ACTIONS_BOT_PAT ?? SERVICE_BOT_PAT.

  - Create a new PR comment with body "/update-branch trace:{TRACE}" (no extra markup), then add ğŸ‘€ reaction.

  - Write to $GITHUB_STEP_SUMMARY: posted=/update-branch, author={stranske|bot}, comment_id, trace, round.

  - Poll pulls.get(head.sha) every 5s up to TTL_short; if changed â†’ mark success (mode=comment-update-branch) and proceed to the next keepalive round.

- Fallback dispatch (Optionâ€¯3) â€” must always fire when TTL_short expires

  - Ensure the Orchestrator job that dispatches has:
    permissions:
      actions: write
      contents: read
      pull-requests: write

  - Use createWorkflowDispatch to call exactly agents-keepalive-branch-sync.yml, passing inputs:
    pr_number, trace, base_ref, head_ref, head_sha, agent, round, comment_id, comment_url, idempotency_key (trace is sufficient).

  - Use ACTIONS_BOT_PAT for the dispatch (required for crossâ€‘workflow dispatch).

  - Write to $GITHUB_STEP_SUMMARY: dispatched=keepalive-branch-sync, http_status, workflow=file, trace, and, when available, a link to the run.

- Poll for landing or pause

  - Poll PR head SHA up to TTL_long; on success â†’ record mode=action-sync-pr and the merged commit SHA, then proceed.

  - On timeout â†’ apply label agents:sync-required; do not post the next instruction; write reason=sync-timeout with {trace} to the step summary. (Optionally post a single oneâ€‘line comment only when agents:debug is present.)

- Idempotency & noâ€‘noise

  - Treat {PR, round, trace} as an idempotency key: donâ€™t reâ€‘emit the command or dispatch for the same key.

  - Do not post any comments for negative cases (gates failed, capped, paused)â€”summaryâ€‘only.

Acceptance criteria

- On a test PR with agents:keepalive and agent:codex, after an agent â€œdoneâ€ where the PR head SHA is unchanged:

  - A new PR comment appears, authored by stranske, with body exactly /update-branch trace:{TRACE} and an ğŸ‘€ reaction from automation.

  - If head moves within TTL_short, the step summary shows mode=comment-update-branch, and the next keepalive instruction is allowed.

  - If head does not move within TTL_short, the Actions list shows a run of â€œKeepalive Branch Syncâ€, and the step summary contains dispatched=keepalive-branch-sync, http_status, and trace.

  - After the fallback completes, the PR head SHA changes within TTL_long; the step summary records mode=action-sync-pr and the merged SHA; the next keepalive instruction is allowed.

  - If neither path lands a commit within TTL_long, label agents:sync-required is applied and no next instruction is posted; the step summary shows reason=sync-timeout trace:{TRACE}.

  - Reâ€‘running the same round ({PR, round, trace}) is idempotent (no duplicate comment/dispatch).

  - Negative cases (keepalive label removed, Gate not concluded, runâ€‘cap reached) produce no PR comments; only the step summary records reason.

Implementation notes

Secrets: use existing ACTIONS_BOT_PAT (preferred) and SERVICE_BOT_PAT (fallback). Do not introduce new PATs.

Posting identity: commentâ€‘command must use the selected PAT so the author shows as stranske when available.

Dispatch filename: must be exactly agents-keepalive-branch-sync.yml. Pass all inputs already defined in that workflow.

Logging: keep PR noise minimalâ€”post only the command comment and (if debug label present) a oneâ€‘line escalation; everything else goes to $GITHUB_STEP_SUMMARY.

Storage for previous SHA: simplest durable approach is a hidden PR comment keyed by trace (e.g., <!-- keepalive-last-sha:{SHA} trace:{TRACE} -->), or a tiny JSON artifact stored/retrieved in the Orchestrator job.

Safety: restrict all operations to originâ€‘repo PRs (skip forks); mask tokens; never log external URLs or payloads.

