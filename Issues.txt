1) PR Gate unification: one reusable CI, one coverage publisher, Gate as the single entry

Suggested title: PR Gate: unify CI signals and coverage into one reusable job, keep Docker/doc fast-paths
Labels: ci, workflows, priority: high, risk: low, testing 
GitHub

Why:
Gate already orchestrates matrix Python CI and conditional Docker plus a docs-only fast-pass. Coverage and status reporting still bounce between Gate and Post-CI, which invites drift. Centralizing CI signals and the coverage artifact in a single reusable job makes Gate authoritative and simplifies Post-CI to read-only summaries. 
GitHub

Task List:

Fold ruff, type checks, pytest + coverage, and artifact upload into reusable-10-ci-python.yml, producing a single, stable coverage artifact path.

Keep Gate’s change classifiers: docs-only fast-pass, Docker-only smoke. Ensure those paths still short-circuit heavy jobs.

Remove any second publisher of coverage from other workflows; make Post-CI read coverage only.

Ensure Gate emits one commit status (“Gate / gate”) that branch protection can require. 
GitHub

Acceptance Criteria:

One CI job publishes coverage; Post-CI never repackages it.

Gate’s job summary shows lint, type check, tests, and coverage lines.

Docker smoke runs only when Docker-relevant paths change; docs-only PRs fast-pass.

Branch protection can require “Gate / gate” exclusively. 
GitHub

Implementation Notes:

Keep artifact name and folder deterministic (e.g., artifacts/coverage/coverage.xml, coverage.json).

Gate should pass only a minimal matrix (e.g., py311, py312) to the reusable CI for speed.

2) Autofix: single opt-in path from Post-CI; retire duplicate Autofix entry point

Suggested title: Autofix: one path triggered from Post-CI on autofix label; retire duplicate PR workflow
Labels: workflows, ci, autofix, priority: medium, risk: low 
GitHub

Why:
You have two places that try to “do small hygiene fixes.” That’s how you get mysterious commits and finger-pointing. Make Post-CI the only invoker of the reusable autofix and delete the standalone PR autofix workflow, or vice versa. Pick one brain. 
GitHub

Task List:

Wire maint-46-post-ci.yml to call the reusable autofix job only when the PR has autofix (and optionally autofix:clean).

Remove the separate Autofix workflow file that duplicates behavior.

Normalize the label name in code and docs to one string (autofix:clean recommended) and drop fallbacks.

Post a concise summary comment listing files touched and checks re-run.

Acceptance Criteria:

Exactly one workflow path can perform autofix in PRs.

The chosen path is gated by an opt-in label and produces a single summarizing comment.

No duplicate “fix” commits for the same PR event.

Implementation Notes:

Use workflow_call with explicit inputs for dry-run and allowed file globs.

Keep the diff surface intentionally small: formatting, trivial lints, import order.

3) Agents control plane: Orchestrator only; workers callable; stronger Guard patterns

Suggested title: Agents: Orchestrator is the only scheduler; belt workers workflow_call only; expand Guard
Labels: agents, automation, workflows, priority: medium, risk: medium 
GitHub

Why:
The Orchestrator is already your control plane. Multiple worker cron schedules are redundant and increase run noise. Centralize scheduling in Orchestrator and treat dispatcher/worker/conveyor as callable plumbing. Strengthen Agents Guard to match any agents-*.yml change, not just a hand-picked list. 
GitHub

Task List:

Remove all on: schedule from belt/dispatcher/worker/conveyor workflows; expose them via workflow_call with typed inputs.

Update Orchestrator to call the belt jobs with explicit parameters and short circuit when no labeled work exists.

Expand Agents Guard from explicit filenames to glob: .github/workflows/agents-*.yml, requiring agents:allow-change to proceed.

Add a single “keepalive” mechanism inside Orchestrator rather than per-worker.

Acceptance Criteria:

Only Orchestrator runs on a schedule; all other agent workflows show “callable only.”

Agents Guard blocks edits to any agents workflow unless the allow-label is present.

Run volume drops meaningfully, with no loss of function (workers still execute when called).

Implementation Notes:

Pass a “dry-run vs live” flag and a “max parallel” cap into workers from Orchestrator to avoid surprise storms.

4) Branch-protection hardening around Gate

Suggested title: Branch protection: require “Gate / gate” and verify via repo-health check
Labels: ci, devops, infra, health:repo, priority: medium, risk: low 
GitHub

Why:
Gate already emits a stable status. Enforce it in branch protection, and add a weekly repo-health assertion that the protection config still requires that check. This prevents quiet regressions when someone toggles required checks or renames statuses. 
GitHub

Task List:

Set required status checks on the default branch to include exactly “Gate / gate.”

In the repo-health workflow, add a step that reads branch protection and fails if the required check list drifts.

Summarize the current protection config in the run output for auditability.

Acceptance Criteria:

Merges are blocked unless Gate is green.

Health job fails with a clear message if “Gate / gate” is not required or is renamed.

Weekly run summary shows branch protection details.

Implementation Notes:

Use the REST API endpoint for branch protection and filter on the required status checks array.

5) Extract inline JS to .github/scripts/ and document the target layout

Suggested title: Shrink YAML, grow scripts: move logic into .github/scripts/ and document the target layout
Labels: documentation, docs, workflows, priority: medium, risk: low 
GitHub

Why:
You’re already using script files for some guardrails. Do the same for Gate’s change-detection, comment dedupe, and coverage normalization so it’s testable and reusable. Also, capture the target workflow layout in docs so future edits don’t re-invent chaos. 
GitHub

Task List:

Create .github/scripts/ and extract:

detect-changes.js for doc-only and docker path logic

comment-dedupe.js for PR summary updates

coverage-normalize.js for post-processing artifacts

Add unit tests for these scripts using Node + a tiny harness.

Add docs/ci/WORKFLOWS.md describing the target layout, including PR checks, autofix path, agents control plane, and health checks. Link to each workflow file.

Update any actions/github-script steps to import and call these scripts.

Acceptance Criteria:

No long inline JS blobs remain in YAML.

Scripts have at least smoke tests.

A single docs/ci/WORKFLOWS.md page shows the “target layout” diagram and links.

Actionlint and CI are green after the refactor. 
GitHub

Implementation Notes:

Keep script exports minimal, prefer pure functions.

Use the same summary section titles as current Issues for consistency.
