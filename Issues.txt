1. Keepalive PR‑meta hardening — single dispatch per activation (shared reaction lock), and scope detect/dispatch to the correct event path

Labels: agents, agents:keepalive, agent:codex, ci, automation, enhancement, bug

Why
On PR #3491, the Agents PR meta manager workflow executed its keepalive sub‑jobs repeatedly under on: pull_request as well as its usual issue_comment route (see the Checks list), and the workflow file rendered for that run shows PR‑meta is configured to trigger on issue_comment, pull_request, and workflow_run: Gate.completed. Because the PR‑meta concurrency group falls back to github.run_id when it cannot resolve a PR number on the workflow_run payload, the Gate path and the comment path can run concurrently and each can reach a dispatch step, resulting in multiple near‑simultaneous runs. Evidence:

Multiple PR‑meta runs listed under “on: pull_request” on #3491.

PR‑meta workflow file for #3491 showing on: issue_comment, pull_request, and workflow_run: Gate with a concurrency group that falls back to github.run_id.

The same workflow file contains both the comment path (Detect keepalive round comments) and the Gate path (Resume keepalive after Gate) and each includes a dispatch step that uses the same comment_id/comment_url.

Scope

- Scope detect/dispatch to run only on issue_comment.created.

- Scope Gate resume (no detect) to run only on workflow_run where workflow_run.name == 'Gate' and conclusion == 'success' and pull_requests[0].number is present.

- Add a shared reaction lock on the activation comment_id so only one path (comment or Gate) can dispatch per activation.

- Add a dispatch‑stage concurrency group per PR to serialize “dispatch orchestrator” across PR‑meta instances.

Non‑Goals

Changing acceptance criteria, Gate contents, or branch‑sync behavior

Changing moderation of connector comments

Tasks

- Scope jobs by event in .github/workflows/agents-pr-meta.yml:

  - keepalive_dispatch (Detect keepalive round comments & Dispatch) →
    if: github.event_name == 'issue_comment' && github.event.action == 'created'

  - keepalive_from_gate (Resume keepalive after Gate) →
    if: github.event_name == 'workflow_run' && github.event.workflow_run.name == 'Gate' && github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.pull_requests && github.event.workflow_run.pull_requests[0] && github.event.workflow_run.pull_requests[0].number

  - upsert_pr_body_sections →
    if: github.event_name == 'pull_request' (no dispatch in this job)

- Shared reaction lock (cross‑event) before any dispatch step (both paths):

  - Use issues.createReaction on the activation comment_id with content: 'rocket'.

  - If HTTP 409 (already exists), exit that job branch (another path already dispatched).

- Dispatch‑stage concurrency

  - For the exact step/job that calls repos.createDispatchEvent / actions.createWorkflowDispatch, add:
    concurrency:
      group: pr-meta-dispatch-${{ needs.keepalive_dispatch.outputs.pr || env.PR_NUMBER }}
      cancel-in-progress: false

  - One‑line summary (no PR noise):

    - After the lock, print:
      DISPATCH: ok=<true|false> path=<comment|gate> pr=#<n> comment_id=<id> trace=<trace>

Acceptance criteria

- On a test PR with both issue_comment and Gate completion close together, only one dispatch happens for a given activation comment; the other path exits with the lock summary.

- The Checks list no longer shows “Detect keepalive round comments / Dispatch” running under on: pull_request.

- Keepalive continues to work for normal sequences (human @agent → Gate success → instruction → agent run).

Implementation notes

All evidence for these changes is present on #3491 and its workflow file: multi‑event triggers, concurrency fallback, and duplicate dispatch paths.

2. Keepalive run‑cap: enforce at PR‑meta dispatch by counting orchestrator runs in {queued,in_progress} for this PR (prevents bursts)

Labels: agents, agents:keepalive, agent:codex, ci, automation, enhancement, bug

Why
On PR #3491, several PR‑meta runs launched close together and orchestrator accepted parallel starts (as designed). The cap didn’t prevent the burst because, at dispatch time, concurrent PR‑meta instances likely evaluated the cap before any orchestrator run had flipped to in_progress. With the current PR‑meta triggers (issue_comment, pull_request, and workflow_run: Gate.completed), it’s critical to count queued runs as active and to tie the count to this PR, independent of event type. Evidence:

multiple PR‑meta runs visible on #3491, including under on: pull_request; orchestrator triggers support parallel acceptance.

Scope

In PR‑meta (before any dispatch), compute active = # of orchestrator runs for this PR with status ∈ {queued, in_progress} and enforce active < cap.

Cap defaults to 2; override via label agents:max-runs:X (X ∈ 1..5).

Use workflow id/name to filter orchestrator runs; use a PR discriminator independent of event type.

Non‑Goals

Changing orchestrator concurrency or the worker pipeline

Changing label names or defaults

Tasks

- Active‑run counter (github‑script step) in agents-pr-meta.yml just before dispatch:

  - List orchestrator workflow runs twice (status queued and in_progress).

  - Filter by this PR using a discriminator you control (e.g., the orchestrator’s concurrency.group embeds the PR number, or inputs.options_json.pr is echoed into the run’s display_title/run_name).

  - Return active and cap (from label or default 2); set ok = active < cap.

- Gate decision: if ok == false, skip dispatch and write one summary line:
  CAP: ok=false reason=run-cap-reached pr=#<n> cap=<cap> active=<active>

- Mirror the same check in Orchestrator before posting the next instruction (prevents over‑posting when several orchestrators are in flight).

Acceptance criteria

- On a test PR with agents:max-runs:2, two dispatches in quick succession succeed; a third concurrent dispatch attempt is skipped with the cap summary line.

- The orchestrator still runs in parallel up to the cap; no unintended serialization occurs.

- The Checks tab shows no bursts beyond the set cap.

Implementation notes

Counting both queued and in_progress is essential because parallel PR‑meta instances evaluate the cap before the first run transitions to in_progress.

Filtering by PR must not rely on pull_requests[] for repository_dispatch/workflow_run events; use the orchestrator workflow name/id and your own PR discriminator (e.g., concurrency group containing -<PR>-).
