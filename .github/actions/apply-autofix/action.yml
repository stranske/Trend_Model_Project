name: "Apply autofix and deliver"
description: "Run the composite autofix action and either push with the service bot PAT or upload a patch artifact"
inputs:
  head_ref:
    description: "Branch ref for the pull request head"
    required: true
  same_repo:
    description: "Whether the PR head resides in the same repository"
    required: true
  commit_prefix:
    description: "Commit prefix for autofix commits"
    required: false
    default: "chore(autofix):"
  safe_paths:
    description: "Newline-separated list of files or directories that autofix may modify"
    required: false
    default: ""
  pr:
    description: "Pull request number"
    required: true
  service_bot_pat:
    description: "Service bot PAT used for pushes"
    required: false
  github_token:
    description: "Fallback GitHub token for checkout"
    required: true
outputs:
  changed:
    description: "Whether any files were modified"
    value: ${{ steps.collect.outputs.changed }}
  remaining_issues:
    description: "Remaining ruff issues after autofix"
    value: ${{ steps.collect.outputs.remaining }}
  new_issues:
    description: "New (non-allowlisted) ruff issues"
    value: ${{ steps.collect.outputs.new }}
runs:
  using: "composite"
  steps:
    - name: Checkout PR head
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.head_ref }}
        fetch-depth: 0
        token: ${{ inputs.same_repo == 'true' && inputs.service_bot_pat || inputs.github_token }}

    - name: Run composite autofix
      id: autofix
      uses: ./.github/actions/autofix

    - name: Collect autofix outputs
      id: collect
      shell: bash
      run: |
        echo "changed=${{ steps.autofix.outputs.changed }}" >> "$GITHUB_OUTPUT"
        echo "remaining=${{ steps.autofix.outputs.remaining_issues }}" >> "$GITHUB_OUTPUT"
        echo "new=${{ steps.autofix.outputs.new_issues }}" >> "$GITHUB_OUTPUT"

    - name: Restrict changes to safe paths
      if: ${{ inputs.safe_paths != '' }}
      shell: bash
      env:
        SAFE_PATHS: ${{ inputs.safe_paths }}
      run: |
        set -euo pipefail
        mapfile -t SAFE_LIST < <(printf '%s\n' "$SAFE_PATHS" | tr -d '\r' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed '/^$/d')
        if [ ${#SAFE_LIST[@]} -eq 0 ]; then
          echo "[autofix] No safe paths provided after sanitisation; skipping restriction."
          exit 0
        fi
        git ls-files -z -m -d -o --exclude-standard | while IFS= read -r -d '' path; do
          allow=0
          for safe in "${SAFE_LIST[@]}"; do
            normalised_safe=${safe%/}
            if [[ "$path" == "$normalised_safe" ]]; then
              allow=1
              break
            fi
            prefix="${normalised_safe}/"
            if [[ "${path#"$prefix"}" != "$path" ]]; then
              allow=1
              break
            fi
          done
          if [ $allow -eq 0 ]; then
            echo "[autofix] Reverting disallowed path: $path"
            if git ls-files --error-unmatch "$path" >/dev/null 2>&1; then
              git restore --source=HEAD --worktree -- "$path" 2>/dev/null || git checkout -- "$path" 2>/dev/null || true
              git restore --source=HEAD --staged -- "$path" 2>/dev/null || git reset HEAD -- "$path" 2>/dev/null || true
            else
              rm -rf -- "$path"
            fi
          fi
        done

    - name: Commit changes
      if: ${{ inputs.same_repo == 'true' && steps.autofix.outputs.changed == 'true' }}
      shell: bash
      env:
        COMMIT_PREFIX: ${{ inputs.commit_prefix }}
        SAFE_PATHS: ${{ inputs.safe_paths }}
      run: |
        set -euo pipefail
        git config user.name "trend-service-bot"
        git config user.email "trend-service-bot@users.noreply.github.com"
        tmp=$(mktemp)
        printf '%s\n' "$SAFE_PATHS" | tr -d '\r' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed '/^$/d' > "$tmp"
        if [ -s "$tmp" ]; then
          while IFS= read -r path; do
            [ -z "$path" ] && continue
            if git ls-files --error-unmatch "$path" >/dev/null 2>&1 || [ -e "$path" ]; then
              git add -- "$path"
            fi
          done < "$tmp"
        else
          git add -A
        fi
        rm -f "$tmp"
        if git diff --cached --quiet; then
          echo "No staged changes after autofix; skipping commit."
          exit 0
        fi
        prefix=${COMMIT_PREFIX:-chore(autofix):}
        git commit -m "${prefix% } formatting/lint"

    - name: Push changes
      if: ${{ inputs.same_repo == 'true' && steps.autofix.outputs.changed == 'true' }}
      shell: bash
      env:
        HEAD_REF: ${{ inputs.head_ref }}
        PAT: ${{ inputs.service_bot_pat }}
      run: |
        set -euo pipefail
        if [ -z "${PAT}" ]; then
          echo "::error::SERVICE_BOT_PAT is required to push autofix commits." >&2
          exit 1
        fi
        git remote set-url origin "https://x-access-token:${PAT}@github.com/${GITHUB_REPOSITORY}.git"
        for attempt in 1 2 3; do
          echo "[autofix] Push attempt ${attempt}"
          if git push origin HEAD:"${HEAD_REF}"; then
            exit 0
          fi
          echo "[autofix] Push failed; attempting rebase." >&2
          git fetch origin "${HEAD_REF}" --prune
          if git rebase --autostash --strategy-option theirs origin/"${HEAD_REF}"; then
            continue
          fi
          git rebase --abort || true
        done
        echo "::error::Failed to push autofix changes after 3 attempts." >&2
        exit 1

    - name: Prepare patch artifact
      if: ${{ inputs.same_repo != 'true' && steps.autofix.outputs.changed == 'true' }}
      shell: bash
      env:
        COMMIT_PREFIX: ${{ inputs.commit_prefix }}
        SAFE_PATHS: ${{ inputs.safe_paths }}
      run: |
        set -euo pipefail
        git config user.name "trend-service-bot"
        git config user.email "trend-service-bot@users.noreply.github.com"
        tmp=$(mktemp)
        printf '%s\n' "$SAFE_PATHS" | tr -d '\r' | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' | sed '/^$/d' > "$tmp"
        if [ -s "$tmp" ]; then
          while IFS= read -r path; do
            [ -z "$path" ] && continue
            if git ls-files --error-unmatch "$path" >/dev/null 2>&1 || [ -e "$path" ]; then
              git add -- "$path"
            fi
          done < "$tmp"
        else
          git add -A
        fi
        rm -f "$tmp"
        if git diff --cached --quiet; then
          exit 0
        fi
        prefix=${COMMIT_PREFIX:-chore(autofix):}
        git commit -m "${prefix% } formatting/lint (patch)" || true
        git format-patch -1 --stdout > autofix.patch

    - name: Upload patch artifact
      if: ${{ inputs.same_repo != 'true' && steps.autofix.outputs.changed == 'true' }}
      uses: actions/upload-artifact@v4
      with:
        name: autofix-patch-pr-${{ inputs.pr }}
        path: autofix.patch
        if-no-files-found: ignore
        retention-days: 7
