name: "Codex Bootstrap (concise)"
description: "Create a new branch and draft PR from an issue, then post a Codex command. Uses PAT if provided, else GITHUB_TOKEN."

inputs:
  issue:
    description: "Issue number to bootstrap from"
    required: true
  service_bot_pat:
    description: "Optional classic PAT with repo scope for branch/PR creation"
    required: false
  allow_fallback:
    description: "Allow fallback to GITHUB_TOKEN when PAT is missing"
    default: "true"
    required: false
  codex_command:
    description: "Command to post to the PR to trigger Codex"
    default: "codex: start"
    required: false
  base_branch:
    description: "Base branch to open PR against (defaults to current checkout)"
    required: false
  debug_mode:
    description: "Enable verbose logging"
    default: "false"
    required: false

outputs:
  pr_number:
    description: "Opened or reused PR number"
    value: ${{ steps.pr_out.outputs.pr_number }}
  pr_url:
    description: "Opened or reused PR URL"
    value: ${{ steps.pr_out.outputs.pr_url }}
  branch_name:
    description: "Created branch name"
    value: ${{ steps.branch_out.outputs.branch_name }}

runs:
  using: "composite"
  steps:
    - name: Preflight and token selection
      id: preflight
      shell: bash
      env:
        INPUT_PAT: ${{ inputs.service_bot_pat }}
        INPUT_ALLOW_FALLBACK: ${{ inputs.allow_fallback }}
        GH_TOKEN_DEFAULT: ${{ github.token }}
        DEBUG_MODE: ${{ inputs.debug_mode }}
      run: |
        set -euo pipefail
        issue="${{ inputs.issue }}"
        [[ -n "$issue" ]] || { echo "issue input is required" >&2; exit 2; }

        # Choose token: PAT first, else GITHUB_TOKEN if allowed
        token=""
        if [ -n "${INPUT_PAT:-}" ]; then
          token="$INPUT_PAT"
          src="SERVICE_BOT_PAT"
        elif [ "${INPUT_ALLOW_FALLBACK:-true}" = "true" ]; then
          token="$GH_TOKEN_DEFAULT"
          src="GITHUB_TOKEN"
        else
          echo "SERVICE_BOT_PAT missing and fallback disabled" >&2
          exit 86
        fi

        # Minimal auth probe
        if ! curl -fsS -H "Authorization: Bearer ${token}" https://api.github.com/rate_limit >/dev/null; then
          # Try legacy header
          if ! curl -fsS -H "Authorization: token ${token}" https://api.github.com/rate_limit >/dev/null; then
            echo "Auth probe failed for selected token source ${src}" >&2
            exit 1
          fi
        fi

        # Derive owner/repo
        repo_full="${{ github.repository }}"
        owner="${repo_full%%/*}"
        repo="${repo_full##*/}"

        # Determine base branch
        base_branch_input="${{ inputs.base_branch }}"
        if [ -n "$base_branch_input" ]; then
          base_branch="$base_branch_input"
        else
          # Fall back to the currently checked-out ref name
          base_branch="${{ github.ref_name }}"
        fi

        # Determine head sha for base branch
        api="https://api.github.com/repos/${owner}/${repo}"
        head_sha=$(curl -fsS -H "Authorization: Bearer ${token}" "${api}/git/ref/heads/${base_branch}" | jq -r '.object.sha')
        if [ "$head_sha" = "null" ] || [ -z "$head_sha" ]; then
          # Try default branch
          default_branch=$(curl -fsS -H "Authorization: Bearer ${token}" "${api}" | jq -r '.default_branch')
          head_sha=$(curl -fsS -H "Authorization: Bearer ${token}" "${api}/git/ref/heads/${default_branch}" | jq -r '.object.sha')
          base_branch="$default_branch"
        fi
        if [ -z "$head_sha" ] || [ "$head_sha" = "null" ]; then
          echo "Failed to resolve base branch head sha" >&2
          exit 3
        fi

        # Create a unique branch name (agents/codex-issue-<n>-<run_id>)
        run_id="${{ github.run_id }}"
        branch="agents/codex-issue-${issue}-${run_id}"

        # Export for later steps
        {
          echo "TOKEN_SRC=${src}"
          echo "BOOTSTRAP_TOKEN=${token}"
          echo "OWNER=${owner}"
          echo "REPO=${repo}"
          echo "BASE_BRANCH=${base_branch}"
          echo "BASE_SHA=${head_sha}"
          echo "ISSUE_NUM=${issue}"
          echo "BRANCH_NAME=${branch}"
        } >> "$GITHUB_ENV"

        if [ "${DEBUG_MODE}" = "true" ]; then
          echo "owner/repo=${owner}/${repo} base=${base_branch} sha=${head_sha} branch=${branch} token=${src}"
        fi

    - name: Create branch (ref)
      id: create_branch
      shell: bash
      env:
        OWNER: ${{ env.OWNER }}
        REPO: ${{ env.REPO }}
        BASE_SHA: ${{ env.BASE_SHA }}
        BRANCH_NAME: ${{ env.BRANCH_NAME }}
        BOOTSTRAP_TOKEN: ${{ env.BOOTSTRAP_TOKEN }}
      run: |
        set -euo pipefail
        api="https://api.github.com/repos/${OWNER}/${REPO}/git/refs"
            // Optional re-bootstrap if existing PR is closed
            if (prNumberExisting && '${{ inputs.rebootstrap_closed_pr }}' === 'true') {
              try {
                const { data: existingPR } = await github.rest.pulls.get({ owner, repo, pull_number: prNumberExisting });
                if (existingPR.state === 'closed') {
                  core.info(`Existing PR #${prNumberExisting} is closed; initiating re-bootstrap.`);
                  const replicatedHeader = `### Source Issue #${issue_number}: ${existingPR.title || ''}`;
                  const newBody = `${replicatedHeader}\n\nRe-bootstrap due to closed original PR #${prNumberExisting}.`;
                  const { data: newPR } = await github.rest.pulls.create({ owner, repo, head: branch, base: baseBranch, draft: true, title: `Codex re-bootstrap for #${issue_number}`, body: newBody });
                  prNumberExisting = newPR.number; prAuthor = newPR.user && newPR.user.login || null; reuse = false; // treat as fresh for outputs
                  const markerContent = Buffer.from(JSON.stringify({ issue: issue_number, pr: prNumberExisting, ts: new Date().toISOString(), rebootstrap: true }, null, 2)).toString('base64');
                  await github.rest.repos.createOrUpdateFileContents({ owner, repo, path: markerPath, branch, message: `chore(codex): rebootstrap marker for #${issue_number}`, content: markerContent });
                  const human = 'stranske-automation-bot';
                  async function assignPair(target) {
                    try {
                      await github.rest.issues.addAssignees({ owner, repo, issue_number: target, assignees: ['chatgpt-codex-connector', human] });
                      return true;
                    } catch (e) {
                      core.warning(`Codex assignment failed on #${target}: ${e.status || '?'} ${e.message}`);
                      return false;
                    }
                  }
                  const issueAssignOk = await assignPair(issue_number);
                  const prAssignOk = await assignPair(prNumberExisting);
                  if (!activationSuppressed) {
                    await github.rest.issues.createComment({ owner, repo, issue_number: prNumberExisting, body: `@chatgpt-codex-connector Please begin work on this task. Source issue #${issue_number}.` });
                  } else {
                    core.info('Activation comment suppressed.');
                  }
                  await github.rest.issues.addLabels({ owner, repo, issue_number: prNumberExisting, labels: ['agent:codex'] });
                  let cmd = String(process.env.CODEX_COMMAND || 'codex: start').replace(/[\r\n`]/g,'').trim();
                  const allowedCommands = ['codex: start','codex: test','codex: lint','codex: build','codex: review','codex: docs'];
                  const allowedCommandsLower = allowedCommands.map(c => c.toLowerCase());
                  if (!allowedCommandsLower.includes(cmd.toLowerCase())) {
                    core.warning('Unsafe Codex command; defaulting.');
                    cmd = 'codex: start';
                  }
                  await github.rest.issues.createComment({ owner, repo, issue_number: prNumberExisting, body: `${cmd}\n\nPlease create commits on this branch, run tests, and keep the PR updated.` });
                  await github.rest.issues.createComment({ owner, repo, issue_number, body: `Opened draft PR #${prNumberExisting} to engage Codex. Track work there.` });
                }
              } catch (e) { core.warning(`Closed PR re-bootstrap check failed: ${e.message}`); }
            }
            if (prNumberExisting) core.setOutput('codex_pr', String(prNumberExisting));
            core.setOutput('codex_reused', reuse ? 'true' : 'false');
            const prAuthorFinal = prAuthor;
            try {
              const fs = require('fs'); fs.mkdirSync('codex-artifacts', { recursive: true });
              fs.writeFileSync('codex-artifacts/codex_bootstrap_summary.json', JSON.stringify({
                reused: reuse, issue: issue_number, pr: prNumberExisting || null, branch, base: baseBranch,
                suppression: activationSuppressed, token_source: tokenSource, pr_author: prAuthorFinal, ts: new Date().toISOString(), rebootstrap_attempt: !reuse,
                fallback_used: (fallbackUsed || core.getOutput('fallback_used') === 'true')
              }, null, 2));
              if (decoded) fs.writeFileSync('codex-artifacts/marker_snapshot.json', decoded);
              fs.writeFileSync('codex-artifacts/README.txt', 'Codex bootstrap artifacts.');
            } catch (e) { core.warning('Failed to write codex_bootstrap_summary.json: ' + e.message); }
            console.log('CODEX_BOOTSTRAP_SUMMARY:' + JSON.stringify({ reused: reuse, issue: issue_number, pr: prNumberExisting || null, branch, base: baseBranch, suppression: activationSuppressed, token_source: tokenSource, pr_author: prAuthorFinal }));
            return;
          }
          // Create marker seed file to ensure branch has a change (issue markdown stub)
          const path = `agents/codex-${issue_number}.md`;
          const content = Buffer.from(`<!-- bootstrap for codex on issue #${issue_number} -->\n`).toString('base64');
          let sha; try { const probe = await github.rest.repos.getContent({ owner, repo, path, ref: branch }); if (!Array.isArray(probe.data)) sha = probe.data.sha; } catch {}
          await github.rest.repos.createOrUpdateFileContents({ owner, repo, path, branch, message: `chore(codex): bootstrap PR for issue #${issue_number}`, content, sha });
          // Pull issue details
          let issueTitle = '(no title)'; let issueBody = '(no body provided)';
          try { const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number }); issueTitle = issue.title || issueTitle; issueBody = issue.body || issueBody; } catch (e) { core.warning(`Failed to fetch issue #${issue_number} for body replication: ${e.message}`); }
          const prMode = (process.env.CODEX_PR_MODE || 'auto').toLowerCase();
          const manual = prMode === 'manual';
          if (manual) {
            const markerContent = Buffer.from(JSON.stringify({ issue: issue_number, pr: null, ts: new Date().toISOString(), mode: 'manual', token_source: tokenSource }, null, 2)).toString('base64');
            await github.rest.repos.createOrUpdateFileContents({ owner, repo, path: markerPath, branch, message: `chore(codex): mark manual bootstrap for #${issue_number}`, content: markerContent });
            await github.rest.issues.createComment({ owner, repo, issue_number, body: `Branch **${branch}** created. Manual mode is enabled (CODEX_PR_MODE=manual). Open a draft PR from this branch targeting **${baseBranch}** then label with \`agent:codex\`.` });
            core.summary.addHeading('Codex Bootstrap (Manual Mode)').addTable([[{data:'Issue',header:true},{data:'Branch',header:true},{data:'PR Created',header:true},{data:'Mode',header:true},{data:'TokenSource',header:true}], [String(issue_number), branch, 'false', 'manual', tokenSource]]).write();
            const fs = require('fs'); fs.mkdirSync('codex-artifacts', { recursive: true });
            fs.writeFileSync('codex-artifacts/codex_bootstrap_summary.json', JSON.stringify({ reused:false, issue:issue_number, pr:null, branch, base:baseBranch, manual:true, token_source: tokenSource, pr_author: null, ts:new Date().toISOString() }, null, 2));
            console.log('CODEX_BOOTSTRAP_SUMMARY:' + JSON.stringify({ reused:false, issue:issue_number, pr:null, branch, base:baseBranch, manual:true, token_source: tokenSource, pr_author: null }));
            core.setOutput('codex_pr', ''); core.setOutput('codex_reused', 'false');
            return;
          }
          const suppressFromToken = (issueBody || '').includes('[codex-suppress-activate]');
          const suppressFromInput = /true/i.test(String(process.env.CODEX_SUPPRESS_ACTIVATE_INPUT||''));
          const suppressFromEnv   = !!process.env.CODEX_SUPPRESS_ACTIVATE;
          const activationSuppressed = suppressFromEnv || suppressFromInput || suppressFromToken;
          const replicatedHeader = `### Source Issue #${issue_number}: ${issueTitle}`;
          const replicatedBody = `${replicatedHeader}\n\n---\n${issueBody}\n\n---\n\nThis draft PR was auto-created to engage Codex on the task above. All edits should occur on this branch.\n`;
          const { data: open } = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${branch}` });
          let prNumber; let prBodyNeedsUpdate = false; let existingPR; let prAuthorLogin = null;
          if (open.length) { existingPR = open[0]; prNumber = existingPR.number; prAuthorLogin = existingPR.user && existingPR.user.login || null; if (!existingPR.body || !existingPR.body.includes(replicatedHeader)) prBodyNeedsUpdate = true; }
          else { const { data: pr } = await github.rest.pulls.create({ owner, repo, head: branch, base: baseBranch, draft: true, title: `Codex bootstrap for #${issue_number}`, body: replicatedBody }); prNumber = pr.number; prAuthorLogin = pr.user && pr.user.login || null; }
          if (prBodyNeedsUpdate) { try { await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body: replicatedBody }); core.info(`Updated existing PR #${prNumber} body.`); } catch (e) { core.warning(`Unable to update PR body: ${e.message}`); } }
          const human = 'stranske-automation-bot';
          async function assignPair(target) { try { await github.rest.issues.addAssignees({ owner, repo, issue_number: target, assignees: ['chatgpt-codex-connector', human] }); return true; } catch (e) { core.warning(`Codex assignment failed on #${target}: ${e.status || '?'} ${e.message}`); return false; } }
          const issueAssignOk = await assignPair(issue_number);
          const prAssignOk = await assignPair(prNumber);
          if (!activationSuppressed) {
            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `@chatgpt-codex-connector Please begin work on this task. Source issue #${issue_number}.` });
          } else { core.info('Activation comment suppressed.'); }
          await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: ['agent:codex'] });
          let cmd = String(process.env.CODEX_COMMAND || 'codex: start').replace(/[\r\n`]/g,'').trim();
          const allowedCommands = [
            'codex: start',
            'codex: test',
            'codex: lint',
            'codex: build',
            'codex: review',
            'codex: docs'
          ];
          const failOnInvalidCommand = /true/i.test(String(process.env.CODEX_FAIL_ON_INVALID_COMMAND||''));
          const originalCmd = cmd;
          let invalidCommand = false;
          if (!allowedCommands.some(c => c.toLowerCase() === cmd.toLowerCase())) {
            invalidCommand = true;
            core.warning(`Unsafe Codex command '${originalCmd}' – defaulting to 'codex: start'.`);
            cmd = 'codex: start';
          }
          await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `${cmd}\n\nPlease create commits on this branch, run tests, and keep the PR updated.` });
          await github.rest.issues.createComment({ owner, repo, issue_number, body: `Opened draft PR #${prNumber} to engage Codex. Track work there.` });
          const markerContent = Buffer.from(JSON.stringify({ issue: issue_number, pr: prNumber, ts: new Date().toISOString() }, null, 2)).toString('base64');
          await github.rest.repos.createOrUpdateFileContents({ owner, repo, path: markerPath, branch, message: `chore(codex): mark bootstrap for #${issue_number}`, content: markerContent });
          core.summary.addHeading('Codex Bootstrap').addTable([[{data:'Issue',header:true},{data:'PR',header:true},{data:'Branch',header:true},{data:'Reused',header:true},{data:'Suppressed',header:true},{data:'TokenSource',header:true},{data:'Author',header:true}], [String(issue_number), String(prNumber), branch, 'false', String(activationSuppressed), tokenSource, prAuthorLogin || '(unknown)']]).write();
          core.setOutput('codex_pr', String(prNumber));
          core.setOutput('codex_reused', 'false');
          try {
            const fs = require('fs'); fs.mkdirSync('codex-artifacts', { recursive: true });
            const artifactPayload = { reused:false, issue:issue_number, pr:prNumber, branch, base:baseBranch, assigned_issue:issueAssignOk, assigned_pr:prAssignOk, suppression:activationSuppressed, token_source: tokenSource, pr_author: prAuthorLogin, ts:new Date().toISOString(), fallback_used: fallbackUsed, command_original: originalCmd, command_final: cmd, invalid_command: invalidCommand };
            fs.writeFileSync('codex-artifacts/codex_bootstrap_result.json', JSON.stringify(artifactPayload, null, 2)); fs.writeFileSync('codex-artifacts/README.txt', 'Codex bootstrap artifacts.');
            console.log('CODEX_BOOTSTRAP_RESULT:' + JSON.stringify(artifactPayload));
          } catch(e){ core.warning('Failed to write artifact: '+e.message); }
          const mismatch = usingPAT && prAuthorLogin === 'github-actions[bot]';
          if (mismatch) {
            const msg = `:warning: Token mismatch – SERVICE_BOT_PAT present but PR author is github-actions[bot].`;
            try { await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: msg }); } catch(e){ core.warning('Comment failed: '+e.message); }
            if (process.env.CODEX_FAIL_ON_TOKEN_MISMATCH) core.setFailed('Failing due to CODEX_FAIL_ON_TOKEN_MISMATCH and author mismatch.');
          }
          if (invalidCommand && failOnInvalidCommand) {
            core.setFailed(`Failing due to invalid Codex command override: '${originalCmd}'.`);
          }
