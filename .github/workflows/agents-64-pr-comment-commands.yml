name: Agents 64 PR comment command listener

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write
  pull-requests: read
  actions: write

concurrency:
  group: pr-comment-${{ github.event.issue.number }}
  cancel-in-progress: true

jobs:
  dispatch:
    if: ${{ github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - name: Handle PR comment command
        id: handle
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const marker = '<!-- codex-activation-marker -->';
            const errorMarker = '<!-- codex-activation-error -->';

            const { github, context, core } = globalThis;
            const { payload } = context;
            const { owner, repo } = context.repo;
            const issueNumber = payload.issue.number;
            const comment = payload.comment;
            const labels = (payload.issue.labels || []).map(label => {
              if (typeof label === 'string') return label;
              return label?.name || '';
            });

            const agentLabels = labels.filter(name => typeof name === 'string' && name.toLowerCase().startsWith('agent:'));
            if (agentLabels.length !== 1) {
              const reason = agentLabels.length === 0
                ? 'No `agent:*` label found on this pull request.'
                : `Multiple agent labels found (${agentLabels.join(', ')}).`;

              const body = `${errorMarker}
**Codex activation blocked**

${reason}`;

              const existingComments = await github.paginate(
                github.rest.issues.listComments,
                {
                  owner,
                  repo,
                  issue_number: issueNumber,
                  per_page: 100,
                }
              );

              const existing = existingComments.find(c => (c.body || '').includes(errorMarker));

              if (existing) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body,
                });
              }

              core.setOutput('dispatched', 'false');
              core.setOutput('reason', 'invalid-agent-label');
              return;
            }

            const agentLabel = agentLabels[0];
            const agent = agentLabel.split(':')[1]?.trim();
            if (!agent) {
              core.setFailed(`Unable to resolve agent from label: ${agentLabel}`);
              return;
            }

            const commandPrefix = `@${agent} use the scope, acceptance criteria, and task list so the keepalive workflow continues nudging until everything is complete. Work through the tasks, checking them off only after each acceptance criterion is satisfied, but check during each comment implementation and check off tasks and acceptance criteria that have been satisfied and repost the current version of the initial scope, task list and acceptance criteria each time that any have been newly completed.`;

            const bodyText = (comment.body || '').trim();
            if (!bodyText.startsWith(commandPrefix)) {
              core.setOutput('dispatched', 'false');
              core.setOutput('reason', 'no-match');
              return;
            }

            const comments = await github.paginate(
              github.rest.issues.listComments,
              {
                owner,
                repo,
                issue_number: issueNumber,
                per_page: 100,
              }
            );

            const matchingComments = comments.filter(c => (c.body || '').trim().startsWith(commandPrefix));
            if (matchingComments.length === 0 || matchingComments[matchingComments.length - 1].id !== comment.id) {
              core.info('Command superseded by a newer comment; skipping dispatch.');
              core.setOutput('dispatched', 'false');
              core.setOutput('reason', 'superseded');
              return;
            }

            const pull = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: issueNumber,
            });

            const payloadData = {
              issue: issueNumber,
              base: pull.data.base.ref,
              head: pull.data.head.ref,
              agent,
              comment_id: comment.id,
              comment_url: comment.html_url,
            };

            await github.rest.repos.createDispatchEvent({
              owner,
              repo,
              event_type: 'codex-pr-comment-command',
              client_payload: payloadData,
            });

            const errorComment = comments.find(c => (c.body || '').includes(errorMarker));
            if (errorComment) {
              await github.rest.issues.deleteComment({
                owner,
                repo,
                comment_id: errorComment.id,
              });
            }

            const activationBody = `${marker}
Codex activation dispatched for **@${agent}** from [comment #${comment.id}](${comment.html_url}).

- Pull request: #${issueNumber}
- Base branch: ${pull.data.base.ref}
- Head branch: ${pull.data.head.ref}
- Comment ID: ${comment.id}`;

            const activationComment = comments.find(c => (c.body || '').includes(marker));
            if (activationComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: activationComment.id,
                body: activationBody,
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: activationBody,
              });
            }

            core.setOutput('dispatched', 'true');
            core.setOutput('agent', agent);
            core.setOutput('comment-id', String(comment.id));

      - name: Log dispatch result
        if: steps.handle.outputs.dispatched == 'true'
        run: |
          echo "Dispatched agent ${AGENT} for comment ${COMMENT}"
        env:
          AGENT: ${{ steps.handle.outputs.agent }}
          COMMENT: ${{ steps.handle.outputs['comment-id'] }}

      - name: Report skipped reason
        if: steps.handle.outputs.dispatched != 'true'
        run: |
          echo "Dispatch skipped: ${{ steps.handle.outputs.reason }}"
