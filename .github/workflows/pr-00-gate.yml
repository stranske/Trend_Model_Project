# Gate orchestrates CI enforcement for pull requests. The final `summary`
# job aggregates artifacts, computes coverage deltas, publishes the commit
# status, and maintains the consolidated PR comment.
name: Gate

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

concurrency:
  group: pr-${{ github.event.pull_request.number || github.ref_name }}-gate
  cancel-in-progress: true

jobs:
  detect:
    name: detect changed files
    runs-on: ubuntu-latest
    outputs:
      doc_only: ${{ steps.diff.outputs.doc_only }}
      run_core: ${{ steps.diff.outputs.run_core }}
      reason: ${{ steps.diff.outputs.reason }}
      docker_changed: ${{ steps.docker_paths.outputs.docker == 'true' || steps.diff.outputs.docker_changed == 'true' }}
      lint: ${{ steps.python_ci_toggles.outputs.lint || 'true' }}
      format_check: ${{ steps.python_ci_toggles.outputs.format_check || 'true' }}
      typecheck: ${{ steps.python_ci_toggles.outputs.typecheck || 'true' }}
      coverage: ${{ steps.python_ci_toggles.outputs.coverage || 'true' }}
      cache: ${{ steps.python_ci_toggles.outputs.cache || 'true' }}
      pytest_markers: ${{ steps.python_ci_toggles.outputs.pytest_markers || 'not quarantine and not slow' }}
    steps:
      - name: Checkout workflow helpers
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
      - name: Detect changes via API
        id: diff
        uses: actions/github-script@v7
        with:
          script: |
            const { detectChanges } = require('./.github/scripts/detect-changes.js');
            await detectChanges({ github, context, core });

      - name: Detect Docker-related changes via paths filter
        if: github.event_name == 'pull_request'
        id: docker_paths
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          base: ${{ github.event.pull_request.base.sha }}
          ref: ${{ github.event.pull_request.head.sha }}
          filters: |
            docker:
              - 'Dockerfile'
              - 'Dockerfile.*'
              - '**/[Dd]ockerfile'
              - '**/[Dd]ockerfile.*'
              - '.dockerignore'
              - '**/.dockerignore'
              - 'docker/**'
              - '**/docker/**'
              - '.docker/**'
              - '**/.docker/**'

      - name: Detect Python CI changes via paths filter
        if: github.event_name == 'pull_request'
        id: python_paths
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          base: ${{ github.event.pull_request.base.sha }}
          ref: ${{ github.event.pull_request.head.sha }}
          filters: |
            lint:
              - '**/*.py'
              - '**/*.pyi'
              - 'pyproject.toml'
              - 'setup.cfg'
              - 'setup.py'
              - '.ruff.toml'
              - 'ruff.toml'
              - 'requirements.txt'
              - 'requirements.lock'
              - 'requirements/**/*.txt'
            format_check:
              - '**/*.py'
              - 'pyproject.toml'
              - '.pre-commit-config.yaml'
              - '.ruff.toml'
              - 'ruff.toml'
            typecheck:
              - '**/*.py'
              - '**/*.pyi'
              - 'pyproject.toml'
              - 'mypy.ini'
              - 'mypy*.ini'
              - 'mypy.toml'
              - 'mypyconfig.toml'
            coverage:
              - '**/*.py'
              - 'tests/**'
              - 'pyproject.toml'
              - 'requirements.txt'
              - 'requirements.lock'
              - 'requirements/**/*.txt'
              - 'config/coverage-baseline.json'
            slow:
              - 'tests/slow/**'
              - 'tests/**/*slow*/**'
              - 'tests/integration/**'
              - 'tests/**/integration/**'

      - name: Compute Python CI toggles
        id: python_ci_toggles
        run: |
          python - <<'PY'
          import os

          def as_bool(value: str | None) -> bool:
              if value is None:
                  return False
              return value.strip().lower() == 'true'

          run_core = as_bool(os.environ.get('RUN_CORE'))
          lint_changed = as_bool(os.environ.get('LINT_CHANGED'))
          format_changed = as_bool(os.environ.get('FORMAT_CHANGED'))
          type_changed = as_bool(os.environ.get('TYPE_CHANGED'))
          coverage_changed = as_bool(os.environ.get('COVERAGE_CHANGED'))
          slow_changed = as_bool(os.environ.get('SLOW_CHANGED'))

          lint = format_check = typecheck = coverage = cache = run_core
          pytest_markers = 'not quarantine and not slow'

          if run_core:
              lint = lint_changed or format_changed or type_changed or coverage_changed
              format_check = format_changed or lint_changed
              typecheck = type_changed or lint_changed
              coverage = coverage_changed or lint_changed or type_changed
              cache = True
              if slow_changed:
                  pytest_markers = 'not quarantine'
          else:
              lint = format_check = typecheck = coverage = cache = False

          def to_str(flag: bool) -> str:
              return 'true' if flag else 'false'

          outputs = {
              'lint': to_str(lint),
              'format_check': to_str(format_check),
              'typecheck': to_str(typecheck),
              'coverage': to_str(coverage),
              'cache': to_str(cache),
              'pytest_markers': pytest_markers,
          }

          output_path = os.environ.get('GITHUB_OUTPUT')
          if output_path:
              with open(output_path, 'a', encoding='utf-8') as handle:
                  for key, value in outputs.items():
                      handle.write(f"{key}={value}\n")
          PY
        env:
          RUN_CORE: ${{ steps.diff.outputs.run_core || 'false' }}
          LINT_CHANGED: ${{ steps.python_paths.outputs.lint || 'false' }}
          FORMAT_CHANGED: ${{ steps.python_paths.outputs.format_check || 'false' }}
          TYPE_CHANGED: ${{ steps.python_paths.outputs.typecheck || 'false' }}
          COVERAGE_CHANGED: ${{ steps.python_paths.outputs.coverage || 'false' }}
          SLOW_CHANGED: ${{ steps.python_paths.outputs.slow || 'false' }}

  python-ci:
    name: python ci
    needs: detect
    if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.run_core == 'true'
    uses: ./.github/workflows/reusable-10-ci-python.yml
    with:
      primary-python-version: '3.11'
      python-versions: '["3.11", "3.12"]'
      marker: "not quarantine and not slow"
      pytest_markers: ${{ needs.detect.outputs.pytest_markers }}
      lint: ${{ needs.detect.outputs.lint == 'true' }}
      format_check: ${{ needs.detect.outputs.format_check == 'true' }}
      typecheck: ${{ needs.detect.outputs.typecheck == 'true' }}
      run-mypy: ${{ needs.detect.outputs.typecheck == 'true' }}
      coverage: ${{ needs.detect.outputs.coverage == 'true' }}
      cache: ${{ needs.detect.outputs.cache == 'true' }}
      enable-soft-gate: ${{ needs.detect.outputs.coverage == 'true' }}
      # Use the shared gate- prefix so downstream Maint workflows can locate the
      # coverage artifacts without special-casing runtime names.
      artifact-prefix: 'gate-'

  docker-smoke:
    name: docker smoke
    needs: detect
    if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.run_core == 'true' && needs.detect.outputs.docker_changed == 'true'
    uses: ./.github/workflows/reusable-12-ci-docker.yml

  summary:
    name: summary
    needs:
      - detect
      - python-ci
      - docker-smoke
    if: ${{ always() }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      statuses: write
    env:
      REQUIRED_JOB_GROUPS_JSON: ${{ vars.REQUIRED_JOB_GROUPS_JSON || '' }}
    steps:
      - name: Checkout workflow helpers
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
            tools
          sparse-checkout-cone-mode: false
      - name: Handle docs-only change
        if: needs.detect.outputs.doc_only == 'true'
        id: docs_only
        uses: actions/github-script@v7
        env:
          REASON: ${{ needs.detect.outputs.reason || 'docs_only' }}
        with:
          script: |
            const { handleDocsOnlyFastPass } = require('./.github/scripts/gate-docs-only.js');
            await handleDocsOnlyFastPass({ core, reason: process.env.REASON });

      - name: Ensure docs-only fast-pass comment
        if: needs.detect.outputs.doc_only == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_BODY: ${{ steps.docs_only.outputs.comment_body }}
          MARKER: ${{ steps.docs_only.outputs.marker }}
          BASE_MESSAGE: ${{ steps.docs_only.outputs.base_message }}
        with:
          script: |
            const { ensureMarkerComment } = require('./.github/scripts/comment-dedupe.js');
            const { DEFAULT_MARKER, BASE_MESSAGE } = require('./.github/scripts/gate-docs-only.js');
            await ensureMarkerComment({
              github,
              context,
              core,
              commentBody: process.env.COMMENT_BODY,
              marker: process.env.MARKER || DEFAULT_MARKER,
              baseMessage: process.env.BASE_MESSAGE || BASE_MESSAGE,
            });

      - name: Remove docs-only fast-pass comment when not needed
        if: needs.detect.outputs.doc_only != 'true'
        uses: actions/github-script@v7
        env:
          MARKER: ${{ steps.docs_only.outputs.marker }}
          BASE_MESSAGE: ${{ steps.docs_only.outputs.base_message }}
        with:
          script: |
            const { removeMarkerComments } = require('./.github/scripts/comment-dedupe.js');
            const { DEFAULT_MARKER, BASE_MESSAGE } = require('./.github/scripts/gate-docs-only.js');
            await removeMarkerComments({
              github,
              context,
              core,
              marker: process.env.MARKER || DEFAULT_MARKER,
              baseMessages: [process.env.BASE_MESSAGE || BASE_MESSAGE],
            });
      - name: Discover Gate workflow runs
        id: gather
        uses: actions/github-script@v7
        with:
          script: |
            const { discoverWorkflowRuns } = require('./.github/scripts/maint-post-ci.js');
            await discoverWorkflowRuns({ github, context, core });

      - name: Download Gate artifacts
        if: ${{ needs.detect.outputs.doc_only != 'true' && needs.python-ci.result != 'skipped' }}
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          pattern: gate-*
          merge-multiple: true
          path: gate_artifacts/downloads

      - name: Load coverage summary snippet
        if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.coverage == 'true'
        id: coverage_summary
        run: |
          set -euo pipefail
          mkdir -p gate_artifacts/downloads
          python <<'PY'
          import os
          from pathlib import Path

          output_path = os.environ.get('GITHUB_OUTPUT')
          root = Path('gate_artifacts/downloads')

          summary_path: Path | None = None
          candidates = list(root.rglob('coverage-summary.md'))
          if candidates:
              summary_path = candidates[0]

          if summary_path is None:
              print('No coverage summary markdown found; continuing without it.')
          else:
              text = summary_path.read_text(encoding='utf-8')
              dest = Path('gate-coverage-summary.md')
              dest.write_text(text, encoding='utf-8')
              if output_path:
                  with Path(output_path).open('a', encoding='utf-8') as handle:
                      handle.write('body<<EOF\n')
                      handle.write(text)
                      if not text.endswith('\n'):
                          handle.write('\n')
                      handle.write('EOF\n')
              print(f'Embedded coverage summary from {summary_path}')
          PY

      - name: Compute coverage stats
        if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.coverage == 'true'
        id: coverage_stats
        uses: actions/github-script@v7
        env:
          COVERAGE_ROOT: gate_artifacts/downloads
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { computeCoverageStats } = require('./.github/scripts/coverage-normalize.js');

            const rootDir = process.env.COVERAGE_ROOT || 'gate_artifacts/downloads';
            const coverageRoot = path.join(rootDir, 'coverage', 'runtimes');

            const { stats, deltaPayload } = await computeCoverageStats({
              core,
              rootDir,
              coverageRoot,
              writeFiles: false,
            });

            const statsPath = path.resolve('gate-coverage.json');
            const deltaPath = path.resolve('gate-coverage-delta.json');

            if (stats && Object.keys(stats).length) {
              fs.writeFileSync(statsPath, JSON.stringify(stats, null, 2), 'utf8');
              core.setOutput('stats_json', JSON.stringify(stats));
            } else {
              core.info('Coverage stats unavailable.');
            }

            if (deltaPayload && Object.keys(deltaPayload).length) {
              fs.writeFileSync(deltaPath, JSON.stringify(deltaPayload, null, 2), 'utf8');
              core.setOutput('delta_json', JSON.stringify(deltaPayload));
            } else {
              core.info('Coverage delta unavailable.');
            }

      - name: Summarize results
        if: ${{ always() }}
        id: summarize
        env:
          DOC_ONLY: ${{ needs.detect.outputs.doc_only || 'false' }}
          RUN_CORE: ${{ needs.detect.outputs.run_core || 'true' }}
          REASON: ${{ needs.detect.outputs.reason }}
          PYTHON_RESULT: ${{ needs.python-ci.result || 'skipped' }}
          DOCKER_RESULT: ${{ needs.docker-smoke.result || 'skipped' }}
          DOCKER_CHANGED: ${{ needs.detect.outputs.docker_changed || 'false' }}
          COVERAGE_ENABLED: ${{ needs.detect.outputs.coverage || 'true' }}
        run: |
          python <<'PY'
          import json
          import os
          from pathlib import Path

          def normalize(value: str | None, default: str = "unknown") -> str:
              return (value or default).strip().lower()

          doc_only = normalize(os.environ.get("DOC_ONLY"), "false") == "true"
          run_core = normalize(os.environ.get("RUN_CORE"), "true") == "true"
          reason = os.environ.get("REASON") or ""
          python_result = normalize(os.environ.get("PYTHON_RESULT"), "skipped")
          docker_result = normalize(os.environ.get("DOCKER_RESULT"), "skipped")
          docker_changed = normalize(os.environ.get("DOCKER_CHANGED"), "false") == "true"
          coverage_enabled = normalize(os.environ.get("COVERAGE_ENABLED"), "true") == "true"

          base = Path("gate_artifacts")
          records: list[dict[str, object]] = []
          if base.exists():
              for path in sorted(base.rglob("**/summary.json")):
                  try:
                      job_name = path.relative_to(base).parts[0]
                  except (ValueError, IndexError):
                      job_name = "unknown"
                  try:
                      data = json.loads(path.read_text(encoding="utf-8"))
                  except json.JSONDecodeError:
                      continue
                  if isinstance(data, dict):
                      data.setdefault("job_name", job_name)
                      records.append(data)

          def emoji(outcome: str) -> str:
              mapping = {
                  "success": "✅",
                  "skipped": "⏭️",
                  "failure": "❌",
                  "cancelled": "⏹️",
                  "timed_out": "⏱️",
                  "pending": "⏳",
              }
              return mapping.get(outcome, "❔")

          def friendly(outcome: str) -> str:
              if not outcome:
                  return "unknown"
              return outcome.replace("_", " ")

          PRIORITY = {"failure": 0, "timed_out": 1, "cancelled": 2, "success": 3, "skipped": 4, "pending": 5}

          def pick_best(outcomes: list[str]) -> str:
              best = "pending"
              for outcome in outcomes:
                  candidate = outcome or "pending"
                  if PRIORITY.get(candidate, 99) < PRIORITY.get(best, 99):
                      best = candidate
              return best

          def aggregate_status(entries: list[tuple[str, str]]) -> tuple[str, str]:
              best = pick_best([outcome for _, outcome in entries])
              groups: list[str] = []
              for runtime, outcome in sorted(entries):
                  groups.append(f"{runtime}: {friendly(outcome)}")
              detail = ", ".join(groups) if groups else "no runs"
              return best, detail

          summary_path = Path(os.environ.get("GITHUB_STEP_SUMMARY", ""))
          lines: list[str] = []

          state = "success"
          description = "All Gate checks succeeded."

          if doc_only or not run_core:
              if not reason:
                  reason = "docs_only"
              note = (
                  "Docs-only change detected; heavy checks skipped."
                  if reason == "docs_only"
                  else f"Docs-only change detected; heavy checks skipped ({reason})."
              )
              description = (
                  "Gate fast-pass: docs-only change detected; heavy checks skipped."
                  if reason == "docs_only"
                  else f"Docs-only change; heavy checks skipped ({reason})."
              )
              lines.append("### Gate status")
              lines.append("Docs-only fast-pass engaged; heavy jobs were skipped.")
              # Add a minimal job/result table so tests can detect the expected header
              lines.append("| Job | Result |")
              lines.append("| --- | --- |")
              lines.append("| docs-only | success |")
          else:
              table = [
                  "| Runtime | Format | Lint | Type | Tests | Coverage min | Coverage % |",
                  "| --- | --- | --- | --- | --- | --- | --- |",
              ]
              format_entries: list[tuple[str, str]] = []
              lint_entries: list[tuple[str, str]] = []
              type_entries: list[tuple[str, str]] = []
              test_entries: list[tuple[str, str]] = []
              coverage_entries: list[tuple[str, str]] = []
              coverage_percents: list[str] = []
              job_results: dict[str, list[str]] = {}

              for record in sorted(records, key=lambda item: str(item.get("python_version", ""))):
                  runtime = str(record.get("python_version", "unknown"))
                  job_name = str(record.get("job_name") or runtime)
                  checks = record.get("checks") if isinstance(record.get("checks"), dict) else {}
                  fmt = normalize(
                      checks.get("format", {}).get("outcome")
                      if isinstance(checks.get("format"), dict)
                      else None,
                      "unknown",
                  )
                  lint = normalize(
                      checks.get("lint", {}).get("outcome")
                      if isinstance(checks.get("lint"), dict)
                      else None,
                      "unknown",
                  )
                  typing = normalize(
                      checks.get("type_check", {}).get("outcome")
                      if isinstance(checks.get("type_check"), dict)
                      else None,
                      "unknown",
                  )
                  tests = normalize(
                      checks.get("tests", {}).get("outcome")
                      if isinstance(checks.get("tests"), dict)
                      else None,
                      "unknown",
                  )
                  coverage_min = normalize(
                      checks.get("coverage_minimum", {}).get("outcome")
                      if isinstance(checks.get("coverage_minimum"), dict)
                      else None,
                      "unknown",
                  )

                  format_entries.append((runtime, fmt))
                  lint_entries.append((runtime, lint))
                  type_entries.append((runtime, typing))
                  test_entries.append((runtime, tests))
                  coverage_entries.append((runtime, coverage_min))
                  job_results.setdefault(job_name, []).extend([fmt, lint, typing, tests, coverage_min])

                  coverage_info = record.get("coverage") if isinstance(record.get("coverage"), dict) else {}
                  percent = coverage_info.get("percent") if isinstance(coverage_info, dict) else None
                  if isinstance(percent, (int, float)):
                      coverage_percents.append(f"{runtime}: {percent:.2f}%")
                      percent_display = f"{percent:.2f}%"
                  else:
                      percent_display = "—"

                  table.append(
                      "| {runtime} | {fmt_icon} {fmt_status} | {lint} {lint_status} | {typing} {type_status} | {tests} {test_status} | {coverage_min} {cov_status} | {percent} |".format(
                          runtime=runtime,
                          fmt_icon=emoji(fmt),
                          fmt_status=friendly(fmt),
                          lint=emoji(lint),
                          lint_status=friendly(lint),
                          typing=emoji(typing),
                          type_status=friendly(typing),
                          tests=emoji(tests),
                          test_status=friendly(tests),
                          coverage_min=emoji(coverage_min),
                          cov_status=friendly(coverage_min),
                          percent=percent_display,
                      )
                  )

              format_status, format_detail = aggregate_status(format_entries)
              lint_status, lint_detail = aggregate_status(lint_entries)
              type_status, type_detail = aggregate_status(type_entries)
              test_status, test_detail = aggregate_status(test_entries)
              coverage_status, coverage_detail = aggregate_status(coverage_entries)

              lines.append("### Gate status")
              lines.extend(table)
              # Also include a compact job/result table for downstream checks
              lines.append("")
              lines.append("| Job | Result |")
              lines.append("| --- | --- |")
              for job_name, outcomes in sorted(job_results.items()):
                  result = pick_best(outcomes)
                  lines.append(f"| {job_name} | {friendly(result)} |")
              lines.append(f"| docker-smoke | {friendly(docker_result)} |")

              lines.append("")
              lines.append(f"- Format: {emoji(format_status)} {friendly(format_status)} ({format_detail})")
              lines.append(f"- Lint: {emoji(lint_status)} {friendly(lint_status)} ({lint_detail})")
              lines.append(f"- Type check: {emoji(type_status)} {friendly(type_status)} ({type_detail})")
              lines.append(f"- Tests: {emoji(test_status)} {friendly(test_status)} ({test_detail})")
              lines.append(f"- Coverage minimum: {emoji(coverage_status)} {friendly(coverage_status)} ({coverage_detail})")
              if coverage_percents:
                  lines.append(f"- Reported coverage: {', '.join(coverage_percents)}")
              if not coverage_enabled:
                  lines.append("- Coverage instrumentation disabled for this change set.")

              if python_result != "success":
                  state = "failure"
                  description = f"Python CI result: {python_result}."
              elif docker_changed and docker_result != "success":
                  state = "failure"
                  description = f"Docker smoke result: {docker_result}."
              elif not docker_changed:
                  lines.append("- Docker smoke skipped: no Docker-related changes detected.")

          if summary_path and lines:
              with summary_path.open("a", encoding="utf-8") as handle:
                  handle.write("\n".join(lines) + "\n")

          output_path = Path(os.environ.get("GITHUB_OUTPUT", ""))
          if output_path:
              with output_path.open("a", encoding="utf-8") as handle:
                  handle.write(f"state={state}\n")
                  handle.write(f"description={description}\n")
          PY

      - name: Prepare summary body
        id: summary_body
        run: |
          python tools/post_ci_summary.py
        env:
          RUNS_JSON: ${{ steps.gather.outputs.runs || '[]' }}
          HEAD_SHA: ${{ steps.gather.outputs.head_sha || github.event.pull_request.head.sha || github.sha }}
          COVERAGE_SECTION: ${{ steps.coverage_summary.outputs.body || '' }}
          COVERAGE_STATS: ${{ steps.coverage_stats.outputs.stats_json || '' }}
          COVERAGE_DELTA: ${{ steps.coverage_stats.outputs.delta_json || '' }}
          REQUIRED_JOB_GROUPS_JSON: ${{ env.REQUIRED_JOB_GROUPS_JSON }}

      - name: Compose PR summary comment
        id: compose_comment
        run: |
          python <<'PY'
          import os
          from pathlib import Path

          body = (os.environ.get('SUMMARY_BODY') or '').strip()
          pr_number = os.environ.get('PR_NUMBER', '').strip()
          head_sha = os.environ.get('HEAD_SHA', '').strip()

          if not body:
              raise SystemExit('Summary body missing; aborting comment composition.')

          head_token = head_sha[:12] if head_sha else ''
          parts = []
          if pr_number:
              parts.append(f'pr={pr_number}')
          if head_token:
              parts.append(f'head={head_token}')
          if not parts:
              parts.append('anchor')

          marker = f"<!-- gate-summary: {' '.join(parts)} -->"
          payload = "\n".join([marker, body, ''])

          Path('gate-summary.md').write_text(payload, encoding='utf-8')
          print(marker)
          PY
        env:
          SUMMARY_BODY: ${{ steps.summary_body.outputs.body }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          HEAD_SHA: ${{ steps.gather.outputs.head_sha || github.event.pull_request.head.sha || github.sha }}

      - name: Upload Gate summary artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gate-summary.md
          path: gate-summary.md
          if-no-files-found: warn
          retention-days: 7
          overwrite: true

      - name: Upload coverage stats artifact
        if: ${{ always() && steps.coverage_stats.outputs.stats_json != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: gate-coverage.json
          path: gate-coverage.json
          if-no-files-found: warn
          retention-days: 7
          overwrite: true

      - name: Upload coverage delta artifact
        if: ${{ always() && steps.coverage_stats.outputs.delta_json != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: gate-coverage-delta.json
          path: gate-coverage-delta.json
          if-no-files-found: warn
          retention-days: 7
          overwrite: true

      - name: Upload coverage summary artifact copy
        if: ${{ always() && steps.coverage_summary.outputs.body != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: gate-coverage-summary.md
          path: gate-coverage-summary.md
          if-no-files-found: warn
          retention-days: 7
          overwrite: true

      - name: Ensure consolidated summary comment
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const path = require('path');
            const fs = require('fs');
            const { upsertAnchoredComment } = require('./.github/scripts/comment-dedupe.js');

            const commentPath = path.resolve('gate-summary.md');
            const body = fs.readFileSync(commentPath, 'utf8');
            await upsertAnchoredComment({
              github,
              context,
              core,
              prNumber: context.payload.pull_request?.number,
              body,
              anchorPattern: /<!--\s*gate-summary:([^>]*)-->/i,
              fallbackMarker: '<!-- gate-summary:',
            });

      - name: Report Gate commit status
        if: ${{ always() }}
        uses: actions/github-script@v7
        env:
          STATE: ${{ steps.summarize.outputs.state || steps.docs_only.outputs.state || 'pending' }}
          DESCRIPTION: ${{ steps.summarize.outputs.description || steps.docs_only.outputs.description || 'Gate status pending' }}
          TARGET_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.payload.pull_request?.head?.sha ?? context.sha;
            const rawState = process.env.STATE || 'pending';
            const allowed = new Set(['error', 'failure', 'pending', 'success']);
            const state = allowed.has(rawState) ? rawState : 'pending';
            const rawDescription = process.env.DESCRIPTION || 'Gate status update';
            const description = rawDescription.length > 140 ? `${rawDescription.slice(0, 137)}...` : rawDescription;
            const targetUrl = process.env.TARGET_URL;

            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha,
              state,
              context: 'Gate / gate',
              description,
              target_url: targetUrl,
            });

      - name: Enforce Gate success
        if: ${{ (steps.summarize.outputs.state || steps.docs_only.outputs.state) == 'failure' }}
        run: |
          echo "Gate reported failure: ${{ steps.summarize.outputs.description || steps.docs_only.outputs.description }}" >&2
          exit 1
