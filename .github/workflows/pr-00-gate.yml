# Gate orchestrates CI enforcement for pull requests. The final `summary`
# job aggregates artifacts, computes coverage deltas, publishes the commit
# status, and maintains the consolidated PR comment.
name: Gate

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled]
  workflow_dispatch:

concurrency:
  group: pr-${{ github.event.pull_request.number || github.ref_name }}-gate
  cancel-in-progress: true

jobs:
  detect:
    name: detect changed files
    # Skip full CI on label-only events, but allow workflow to continue for autofix
    if: github.event.action != 'labeled'
    runs-on: ubuntu-latest
    outputs:
      doc_only: ${{ steps.diff.outputs.doc_only }}
      run_core: ${{ steps.diff.outputs.run_core }}
      reason: ${{ steps.diff.outputs.reason }}
      docker_changed: ${{ steps.docker_paths.outputs.docker == 'true' || steps.diff.outputs.docker_changed == 'true' }}
      lint: ${{ steps.python_ci_toggles.outputs.lint || 'true' }}
      format_check: ${{ steps.python_ci_toggles.outputs.format_check || 'true' }}
      typecheck: ${{ steps.python_ci_toggles.outputs.typecheck || 'true' }}
      coverage: ${{ steps.python_ci_toggles.outputs.coverage || 'true' }}
      cache: ${{ steps.python_ci_toggles.outputs.cache || 'true' }}
      pytest_markers: ${{ steps.python_ci_toggles.outputs.pytest_markers || 'not quarantine and not slow' }}
    steps:
      - name: Checkout workflow helpers
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
      - name: Detect changes via API
        id: diff
        uses: actions/github-script@v7
        with:
          script: |
            const { detectChanges } = require('./.github/scripts/detect-changes.js');
            await detectChanges({ github, context, core });

      - name: Detect Docker-related changes via paths filter
        if: github.event_name == 'pull_request'
        id: docker_paths
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          base: ${{ github.event.pull_request.base.sha }}
          ref: ${{ github.event.pull_request.head.sha }}
          filters: |
            docker:
              - 'Dockerfile'
              - 'Dockerfile.*'
              - '**/[Dd]ockerfile'
              - '**/[Dd]ockerfile.*'
              - '.dockerignore'
              - '**/.dockerignore'
              - 'docker/**'
              - '**/docker/**'
              - '.docker/**'
              - '**/.docker/**'

      - name: Detect Python CI changes via paths filter
        if: github.event_name == 'pull_request'
        id: python_paths
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          base: ${{ github.event.pull_request.base.sha }}
          ref: ${{ github.event.pull_request.head.sha }}
          filters: |
            lint:
              - '**/*.py'
              - '**/*.pyi'
              - 'pyproject.toml'
              - 'setup.cfg'
              - 'setup.py'
              - '.ruff.toml'
              - 'ruff.toml'
              - 'requirements.txt'
              - 'requirements.lock'
              - 'requirements/**/*.txt'
            format_check:
              - '**/*.py'
              - 'pyproject.toml'
              - '.pre-commit-config.yaml'
              - '.ruff.toml'
              - 'ruff.toml'
            typecheck:
              - '**/*.py'
              - '**/*.pyi'
              - 'pyproject.toml'
              - 'mypy.ini'
              - 'mypy*.ini'
              - 'mypy.toml'
              - 'mypyconfig.toml'
            coverage:
              - '**/*.py'
              - 'tests/**'
              - 'pyproject.toml'
              - 'requirements.txt'
              - 'requirements.lock'
              - 'requirements/**/*.txt'
              - 'config/coverage-baseline.json'
            slow:
              - 'tests/slow/**'
              - 'tests/**/*slow*/**'
              - 'tests/integration/**'
              - 'tests/**/integration/**'

      - name: Compute Python CI toggles
        id: python_ci_toggles
        run: |
          python - <<'PY'
          import os

          def as_bool(value: str | None) -> bool:
              if value is None:
                  return False
              return value.strip().lower() == 'true'

          run_core = as_bool(os.environ.get('RUN_CORE'))
          lint_changed = as_bool(os.environ.get('LINT_CHANGED'))
          format_changed = as_bool(os.environ.get('FORMAT_CHANGED'))
          type_changed = as_bool(os.environ.get('TYPE_CHANGED'))
          coverage_changed = as_bool(os.environ.get('COVERAGE_CHANGED'))
          slow_changed = as_bool(os.environ.get('SLOW_CHANGED'))

          lint = format_check = typecheck = coverage = cache = run_core
          pytest_markers = 'not quarantine and not slow'

          if run_core:
              lint = lint_changed or format_changed or type_changed or coverage_changed
              format_check = format_changed or lint_changed
              typecheck = type_changed or lint_changed
              coverage = coverage_changed or lint_changed or type_changed
              cache = True
              if slow_changed:
                  pytest_markers = 'not quarantine'
          else:
              lint = format_check = typecheck = coverage = cache = False

          def to_str(flag: bool) -> str:
              return 'true' if flag else 'false'

          outputs = {
              'lint': to_str(lint),
              'format_check': to_str(format_check),
              'typecheck': to_str(typecheck),
              'coverage': to_str(coverage),
              'cache': to_str(cache),
              'pytest_markers': pytest_markers,
          }

          output_path = os.environ.get('GITHUB_OUTPUT')
          if output_path:
              with open(output_path, 'a', encoding='utf-8') as handle:
                  for key, value in outputs.items():
                      handle.write(f"{key}={value}\n")
          PY
        env:
          RUN_CORE: ${{ steps.diff.outputs.run_core || 'false' }}
          LINT_CHANGED: ${{ steps.python_paths.outputs.lint || 'false' }}
          FORMAT_CHANGED: ${{ steps.python_paths.outputs.format_check || 'false' }}
          TYPE_CHANGED: ${{ steps.python_paths.outputs.typecheck || 'false' }}
          COVERAGE_CHANGED: ${{ steps.python_paths.outputs.coverage || 'false' }}
          SLOW_CHANGED: ${{ steps.python_paths.outputs.slow || 'false' }}

  python-ci:
    name: python ci
    needs: detect
    if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.run_core == 'true'
    uses: ./.github/workflows/reusable-10-ci-python.yml
    with:
      primary-python-version: '3.11'
      python-versions: '["3.11", "3.12"]'
      marker: "not quarantine and not slow"
      pytest_markers: ${{ needs.detect.outputs.pytest_markers }}
      lint: ${{ needs.detect.outputs.lint == 'true' }}
      format_check: ${{ needs.detect.outputs.format_check == 'true' }}
      typecheck: ${{ needs.detect.outputs.typecheck == 'true' }}
      run-mypy: ${{ needs.detect.outputs.typecheck == 'true' }}
      coverage: ${{ needs.detect.outputs.coverage == 'true' }}
      cache: ${{ needs.detect.outputs.cache == 'true' }}
      enable-soft-gate: ${{ needs.detect.outputs.coverage == 'true' }}
      # Use the shared gate- prefix so downstream Maint workflows can locate the
      # coverage artifacts without special-casing runtime names.
      artifact-prefix: 'gate-'

  github-scripts-tests:
    name: github scripts tests
    needs: detect
    if: needs.detect.outputs.doc_only != 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: node --test .github/scripts/__tests__/*.test.js
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - run: python -m pip install --upgrade pip pytest requests
      - run: pytest tests/github_scripts

  docker-smoke:
    name: docker smoke
    needs: detect
    if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.run_core == 'true' && needs.detect.outputs.docker_changed == 'true'
    uses: ./.github/workflows/reusable-12-ci-docker.yml

  ledger-validation:
    name: ledger validation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install PyYAML
        run: pip install PyYAML

      - name: Validate ledger files
        run: |
          if [ -d .agents ] && find .agents -name 'issue-*-ledger.yml' -print -quit | grep -q .; then
            python scripts/ledger_validate.py
          else
            echo "No ledger files found; validation skipped."
          fi

  summary:
    name: summary
    needs:
      - detect
      - python-ci
      - docker-smoke
      - github-scripts-tests
      - ledger-validation
    if: ${{ always() }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      statuses: write
    env:
      REQUIRED_JOB_GROUPS_JSON: ${{ vars.REQUIRED_JOB_GROUPS_JSON || '' }}
    outputs:
      state: ${{ steps.summarize.outputs.state || steps.docs_only.outputs.state || 'success' }}
      description: ${{ steps.summarize.outputs.description || steps.docs_only.outputs.description || '' }}
      cosmetic_failure: ${{ steps.summarize.outputs.cosmetic_failure || 'false' }}
      failure_checks: ${{ steps.summarize.outputs.failure_checks || '' }}
      autofix_label_applied: ${{ steps.autofix_label.outputs.applied || 'false' }}
      autofix_label_skipped: ${{ steps.autofix_label.outputs.skipped_reason || '' }}
    steps:
      - name: Checkout workflow helpers
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
            .github/config
            tools
          sparse-checkout-cone-mode: false
      - name: Handle docs-only change
        if: needs.detect.outputs.doc_only == 'true'
        id: docs_only
        uses: actions/github-script@v7
        env:
          REASON: ${{ needs.detect.outputs.reason || 'docs_only' }}
        with:
          script: |
            const { handleDocsOnlyFastPass } = require('./.github/scripts/gate-docs-only.js');
            await handleDocsOnlyFastPass({ core, reason: process.env.REASON });

      - name: Ensure docs-only fast-pass comment
        if: needs.detect.outputs.doc_only == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_BODY: ${{ steps.docs_only.outputs.comment_body }}
          MARKER: ${{ steps.docs_only.outputs.marker }}
          BASE_MESSAGE: ${{ steps.docs_only.outputs.base_message }}
        with:
          script: |
            const { ensureMarkerComment } = require('./.github/scripts/comment-dedupe.js');
            const { DEFAULT_MARKER, BASE_MESSAGE } = require('./.github/scripts/gate-docs-only.js');
            await ensureMarkerComment({
              github,
              context,
              core,
              commentBody: process.env.COMMENT_BODY,
              marker: process.env.MARKER || DEFAULT_MARKER,
              baseMessage: process.env.BASE_MESSAGE || BASE_MESSAGE,
            });

      - name: Remove docs-only fast-pass comment when not needed
        if: needs.detect.outputs.doc_only != 'true'
        uses: actions/github-script@v7
        env:
          MARKER: ${{ steps.docs_only.outputs.marker }}
          BASE_MESSAGE: ${{ steps.docs_only.outputs.base_message }}
        with:
          script: |
            const { removeMarkerComments } = require('./.github/scripts/comment-dedupe.js');
            const { DEFAULT_MARKER, BASE_MESSAGE } = require('./.github/scripts/gate-docs-only.js');
            await removeMarkerComments({
              github,
              context,
              core,
              marker: process.env.MARKER || DEFAULT_MARKER,
              baseMessages: [process.env.BASE_MESSAGE || BASE_MESSAGE],
            });
      - name: Discover Gate workflow runs
        id: gather
        uses: actions/github-script@v7
        with:
          script: |
            const { discoverWorkflowRuns } = require('./.github/scripts/maint-post-ci.js');
            await discoverWorkflowRuns({ github, context, core });

      - name: Download Gate artifacts
        if: ${{ needs.detect.outputs.doc_only != 'true' && needs.python-ci.result != 'skipped' }}
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          pattern: gate-*
          merge-multiple: true
          path: gate_artifacts/downloads

      - name: Load coverage summary snippet
        if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.coverage == 'true'
        id: coverage_summary
        run: |
          set -euo pipefail
          mkdir -p gate_artifacts/downloads
          python <<'PY'
          import os
          from pathlib import Path

          output_path = os.environ.get('GITHUB_OUTPUT')
          root = Path('gate_artifacts/downloads')

          summary_path: Path | None = None
          candidates = list(root.rglob('coverage-summary.md'))
          if candidates:
              summary_path = candidates[0]

          if summary_path is None:
              print('No coverage summary markdown found; continuing without it.')
          else:
              text = summary_path.read_text(encoding='utf-8')
              dest = Path('gate-coverage-summary.md')
              dest.write_text(text, encoding='utf-8')
              if output_path:
                  with Path(output_path).open('a', encoding='utf-8') as handle:
                      handle.write('body<<EOF\n')
                      handle.write(text)
                      if not text.endswith('\n'):
                          handle.write('\n')
                      handle.write('EOF\n')
              print(f'Embedded coverage summary from {summary_path}')
          PY

      - name: Compute coverage stats
        if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.coverage == 'true'
        id: coverage_stats
        uses: actions/github-script@v7
        env:
          COVERAGE_ROOT: gate_artifacts/downloads
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { computeCoverageStats } = require('./.github/scripts/coverage-normalize.js');

            const rootDir = process.env.COVERAGE_ROOT || 'gate_artifacts/downloads';
            const coverageRoot = path.join(rootDir, 'coverage', 'runtimes');

            const { stats, deltaPayload } = await computeCoverageStats({
              core,
              rootDir,
              coverageRoot,
              writeFiles: false,
            });

            const statsPath = path.resolve('gate-coverage.json');
            const deltaPath = path.resolve('gate-coverage-delta.json');

            if (stats && Object.keys(stats).length) {
              fs.writeFileSync(statsPath, JSON.stringify(stats, null, 2), 'utf8');
              core.setOutput('stats_json', JSON.stringify(stats));
            } else {
              core.info('Coverage stats unavailable.');
            }

            if (deltaPayload && Object.keys(deltaPayload).length) {
              fs.writeFileSync(deltaPath, JSON.stringify(deltaPayload, null, 2), 'utf8');
              core.setOutput('delta_json', JSON.stringify(deltaPayload));
            } else {
              core.info('Coverage delta unavailable.');
            }

      - name: Summarize results
        if: ${{ always() }}
        id: summarize
        env:
          DOC_ONLY: ${{ needs.detect.outputs.doc_only || 'false' }}
          RUN_CORE: ${{ needs.detect.outputs.run_core || 'true' }}
          REASON: ${{ needs.detect.outputs.reason }}
          PYTHON_RESULT: ${{ needs.python-ci.result || 'skipped' }}
          DOCKER_RESULT: ${{ needs.docker-smoke.result || 'skipped' }}
          DOCKER_CHANGED: ${{ needs.detect.outputs.docker_changed || 'false' }}
          COVERAGE_ENABLED: ${{ needs.detect.outputs.coverage || 'true' }}
        run: python .github/scripts/gate_summary.py

      - name: Auto-apply autofix label for cosmetic failures
        id: autofix_label
        if: |
          github.event_name == 'pull_request' &&
          needs.detect.outputs.doc_only != 'true' &&
          steps.summarize.outputs.state == 'failure' &&
          steps.summarize.outputs.cosmetic_failure == 'true' &&
          !contains(github.event.pull_request.labels.*.name, 'autofix:clean')
        uses: actions/github-script@v7
        env:
          ALLOWED_EXTENSIONS: 'py,pyi'
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            core.setOutput('applied', 'false');
            core.setOutput('skipped_reason', '');

            if (!pr) {
              core.info('No pull request context available; skipping auto-label.');
              core.setOutput('skipped_reason', 'missing-pr');
              return;
            }

            if (!pr.number) {
              core.info('Pull request number missing; skipping auto-label.');
              core.setOutput('skipped_reason', 'invalid-pr');
              return;
            }

            const sameRepo =
              pr.head?.repo?.full_name === `${owner}/${repo}` &&
              pr.base?.repo?.full_name === `${owner}/${repo}`;
            if (!sameRepo) {
              core.info('Skipping auto-label for forked PR.');
              core.setOutput('skipped_reason', 'fork-pr');
              return;
            }

            const iterator = github.paginate.iterator(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: pr.number,
              per_page: 100,
            });

            const allowedExtensions = String(process.env.ALLOWED_EXTENSIONS || '')
              .split(',')
              .map(ext => ext.trim().toLowerCase())
              .filter(Boolean)
              .map(ext => (ext.startsWith('.') ? ext : `.${ext}`));

            const disallowed = [];
            for await (const page of iterator) {
              if (!Array.isArray(page.data)) {
                continue;
              }
              for (const file of page.data) {
                const filename = file?.filename;
                if (typeof filename !== 'string' || filename.length === 0) {
                  continue;
                }
                const lower = filename.toLowerCase();
                const allowed = allowedExtensions.some(ext => lower.endsWith(ext));
                if (!allowed) {
                  disallowed.push(filename);
                }
              }
            }

            if (disallowed.length > 0) {
              core.info(`Skipping auto-label; non-Python changes detected: ${disallowed.join(', ')}`);
              core.setOutput('skipped_reason', 'non-python');
              return;
            }

            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: pr.number,
              labels: ['autofix:clean'],
            });
            core.info('Applied autofix:clean label for cosmetic failure.');
            core.setOutput('applied', 'true');

      - name: Prepare summary body
        id: summary_body
        run: |
          python tools/post_ci_summary.py
        env:
          RUNS_JSON: ${{ steps.gather.outputs.runs || '[]' }}
          HEAD_SHA: ${{ steps.gather.outputs.head_sha || github.event.pull_request.head.sha || github.sha }}
          COVERAGE_SECTION: ${{ steps.coverage_summary.outputs.body || '' }}
          COVERAGE_STATS: ${{ steps.coverage_stats.outputs.stats_json || '' }}
          COVERAGE_DELTA: ${{ steps.coverage_stats.outputs.delta_json || '' }}
          REQUIRED_JOB_GROUPS_JSON: ${{ env.REQUIRED_JOB_GROUPS_JSON }}
          REQUIRED_CONTEXTS_FILE: .github/config/required-contexts.json

      - name: Compose PR summary comment
        id: compose_comment
        run: |
          python <<'PY'
          import os
          from pathlib import Path

          body = (os.environ.get('SUMMARY_BODY') or '').strip()
          pr_number = os.environ.get('PR_NUMBER', '').strip()
          head_sha = os.environ.get('HEAD_SHA', '').strip()

          if not body:
              raise SystemExit('Summary body missing; aborting comment composition.')

          head_token = head_sha[:12] if head_sha else ''
          parts = []
          if pr_number:
              parts.append(f'pr={pr_number}')
          if head_token:
              parts.append(f'head={head_token}')
          if not parts:
              parts.append('anchor')

          marker = f"<!-- gate-summary: {' '.join(parts)} -->"
          payload = "\n".join([marker, body, ''])

          Path('gate-summary.md').write_text(payload, encoding='utf-8')
          print(marker)
          PY
        env:
          SUMMARY_BODY: ${{ steps.summary_body.outputs.body }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          HEAD_SHA: ${{ steps.gather.outputs.head_sha || github.event.pull_request.head.sha || github.sha }}

      - name: Append keepalive checklists
        env:
          LABEL_APPLIED: ${{ steps.autofix_label.outputs.applied || 'false' }}
        run: |
          autofix_task=' '
          if [ "${LABEL_APPLIED}" = "true" ]; then
            autofix_task='x'
          fi

          autofix_accept=' '
          if [ "${LABEL_APPLIED}" = "true" ]; then
            autofix_accept='x'
          fi

          cat <<EOF >> gate-summary.md

          ---
          ### Keepalive checklist

          #### Scope
          - [x] Small change in Gateâ€™s summary job plus label logic in Autofix.

          #### Tasks
          - [${autofix_task}] In Gate summary, detect format/import-only failures and add autofix:clean.
          - [ ] In autofix.yml, drop the agent:* co-label requirement; trigger solely on autofix/autofix:clean.
          - [ ] Keep ALLOWED_GLOBS as *.py, *.pyi; add explicit guard against non-Python changes.

          #### Acceptance criteria
          - [${autofix_accept}] For cosmetic failures, PR gains autofix:clean automatically.
          - [ ] Autofix Loop runs and pushes minimal import/format fixes.
          - [ ] No edits outside allowed globs.
          EOF

      - name: Upload Gate summary artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: gate-summary.md
          path: gate-summary.md
          if-no-files-found: warn
          retention-days: 7
          overwrite: true

      - name: Upload coverage stats artifact
        if: ${{ always() && steps.coverage_stats.outputs.stats_json != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: gate-coverage.json
          path: gate-coverage.json
          if-no-files-found: warn
          retention-days: 7
          overwrite: true

      - name: Upload coverage delta artifact
        if: ${{ always() && steps.coverage_stats.outputs.delta_json != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: gate-coverage-delta.json
          path: gate-coverage-delta.json
          if-no-files-found: warn
          retention-days: 7
          overwrite: true

      - name: Upload coverage summary artifact copy
        if: ${{ always() && steps.coverage_summary.outputs.body != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: gate-coverage-summary.md
          path: gate-coverage-summary.md
          if-no-files-found: warn
          retention-days: 7
          overwrite: true

      - name: Ensure consolidated summary comment
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const path = require('path');
            const fs = require('fs');
            const { upsertAnchoredComment } = require('./.github/scripts/comment-dedupe.js');

            const commentPath = path.resolve('gate-summary.md');
            const body = fs.readFileSync(commentPath, 'utf8');
            await upsertAnchoredComment({
              github,
              context,
              core,
              prNumber: context.payload.pull_request?.number,
              body,
              anchorPattern: /<!--\s*gate-summary:([^>]*)-->/i,
              fallbackMarker: '<!-- gate-summary:',
            });

      - name: Report Gate commit status
        if: ${{ always() }}
        uses: actions/github-script@v7
        env:
          STATE: ${{ steps.summarize.outputs.state || steps.docs_only.outputs.state || (github.event.action == 'labeled' && 'success') || 'pending' }}
          DESCRIPTION: ${{ steps.summarize.outputs.description || steps.docs_only.outputs.description || (github.event.action == 'labeled' && 'Label update - no CI required') || 'Gate status pending' }}
          TARGET_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.payload.pull_request?.head?.sha ?? context.sha;
            const rawState = process.env.STATE || 'pending';
            const allowed = new Set(['error', 'failure', 'pending', 'success']);
            const state = allowed.has(rawState) ? rawState : 'pending';
            const rawDescription = process.env.DESCRIPTION || 'Gate status update';
            const description = rawDescription.length > 140 ? `${rawDescription.slice(0, 137)}...` : rawDescription;
            const targetUrl = process.env.TARGET_URL;

            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha,
              state,
              context: 'Gate / gate',
              description,
              target_url: targetUrl,
            });

      - name: Enforce Gate success
        if: ${{ (steps.summarize.outputs.state || steps.docs_only.outputs.state) == 'failure' }}
        run: |
          echo "Gate reported failure: ${{ steps.summarize.outputs.description || steps.docs_only.outputs.description }}" >&2
          exit 1

  autofix:
    name: autofix
    needs:
      - summary
    if: |
      always() &&
      github.event_name == 'pull_request' &&
      github.event.pull_request.head.repo.full_name == github.repository &&
      (contains(github.event.pull_request.labels.*.name, 'autofix') ||
       contains(github.event.pull_request.labels.*.name, 'autofix:clean')) &&
      needs.summary.result == 'failure'
    uses: ./.github/workflows/reusable-18-autofix.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      pr_head_ref: ${{ github.event.pull_request.head.ref }}
      pr_title: ${{ github.event.pull_request.title }}
      pr_is_draft: ${{ github.event.pull_request.draft }}
      pr_labels_json: ${{ toJSON(github.event.pull_request.labels.*.name) }}
      same_repo: true
      caller_actor: ${{ github.actor }}
      trigger_conclusion: ${{ needs.summary.result }}
      trigger_class: ${{ needs.summary.outputs.state == 'failure' && 'ci-failure' || 'ci-success' }}
      trigger_reason: 'Triggered by Gate workflow after CI completion'
      allowed_file_globs: |-
        **/*.py
        **/*.pyi
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}

