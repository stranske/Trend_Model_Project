name: Gate

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

concurrency:
  group: pr-${{ github.event.pull_request.number || github.ref_name }}-gate
  cancel-in-progress: true

jobs:
  detect:
    name: detect changed files
    runs-on: ubuntu-latest
    outputs:
      doc_only: ${{ steps.diff.outputs.doc_only }}
      run_core: ${{ steps.diff.outputs.run_core }}
      reason: ${{ steps.diff.outputs.reason }}
      docker_changed: ${{ steps.docker_paths.outputs.docker == 'true' || steps.diff.outputs.docker_changed == 'true' }}
    steps:
      - name: Detect changes via API
        id: diff
        uses: actions/github-script@v7
        with:
          script: |
            const { detectChanges } = require('./.github/scripts/detect-changes.js');
            await detectChanges({ github, context, core });

      - name: Detect Docker-related changes via paths filter
        if: github.event_name == 'pull_request'
        id: docker_paths
        uses: dorny/paths-filter@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          base: ${{ github.event.pull_request.base.sha }}
          head: ${{ github.event.pull_request.head.sha }}
          filters: |
            docker:
              - 'Dockerfile'
              - 'Dockerfile.*'
              - '**/[Dd]ockerfile'
              - '**/[Dd]ockerfile.*'
              - '.dockerignore'
              - '**/.dockerignore'
              - 'docker/**'
              - '**/docker/**'
              - '.docker/**'
              - '**/.docker/**'

  core-tests-311:
    name: core-tests-311
    needs: detect
    if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.run_core == 'true'
    uses: ./.github/workflows/reusable-10-ci-python.yml
    with:
      python-version: '3.11'
      primary-python-version: '3.11'
      marker: "not quarantine and not slow"
      enable-soft-gate: true
      # Use the shared gate- prefix so downstream Maint workflows can locate the
      # coverage artifacts without special-casing runtime names.
      artifact-prefix: 'gate-'

  core-tests-312:
    name: core-tests-312
    needs: detect
    if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.run_core == 'true'
    uses: ./.github/workflows/reusable-10-ci-python.yml
    with:
      python-version: '3.12'
      primary-python-version: '3.11'
      marker: "not quarantine and not slow"
      enable-soft-gate: true
      artifact-prefix: 'gate-'

  docker-smoke:
    name: docker smoke
    needs: detect
    if: needs.detect.outputs.doc_only != 'true' && needs.detect.outputs.run_core == 'true' && needs.detect.outputs.docker_changed == 'true'
    uses: ./.github/workflows/reusable-12-ci-docker.yml

  gate:
    name: gate
    needs:
      - detect
      - core-tests-311
      - core-tests-312
      - docker-smoke
    if: ${{ always() }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      statuses: write
    steps:
      - name: Handle docs-only change
        if: needs.detect.outputs.doc_only == 'true'
        id: docs_only
        uses: actions/github-script@v7
        env:
          REASON: ${{ needs.detect.outputs.reason || 'docs_only' }}
        with:
          script: |
            const reason = process.env.REASON || 'docs_only';

            let message;
            if (!reason || reason === 'docs_only') {
              message = 'Gate fast-pass: docs-only change detected; heavy checks skipped.';
            } else if (reason === 'no_changes') {
              message = 'Gate fast-pass: no changes detected; heavy checks skipped.';
            } else {
              message = `Gate fast-pass: docs-only change detected; heavy checks skipped. Reason: ${reason}.`;
            }

            core.info(message);
            core.setOutput('state', 'success');
            core.setOutput('description', message);
            const marker = '<!-- gate-docs-only -->';
            const commentBody = `${message}\n\n${marker}`;
            core.setOutput('comment_body', commentBody);

            await core.summary
              .addHeading('Gate docs-only fast-pass', 3)
              .addRaw(`${message}\n`)
              .write();

      - name: Ensure docs-only fast-pass comment
        if: needs.detect.outputs.doc_only == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_BODY: ${{ steps.docs_only.outputs.comment_body }}
        with:
          script: |
            if (context.eventName !== 'pull_request') {
              core.info('Not a pull_request event; skipping comment management.');
              return;
            }

            const commentBody = process.env.COMMENT_BODY;
            if (!commentBody) {
              core.setFailed('Docs-only comment body is missing.');
              return;
            }

            const marker = '<!-- gate-docs-only -->';
            const baseMessage = 'Gate fast-pass: docs-only change detected; heavy checks skipped.';
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.pull_request.number;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100,
            });

            let target = null;
            const duplicates = [];
            for (const comment of comments) {
              if (typeof comment.body !== 'string') {
                continue;
              }

              const body = comment.body;
              const trimmed = body.trim();
              const hasMarker = body.includes(marker);
              const isLegacy = trimmed === baseMessage || trimmed.startsWith(baseMessage);

              if (!hasMarker && !isLegacy) {
                continue;
              }

              if (!target) {
                target = { comment, hasMarker };
                continue;
              }

              if (!target.hasMarker && hasMarker) {
                duplicates.push(target.comment);
                target = { comment, hasMarker };
              } else {
                duplicates.push(comment);
              }
            }

            const desired = commentBody.trim();
            let targetId = target?.comment?.id;

            if (targetId) {
              const current = typeof target.comment.body === 'string' ? target.comment.body.trim() : '';
              if (current === desired) {
                core.info(`Existing docs-only comment ${targetId} is up to date.`);
              } else {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: targetId,
                  body: commentBody,
                });
                core.info(`Updated docs-only comment ${targetId}.`);
              }
            } else {
              const created = await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body: commentBody,
              });
              targetId = created.data.id;
              core.info(`Created docs-only comment ${targetId}.`);
            }

            for (const duplicate of duplicates) {
              if (!duplicate || duplicate.id === targetId) {
                continue;
              }

              await github.rest.issues.deleteComment({
                owner,
                repo,
                comment_id: duplicate.id,
              });
              core.info(`Removed duplicate docs-only comment ${duplicate.id}.`);
            }

      - name: Remove docs-only fast-pass comment when not needed
        if: needs.detect.outputs.doc_only != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            if (context.eventName !== 'pull_request') {
              core.info('Not a pull_request event; nothing to clean up.');
              return;
            }

            const marker = '<!-- gate-docs-only -->';
            const baseMessage =
              'Gate fast-pass: docs-only change detected; heavy checks skipped.';
            const legacyBodies = new Set([baseMessage]);

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              per_page: 100,
            });

            const targets = comments.filter(comment => {
              if (typeof comment.body !== 'string') {
                return false;
              }

              if (comment.body.includes(marker)) {
                return true;
              }

              const trimmed = comment.body.trim();
              if (legacyBodies.has(trimmed)) {
                return true;
              }

              return trimmed.startsWith(baseMessage);
            });

            if (targets.length === 0) {
              core.info('No docs-only fast-pass comment found to remove.');
              return;
            }

            for (const comment of targets) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: comment.id,
              });
              core.info(`Removed docs-only fast-pass comment ${comment.id}.`);
            }

      - name: Download coverage (3.11)
        if: ${{ needs.detect.outputs.doc_only != 'true' && needs.core-tests-311.result != 'skipped' }}
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: gate-coverage-3.11
          path: gate_artifacts/core-tests-311

      - name: Download coverage (3.12)
        if: ${{ needs.detect.outputs.doc_only != 'true' && needs.core-tests-312.result != 'skipped' }}
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: gate-coverage-3.12
          path: gate_artifacts/core-tests-312

      - name: Summarize results
        if: ${{ always() }}
        id: summarize
        env:
          DOC_ONLY: ${{ needs.detect.outputs.doc_only || 'false' }}
          RUN_CORE: ${{ needs.detect.outputs.run_core || 'true' }}
          REASON: ${{ needs.detect.outputs.reason }}
          PYTHON_RESULT: ${{ needs.core-tests-311.result || needs.core-tests-312.result || 'skipped' }}
          DOCKER_RESULT: ${{ needs.docker-smoke.result || 'skipped' }}
          DOCKER_CHANGED: ${{ needs.detect.outputs.docker_changed || 'false' }}
        run: |
          python <<'PY'
          import json
          import os
          from pathlib import Path

          def normalize(value: str | None, default: str = "unknown") -> str:
              return (value or default).strip().lower()

          doc_only = normalize(os.environ.get("DOC_ONLY"), "false") == "true"
          run_core = normalize(os.environ.get("RUN_CORE"), "true") == "true"
          reason = os.environ.get("REASON") or ""
          python_result = normalize(os.environ.get("PYTHON_RESULT"), "skipped")
          docker_result = normalize(os.environ.get("DOCKER_RESULT"), "skipped")
          docker_changed = normalize(os.environ.get("DOCKER_CHANGED"), "false") == "true"

          base = Path("gate_artifacts")
          records: list[dict[str, object]] = []
          if base.exists():
              for path in sorted(base.rglob("**/summary.json")):
                  try:
                      job_name = path.relative_to(base).parts[0]
                  except (ValueError, IndexError):
                      job_name = "unknown"
                  try:
                      data = json.loads(path.read_text(encoding="utf-8"))
                  except json.JSONDecodeError:
                      continue
                  if isinstance(data, dict):
                      data.setdefault("job_name", job_name)
                      records.append(data)

          def emoji(outcome: str) -> str:
              mapping = {
                  "success": "✅",
                  "skipped": "⏭️",
                  "failure": "❌",
                  "cancelled": "⏹️",
                  "timed_out": "⏱️",
                  "pending": "⏳",
              }
              return mapping.get(outcome, "❔")

          def friendly(outcome: str) -> str:
              if not outcome:
                  return "unknown"
              return outcome.replace("_", " ")

          PRIORITY = {"failure": 0, "timed_out": 1, "cancelled": 2, "success": 3, "skipped": 4, "pending": 5}

          def pick_best(outcomes: list[str]) -> str:
              best = "pending"
              for outcome in outcomes:
                  candidate = outcome or "pending"
                  if PRIORITY.get(candidate, 99) < PRIORITY.get(best, 99):
                      best = candidate
              return best

          def aggregate_status(entries: list[tuple[str, str]]) -> tuple[str, str]:
              best = pick_best([outcome for _, outcome in entries])
              groups: list[str] = []
              for runtime, outcome in sorted(entries):
                  groups.append(f"{runtime}: {friendly(outcome)}")
              detail = ", ".join(groups) if groups else "no runs"
              return best, detail

          summary_path = Path(os.environ.get("GITHUB_STEP_SUMMARY", ""))
          lines: list[str] = []

          state = "success"
          description = "All Gate checks succeeded."

          if doc_only or not run_core:
              if not reason:
                  reason = "docs_only"
              note = (
                  "Docs-only change detected; heavy checks skipped."
                  if reason == "docs_only"
                  else f"Docs-only change detected; heavy checks skipped ({reason})."
              )
              description = (
                  "Gate fast-pass: docs-only change detected; heavy checks skipped."
                  if reason == "docs_only"
                  else f"Docs-only change; heavy checks skipped ({reason})."
              )
              lines.append("### Gate status")
              lines.append("Docs-only fast-pass engaged; heavy jobs were skipped.")
              # Add a minimal job/result table so tests can detect the expected header
              lines.append("| Job | Result |")
              lines.append("| --- | --- |")
              lines.append("| docs-only | success |")
          else:
              table = [
                  "| Runtime | Lint | Type | Tests | Coverage min | Coverage % |",
                  "| --- | --- | --- | --- | --- | --- |",
              ]
              lint_entries: list[tuple[str, str]] = []
              type_entries: list[tuple[str, str]] = []
              test_entries: list[tuple[str, str]] = []
              coverage_entries: list[tuple[str, str]] = []
              coverage_percents: list[str] = []
              job_results: dict[str, list[str]] = {}

              for record in sorted(records, key=lambda item: str(item.get("python_version", ""))):
                  runtime = str(record.get("python_version", "unknown"))
                  job_name = str(record.get("job_name") or runtime)
                  checks = record.get("checks") if isinstance(record.get("checks"), dict) else {}
                  lint = normalize(
                      checks.get("lint", {}).get("outcome")
                      if isinstance(checks.get("lint"), dict)
                      else None,
                      "unknown",
                  )
                  typing = normalize(
                      checks.get("type_check", {}).get("outcome")
                      if isinstance(checks.get("type_check"), dict)
                      else None,
                      "unknown",
                  )
                  tests = normalize(
                      checks.get("tests", {}).get("outcome")
                      if isinstance(checks.get("tests"), dict)
                      else None,
                      "unknown",
                  )
                  coverage_min = normalize(
                      checks.get("coverage_minimum", {}).get("outcome")
                      if isinstance(checks.get("coverage_minimum"), dict)
                      else None,
                      "unknown",
                  )

                  lint_entries.append((runtime, lint))
                  type_entries.append((runtime, typing))
                  test_entries.append((runtime, tests))
                  coverage_entries.append((runtime, coverage_min))
                  job_results.setdefault(job_name, []).extend([lint, typing, tests, coverage_min])

                  coverage_info = record.get("coverage") if isinstance(record.get("coverage"), dict) else {}
                  percent = coverage_info.get("percent") if isinstance(coverage_info, dict) else None
                  if isinstance(percent, (int, float)):
                      coverage_percents.append(f"{runtime}: {percent:.2f}%")
                      percent_display = f"{percent:.2f}%"
                  else:
                      percent_display = "—"

                  table.append(
                      "| {runtime} | {lint} {lint_status} | {typing} {type_status} | {tests} {test_status} | {coverage_min} {cov_status} | {percent} |".format(
                          runtime=runtime,
                          lint=emoji(lint),
                          lint_status=friendly(lint),
                          typing=emoji(typing),
                          type_status=friendly(typing),
                          tests=emoji(tests),
                          test_status=friendly(tests),
                          coverage_min=emoji(coverage_min),
                          cov_status=friendly(coverage_min),
                          percent=percent_display,
                      )
                  )

              lint_status, lint_detail = aggregate_status(lint_entries)
              type_status, type_detail = aggregate_status(type_entries)
              test_status, test_detail = aggregate_status(test_entries)
              coverage_status, coverage_detail = aggregate_status(coverage_entries)

              lines.append("### Gate status")
              lines.extend(table)
              # Also include a compact job/result table for downstream checks
              lines.append("")
              lines.append("| Job | Result |")
              lines.append("| --- | --- |")
              for job_name, outcomes in sorted(job_results.items()):
                  result = pick_best(outcomes)
                  lines.append(f"| {job_name} | {friendly(result)} |")
              lines.append(f"| docker-smoke | {friendly(docker_result)} |")

              lines.append("")
              lines.append(f"- Lint: {emoji(lint_status)} {friendly(lint_status)} ({lint_detail})")
              lines.append(f"- Type check: {emoji(type_status)} {friendly(type_status)} ({type_detail})")
              lines.append(f"- Tests: {emoji(test_status)} {friendly(test_status)} ({test_detail})")
              lines.append(f"- Coverage minimum: {emoji(coverage_status)} {friendly(coverage_status)} ({coverage_detail})")
              if coverage_percents:
                  lines.append(f"- Reported coverage: {', '.join(coverage_percents)}")

              if python_result != "success":
                  state = "failure"
                  description = f"Python CI result: {python_result}."
              elif docker_changed and docker_result != "success":
                  state = "failure"
                  description = f"Docker smoke result: {docker_result}."
              elif not docker_changed:
                  lines.append("- Docker smoke skipped: no Docker-related changes detected.")

          if summary_path and lines:
              with summary_path.open("a", encoding="utf-8") as handle:
                  handle.write("\n".join(lines) + "\n")

          output_path = Path(os.environ.get("GITHUB_OUTPUT", ""))
          if output_path:
              with output_path.open("a", encoding="utf-8") as handle:
                  handle.write(f"state={state}\n")
                  handle.write(f"description={description}\n")
          PY

      - name: Report Gate commit status
        if: ${{ always() }}
        uses: actions/github-script@v7
        env:
          STATE: ${{ steps.summarize.outputs.state || steps.docs_only.outputs.state || 'pending' }}
          DESCRIPTION: ${{ steps.summarize.outputs.description || steps.docs_only.outputs.description || 'Gate status pending' }}
          TARGET_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const sha = context.payload.pull_request?.head?.sha ?? context.sha;
            const rawState = process.env.STATE || 'pending';
            const allowed = new Set(['error', 'failure', 'pending', 'success']);
            const state = allowed.has(rawState) ? rawState : 'pending';
            const rawDescription = process.env.DESCRIPTION || 'Gate status update';
            const description = rawDescription.length > 140 ? `${rawDescription.slice(0, 137)}...` : rawDescription;
            const targetUrl = process.env.TARGET_URL;

            await github.rest.repos.createCommitStatus({
              owner,
              repo,
              sha,
              state,
              context: 'Gate / gate',
              description,
              target_url: targetUrl,
            });

      - name: Enforce Gate success
        if: ${{ (steps.summarize.outputs.state || steps.docs_only.outputs.state) == 'failure' }}
        run: |
          echo "Gate reported failure: ${{ steps.summarize.outputs.description || steps.docs_only.outputs.description }}" >&2
          exit 1
