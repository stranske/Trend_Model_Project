name: Health 41 Repo Health

on:
  schedule:
    # 07:15 UTC each Monday keeps results inside a quiet window.
    - cron: '15 7 * * 1'
  workflow_dispatch:

permissions:
  contents: read
  issues: read

jobs:
  weekly-sweep:
    name: Weekly repository health sweep
    runs-on: ubuntu-latest
    env:
      STALE_BRANCH_DAYS: ${{ vars.REPO_HEALTH_STALE_BRANCH_DAYS || '30' }}
      MAX_TABLE_ROWS: '20'
    steps:
      - name: Summarise repository health signals
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');

            const staleBranchDays = parseInt(process.env.STALE_BRANCH_DAYS || '30', 10);
            const maxRows = parseInt(process.env.MAX_TABLE_ROWS || '20', 10);
            const now = new Date();
            const staleCutoff = new Date(now.getTime() - staleBranchDays * 24 * 60 * 60 * 1000);

            const repoInfo = await github.rest.repos.get(context.repo);
            const defaultBranch = repoInfo.data.default_branch;

            const branches = await github.paginate(github.rest.repos.listBranches, {
              ...context.repo,
              per_page: 100,
            });

            const staleBranches = [];
            for (const branch of branches) {
              if (!branch || branch.name === defaultBranch) {
                continue;
              }

              try {
                const commitSha = branch.commit?.sha;
                if (!commitSha) {
                  continue;
                }

                const commit = await github.rest.repos.getCommit({
                  ...context.repo,
                  ref: commitSha,
                });

                const commitDateRaw = commit.data.commit?.committer?.date || commit.data.commit?.author?.date;
                if (!commitDateRaw) {
                  continue;
                }

                const commitDate = new Date(commitDateRaw);
                if (Number.isNaN(commitDate.getTime())) {
                  continue;
                }

                if (commitDate <= staleCutoff) {
                  const ageDays = Math.floor((now.getTime() - commitDate.getTime()) / (24 * 60 * 60 * 1000));
                  staleBranches.push({
                    name: branch.name,
                    lastCommit: commitDate.toISOString().slice(0, 10),
                    ageDays,
                  });
                }
              } catch (error) {
                core.warning(`Failed to inspect branch ${branch.name}: ${error.message}`);
              }
            }

            staleBranches.sort((a, b) => b.ageDays - a.ageDays);

            const openItems = await github.paginate(github.rest.issues.listForRepo, {
              ...context.repo,
              per_page: 100,
              state: 'open',
              filter: 'all',
            });

            const unassignedIssues = openItems
              .filter(item => !item.pull_request)
              .filter(issue => !issue.assignees || issue.assignees.length === 0)
              .map(issue => ({
                number: issue.number,
                title: issue.title || '(no title)',
                url: issue.html_url,
                updatedAt: issue.updated_at,
              }))
              .sort((a, b) => new Date(a.updatedAt) - new Date(b.updatedAt));

            const summary = core.summary;
            summary.addHeading('Repository health weekly sweep', 1);
            summary.addRaw(`Generated on ${now.toUTCString()}`, true);
            summary.addBreak();
            summary.addTable([
              [
                { data: 'Signal', header: true },
                { data: 'Count', header: true },
              ],
              [
                `Stale branches (>${staleBranchDays}d)`,
                `${staleBranches.length}`,
              ],
              [
                'Open issues without assignees',
                `${unassignedIssues.length}`,
              ],
            ]);

            if (staleBranches.length > 0) {
              summary.addHeading('Stale branches', 2);
              const branchRows = staleBranches.slice(0, maxRows).map(branch => [
                branch.name,
                branch.lastCommit,
                branch.ageDays.toString(),
              ]);
              summary.addTable([
                [
                  { data: 'Branch', header: true },
                  { data: 'Last commit (UTC)', header: true },
                  { data: 'Age (days)', header: true },
                ],
                ...branchRows,
              ]);

              if (staleBranches.length > maxRows) {
                summary.addRaw(`‚Ä¶and ${staleBranches.length - maxRows} more branches.`, true);
              }
            } else {
              summary.addHeading('Stale branches', 2);
              summary.addRaw('No stale branches detected üéâ', true);
            }

            if (unassignedIssues.length > 0) {
              summary.addHeading('Open issues without assignees', 2);
              const issueRows = unassignedIssues.slice(0, maxRows).map(issue => [
                `[#${issue.number}](${issue.url})`,
                issue.title,
              ]);
              summary.addTable([
                [
                  { data: 'Issue', header: true },
                  { data: 'Title', header: true },
                ],
                ...issueRows,
              ]);

              if (unassignedIssues.length > maxRows) {
                summary.addRaw(`‚Ä¶and ${unassignedIssues.length - maxRows} more issues.`, true);
              }
            } else {
              summary.addHeading('Open issues without assignees', 2);
              summary.addRaw('All open issues have at least one assignee ‚úÖ', true);
            }

            await summary.write();

            core.info('Repository health summary written to workflow run.');

      - name: Verify default branch protection requires Gate / gate
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');

            const repoInfo = await github.rest.repos.get(context.repo);
            const defaultBranch = repoInfo.data.default_branch;
            const expectedContexts = ['Gate / gate'];

            const branchProtectionResult = {
              contexts: [],
              strict: null,
              source: 'branches',
            };

            try {
              const protection = await github.rest.repos.getBranchProtection({
                ...context.repo,
                branch: defaultBranch,
              });

              const contexts = protection.data?.required_status_checks?.contexts;
              if (Array.isArray(contexts)) {
                branchProtectionResult.contexts = contexts.map(value => `${value}`);
              }
              if (typeof protection.data?.required_status_checks?.strict === 'boolean') {
                branchProtectionResult.strict = protection.data.required_status_checks.strict;
              }
              branchProtectionResult.source = 'branchProtection';
            } catch (error) {
              core.warning(`Falling back to branch metadata for protection details: ${error.message}`);
              const branch = await github.rest.repos.getBranch({
                ...context.repo,
                branch: defaultBranch,
              });
              const contexts = branch.data?.protection?.required_status_checks?.contexts;
              if (Array.isArray(contexts)) {
                branchProtectionResult.contexts = contexts.map(value => `${value}`);
              }
            }

            const uniqueContexts = Array.from(new Set(branchProtectionResult.contexts.filter(Boolean))).sort((a, b) => a.localeCompare(b));
            const expectedSorted = [...expectedContexts].sort((a, b) => a.localeCompare(b));
            const missing = expectedSorted.filter(contextName => !uniqueContexts.includes(contextName));
            const unexpected = uniqueContexts.filter(contextName => !expectedSorted.includes(contextName));

            const summary = core.summary;
            summary.addBreak();
            summary.addHeading('Default branch protection', 2);
            summary.addTable([
              [
                { data: 'Property', header: true },
                { data: 'Value', header: true },
              ],
              ['Branch', defaultBranch],
              ['Source', branchProtectionResult.source],
              ['Expected contexts', expectedContexts.length > 0 ? expectedContexts.join(', ') : '‚Äì'],
              ['Required contexts', uniqueContexts.length > 0 ? uniqueContexts.join(', ') : '‚Äì'],
              ['Required ‚Äúup to date‚Äù', branchProtectionResult.strict === null ? 'unknown' : String(branchProtectionResult.strict)],
            ]);

            let branchProtectionFailure = null;
            const expectedListForPointer = expectedSorted.length > 0 ? expectedSorted.join(', ') : 'no required checks';
            const actualListForPointer = uniqueContexts.length > 0 ? uniqueContexts.join(', ') : 'no required checks';
            if (missing.length > 0 || unexpected.length > 0) {
              const problems = [];
              if (missing.length > 0) {
                problems.push(`missing contexts: ${missing.join(', ')}`);
              }
              if (unexpected.length > 0) {
                problems.push(`unexpected contexts: ${unexpected.join(', ')}`);
              }
              const failurePrefix = `Branch protection drift detected for ${defaultBranch}`;
              summary.addRaw(`‚ùå ${failurePrefix} ‚Äî ${problems.join('; ')}`, true);
              summary.addRaw(
                `‚û°Ô∏è Update branch protection (Settings ‚Üí Branches ‚Üí ${defaultBranch}) so required status checks are exactly: ${expectedListForPointer}.`,
                true,
              );

              if (missing.includes('Gate / gate')) {
                branchProtectionFailure = `Default branch ("${defaultBranch}") no longer requires the "Gate / gate" status check. Expected: ${expectedListForPointer}. Actual: ${actualListForPointer}. Update branch protection to restore Gate.`;
              } else {
                branchProtectionFailure = `${failurePrefix}. Expected: ${expectedListForPointer}. Actual: ${actualListForPointer}. (${problems.join('; ')}).`;
              }
            } else {
              summary.addRaw('‚úÖ Branch protection contexts match the expected configuration.', true);
            }

            await summary.write();

            if (branchProtectionFailure) {
              core.setFailed(branchProtectionFailure);
              return;
            }

            core.info('Branch protection configuration matches expectations.');
