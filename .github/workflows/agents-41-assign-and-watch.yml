name: Agents Assign + Watch

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "assign | clear | watch | sweep"
        required: false
        default: ""
      issue:
        description: "Issue number"
        required: false
        default: ""
      agent:
        description: "Agent key (codex | copilot)"
        required: false
        default: ""
      timeout_minutes:
        description: "Timeout window for watchdog checks"
        required: false
        default: ""
      started_at:
        description: "Override watchdog start timestamp (ISO)"
        required: false
        default: ""
      expected_pr:
        description: "Expected PR number when invoking watchdog manually"
        required: false
        default: ""
      event_name:
        description: "Original event name forwarded by wrapper workflows"
        required: false
        default: ""
      event_payload:
        description: "JSON payload forwarded by wrapper workflows"
        required: false
        default: ""
  schedule:
    - cron: "*/30 * * * *"

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

concurrency:
  group: agents-assign-and-watch-${{ github.event.inputs.issue || github.run_id }}
  cancel-in-progress: false

jobs:
  resolve:
    name: Resolve agent operation
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.ctx.outputs.should_run }}
      operation: ${{ steps.ctx.outputs.operation }}
      agent: ${{ steps.ctx.outputs.agent }}
      issue: ${{ steps.ctx.outputs.issue }}
      assignees: ${{ steps.ctx.outputs.assignees }}
      command: ${{ steps.ctx.outputs.command }}
      timeout: ${{ steps.ctx.outputs.timeout }}
      started_at: ${{ steps.ctx.outputs.started_at }}
      expected_pr: ${{ steps.ctx.outputs.expected_pr }}
      watchdog_enabled: ${{ steps.ctx.outputs.watchdog_enabled }}
      readiness_agents: ${{ steps.ctx.outputs.readiness_agents }}
      default_branch: ${{ steps.ctx.outputs.default_branch }}
      stale_minutes: ${{ steps.ctx.outputs.stale_minutes }}
    steps:
      - name: Determine action
        id: ctx
        uses: actions/github-script@v7
        with:
          script: |
            const CONFIG = {
              codex: {
                labels: ['agent:codex', 'agents:codex'],
                assignees: ['chatgpt-codex-connector'],
                command: '@codex start',
                watchdog_timeout: 7,
                stale_minutes: 240,
                mention: '@codex',
                watchdog_enabled: true
              },
              copilot: {
                labels: ['agent:copilot', 'agents:copilot'],
                assignees: ['copilot'],
                command: '@copilot start',
                watchdog_timeout: 7,
                stale_minutes: 360,
                mention: '@copilot',
                watchdog_enabled: false
              }
            };

            const labelToAgent = {};
            for (const [agentKey, cfg] of Object.entries(CONFIG)) {
              for (const label of cfg.labels) {
                labelToAgent[label.toLowerCase()] = agentKey;
              }
            }

            const { owner, repo } = context.repo;
            const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
            const defaultBranch = repoInfo.default_branch || 'main';

            const dispatchInputs = context.payload?.inputs || {};
            const manualMode = (dispatchInputs.mode || '').trim().toLowerCase();
            const manualIssue = (dispatchInputs.issue || '').trim();
            const manualAgent = (dispatchInputs.agent || '').trim().toLowerCase();
            const manualTimeout = (dispatchInputs.timeout_minutes || '').trim();
            const manualStartedAt = (dispatchInputs.started_at || '').trim();
            const manualExpectedPr = (dispatchInputs.expected_pr || '').trim();
            const forwardedEventName = (dispatchInputs.event_name || '').trim().toLowerCase();
            const payloadRaw = dispatchInputs.event_payload || '';

            let forwardedPayload = null;
            if (payloadRaw) {
              try {
                forwardedPayload = JSON.parse(payloadRaw);
              } catch (error) {
                core.warning(`Failed to parse forwarded payload: ${error.message}`);
              }
            }

            const eventName = context.eventName === 'workflow_dispatch' && forwardedEventName
              ? forwardedEventName
              : context.eventName;

            const nowIso = new Date().toISOString();

            let operation = 'none';
            let agentKey = '';
            let issueNumber = 0;
            let timeoutMinutes = '';
            let startedAt = '';
            let expectedPr = manualExpectedPr;
            let readinessAgents = '';
            let watchdogEnabled = 'false';
            let staleMinutes = '';

            const resolveFromIssuePayload = (payload, actionOverride = '') => {
              if (!payload) { return; }
              const action = (actionOverride || payload.action || '').toLowerCase();
              const issue = payload.issue || {};
              const number = Number(issue.number || 0);
              const labelName = (payload.label?.name || '').toLowerCase();
              const labels = (issue.labels || []).map(l => (l.name || '').toLowerCase());

              if (!number) {
                return;
              }

              if (action === 'labeled') {
                const directAgent = labelToAgent[labelName];
                if (directAgent) {
                  issueNumber = number;
                  agentKey = directAgent;
                  operation = 'assign';
                }
              } else if (action === 'unlabeled') {
                const removedAgent = labelToAgent[labelName];
                if (removedAgent) {
                  issueNumber = number;
                  agentKey = removedAgent;
                  operation = 'clear';
                }
              } else if (!action && labels.length) {
                for (const lbl of labels) {
                  if (labelToAgent[lbl]) {
                    issueNumber = number;
                    agentKey = labelToAgent[lbl];
                    operation = 'assign';
                    break;
                  }
                }
              }
            };

            if (context.eventName === 'schedule') {
              operation = 'sweep';
              readinessAgents = Object.keys(CONFIG).join(',');
            } else if (manualMode) {
              if (manualMode === 'assign') {
                const cfg = CONFIG[manualAgent] || null;
                if (cfg && manualIssue) {
                  operation = 'assign';
                  agentKey = manualAgent;
                  issueNumber = Number(manualIssue);
                }
              } else if (manualMode === 'clear') {
                const cfg = CONFIG[manualAgent] || null;
                if (cfg && manualIssue) {
                  operation = 'clear';
                  agentKey = manualAgent;
                  issueNumber = Number(manualIssue);
                }
              } else if (manualMode === 'watch') {
                const cfg = CONFIG[manualAgent] || null;
                if (cfg && manualIssue) {
                  operation = 'watch';
                  agentKey = manualAgent;
                  issueNumber = Number(manualIssue);
                }
              } else if (manualMode === 'sweep') {
                operation = 'sweep';
                readinessAgents = manualAgent ? manualAgent : Object.keys(CONFIG).join(',');
              }
            } else if (eventName === 'issues') {
              resolveFromIssuePayload(forwardedPayload || context.payload);
            }

            if (operation === 'assign' || operation === 'watch') {
              const cfg = CONFIG[agentKey] || {};
              timeoutMinutes = manualTimeout || String(cfg.watchdog_timeout || 7);
              startedAt = manualStartedAt || nowIso;
              readinessAgents = agentKey;
              staleMinutes = String(cfg.stale_minutes || 240);
              if (operation === 'assign' && cfg) {
                watchdogEnabled = cfg.watchdog_enabled ? 'true' : 'false';
              } else if (operation === 'watch') {
                watchdogEnabled = 'true';
              }
            } else if (operation === 'clear') {
              const cfg = CONFIG[agentKey] || {};
              staleMinutes = String(cfg.stale_minutes || 240);
            } else if (operation === 'sweep') {
              startedAt = nowIso;
            }

            const cfg = CONFIG[agentKey] || {};
            const assignees = JSON.stringify(cfg.assignees || []);
            const command = cfg.command || '';

            const shouldRun = Boolean(
              (operation === 'assign' && issueNumber && agentKey) ||
              (operation === 'clear' && issueNumber && agentKey) ||
              (operation === 'watch' && issueNumber && agentKey) ||
              operation === 'sweep'
            );

            core.setOutput('should_run', shouldRun ? 'true' : 'false');
            core.setOutput('operation', operation);
            core.setOutput('agent', agentKey);
            core.setOutput('issue', issueNumber ? String(issueNumber) : '');
            core.setOutput('assignees', assignees);
            core.setOutput('command', command);
            core.setOutput('timeout', timeoutMinutes || '');
            core.setOutput('started_at', startedAt || '');
            core.setOutput('expected_pr', expectedPr || '');
            core.setOutput('watchdog_enabled', watchdogEnabled);
            core.setOutput('readiness_agents', readinessAgents || '');
            core.setOutput('default_branch', defaultBranch);
            core.setOutput('stale_minutes', staleMinutes || '');

            if (!shouldRun) {
              core.info('No actionable agent event detected.');
            } else {
              core.info(`Operation=${operation} agent=${agentKey} issue=${issueNumber}`);
            }

  readiness_probe:
    needs:
      - resolve
    if: needs.resolve.outputs.should_run == 'true' && (needs.resolve.outputs.operation == 'assign' || needs.resolve.outputs.operation == 'sweep')
    name: Agent availability check
    uses: ./.github/workflows/reusable-90-agents.yml
    with:
      enable_readiness: ${{ 'true' }}
      readiness_agents: ${{ needs.resolve.outputs.readiness_agents }}
      require_all: ${{ needs.resolve.outputs.operation == 'assign' && 'true' || 'false' }}
      enable_preflight: ${{ 'false' }}
      enable_diagnostic: ${{ 'false' }}
      enable_verify_issue: ${{ 'false' }}
      enable_watchdog: ${{ 'false' }}
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}

  assign_issue:
    needs:
      - resolve
      - readiness_probe
    if: needs.resolve.outputs.should_run == 'true' && needs.resolve.outputs.operation == 'assign' && needs.readiness_probe.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      expected_pr: ${{ steps.bootstrap.outputs.pr || needs.resolve.outputs.expected_pr }}
    steps:
      - name: Assign agent actor
        uses: actions/github-script@v7
        env:
          ISSUE: ${{ needs.resolve.outputs.issue }}
          ASSIGNEES: ${{ needs.resolve.outputs.assignees }}
        with:
          script: |
            const issue = Number(process.env.ISSUE || '0');
            const assignees = JSON.parse(process.env.ASSIGNEES || '[]').filter(Boolean);
            if (!issue || !assignees.length) {
              core.info('No assignment performed (missing issue or assignees).');
              return;
            }
            const { owner, repo } = context.repo;
            await github.rest.issues.addAssignees({ owner, repo, issue_number: issue, assignees });
            core.info(`Assigned ${assignees.join(', ')} to #${issue}.`);

      - name: Bootstrap Codex issue branch
        id: bootstrap
        if: needs.resolve.outputs.agent == 'codex'
        continue-on-error: true
        uses: ./.github/actions/codex-bootstrap-lite
        with:
          issue: ${{ needs.resolve.outputs.issue }}
          service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
          allow_fallback: 'true'
          codex_command: '@codex start'
          draft: 'false'
          auto_ready: 'true'
          post_codex_comment: 'false'
          pr_mode: 'create'

      - name: Surface bootstrap failure
        if: needs.resolve.outputs.agent == 'codex' && steps.bootstrap.outcome == 'failure'
        run: |
          echo "::warning::Codex bootstrap step failed (non-fatal while fallback evaluated)."

      - name: Fallback dispatch Codex Issue Bridge
        id: fallback_dispatch
        if: needs.resolve.outputs.agent == 'codex' && steps.bootstrap.outcome == 'failure'
        uses: actions/github-script@v7
        env:
          ISSUE: ${{ needs.resolve.outputs.issue }}
          REF: ${{ needs.resolve.outputs.default_branch }}
        with:
          script: |
            const issue = Number(process.env.ISSUE || '0');
            const ref = (process.env.REF || '').trim() || 'main';
            if (!issue) {
              core.setFailed('Fallback dispatch aborted: missing issue number.');
              return;
            }
            const { owner, repo } = context.repo;
            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id: 'codex-issue-bridge.yml',
              ref,
              inputs: {
                test_issue: String(issue),
                pr_mode: 'create',
                post_codex_comment: 'false',
                codex_pr_draft: 'false'
              }
            });
            core.info(`Fallback codex-issue-bridge dispatched for issue #${issue}.`);

      - name: Fail if both primary and fallback bootstrap failed
        if: needs.resolve.outputs.agent == 'codex' && steps.bootstrap.outcome == 'failure' && steps.fallback_dispatch.outcome == 'failure'
        run: |
          echo "::error::Both primary bootstrap and fallback dispatch failed."
          exit 1

  clear_assignment:
    needs: resolve
    if: needs.resolve.outputs.should_run == 'true' && needs.resolve.outputs.operation == 'clear'
    runs-on: ubuntu-latest
    steps:
      - name: Remove agent assignment after label removal
        uses: actions/github-script@v7
        env:
          ISSUE: ${{ needs.resolve.outputs.issue }}
          ASSIGNEES: ${{ needs.resolve.outputs.assignees }}
          AGENT: ${{ needs.resolve.outputs.agent }}
        with:
          script: |
            const issue = Number(process.env.ISSUE || '0');
            const assignees = JSON.parse(process.env.ASSIGNEES || '[]').filter(Boolean);
            if (!issue || !assignees.length) {
              core.info('Nothing to clear.');
              return;
            }
            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.removeAssignees({ owner, repo, issue_number: issue, assignees });
              core.info(`Removed ${assignees.join(', ')} from #${issue}.`);
            } catch (error) {
              core.warning(`Failed to remove assignees: ${error.message}`);
            }
            const note = `Agent label removed; cleared ${process.env.AGENT || 'agent'} assignment.`;
            await github.rest.issues.createComment({ owner, repo, issue_number: issue, body: note });

  watch_pr:
    needs:
      - resolve
      - assign_issue
    if: always() && needs.resolve.outputs.should_run == 'true' && (needs.resolve.outputs.operation == 'watch' || (needs.resolve.outputs.operation == 'assign' && needs.resolve.outputs.watchdog_enabled == 'true' && needs.assign_issue.result == 'success'))
    runs-on: ubuntu-latest
    steps:
      - name: Monitor for cross-referenced PR
        uses: actions/github-script@v7
        env:
          ISSUE: ${{ needs.resolve.outputs.issue }}
          AGENT: ${{ needs.resolve.outputs.agent }}
          TIMEOUT: ${{ needs.resolve.outputs.timeout }}
          STARTED_AT: ${{ needs.resolve.outputs.started_at }}
          EXPECTED_PR_RESOLVE: ${{ needs.resolve.outputs.expected_pr }}
          EXPECTED_PR_ASSIGN: ${{ needs.assign_issue.outputs.expected_pr }}
        with:
          script: |
            const issueNumber = Number(process.env.ISSUE || '0');
            if (!issueNumber) {
              core.setFailed('Missing issue number input.');
              return;
            }
            const agent = process.env.AGENT || '';
            const expectedAssign = process.env.EXPECTED_PR_ASSIGN || '';
            const expectedResolve = process.env.EXPECTED_PR_RESOLVE || '';
            const expectedPr = expectedAssign || expectedResolve;
            const timeoutInput = process.env.TIMEOUT || '7';
            const timeoutMinutes = Number(timeoutInput) > 0 ? Number(timeoutInput) : 7;
            const startInput = process.env.STARTED_AT || '';
            let startTime = startInput ? new Date(startInput) : new Date();
            if (Number.isNaN(startTime.getTime())) {
              startTime = new Date();
            }
            const startMs = startTime.getTime();
            const pollMs = 30000;
            const deadline = startMs + timeoutMinutes * 60000;
            const threshold = startMs - 5000;
            const { owner, repo } = context.repo;

            const findCrossReference = async () => {
              const events = await github.paginate(
                github.request,
                {
                  method: 'GET',
                  url: '/repos/{owner}/{repo}/issues/{issue_number}/timeline',
                  owner,
                  repo,
                  issue_number: issueNumber,
                  per_page: 100,
                  headers: { 'accept': 'application/vnd.github.mockingbird-preview+json' }
                }
              );
              for (const event of events) {
                if ((event.event || '') !== 'cross-referenced') {
                  continue;
                }
                const sourceIssue = event.source?.issue;
                if (!sourceIssue || !sourceIssue.pull_request) {
                  continue;
                }
                const prNumber = Number(sourceIssue.number || 0);
                if (!prNumber) {
                  continue;
                }
                if (expectedPr && prNumber !== Number(expectedPr)) {
                  continue;
                }
                const createdAt = new Date(event.created_at || '').getTime();
                if (Number.isNaN(createdAt) || createdAt < threshold) {
                  continue;
                }
                return {
                  number: prNumber,
                  url: sourceIssue.html_url || `https://github.com/${owner}/${repo}/pull/${prNumber}`,
                  title: sourceIssue.title || '',
                  createdAt
                };
              }
              return null;
            };

            let found = null;
            while (Date.now() < deadline) {
              found = await findCrossReference();
              if (found) {
                break;
              }
              await new Promise(resolve => setTimeout(resolve, pollMs));
            }

            const elapsedMs = found ? Math.max(0, found.createdAt - startMs) : Math.max(0, Date.now() - startMs);
            const elapsedMinutes = elapsedMs / 60000;
            const friendlyElapsed = elapsedMinutes.toFixed(2);
            const agentLabel = agent ? agent : 'agent';

            core.setOutput('found', found ? 'true' : 'false');
            core.setOutput('pr', found ? String(found.number) : '');
            core.setOutput('elapsed_minutes', friendlyElapsed);

            const summary = core.summary.addHeading('Agent Watchdog Result');
            if (found) {
              summary.addTable([
                [{ data: 'Status', header: true }, { data: 'Details', header: true }],
                ['âœ… PR detected', `#${found.number} (${found.url}) in ${friendlyElapsed} minutes`]
              ]);
            } else {
              summary.addTable([
                [{ data: 'Status', header: true }, { data: 'Details', header: true }],
                ['âš ï¸ Timeout', `No PR detected within ${timeoutMinutes} minute window`]
              ]);
            }
            await summary.write();

            const commentPrefix = found ? 'âœ… Agent Watchdog' : 'âš ï¸ Agent Watchdog';
            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number: issueNumber, per_page: 100, page: 1 });
            const alreadyCommented = (comments || []).some(c => (c.body || '').startsWith(commentPrefix));

            if (found) {
              const body = `${commentPrefix}: Detected PR #${found.number} referencing this issue after ${friendlyElapsed} minute${elapsedMinutes === 1 ? '' : 's'}.\n\nLink: ${found.url}`;
              if (!alreadyCommented) {
                await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body });
              }
            } else {
              const mention = agentLabel && agentLabel !== 'agent' ? `${agentLabel} ` : '';
              const body = `${commentPrefix}: ${mention}no pull request cross-reference detected within ${timeoutMinutes} minute${timeoutMinutes === 1 ? '' : 's'}.`;
              if (!alreadyCommented) {
                await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body });
              }
            }

  watchdog_sweep:
    needs:
      - resolve
      - readiness_probe
    if: needs.resolve.outputs.operation == 'sweep' && needs.readiness_probe.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Sweep stale agent issues
        uses: actions/github-script@v7
        env:
          READINESS_REPORT: ${{ needs.readiness_probe.outputs.readiness_report }}
          STALE_MINUTES: ${{ needs.resolve.outputs.stale_minutes }}
        with:
          script: |
            const readiness = (() => {
              const raw = process.env.READINESS_REPORT || '{}';
              try { return JSON.parse(raw); } catch (error) { core.warning('Failed to parse readiness report JSON.'); return {}; }
            })();
            const CONFIG = {
              codex: {
                labels: ['agent:codex', 'agents:codex'],
                assignees: ['chatgpt-codex-connector'],
                stale_minutes: 240,
                ping_prefix: 'ðŸ¤– Watchdog ping (codex)',
                escalate_prefix: 'ðŸš¨ Watchdog escalation (codex)',
                mention: '@codex'
              },
              copilot: {
                labels: ['agent:copilot', 'agents:copilot'],
                assignees: ['copilot'],
                stale_minutes: 360,
                ping_prefix: 'ðŸ¤– Watchdog ping (copilot)',
                escalate_prefix: 'ðŸš¨ Watchdog escalation (copilot)',
                mention: '@copilot'
              }
            };

            const labelToAgent = {};
            for (const [agent, cfg] of Object.entries(CONFIG)) {
              for (const label of cfg.labels) {
                labelToAgent[label.toLowerCase()] = agent;
              }
            }

            const { owner, repo } = context.repo;
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'open',
              per_page: 100,
              labels: undefined
            });

            const staleActions = [];
            const nowMs = Date.now();

            for (const issue of issues) {
              if (!issue || issue.pull_request) {
                continue;
              }
              const labels = (issue.labels || []).map(l => (typeof l === 'string' ? l : l.name || '').toLowerCase());
              let agent = '';
              for (const lbl of labels) {
                if (labelToAgent[lbl]) {
                  agent = labelToAgent[lbl];
                  break;
                }
              }
              if (!agent) {
                continue;
              }

              const cfg = CONFIG[agent];
              const staleMinutes = cfg?.stale_minutes || 240;
              const updatedAt = new Date(issue.updated_at || issue.created_at || '').getTime();
              if (!updatedAt) {
                continue;
              }
              const ageMs = nowMs - updatedAt;
              if (ageMs < staleMinutes * 60000) {
                continue;
              }

              staleActions.push({ issue, agent, cfg, ageMinutes: Math.round(ageMs / 60000) });
            }

            if (!staleActions.length) {
              core.info('No stale agent issues detected.');
              await core.summary.addHeading('Agent Watchdog Sweep').addRaw('âœ… No stale issues detected.').write();
              return;
            }

            const readinessOk = (agent) => {
              const key = agent.toLowerCase();
              const report = readiness[key];
              return report ? Boolean(report.ok) : false;
            };

            for (const entry of staleActions) {
              const issueNumber = entry.issue.number;
              const agent = entry.agent;
              const cfg = entry.cfg;
              const pingPrefix = cfg.ping_prefix;
              const escalatePrefix = cfg.escalate_prefix;
              const mention = cfg.mention || '';
              const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number: issueNumber, per_page: 100, page: 1 });
              const hasPing = (comments || []).some(c => (c.body || '').startsWith(pingPrefix));
              const hasEscalation = (comments || []).some(c => (c.body || '').startsWith(escalatePrefix));

              if (readinessOk(agent)) {
                if (hasPing) {
                  core.info(`#${issueNumber} already pinged.`);
                  continue;
                }
                const body = `${pingPrefix}: ${mention} issue has been inactive for ${entry.ageMinutes} minutes.`;
                await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body });
                core.info(`Pinged ${mention || agent} on issue #${issueNumber}.`);
              } else {
                if (hasEscalation) {
                  core.info(`#${issueNumber} already escalated.`);
                  continue;
                }
                const body = `${escalatePrefix}: ${mention || agent} is currently unavailable. Removing assignment so maintainers can re-triage.`;
                await github.rest.issues.createComment({ owner, repo, issue_number: issueNumber, body });
                const assignees = (cfg.assignees || []).filter(Boolean);
                if (assignees.length) {
                  await github.rest.issues.removeAssignees({ owner, repo, issue_number: issueNumber, assignees });
                }
                for (const label of cfg.labels) {
                  const present = (entry.issue.labels || []).some(l => (typeof l === 'string' ? l : l.name || '').toLowerCase() === label.toLowerCase());
                  if (present) {
                    try {
                      await github.rest.issues.removeLabel({ owner, repo, issue_number: issueNumber, name: label });
                    } catch (error) {
                      core.warning(`Unable to remove label ${label} from #${issueNumber}: ${error.message}`);
                    }
                  }
                }
                core.info(`Escalated issue #${issueNumber} due to unavailable agent ${agent}.`);
              }
            }

            const summary = core.summary.addHeading('Agent Watchdog Sweep');
            summary.addTable([
              [{ data: 'Issue', header: true }, { data: 'Agent', header: true }, { data: 'Action', header: true }],
              ...staleActions.map(entry => {
                const ready = readinessOk(entry.agent);
                return [`#${entry.issue.number}`, entry.agent, ready ? 'Pinged owner' : 'Escalated'];
              })
            ]);
            await summary.write();

