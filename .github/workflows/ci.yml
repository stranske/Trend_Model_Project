name: Assign to Copilot (Issues + PRs)

on:
  issues:
    types: [opened, labeled, reopened]
  pull_request_target:
    types: [opened, labeled, reopened]
  workflow_dispatch:
    inputs:
      scope:
        description: "Backfill scope: issues | prs | both"
        required: false
        default: "both"

permissions:
  issues: write
  pull-requests: write

concurrency:
  group: assign-${{ github.event_name }}-${{ github.event.issue.number || github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  assign_or_backfill:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const LABEL = 'agent:copilot';

            async function assignToCopilot(issue_number) {
              // Always refetch to get current labels/assignees
              const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number });
              const labels = (issue.labels || []).map(l => (l.name || '').toLowerCase());
              if (!labels.includes(LABEL)) {
                core.info(`#${issue_number}: missing ${LABEL}, skipping`);
                return;
              }
              const assignees = (issue.assignees || []).map(a => (a.login || '').toLowerCase());
              if (!assignees.includes('copilot')) {
                await github.rest.issues.addAssignees({ owner, repo, issue_number, assignees: ['copilot'] });
                await github.rest.issues.createComment({
                  owner, repo, issue_number,
                  body: 'Assigning to @copilot. Please pick up this task.'
                });
                core.info(`#${issue_number}: assigned to copilot`);
              } else {
                core.info(`#${issue_number}: copilot already assigned`);
              }
            }

            // Manual backfill via Actions button
            if (context.eventName === 'workflow_dispatch') {
              const scope = (context.payload.inputs?.scope || 'both').toLowerCase();
              const queries = [];
              if (scope === 'issues' || scope === 'both')
                queries.push(`repo:${owner}/${repo} is:issue is:open label:"${LABEL}" -assignee:copilot`);
              if (scope === 'prs' || scope === 'both')
                queries.push(`repo:${owner}/${repo} is:pr is:open label:"${LABEL}" -assignee:copilot`);

              for (const q of queries) {
                core.info(`Backfill query: ${q}`);
                const { data } = await github.rest.search.issuesAndPullRequests({ q, per_page: 100 });
                for (const it of data.items) {
                  await assignToCopilot(it.number);
                }
              }
              return;
            }

            // Issue events
            if (context.eventName === 'issues') {
              const issue = context.payload.issue;
              const eventLabel = ((context.payload.label && context.payload.label.name) || '').toLowerCase();
              const hasLabel =
                (issue.labels || []).map(l => (l.name || '').toLowerCase()).includes(LABEL) ||
                eventLabel === LABEL;

              if (!hasLabel) {
                core.info('Issue event without agent label; skipping');
                return;
              }
              await assignToCopilot(issue.number);
              return;
            }

            // PR events (use the Issues API with PR number)
            if (context.eventName === 'pull_request_target') {
              const pr = context.payload.pull_request;
              const eventLabel = ((context.payload.label && context.payload.label.name) || '').toLowerCase();
              const hasLabel =
                (pr.labels || []).map(l => (l.name || '').toLowerCase()).includes(LABEL) ||
                eventLabel === LABEL;

              if (!hasLabel) {
                core.info('PR event without agent label; skipping');
                return;
              }
              await assignToCopilot(pr.number);
              return;
            }
