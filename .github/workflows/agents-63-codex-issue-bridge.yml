# See docs/ci/AGENTS_POLICY.md for guardrails and override process.
name: Agents 63 Codex Issue Bridge

on:
  issues:
    types: [opened, labeled, reopened]
  workflow_dispatch:
    inputs:
      test_issue:
        description: "Manually test with a specific issue number (optional)"
        required: false
        default: ""
      post_codex_comment:
        description: "Auto-post '@codex start' as the actor (true/false)"
        required: false
        default: "true"
      pr_mode:
        description: "create | invite (invite = human opens the PR)"
        required: false
        default: "create"
      codex_pr_draft:
        description: "Force created PR to be draft (true/false)"
        required: false
        default: "false"

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: codex-issue-${{ github.event.issue.number || inputs.test_issue || github.run_id }}
  cancel-in-progress: true

jobs:
  bridge:
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event.action == 'labeled' &&
        (contains(github.event.label.name, 'agent:codex') || contains(github.event.label.name, 'agents:codex'))) ||
      (github.event.action != 'labeled' &&
        (
          contains(join(github.event.issue.labels.*.name, ' '), 'agent:codex') ||
          contains(join(github.event.issue.labels.*.name, ' '), 'agents:codex')
        ))
    runs-on: ubuntu-latest
    env:
      SERVICE_BOT_PAT: ${{ secrets.SERVICE_BOT_PAT }}

    steps:
      - name: Event summary
        uses: actions/github-script@v7
        with:
          script: |
            const act = context.payload.action;
            const label = (context.payload.label && context.payload.label.name) || '(none)';
            const issueNo = context.payload.issue && context.payload.issue.number;
            const manualIssue = context.payload.inputs && context.payload.inputs.test_issue;
            core.summary.addHeading('Codex Bridge Event Summary').addTable([
              [
                {data:'Action',header:true},
                {data:'Label',header:true},
                {data:'Issue (event)',header:true},
                {data:'Issue (input)',header:true}
              ],
              [String(act), label, String(issueNo), String(manualIssue || '')]
            ]).write();

      - name: Resolve issue number
        id: ctx
        uses: actions/github-script@v7
        with:
          script: |
            const ev = context.eventName;
            const issueFromEvent = context.payload.issue && context.payload.issue.number;
            const issueFromInput = context.payload.inputs && context.payload.inputs.test_issue;
            const num = Number(issueFromEvent || issueFromInput || 0);
            core.setOutput('issue', num > 0 ? String(num) : '');
            core.setOutput('has_issue', num > 0 ? 'true' : 'false');

      - name: Resolve keepalive opt-in
        id: keepalive
        if: ${{ steps.ctx.outputs.has_issue == 'true' }}
        uses: actions/github-script@v7
        env:
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue }}
        with:
          script: |
            const issueNumber = Number(process.env.ISSUE_NUMBER || 0);
            const { owner, repo } = context.repo;
            const sentinelToken = '[keepalive]';
            const sentinelLower = sentinelToken.toLowerCase();

            const normaliseLabel = (value) => String(value || '').trim().toLowerCase();

            const labels = Array.isArray(context.payload.issue?.labels)
              ? context.payload.issue.labels.map((label) => normaliseLabel(typeof label === 'string' ? label : label?.name))
              : [];

            let labelOptIn = labels.includes('agents:keepalive');
            const eventLabel = normaliseLabel(context.payload.label?.name);
            if (!labelOptIn && eventLabel === 'agents:keepalive') {
              labelOptIn = true;
            }

            let sentinelOptIn = false;
            if (issueNumber > 0) {
              try {
                const iterator = github.paginate.iterator(
                  github.rest.issues.listComments,
                  { owner, repo, issue_number: issueNumber, per_page: 100 }
                );
                for await (const page of iterator) {
                  for (const comment of page.data) {
                    if (typeof comment?.body === 'string' && comment.body.toLowerCase().includes(sentinelLower)) {
                      sentinelOptIn = true;
                      break;
                    }
                  }
                  if (sentinelOptIn) {
                    break;
                  }
                }
              } catch (error) {
                core.warning(`Failed to scan comments for keepalive sentinel on issue #${issueNumber}: ${error.message}`);
              }
            }

            const enabled = labelOptIn || sentinelOptIn;
            let source = 'none';
            if (labelOptIn && sentinelOptIn) {
              source = 'label+sentinel';
            } else if (labelOptIn) {
              source = 'label';
            } else if (sentinelOptIn) {
              source = 'sentinel';
            }

            const mode = enabled ? 'ON' : 'OFF';
            const options = { keepalive: { enabled } };

            core.info(`Keepalive opt-in for issue #${issueNumber || 'n/a'}: ${enabled ? 'enabled' : 'disabled'} (${source}).`);
            core.setOutput('enabled', enabled ? 'true' : 'false');
            core.setOutput('mode', mode);
            core.setOutput('source', source);
            core.setOutput('options_json', JSON.stringify(options));

            const summary = core.summary;
            summary.addHeading('Codex keepalive opt-in');
            summary.addRaw(`Mode: **${mode}**`).addEOL();
            summary.addRaw(`Source: ${source}`).addEOL();
            await summary.write();
            summary.clear();

      - name: Fail fast on missing issue (manual run)
        if: ${{ github.event_name == 'workflow_dispatch' && steps.ctx.outputs.has_issue != 'true' }}
        run: |
          echo "::error::Missing input test_issue for workflow_dispatch. Provide an issue number when manually running this workflow." && exit 1

      - name: Get default branch
        id: def
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const {data} = await github.rest.repos.get({owner, repo});
            core.setOutput('default', data.default_branch || 'main');

      - name: Checkout default
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.def.outputs.default }}
          fetch-depth: 0
          persist-credentials: true

      - name: Select PR mode
        id: mode
        uses: actions/github-script@v7
        with:
          script: |
            const ev = context.eventName;
            let mode = 'create';
            let reason = 'issue-event-default-create';
            if (ev === 'workflow_dispatch') {
              const im = (context.payload.inputs && context.payload.inputs.pr_mode) || 'create';
              const m = String(im).toLowerCase();
              mode = (m === 'invite' || m === 'create') ? m : 'create';
              reason = 'workflow-dispatch';
            } else {
              const labels = (context.payload.issue && Array.isArray(context.payload.issue.labels)) ? context.payload.issue.labels : [];
              const hasInvite = labels.some((lbl) => String(lbl.name || '').toLowerCase() === 'agent:codex-invite');
              if (hasInvite) {
                mode = 'invite';
                reason = 'issue-label-override';
              }
            }
            core.setOutput('mode', mode);
            core.setOutput('reason', reason);

      - name: Resolve draft flag
        id: draft
        uses: actions/github-script@v7
        with:
          script: |
            const raw = (context.payload.inputs && context.payload.inputs.codex_pr_draft) || 'false';
            const val = String(raw).toLowerCase() === 'true';
            core.setOutput('draft', val ? 'true' : 'false');

      - name: Resolve post-codex comment flag
        id: codex
        uses: actions/github-script@v7
        with:
          script: |
            const ev = context.eventName;
            let raw = 'false';
            if (ev === 'workflow_dispatch') {
              raw = (context.payload.inputs && context.payload.inputs.post_codex_comment) || 'false';
            }
            const val = String(raw).toLowerCase() === 'true';
            core.setOutput('post', val ? 'true' : 'false');

      - name: Log chosen mode & draft
        run: |
          echo "Chosen PR mode: ${{ steps.mode.outputs.mode }} (reason: ${{ steps.mode.outputs.reason }})"
          echo "Resolved draft flag: ${{ steps.draft.outputs.draft }}"
          echo "Post Codex comment: ${{ steps.codex.outputs.post }}"

      - name: Document concurrency policy decision
        run: |
          cat <<'EOF' >> "$GITHUB_STEP_SUMMARY"
          ## Concurrency policy audit (last 7 days)

          - Queried the GitHub REST API with:
            - `curl "https://api.github.com/repos/stranske/Trend_Model_Project/actions/workflows/agents-63-codex-issue-bridge.yml/runs?per_page=100&page=1"`
            - `curl "https://api.github.com/repos/stranske/Trend_Model_Project/actions/workflows/agents-63-codex-issue-bridge.yml/runs?per_page=100&page=2"`
            - Grouped results by `display_title` (issue title) to approximate the concurrency key `codex-issue-<issue_number>`.
          - Findings (runs created in the last 7 days):
            - 10 runs queued for **“Authoritative Gate: self‑skip doc‑only and delete PR‑14”** within ~60 seconds ([run 18502200466](https://github.com/stranske/Trend_Model_Project/actions/runs/18502200466), [run 18502200416](https://github.com/stranske/Trend_Model_Project/actions/runs/18502200416), [run 18502200406](https://github.com/stranske/Trend_Model_Project/actions/runs/18502200406)).
            - 9 runs for **“Enforce Gate as required on the default branch; verify with Health‑44”** across ~4 hours ([run 18500806970](https://github.com/stranske/Trend_Model_Project/actions/runs/18500806970), [run 18500806943](https://github.com/stranske/Trend_Model_Project/actions/runs/18500806943), [run 18500806916](https://github.com/stranske/Trend_Model_Project/actions/runs/18500806916)).
            - 8 runs for **“Types: align mypy execution with pinned Python version”** within ~4.5 hours ([run 18500949641](https://github.com/stranske/Trend_Model_Project/actions/runs/18500949641), [run 18500949514](https://github.com/stranske/Trend_Model_Project/actions/runs/18500949514), [run 18500949509](https://github.com/stranske/Trend_Model_Project/actions/runs/18500949509)).
          - Conclusion: repeated label churn causes deep per-issue queues; enabling `cancel-in-progress` prevents redundant runs and surfaces only the most recent label state. Maintainers can rerun diagnostics by reapplying the label or using the manual dispatch input for a specific issue.
          EOF

      - name: Try local composite Codex bootstrap (lite)
        id: local_action
        continue-on-error: true
        if: ${{ steps.ctx.outputs.has_issue == 'true' }}
        uses: ./.github/actions/codex-bootstrap-lite
        with:
          issue: ${{ steps.ctx.outputs.issue }}
          service_bot_pat: ${{ (steps.mode.outputs.mode == 'create' && secrets.OWNER_PR_PAT) || secrets.SERVICE_BOT_PAT }}
          allow_fallback: true
          codex_command: '@codex start'
          base_branch: ''
          draft: ${{ steps.draft.outputs.draft }}
          auto_ready: 'true'
          post_codex_comment: ${{ steps.codex.outputs.post }}
          pr_mode: ${{ steps.mode.outputs.mode }}
          keepalive_mode: ${{ steps.keepalive.outputs.mode || 'OFF' }}

      - name: Debug composite outputs
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'success' }}
        run: |
          echo "Composite outputs: pr=${{ steps.local_action.outputs.pr }} branch=${{ steps.local_action.outputs.branch }}"

      - name: Post copyable PR template (composite)
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'success' && steps.mode.outputs.mode != 'invite' && steps.local_action.outputs.pr != '' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issue_number = (context.payload.issue && context.payload.issue.number) || Number(context.payload.inputs && context.payload.inputs.test_issue);
            if (!issue_number) {
              core.warning('No issue context available to annotate.');
              return;
            }
            const prNumber = Number('${{ steps.local_action.outputs.pr }}');
            if (!prNumber) {
              core.warning('Composite returned empty PR number; skipping snippet comment.');
              return;
            }
            let issueTitle = '';
            let issueBody = '';
            try {
              const { data: is } = await github.rest.issues.get({ owner, repo, issue_number });
              issueTitle = is.title || '';
              issueBody = is.body || '';
            } catch (e) {
              core.warning(`Failed to fetch issue #${issue_number}: ${e.message}`);
            }
            const issueUrl = `https://github.com/${owner}/${repo}/issues/${issue_number}`;
            const header = `### Source Issue #${issue_number}: ${issueTitle}`.trim();
            const quoted = (issueBody || '')
              .split('\n')
              .map((line) => `> ${line}`)
              .join('\n');
            const snippet = [header, '', `Source: ${issueUrl}`, '', quoted].join('\n');
            const message = [
              `Opened PR #${prNumber} to engage Codex.`,
              '',
              'Next steps for the PR author:',
              '1. Comment `@codex start` (posted automatically when possible) so Codex drafts the plan.',
              '2. After Codex replies with the checklist, post the execution command below to kick off delivery and enable keepalive nudge checks.',
              '',
              '```markdown',
              '@codex plan-and-execute',
              '',
              'Codex, reuse the scope, acceptance criteria, and task list from the source issue.',
              'Post those sections on this PR using markdown checklists (- [ ]) so the keepalive workflow continues nudging until everything is complete.',
              'Work through the tasks, checking them off only after each acceptance criterion is satisfied.',
              '```',
              '',
              'Issue context (optional: copy into the PR body if needed):',
              '',
              '```markdown',
              snippet,
              '```'
            ].join('\n');
            await github.rest.issues.createComment({ owner, repo, issue_number, body: message });

      - name: Create branch and bootstrap file
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'failure' }}
        id: mk
        env:
          ISSUE: ${{ steps.ctx.outputs.issue }}
        run: |
          set -euo pipefail
          PREFIX="agents/codex-issue-${ISSUE}-"
          # List all remote heads, filter for branches matching the prefix, and extract the branch name.
          # This finds the first branch matching agents/codex-issue-${ISSUE}-*
          EXISTING=$(git ls-remote --heads origin \
            | grep "refs/heads/${PREFIX}" \
            | head -n1 \
            | awk '{print $2}' \
            | sed 's|refs/heads/||')
          if [ -n "${EXISTING}" ]; then
            echo "Reusing existing Codex branch ${EXISTING} for issue #${ISSUE}."
            echo "branch=${EXISTING}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          BR=${PREFIX}${GITHUB_RUN_ID}
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BR"
          mkdir -p agents
          printf "<!-- bootstrap for codex on issue #%s -->\n" "$ISSUE" > "agents/codex-${ISSUE}.md"
          git add -A || true
          if ! git diff --cached --quiet; then
            git commit -m "chore(codex): bootstrap PR for issue #${ISSUE}"
          else
            echo "No changes to commit; proceeding to push branch with existing tree."
          fi
          git push origin "$BR"
          echo "branch=$BR" >> "$GITHUB_OUTPUT"

      - name: Invite human to open PR (fallback)
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'failure' && steps.mode.outputs.mode == 'invite' }}
        uses: actions/github-script@v7
        env:
          BRANCH: ${{ steps.mk.outputs.branch }}
          KEEPALIVE_MODE: ${{ steps.keepalive.outputs.mode || 'OFF' }}
        with:
          script: |
            const {owner, repo} = context.repo;
            const issue_number = Number('${{ steps.ctx.outputs.issue }}');
            const base = "${{ steps.def.outputs.default }}";
            const branch = process.env.BRANCH;
            let issueTitle = '';
            let issueBody = '';
            try { 
              const { data: is } = await github.rest.issues.get({ owner, repo, issue_number }); 
              issueTitle = is.title || ''; 
              issueBody = is.body || ''; 
            } catch (err) { 
              core.error('Failed to fetch issue: ' + err); 
            }
            const issueUrl = `https://github.com/${owner}/${repo}/issues/${issue_number}`;
            const keepaliveMode = (process.env.KEEPALIVE_MODE || 'OFF').trim().toUpperCase() === 'ON' ? 'ON' : 'OFF';
            const keepaliveHeader = `### Keepalive: ${keepaliveMode}`;
            const header = `### Source Issue #${issue_number}: ${issueTitle}`;
            const quoted = (issueBody || '').split('\n').map(l => `> ${l}`).join('\n');
            const bodySections = [
              keepaliveHeader,
              '',
              header,
              '',
              `Source: ${issueUrl}`,
              '',
              quoted,
              '',
              '@codex start',
              '',
              'Codex, please derive and propose:',
              '- Scope / key constraints',
              '- Acceptance criteria / definition of done',
              '- Initial task checklist to iterate through',
              '',
              'Use the issue details above to draft the plan, then proceed with implementation.',
              '',
              '---',
              '',
              'Once the plan is posted, comment the snippet below to start execution and enable keepalive:',
              '',
              'The following block should be pasted as a separate PR comment:',
              '',
              '```markdown',
              '@codex plan-and-execute',
              '',
              'Codex, reuse the scope, acceptance criteria, and task list from the source issue.',
              'Post those sections on this PR using markdown checklists (- [ ]) so the keepalive workflow continues nudging until everything is complete.',
              'Work through the tasks, checking them off only after each acceptance criterion is satisfied.',
              '```'
            ];
            const suggestion = bodySections.join('\n');
            const compareUrl = `https://github.com/${owner}/${repo}/compare/${base}...${branch}?expand=1`;
            if (!issue_number) { core.setFailed('Resolved issue number missing; cannot post invite.'); return; }
            await github.rest.issues.createComment({ owner, repo, issue_number, body: `Branch \`${branch}\` created from \`${base}\`.\n\nOption 1 (Invite) is enforced on issue events. PR creation is disabled by design so you are the PR author. Codex only engages on human-authored PRs.\n\nPlease open the PR as the author so Codex can work on it:\n\n- Compare link: ${compareUrl}\n- Suggested title: \`Codex bootstrap for #${issue_number}\`\n- Suggested body (copy/paste):\n\n\n${'```markdown'}\n${suggestion}\n${'```'}` });

      - name: Skip PR creation when inviting
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'failure' && steps.mode.outputs.mode == 'invite' }}
        run: |
          echo "Invite mode: skipping PR creation; waiting for human author."

      - name: Open or reuse PR
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'failure' && steps.mode.outputs.mode != 'invite' }}
        id: pr
        uses: actions/github-script@v7
        env:
          BRANCH: ${{ steps.mk.outputs.branch }}
          KEEPALIVE_MODE: ${{ steps.keepalive.outputs.mode || 'OFF' }}
        with:
          github-token: ${{ secrets.OWNER_PR_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const {owner, repo} = context.repo;
            const issue_number = Number('${{ steps.ctx.outputs.issue }}');
            const base = "${{ steps.def.outputs.default }}";
            const head = process.env.BRANCH;
            const draftFlag = "${{ steps.draft.outputs.draft }}" === 'true';
            if (!issue_number) { core.setFailed('Resolved issue number missing; cannot open PR.'); return; }
            const existing = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${head}` });
            let pr = existing.data[0];
            if (!pr) {
              let issueTitle = '';
              let issueBody = '';
              try { const { data: is } = await github.rest.issues.get({ owner, repo, issue_number }); issueTitle = is.title || ''; issueBody = is.body || ''; } catch (e) { core.warning(`Failed to fetch issue #${issue_number}: ${e.message}`); }
              const issueUrl = `https://github.com/${owner}/${repo}/issues/${issue_number}`;
              const keepaliveMode = (process.env.KEEPALIVE_MODE || 'OFF').trim().toUpperCase() === 'ON' ? 'ON' : 'OFF';
              const keepaliveHeader = `### Keepalive: ${keepaliveMode}`;
              const header = `### Source Issue #${issue_number}: ${issueTitle}`;
              const quoted = (issueBody || '').split('\n').map(l => `> ${l}`).join('\n');
              const prBody = [
                keepaliveHeader,
                '',
                header,
                '',
                `Source: ${issueUrl}`,
                '',
                quoted,
                '',
                '—',
                'PR created automatically to engage Codex.'
              ].join('\n');
              ({ data: pr } = await github.rest.pulls.create({ owner, repo, head, base, draft: draftFlag, title: `Codex bootstrap for #${issue_number}`, body: prBody }));
            }
            core.setOutput('number', String(pr.number));
            const assignees = ['chatgpt-codex-connector', 'stranske-automation-bot'];
            try { await github.rest.issues.addAssignees({ owner, repo, issue_number: pr.number, assignees }); } catch (e) { core.warning(`PR assign failed: ${e.message}`); }
            try { await github.rest.issues.addAssignees({ owner, repo, issue_number, assignees }); } catch (e) { core.warning(`Issue assign failed: ${e.message}`); }

      - name: Label PR (agent:codex)
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'failure' && steps.mode.outputs.mode != 'invite' }}
        uses: actions/github-script@v7
        env:
          PR: ${{ steps.pr.outputs.number }}
        with:
          script: |
            const {owner, repo} = context.repo;
            const prNumber = Number(process.env.PR);
            await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: ['agent:codex'] });

      - name: Post Codex command as service user
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'failure' && steps.mode.outputs.mode != 'invite' && env.SERVICE_BOT_PAT != '' && (steps.codex.outputs.post == 'true') }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.SERVICE_BOT_PAT }}
          script: |
            const {owner, repo} = context.repo;
            const prNumber = Number("${{ steps.pr.outputs.number }}");
            const cmd = '@codex start';
            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `${cmd}\n\nPlease create commits on this branch, run tests, and keep the PR updated.` });

      - name: Post Codex command (fallback as github-actions)
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'failure' && steps.mode.outputs.mode != 'invite' && env.SERVICE_BOT_PAT == '' && (steps.codex.outputs.post == 'true') }}
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const prNumber = Number("${{ steps.pr.outputs.number }}");
            const cmd = '@codex start';
            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `${cmd}\n\nPlease create commits on this branch, run tests, and keep the PR updated.` });

      - name: Prompt human to post Codex command
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'failure' && steps.mode.outputs.mode != 'invite' && (steps.codex.outputs.post != 'true') }}
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const prNumber = Number("${{ steps.pr.outputs.number }}");
            const codexPromptMsg = [
              "PR created. Comment `@codex start` to request the plan.",
              "Tell Codex to reuse the scope, acceptance criteria, and task list from the source issue and publish them here with `- [ ]` checklists so keepalive keeps watching.",
              "After Codex replies, follow the instructions posted on the source issue to begin execution."
            ].join(' ');
            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: codexPromptMsg });

      - name: Link PR on original issue
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.local_action.outcome == 'failure' && steps.mode.outputs.mode != 'invite' }}
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const issue_number = (context.payload.issue && context.payload.issue.number) || Number(context.payload.inputs && context.payload.inputs.test_issue);
            if (!issue_number) {
              core.warning('No issue context available to link PR back (workflow_dispatch without test_issue).');
            } else {
              let issueTitle = '';
              let issueBody = '';
              try {
                const { data: is } = await github.rest.issues.get({ owner, repo, issue_number });
                issueTitle = is.title || '';
                issueBody = is.body || '';
              } catch (e) {
                core.warning(`Failed to fetch issue #${issue_number}: ${e.message}`);
              }
              const prNumber = Number('${{ steps.pr.outputs.number }}');
              const issueUrl = `https://github.com/${owner}/${repo}/issues/${issue_number}`;
              const header = `### Source Issue #${issue_number}: ${issueTitle}`.trim();
              const quoted = (issueBody || '')
                .split('\n')
                .map((line) => `> ${line}`)
                .join('\n');
              const snippet = [header, '', `Source: ${issueUrl}`, '', quoted].join('\n');
              const message = [
                `Opened PR #${prNumber} to engage Codex.`,
                '',
                'Next steps for the PR author:',
                '- Comment `@codex start` (auto-posted when possible) so Codex drafts the plan.',
                '- After Codex replies with the checklist, post the execution command below to begin delivery and enable keepalive.',
                '',
                'Execution command (copy into a standalone PR comment):',
                '```markdown',
                '@codex plan-and-execute',
                '',
                'Codex, reuse the scope, acceptance criteria, and task list from the source issue.',
                'Post those sections on this PR using markdown checklists (- [ ]) so the keepalive workflow continues nudging until everything is complete.',
                'Work through the tasks, checking them off only after each acceptance criterion is satisfied.',
                '```',
                '',
                'Issue context (optional: copy into the PR description):',
                '',
                '```markdown',
                snippet,
                '```'
              ].join('\n');
              await github.rest.issues.createComment({ owner, repo, issue_number, body: message });
            }

      - name: Dispatch Agents Orchestrator (keepalive sync)
        if: ${{ steps.ctx.outputs.has_issue == 'true' && ((steps.local_action.outcome == 'success' && steps.local_action.outputs.pr != '') || (steps.local_action.outcome == 'failure' && steps.mode.outputs.mode != 'invite' && steps.pr.outputs.number != '')) }}
        uses: actions/github-script@v7
        env:
          DEFAULT_BRANCH: ${{ steps.def.outputs.default }}
          KEEPALIVE_ENABLED: ${{ steps.keepalive.outputs.enabled || 'false' }}
          KEEPALIVE_OPTIONS: ${{ steps.keepalive.outputs.options_json || '{}' }}
          KEEPALIVE_MODE: ${{ steps.keepalive.outputs.mode || 'OFF' }}
          KEEPALIVE_SOURCE: ${{ steps.keepalive.outputs.source || 'none' }}
          ISSUE_NUMBER: ${{ steps.ctx.outputs.issue }}
          PR_NUMBER: ${{ steps.local_action.outcome == 'success' && steps.local_action.outputs.pr || steps.pr.outputs.number || '' }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const { owner, repo } = context.repo;
            const defaultBranch = (process.env.DEFAULT_BRANCH || '').trim();
            const ref = defaultBranch
              ? (defaultBranch.startsWith('refs/') ? defaultBranch : `refs/heads/${defaultBranch}`)
              : context.ref;
            const keepaliveEnabled = (process.env.KEEPALIVE_ENABLED || '').trim().toLowerCase() === 'true';
            const keepaliveSource = (process.env.KEEPALIVE_SOURCE || 'none').trim() || 'none';
            const keepaliveMode = (process.env.KEEPALIVE_MODE || 'OFF').trim() || 'OFF';
            const issueNumber = (process.env.ISSUE_NUMBER || '').trim();
            const prNumber = (process.env.PR_NUMBER || '').trim();

            let options = {};
            try {
              options = JSON.parse(process.env.KEEPALIVE_OPTIONS || '{}') || {};
            } catch (error) {
              core.warning(`Failed to parse keepalive options_json; using defaults. ${error.message}`);
            }
            if (!options.keepalive || typeof options.keepalive !== 'object') {
              options.keepalive = {};
            }
            options.keepalive.enabled = keepaliveEnabled;
            const optionsJson = JSON.stringify(options);

            const params = {
              keepalive: { enabled: keepaliveEnabled },
              options_json: optionsJson,
              enable_keepalive: keepaliveEnabled ? 'true' : 'false'
            };
            if (issueNumber) {
              params.keepalive.issue = issueNumber;
            }
            if (prNumber) {
              params.keepalive.pr = prNumber;
            }

            try {
              await github.rest.actions.createWorkflowDispatch({
                owner,
                repo,
                workflow_id: 'agents-70-orchestrator.yml',
                ref,
                inputs: {
                  params_json: JSON.stringify(params)
                }
              });
              core.info(`Dispatched Agents 70 Orchestrator with keepalive ${keepaliveEnabled ? 'enabled' : 'disabled'} (${keepaliveSource}).`);
            } catch (error) {
              core.warning(`Failed to dispatch Agents 70 Orchestrator: ${error.message}`);
            }

            const summary = core.summary;
            summary.addHeading('Orchestrator keepalive dispatch');
            summary.addRaw(`Keepalive mode: **${keepaliveMode}**`).addEOL();
            summary.addRaw(`Source: ${keepaliveSource}`).addEOL();
            if (issueNumber) {
              summary.addRaw(`Issue: #${issueNumber}`).addEOL();
            }
            if (prNumber) {
              summary.addRaw(`PR: #${prNumber}`).addEOL();
            }
            await summary.write();
            summary.clear();
