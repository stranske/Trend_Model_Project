name: PR 10 CI Python

# Unified Python CI workflow that enforces formatting, linting, typing, tests,
# and coverage within a single job to simplify gating for pull requests.

on:
  workflow_call:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - '.github/ISSUE_TEMPLATE/**'
  push:
    branches: [ phase-2-dev ]
    paths-ignore:
      - 'docs/**'
      - '**/*.md'
      - '.github/ISSUE_TEMPLATE/**'

concurrency:
  group: ci-${{ github.ref }}-${{ github.event.pull_request.number || github.sha }}
  cancel-in-progress: true

jobs:
  ci-python:
    name: main / python (style, types, tests, coverage)
    runs-on: ubuntu-latest
    env:
      PYTHON_VERSION: ${{ fromJson(vars.CI_PY_VERSIONS || '["3.11"]')[0] }}
      COVERAGE_MIN: ${{ vars.COV_MIN || '70' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Fetch only the minimal history needed to compute PR diffs.
          # Depth=2 grabs the merge commit plus its immediate parents, cutting
          # checkout time from ~8 minutes to a few seconds on CI runners.
          fetch-depth: 2

      - name: Load pinned tool versions
        run: |
          if [ -f .github/workflows/autofix-versions.env ]; then
            while IFS= read -r line; do
              if [ -n "$line" ]; then
                echo "$line" >> "$GITHUB_ENV"
              fi
            done < .github/workflows/autofix-versions.env
          fi

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Prepare virtualenv and install dependencies
        run: |
          python -m venv .venv
          echo "${{ github.workspace }}/.venv/bin" >> "$GITHUB_PATH"
          echo "VIRTUAL_ENV=${{ github.workspace }}/.venv" >> "$GITHUB_ENV"
          source .venv/bin/activate
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -e '.[dev]'
          pip install pytest pytest-cov jq
          pip install "black==${BLACK_VERSION}" "ruff==${RUFF_VERSION}" "mypy==${MYPY_VERSION}"
          pip install pydantic streamlit

      - name: Black (check)
        run: |
          if git ls-files '*.py' >/dev/null 2>&1; then
            black --check .
          else
            echo "No Python files detected for Black check."
          fi

      - name: Ruff (check with allowlist)
        id: ruff
        run: |
          set -e
          if ! ruff check --output-format json . > ruff_diagnostics.json 2> ruff_stderr.log; then
            echo "Ruff reported issues (expected if violations exist)"
          fi
          if [ -f scripts/classify_ruff.py ]; then
            python scripts/classify_ruff.py ruff_diagnostics.json .ruff-residual-allowlist.json ruff_classification.json || echo '{"error":"classification_failed"}' > ruff_classification.json
          else
            echo '{"total":0,"allowed":0,"new":0,"by_code":{},"new_by_code":{}}' > ruff_classification.json
          fi
          new=$(jq -r '.new // 0' ruff_classification.json 2>/dev/null || echo 0)
          echo "new=$new" >> "$GITHUB_OUTPUT"
          total=$(jq -r '.total // 0' ruff_classification.json 2>/dev/null || echo 0)
          echo "total=$total" >> "$GITHUB_OUTPUT"
          if [ "$new" != "0" ]; then
            echo "Found $new new ruff issues (failing CI job)." >&2
            exit 1
          fi

      - name: Mypy (type check core + app)
        run: |
          echo "Running pinned mypy==${MYPY_VERSION}" >&2
          status=0
          resolved_mypy_version=$(mypy --version | awk '{print $2}')
          if [ -z "$resolved_mypy_version" ]; then
            resolved_mypy_version="${MYPY_VERSION}"
          fi
          if [ "$(printf '%s\n' "1.11.0" "$resolved_mypy_version" | sort -V | head -n1)" = "1.11.0" ]; then
            mypy --config-file pyproject.toml --show-column-numbers --error-format json \
              src/trend_analysis src/trend_portfolio_app > mypy_diagnostics.json 2> mypy_stderr.log || status=$?
            if [ "$status" -ne 0 ] && grep -q "unrecognized arguments: --error-format" mypy_stderr.log 2>/dev/null; then
              echo "Detected mypy $resolved_mypy_version without JSON diagnostics support; falling back to text output" >&2
              status=0
              mypy --config-file pyproject.toml --show-column-numbers --show-error-codes --no-color-output \
                src/trend_analysis src/trend_portfolio_app > mypy_plain.log 2>&1 || status=$?
              if [ "$status" -eq 0 ]; then
                echo "Success: no mypy issues detected." > mypy_report.txt
              else
                cat mypy_plain.log > mypy_report.txt
              fi
            else
              python scripts/render_mypy_summary.py mypy_diagnostics.json mypy_report.txt
            fi
          else
            echo "Detected mypy $resolved_mypy_version without JSON diagnostics support; using text fallback" >&2
            mypy --config-file pyproject.toml --show-column-numbers --show-error-codes --no-color-output \
              src/trend_analysis src/trend_portfolio_app > mypy_plain.log 2>&1 || status=$?
            if [ "$status" -eq 0 ]; then
              echo "Success: no mypy issues detected." > mypy_report.txt
            else
              cat mypy_plain.log > mypy_report.txt
            fi
          fi
          if [ "$status" -ne 0 ]; then
            echo "mypy failed" >&2
            cat mypy_report.txt
            exit "$status"
          fi
          echo "mypy: PASS" >> "$GITHUB_STEP_SUMMARY"

      - name: Run unit tests with coverage
        env:
          PYTHONPATH: ./src
        run: |
          pytest --junitxml=pytest-junit.xml \
            --cov=src --cov-branch \
            --cov-report=xml:coverage.xml \
            --cov-report=json:coverage.json \
            --cov-report=html:htmlcov \
            --cov-report=term-missing

      - name: Prepare coverage artifacts
        run: |
          cp -f pytest-junit.xml pytest-report.xml || true

      - name: Upload coverage artifacts
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ env.PYTHON_VERSION }}
          retention-days: 10
          path: |
            coverage.xml
            coverage.json
            htmlcov/**
            pytest-junit.xml
            pytest-report.xml

      - name: Enforce coverage minimum
        run: |
          RAW=$(grep -Eo 'line-rate="[0-9.]+"' coverage.xml | head -1 | sed -E 's/.*"([0-9.]+)"/\1/')
          PCT=$(python -c "print(float('$RAW')*100.0)")
          echo "Coverage: ${PCT}% (min ${COVERAGE_MIN}%)"
          python -c "import sys; cur=float('$PCT'); m=float('${COVERAGE_MIN}'); sys.exit(0 if cur>=m else 1)" || { echo 'Coverage below minimum' >&2; exit 1; }

      - name: Publish coverage summary
        run: |
          RAW=$(grep -Eo 'line-rate="[0-9.]+"' coverage.xml | head -1 | sed -E 's/.*"([0-9.]+)"/\1/')
          PCT=$(python -c "print(round(float('$RAW')*100.0, 2))")
          {
            echo "## Test Coverage"
            echo ""
            echo "- Python: ${PYTHON_VERSION}"
            echo "- Line coverage: ${PCT}%"
            echo "- Minimum required: ${COVERAGE_MIN}%"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Summarize lint results
        if: always()
        run: |
          {
            echo "### CI Style Summary"
            echo "Black: PASS"
            echo "Ruff total issues: ${{ steps.ruff.outputs.total }}"
            echo "Ruff new issues: ${{ steps.ruff.outputs.new }}"
            if [ -f mypy_report.txt ]; then
              if grep -q "error:" mypy_report.txt; then
                echo "mypy: FAIL"
              else
                echo "mypy: PASS"
              fi
            fi
          } >> "$GITHUB_STEP_SUMMARY"
