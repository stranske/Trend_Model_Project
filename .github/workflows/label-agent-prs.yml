name: Label agent PRs

# Hardening Note (Issue #1140)
# Uses pull_request_target only to apply labels; no untrusted code execution.
# Sparse checkout restricts fetched files to a single trusted JSON rule file.
# Any addition of build/test/script execution must undergo security review.

# ----------------------------------------------------------------------------------
# DESIGN NOTE (2025-09-12)
# We intentionally use `pull_request_target` instead of `pull_request` here because:
#   1. The workflow needs to apply labels with a PAT fallback (SERVICE_BOT_PAT) for
#      cross‑fork agent PRs. `pull_request_target` executes in the base repo context
#      so secrets are available (GitHub’s standard permission model blocks secrets
#      on arbitrary fork code when using plain `pull_request`).
#   2. This job is read‑only with respect to the fork’s code; it never checks out
#      or executes untrusted fork contents. All logic operates solely on the event
#      payload metadata (actor login, head ref name, existing labels). This mitigates
#      the primary supply‑chain risk of `pull_request_target` (i.e. running attacker
#      code with elevated secrets).
#   3. Labels must be applied before other guarded workflows (assignment/autofix)
#      evaluate label predicates; using `pull_request_target` guarantees the labeler
#      runs even for first‑time contributors whose PRs would otherwise lack secret
#      access, keeping downstream automation deterministic.
#
# Guard‑rails implemented:
#   • No repository write operations beyond issue/PR label mutation.
#   • No checkout of fork code (avoids executing attacker code path).
#   • Optional PAT fallback only when SERVICE_BOT_PAT is defined; otherwise the
#     ephemeral GITHUB_TOKEN is used (principle of least privilege by default).
#   • Idempotent logic: computes missing labels and only adds the delta, reducing
#     audit noise.
#
# Migration criteria for reconsidering `pull_request_target`:
#   • If GitHub enables secure label mutation with secrets on `pull_request` for
#     forks (current limitation removed), OR
#   • If we drop PAT usage entirely and rely solely on GITHUB_TOKEN with sufficient
#     scopes, making secret access unnecessary, OR
#   • If threat modeling changes and we decide to centralize labeling within the
#     broader assignment workflow (already split‑permission aware).
#
# Until one of those conditions is satisfied, retaining `pull_request_target` here
# keeps cross‑fork agent labeling reliable without expanding the attack surface.
# ----------------------------------------------------------------------------------

on:
  pull_request_target:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  label:
    runs-on: ubuntu-latest
    env:
      TRUSTED_LABEL_RULE_PATHS: |
        .github/agent-label-rules.json
    steps:
      - name: Select token (PAT fallback)
        id: token
        run: |
          if [ -n "${{ secrets.SERVICE_BOT_PAT }}" ]; then
            echo "value=${{ secrets.SERVICE_BOT_PAT }}" >> $GITHUB_OUTPUT
          else
            echo "value=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT
          fi
      - name: Checkout trusted config
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          persist-credentials: false
          fetch-depth: 1
          sparse-checkout: ${{ env.TRUSTED_LABEL_RULE_PATHS }}
          sparse-checkout-cone-mode: false
          path: trusted-config
      - name: Assert sparse checkout scope (Issue #1140)
        run: |
          set -euo pipefail
          python .github/scripts/label_rules_assert.py
      - uses: actions/github-script@v7
        with:
          github-token: ${{ steps.token.outputs.value }}
          script: |
            const fs = require('fs');
            function loadRules(filePath) {
              if (!filePath) {
                return {};
              }
              try {
                const raw = fs.readFileSync(filePath, 'utf8');
                return JSON.parse(raw);
              } catch (error) {
                core.warning(`Failed to load agent label rules from ${filePath}: ${error.message}`);
                return {};
              }
            }
            function collectStrings(value) {
              if (!Array.isArray(value)) {
                return [];
              }
              return value
                .filter(v => typeof v === 'string')
                .map(v => v.trim())
                .filter(v => v.length > 0);
            }
            const rulesPath = process.env.LABEL_RULES_PATH || 'trusted-config/.github/agent-label-rules.json';
            const rules = loadRules(rulesPath);
            const agents = rules.agents || {};
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            const actor = (pr.user?.login || '').toLowerCase();
            const head = (pr.head?.ref || '').toLowerCase();

            const defaultAutomerge = (rules.common && typeof rules.common.automerge === 'string')
              ? rules.common.automerge
              : 'automerge';
            const defaultRisk = (rules.common && typeof rules.common.risk === 'string')
              ? rules.common.risk
              : 'risk:low';
            const COMMON_LABELS = [
              process.env.AUTOMERGE_LABEL || defaultAutomerge,
              process.env.RISK_LABEL || defaultRisk,
            ];

            const copilotRules = agents.copilot || {};
            const codexRules = agents.codex || {};

            const copilotDefaults = collectStrings(copilotRules.labels);
            const codexDefaults = collectStrings(codexRules.labels);

            const COPILOT_LABELS = [
              process.env.AGENT_FROM_LABEL || copilotDefaults[0] || 'from:copilot',
              process.env.AGENT_LABEL || copilotDefaults[1] || 'agent:copilot',
              ...COMMON_LABELS,
            ];
            const CODEX_LABELS = [
              process.env.AGENT_FROM_LABEL_ALT || codexDefaults[0] || 'from:codex',
              process.env.AGENT_LABEL_ALT || codexDefaults[1] || 'agent:codex',
              ...COMMON_LABELS,
            ];

            const copilotActorFragments = collectStrings(copilotRules.actor_substrings);
            const copilotHeadPrefixes = collectStrings(copilotRules.head_prefixes);
            const codexActorFragments = collectStrings(codexRules.actor_substrings);
            const codexHeadPrefixes = collectStrings(codexRules.head_prefixes);

            const labels = new Set();
            const matchesCopilotActor = copilotActorFragments.length
              ? copilotActorFragments.some(fragment => actor.includes(fragment.toLowerCase()))
              : actor.includes('copilot');
            const matchesCopilotHead = copilotHeadPrefixes.length
              ? copilotHeadPrefixes.some(prefix => head.startsWith(prefix.toLowerCase()))
              : head.startsWith('copilot/') || head.startsWith('agents/copilot-');
            if (matchesCopilotActor || matchesCopilotHead) {
              COPILOT_LABELS.forEach(l => labels.add(l));
            }
            const matchesCodexActor = codexActorFragments.length
              ? codexActorFragments.some(fragment => actor.includes(fragment.toLowerCase()))
              : actor.includes('codex');
            const matchesCodexHead = codexHeadPrefixes.length
              ? codexHeadPrefixes.some(prefix => head.startsWith(prefix.toLowerCase()))
              : head.startsWith('codex/') || head.startsWith('agents/codex-');
            if (matchesCodexActor || matchesCodexHead) {
              CODEX_LABELS.forEach(l => labels.add(l));
            }
            const desired = Array.from(labels);
            const existing = (pr.labels || []).map(l => l.name);
            const missing = desired.filter(l => !existing.includes(l));
            if (!missing.length) {
              core.info('All desired agent labels already present; no-op.');
            } else {
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: missing });
              core.info('Applied labels: ' + JSON.stringify(missing));
            }

            core.summary
              .addHeading('Agent PR Label Summary')
              .addTable([
                [{data: 'PR', header: true}, {data: 'Actor', header: true}, {data: 'Head Ref', header: true}, {data: 'Added', header: true}, {data: 'Already Present', header: true}],
                [String(pr.number), actor, head, missing.join(',') || '(none)', desired.filter(l => existing.includes(l)).join(',') || '(none)']
              ])
              .write();
        env:
          LABEL_RULES_PATH: trusted-config/.github/agent-label-rules.json
          AUTOMERGE_LABEL: ${{ vars.AUTOMERGE_LABEL }}
          RISK_LABEL: ${{ vars.RISK_LABEL }}
          AGENT_FROM_LABEL: ${{ vars.AGENT_FROM_LABEL }}
          AGENT_LABEL: ${{ vars.AGENT_LABEL }}
          AGENT_FROM_LABEL_ALT: ${{ vars.AGENT_FROM_LABEL_ALT }}
          AGENT_LABEL_ALT: ${{ vars.AGENT_LABEL_ALT }}
