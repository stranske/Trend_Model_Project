name: Merge Manager

on:
  pull_request:
    types: [opened, labeled, synchronize, ready_for_review, reopened]
  workflow_run:
    workflows: ["CI", "Docker"]
    types: [completed]  

permissions:
  pull-requests: write
  contents: write
  checks: read
  actions: read

env:
  COMMIT_PREFIX: ${{ vars.AUTOFIX_COMMIT_PREFIX || 'chore(autofix):' }}
  SAFE_LABEL_AUTOMERGE: ${{ vars.AUTOMERGE_LABEL || 'automerge' }}
  SAFE_LABEL_RISK: ${{ vars.RISK_LABEL || 'risk:low' }}
  SAFE_LABEL_CI: ${{ vars.CI_LABEL || 'ci:green' }}
  SAFE_LABEL_AGENT1: ${{ vars.AGENT_FROM_LABEL || 'from:copilot' }}
  SAFE_LABEL_AGENT2: ${{ vars.AGENT_FROM_LABEL_ALT || 'from:codex' }}
  SAFE_LABEL_BREAKING: ${{ vars.BREAKING_LABEL || 'breaking' }}
  QUIET_MINUTES: ${{ vars.QUIET_MINUTES || '3' }}
  MAX_LINES_CHANGED: ${{ vars.MAX_LINES_CHANGED || '1000' }}
  APPROVE_PATTERNS: ${{ vars.APPROVE_PATTERNS || '' }}
  GH_TOKEN: ${{ secrets.SERVICE_BOT_PAT || secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}

jobs:
  decide-on-pr-event:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    outputs:
      approve: ${{ steps.decide.outputs.approve }}
      enable_automerge: ${{ steps.decide.outputs.enable_automerge }}
      rationale: ${{ steps.decide.outputs.rationale }}
    steps:
      - name: Checkout (read-only)
        uses: actions/checkout@v4
      - name: Gather PR context
        id: ctx
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const labels = (pr.labels||[]).map(l=>l.name);
            const labelSet = new Set(labels);
            function has(l){ return labelSet.has(l); }
            const need = (envName, fallback) => process.env[envName] || fallback;
            const breakingLabelName = need('SAFE_LABEL_BREAKING','breaking');
            const hasBreaking = has(breakingLabelName) || labels.some(label => (label || '').toLowerCase().includes('breaking'));
            const meta = {
              draft: pr.draft,
              hasAgent: has(need('SAFE_LABEL_AGENT1','from:copilot')) || has(need('SAFE_LABEL_AGENT2','from:codex')),
              hasRisk: has(need('SAFE_LABEL_RISK','risk:low')),
              hasAutomerge: has(need('SAFE_LABEL_AUTOMERGE','automerge')),
              hasCI: has(need('SAFE_LABEL_CI','ci:green')),
              hasBreaking,
            };
            core.setOutput('labels', labels.join(','));
            core.setOutput('meta', JSON.stringify(meta));
      - name: Check required workflows
        id: checks
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;
            async function findRun(workflowName){
              try {
                const response = await github.rest.actions.listWorkflowRunsForRepo({
                  owner,
                  repo,
                  branch: pr.head.ref,
                  per_page: 100,
                });
                const run = (response.data.workflow_runs || []).find(candidate => candidate.name === workflowName && candidate.head_sha === pr.head.sha);
                if(!run){
                  return { found: false, status: 'missing', conclusion: '', url: '' };
                }
                return {
                  found: true,
                  status: run.status || '',
                  conclusion: run.conclusion || '',
                  url: run.html_url || run.url || '',
                };
              } catch (error) {
                core.warning(`Failed to list workflow runs for ${workflowName}: ${error.message}`);
                return { found: false, status: 'error', conclusion: '', url: '', error: error.message };
              }
            }
            function isGreen(info){
              if(!info.found){ return false; }
              if((info.status || '').toLowerCase() !== 'completed'){ return false; }
              return (info.conclusion || '').toLowerCase() === 'success';
            }
            const ci = await findRun('CI');
            const docker = await findRun('Docker');
            core.setOutput('ci', JSON.stringify(ci));
            core.setOutput('docker', JSON.stringify(docker));
            core.setOutput('ci_green', String(isGreen(ci)));
            core.setOutput('docker_green', String(isGreen(docker)));
      - name: Inspect file diff & size
        id: diff
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;
            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: pr.number, per_page: 100 });
            const totalChanges = files.reduce((a,f)=>a + (f.changes||0), 0);
            const patternsRaw = (process.env.APPROVE_PATTERNS||'').split(',').map(s=>s.trim()).filter(Boolean);
            const patterns = patternsRaw.length ? patternsRaw : ['docs/**','*.md','**/*.md','tests/**','src/**/*.py','pyproject.toml'];
            function match(filename){
              return patterns.some(p => {
                if(p.endsWith('/**')) return filename.startsWith(p.slice(0,-3));
                if(p.startsWith('**/*.')) return filename.endsWith(p.slice(4));
                if(p === '*.md') return filename.endsWith('.md');
                return filename === p;
              });
            }
            const allSafe = files.every(f => match(f.filename));
            core.setOutput('all_safe', String(allSafe));
            core.setOutput('total_changes', String(totalChanges));
      - name: Evaluate quiet window & active workflows
        id: gate
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const quietMinutes = parseInt(process.env.QUIET_MINUTES||'3',10);
            const { owner, repo } = context.repo;
            const sha = pr.head.sha;
            const commit = await github.rest.repos.getCommit({ owner, repo, ref: sha });
            const commitTime = new Date(commit.data.commit.author.date).getTime();
            const ageMin = (Date.now()-commitTime)/60000;
            async function active(workflowName){
              try {
                const runs = await github.rest.actions.listWorkflowRunsForRepo({ owner, repo, per_page: 30, branch: pr.head.ref });
                return runs.data.workflow_runs.some(r => r.name === workflowName && ['in_progress','queued','waiting'].includes(r.status));
              } catch(e){ core.warning('List runs failed: '+e.message); return false; }
            }
            const activeCI = await active('CI');
            const activeAutofix = await active('Autofix');
            const quietOk = ageMin >= quietMinutes;
            const activeOk = !(activeCI || activeAutofix);
            core.setOutput('quiet_ok', String(quietOk));
            core.setOutput('active_ok', String(activeOk));
            core.setOutput('age_min', ageMin.toFixed(2));
      - name: Decide policy
        id: decide
        uses: actions/github-script@v7
        with:
          script: |
            const safeParse = (value, fallback) => {
              try {
                return JSON.parse(value);
              } catch (error) {
                core.warning(`Failed to parse JSON input: ${error.message}`);
                return fallback;
              }
            };
            const meta = safeParse(process.env.meta_json || '{}', {
              draft: false,
              hasAgent: false,
              hasRisk: false,
              hasAutomerge: false,
              hasCI: false,
              hasBreaking: false,
            });
            const allSafe = (process.env.all_safe || '').toLowerCase() === 'true';
            const totalChanges = parseInt(process.env.total_changes || '0', 10);
            const maxLines = parseInt(process.env.MAX_LINES_CHANGED || '1000', 10);
            const quietOk = (process.env.quiet_ok || '').toLowerCase() === 'true';
            const activeOk = (process.env.active_ok || '').toLowerCase() === 'true';
            const ciGreen = (process.env.ci_green || '').toLowerCase() === 'true';
            const dockerGreen = (process.env.docker_green || '').toLowerCase() === 'true';
            const parseStatus = (value) => {
              try {
                return JSON.parse(value || '{}');
              } catch (error) {
                core.warning(`Failed to parse workflow status payload: ${error.message}`);
                return { found: false, status: 'error', conclusion: '', url: '' };
              }
            };
            const ciInfo = parseStatus(process.env.ci_status || '{}');
            const dockerInfo = parseStatus(process.env.docker_status || '{}');
            function workflowReason(info, name){
              if(!info.found){
                return `${name} workflow has not completed for this commit`;
              }
              const status = (info.status || '').toLowerCase();
              if(status !== 'completed'){
                return `${name} workflow status ${status || 'pending'}`;
              }
              const conclusion = (info.conclusion || '').toLowerCase();
              if(conclusion !== 'success'){
                return `${name} workflow conclusion ${conclusion || 'unknown'}`;
              }
              return '';
            }
            const reasons = [];
            if(meta.draft) reasons.push('draft PR');
            if(!meta.hasAgent) reasons.push('missing agent label');
            if(!meta.hasRisk) reasons.push('missing risk label');
            if(!meta.hasAutomerge) reasons.push('missing automerge label');
            if(meta.hasBreaking) reasons.push('breaking label present');
            if(!ciGreen){
              const msg = workflowReason(ciInfo, 'CI');
              reasons.push(msg || 'CI workflow not green');
            }
            if(!dockerGreen){
              const msg = workflowReason(dockerInfo, 'Docker');
              reasons.push(msg || 'Docker workflow not green');
            }
            if(!meta.hasCI) reasons.push('missing ci:green label');
            if(!allSafe) reasons.push('non-allowlist file changes');
            if(totalChanges > maxLines) reasons.push(`exceeds size cap (${totalChanges}>${maxLines})`);
            if(!quietOk) reasons.push('quiet period not satisfied');
            if(!activeOk) reasons.push('active workflows running');
            const hasBlockerReason = reasons.filter(r => ['non-allowlist file changes', 'exceeds size cap', 'draft PR', 'breaking label present'].includes(r)).length > 0;
            const isSafe = allSafe;
            const isWithinSize = totalChanges <= maxLines;
            const isNotDraft = !meta.draft;
            const approve = !hasBlockerReason && isSafe && isWithinSize && isNotDraft;
            const enableAutomerge = approve && reasons.length === 0;
            core.setOutput('approve', String(approve));
            core.setOutput('enable_automerge', String(enableAutomerge));
            core.setOutput('rationale', reasons.join('; '));
        env:
          meta_json: ${{ steps.ctx.outputs.meta }}
          all_safe: ${{ steps.diff.outputs.all_safe }}
          total_changes: ${{ steps.diff.outputs.total_changes }}
          quiet_ok: ${{ steps.gate.outputs.quiet_ok }}
          active_ok: ${{ steps.gate.outputs.active_ok }}
          ci_status: ${{ steps.checks.outputs.ci }}
          docker_status: ${{ steps.checks.outputs.docker }}
          ci_green: ${{ steps.checks.outputs.ci_green }}
          docker_green: ${{ steps.checks.outputs.docker_green }}
      - name: Approve PR
        if: steps.decide.outputs.approve == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            await github.rest.pulls.createReview({ owner: context.repo.owner, repo: context.repo.repo, pull_number: pr.number, event: 'APPROVE', body: 'Merge Manager auto-approval' });
      - name: Enable auto-merge
        if: steps.decide.outputs.enable_automerge == 'true'
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ secrets.SERVICE_BOT_PAT || secrets.GITHUB_TOKEN }}
          merge-method: squash
          pull-request-number: ${{ github.event.pull_request.number }}
      - name: Post decline rationale (single comment)
        if: steps.decide.outputs.enable_automerge != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const rationale = process.env.rationale || '';
            if(!rationale){ return; }
            const { owner, repo } = context.repo;
            const marker = '<!-- merge-manager-rationale -->';
            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number: pr.number, per_page: 50 });
            const existing = comments.find(c => c.body && c.body.includes(marker));
            const body = `${marker}\nMerge Manager decline rationale: ${rationale}`;
            if(existing){
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: pr.number, body });
            }
        env:
          rationale: ${{ steps.decide.outputs.rationale }}

  post-workflow-run:
    if: github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Identify PR
        id: find_pr
        uses: actions/github-script@v7
        with:
          script: |
            const run = context.payload.workflow_run;
            const { owner, repo } = context.repo;
            const branch = run.head_branch;
            const prs = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${branch}` });
            if(!prs.data.length){ core.setOutput('pr',''); return; }
            core.setOutput('pr', String(prs.data[0].number));
      - name: Skip if no PR
        if: steps.find_pr.outputs.pr == ''
        run: echo 'No PR for branch.'
      - name: Re-dispatch PR event evaluation
        if: steps.find_pr.outputs.pr != ''
        uses: actions/github-script@v7
        with:
          script: |
            // Lightweight poke: add a label noop or issue comment could be used; here we just log.
            core.info('Workflow_run completed; rely on PR event path for further decisions.')
