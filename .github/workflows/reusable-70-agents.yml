name: Reusable 70 Agents

on:
  workflow_call:
    inputs:
      enable_readiness:
        description: 'Run agent readiness (assignability) probe (true/false)'
        required: false
        default: 'false'
        type: string
      readiness_agents:
        description: 'Comma-separated agent keys (copilot,codex)'
        required: false
        default: 'copilot,codex'
        type: string
      readiness_custom_logins:
        description: 'Comma-separated additional raw bot logins (exact usernames)'
        required: false
        default: ''
        type: string
      require_all:
        description: 'Fail readiness job if any requested agent/custom login not assignable (true/false)'
        required: false
        default: 'false'
        type: string
      enable_preflight:
        description: 'Run codex preflight probe (true/false)'
        required: false
        default: 'false'
        type: string
      codex_user:
        description: 'Codex connector login override'
        required: false
        default: ''
        type: string
      codex_command_phrase:
        description: 'Command phrase to post for Codex'
        required: false
        default: ''
        type: string
      enable_diagnostic:
        description: 'Run bootstrap diagnostic job (true/false)'
        required: false
        default: 'false'
        type: string
      diagnostic_attempt_branch:
        description: 'Attempt branch create in diagnostic (true/false)'
        required: false
        default: 'false'
        type: string
      diagnostic_dry_run:
        description: 'Diagnostic dry run (true/false)'
        required: false
        default: 'true'
        type: string
      enable_verify_issue:
        description: 'Verify a specific issue has an agent assignee (true/false)'
        required: false
        default: 'false'
        type: string
      verify_issue_number:
        description: 'Issue number to verify when enable_verify_issue=true'
        required: false
        default: ''
        type: string
      enable_watchdog:
        description: 'Run watchdog checks (true/false)'
        required: false
        default: 'true'
        type: string
      bootstrap_issues_label:
        description: 'Label to trigger Codex bootstrap'
        required: false
        default: 'agent:codex'
        type: string
      draft_pr:
        description: 'Open bootstrap PRs as draft (true/false)'
        required: false
        default: 'false'
        type: string
      options_json:
        description: 'JSON configuration for optional automation (keepalive sweep, etc)'
        required: false
        default: '{}'
        type: string
    secrets:
      service_bot_pat:
        required: false
    outputs:
      readiness_report:
        description: 'JSON report emitted by the readiness probe when enabled'
        value: ${{ jobs.readiness.outputs.report_json }}
      readiness_table:
        description: 'Markdown table emitted by the readiness probe when enabled'
        value: ${{ jobs.readiness.outputs.table_md }}

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  readiness:
    if: inputs.enable_readiness == 'true'
    name: Agent Readiness Probe
    runs-on: ubuntu-latest
    outputs:
      report_json: ${{ steps.try.outputs.report || '{}' }}
      table_md: ${{ steps.try.outputs.table || '' }}
    permissions:
      contents: read
      issues: write
    steps:
      - name: Probe assignable actors
        id: gql
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const q = `query($owner:String!, $repo:String!) { repository(owner:$owner, name:$repo) { suggestedActors(capabilities:[CAN_BE_ASSIGNED], first:100) { nodes { login } } } }`;
            const res = await github.graphql(q, { owner, repo });
            const actors = (res.repository?.suggestedActors?.nodes || []).map(n => (n.login || '').toLowerCase());
            core.setOutput('actors', JSON.stringify(actors));
      - name: Create temp issue
        id: tmp
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const { data: issue } = await github.rest.issues.create({ owner, repo, title: '[readiness] probe', body: 'temp' });
            core.setOutput('num', String(issue.number));
      - name: Try agent assignment
        id: try
        env:
          ACTORS_JSON: ${{ steps.gql.outputs.actors }}
          AGENTS_REQ: ${{ inputs.readiness_agents }}
          CUSTOM_LOGINS: ${{ inputs.readiness_custom_logins }}
          REQUIRE_ALL: ${{ inputs.require_all }}
        uses: actions/github-script@v7
        with:
          script: |
            const num = Number(core.getInput('issue_number') || process.env.ISSUE_NUM || '${{ steps.tmp.outputs.num }}');
            const actors = JSON.parse(process.env.ACTORS_JSON || '[]');
            const requested = (process.env.AGENTS_REQ || 'copilot,codex').split(',').map(s=>s.trim()).filter(Boolean);
            const custom = (process.env.CUSTOM_LOGINS || '').split(',').map(s=>s.trim()).filter(Boolean);
            const CANDIDATES = {
              copilot: ['copilot','copilot-swe-agent'],
              codex: ['chatgpt-codex-connector']
            };
            const rows = [];
            const report = {};
            // Handle keyed agents
            for (const key of requested) {
              const cands = CANDIDATES[key]||[];
              let ok=false, used='';
              for (const c of cands) { if (actors.includes(c)) { ok=true; used=c; break; } }
              report[key]={ok, used};
              rows.push({ label:key, type:'builtin', requested:true, ok, used });
            }
            // Handle custom explicit logins (exact matches)
            for (const login of custom) {
              const ok = actors.includes(login.toLowerCase());
              report[`custom:${login}`] = { ok, used: ok ? login.toLowerCase(): '' };
              rows.push({ label:login.toLowerCase(), type:'custom', requested:true, ok, used: ok? login.toLowerCase(): '' });
            }
            // Build markdown table
            const header = '| Agent | Kind | Requested | Assignable | Resolved Login |';
            const sep = '|-------|------|-----------|-----------|---------------|';
            const mdRows = rows.map(r => `| ${r.label} | ${r.type} | yes | ${r.ok? '':''} | ${r.used} |`);
            const table = [header, sep, ...mdRows].join('\n');
            core.setOutput('report', JSON.stringify(report));
            core.setOutput('table', table);
            const requireAll = (process.env.REQUIRE_ALL||'false').toLowerCase()==='true';
            if (requireAll) {
              const missing = rows.filter(r=>!r.ok).map(r=>r.label);
              if (missing.length) {
                core.setFailed('Missing assignable agents: '+missing.join(', '));
              }
            }
      - name: Close temp
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo; await github.rest.issues.update({ owner, repo, issue_number: Number('${{ steps.tmp.outputs.num }}'), state: 'closed' });
      - name: Summary
        if: always()
        run: |
          {
            printf '### Agent Readiness Report %s\n' "${{ steps.try.outcome == 'failure' && '' || '' }}"
            printf '\n```json\n'
            printf '%s\n' "${{ steps.try.outputs.report }}"
            printf '```\n\n'
            printf '%s\n\n' "${{ steps.try.outputs.table }}"
            printf 'Require all: %s\n' "${{ inputs.require_all }}"
            printf 'Custom logins: %s\n' "${{ inputs.readiness_custom_logins }}"
            printf 'Overall: %s\n' "${{ steps.try.outcome == 'failure' && 'failure (missing required agents)' || 'success' }}"
          } >>"$GITHUB_STEP_SUMMARY"

  preflight:
    if: inputs.enable_preflight == 'true'
    name: Codex Preflight
    runs-on: ubuntu-latest
    steps:
      - name: Preflight probe
        uses: actions/github-script@v7
        env:
          CODEX_USER: ${{ inputs.codex_user }}
          CODEX_COMMAND: ${{ inputs.codex_command_phrase }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const user = process.env.CODEX_USER;
            if (!user) { core.warning('No CODEX_USER provided'); return; }
            const { data: issue } = await github.rest.issues.create({ owner, repo, title: '[probe] codex-assignability', body: 'temp' });
            try { await github.rest.issues.addAssignees({ owner, repo, issue_number: issue.number, assignees: [user] }); core.info('Assignable'); }
            catch (e) { core.warning('Not assignable: '+e.message); }
            if (process.env.CODEX_COMMAND) { await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: process.env.CODEX_COMMAND }); }
            await github.rest.issues.update({ owner, repo, issue_number: issue.number, state: 'closed' });

  diagnostic:
    if: inputs.enable_diagnostic == 'true'
    name: Bootstrap Diagnostic
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Token / Env Probe
        shell: bash
        env:
          DRY_RUN: ${{ inputs.diagnostic_dry_run }}
          ATTEMPT: ${{ inputs.diagnostic_attempt_branch }}
        run: |
          set -euo pipefail
          echo "Diagnostic dry_run=$DRY_RUN attempt_branch=$ATTEMPT"
          echo "Tokens present: GITHUB_TOKEN=${GITHUB_TOKEN:+yes} SERVICE_BOT_PAT=${SERVICE_BOT_PAT:+yes}"
      - name: Attempt branch create
        if: inputs.diagnostic_attempt_branch == 'true'
        shell: bash
        run: |
          set -euo pipefail
          base=$(git rev-parse HEAD)
            ts=$(date -u +%Y%m%d%H%M%S)
            target="diagnostic/codex-${ts}"
            echo "Creating $target from $base"
            curl -s -o /tmp/create.json -w '%{http_code}' -X POST \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H 'Accept: application/vnd.github+json' \
              https://api.github.com/repos/${{ github.repository }}/git/refs \
              -d '{"ref":"refs/heads/'"$target"'","sha":"'"$base"'"}' || true

  verify_issue:
    if: inputs.enable_verify_issue == 'true' && inputs.verify_issue_number != ''
    name: Verify Agent Issue Assignment
    runs-on: ubuntu-latest
    steps:
      - name: Check assignees
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issue_num = Number('${{ inputs.verify_issue_number }}');
            const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number: issue_num });
            const assignees = (issue.assignees||[]).map(a => (a.login||'').toLowerCase());
            if (!assignees.includes('copilot') && !assignees.includes('chatgpt-codex-connector')) {
              core.setFailed(`Issue #${issue_num} has no agent assignee`);
            } else { core.info('Agent assigned: '+assignees.join(',')); }

  bootstrap-codex:
    name: Bootstrap Codex PRs
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Find Ready Issues
        id: ready
        uses: actions/github-script@v7
        env:
          LABEL: ${{ inputs.bootstrap_issues_label }}
        with:
          script: |
            const label = process.env.LABEL;
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: label,
              per_page: 30
            });
            const ready = issues.filter(i => !i.pull_request && !i.title.toLowerCase().includes('wip'));
            core.setOutput('issue_numbers', ready.map(r => r.number).join(','));
      - name: Bootstrap First Issue (if any)
        if: steps.ready.outputs.issue_numbers != ''
        uses: ./.github/actions/codex-bootstrap-lite
        with:
          issue: ${{ fromJSON(format('[{0}]', steps.ready.outputs.issue_numbers))[0] }}
          service_bot_pat: ${{ secrets.service_bot_pat || '' }}
          draft: ${{ inputs.draft_pr }}

  keepalive-sweep:
    name: Codex Keepalive Sweep
    runs-on: ubuntu-latest
    if: ${{ always() }}
    steps:
      - name: Sweep stalled checklists
        id: sweep
        uses: actions/github-script@v7
        env:
          OPTIONS_JSON: ${{ inputs.options_json }}
        with:
          script: |
            const DEFAULT_KEEPALIVE = {
              enabled: true,
              dry_run: false,
              idle_minutes: 10,
              cooldown_minutes: 30,
              command: '@codex plan-and-execute',
              comment_suffix: '_(automated keepalive sweep)_',
              labels: ['agent:codex'],
              exclude_labels: ['status:complete', 'status:done'],
              assignees: ['chatgpt-codex-connector'],
              include_prs: false,
              max_candidates: 25
            };

            const parseJson = (raw) => {
              if (!raw || !raw.trim()) {
                return {};
              }
              try {
                return JSON.parse(raw);
              } catch (error) {
                core.warning(`Invalid options_json provided (${error.message}). Falling back to defaults.`);
                return {};
              }
            };

            const normalizeList = (value) => {
              if (Array.isArray(value)) {
                return value.filter(Boolean).map((entry) => String(entry).trim()).filter(Boolean);
              }
              if (typeof value === 'string' && value.trim()) {
                return value.split(',').map((entry) => entry.trim()).filter(Boolean);
              }
              return [];
            };

            const rawOptions = process.env.OPTIONS_JSON || '{}';
            const userOptions = parseJson(rawOptions);
            const keepalive = {
              ...DEFAULT_KEEPALIVE,
              ...(userOptions.keepalive || {})
            };

            keepalive.labels = normalizeList(keepalive.labels);
            keepalive.exclude_labels = normalizeList(keepalive.exclude_labels);
            keepalive.assignees = normalizeList(keepalive.assignees);

            const toNumber = (value, fallback) => {
              const n = Number(value);
              return Number.isFinite(n) && n > 0 ? n : fallback;
            };

            keepalive.idle_minutes = toNumber(keepalive.idle_minutes, DEFAULT_KEEPALIVE.idle_minutes);
            keepalive.cooldown_minutes = toNumber(keepalive.cooldown_minutes, DEFAULT_KEEPALIVE.cooldown_minutes);
            keepalive.max_candidates = Math.max(1, Math.floor(toNumber(keepalive.max_candidates, DEFAULT_KEEPALIVE.max_candidates)));

            const summary = core.summary;
            summary.addHeading('Codex Keepalive Sweep', 2);

            if (!keepalive.enabled) {
              core.notice('Codex keepalive sweep disabled via configuration.');
              summary.addRaw('Disabled via configuration.').addEOL();
              await summary.write();
              core.setOutput('triggered', '[]');
              core.setOutput('dry_run', String(keepalive.dry_run));
              return;
            }

            const now = Date.now();
            const idleMs = keepalive.idle_minutes * 60 * 1000;
            const cooldownMs = keepalive.cooldown_minutes * 60 * 1000;
            const command = String(keepalive.command || DEFAULT_KEEPALIVE.command);
            const commandRegex = new RegExp(command.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i');

            const { owner, repo } = context.repo;
            const issueParams = {
              owner,
              repo,
              state: 'open',
              per_page: 100
            };

            if (keepalive.labels.length) {
              issueParams.labels = keepalive.labels.join(',');
            }

            const candidates = [];
            const issues = await github.paginate(github.rest.issues.listForRepo, issueParams);

            for (const issue of issues) {
              if (candidates.length >= keepalive.max_candidates) {
                break;
              }

              if (!keepalive.include_prs && issue.pull_request) {
                continue;
              }

              const issueLabels = (issue.labels || []).map((label) => (typeof label === 'string' ? label : label.name || '').toLowerCase());
              if (keepalive.exclude_labels.some((label) => issueLabels.includes(label.toLowerCase()))) {
                continue;
              }

              if (keepalive.assignees.length) {
                const assignees = (issue.assignees || []).map((as) => (as.login || '').toLowerCase());
                const hasAssignee = keepalive.assignees.some((target) => assignees.includes(target.toLowerCase()));
                if (!hasAssignee) {
                  continue;
                }
              }

              const updatedAt = new Date(issue.updated_at).getTime();
              if (Number.isFinite(updatedAt) && now - updatedAt < idleMs) {
                continue;
              }

              const comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: issue.number,
                per_page: 100
              });

              let lastCommand = null;
              for (const comment of comments) {
                if (commandRegex.test(comment.body || '')) {
                  lastCommand = comment;
                }
              }

              if (lastCommand) {
                const lastCommandAt = new Date(lastCommand.created_at).getTime();
                if (Number.isFinite(lastCommandAt) && now - lastCommandAt < cooldownMs) {
                  continue;
                }
              }

              candidates.push({
                issue,
                lastCommandAt: lastCommand ? lastCommand.created_at : null,
                idleMinutes: Math.floor((now - updatedAt) / 60000)
              });
            }

            if (!candidates.length) {
              summary.addRaw('No stalled checklists detected.').addEOL();
              await summary.write();
              core.setOutput('triggered', '[]');
              core.setOutput('dry_run', String(keepalive.dry_run));
              return;
            }

            const triggered = [];
            for (const candidate of candidates) {
              triggered.push({
                number: candidate.issue.number,
                title: candidate.issue.title,
                idleMinutes: candidate.idleMinutes,
                lastCommandAt: candidate.lastCommandAt
              });
              if (keepalive.dry_run) {
                core.info(`[dry-run] Would reissue command for #${candidate.issue.number}`);
                continue;
              }
              const bodyLines = [
                command,
                '',
                `_(keepalive sweep triggered after ${candidate.idleMinutes} minutes idle)_`
              ];
              if (keepalive.comment_suffix) {
                bodyLines.push('', keepalive.comment_suffix);
              }
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: candidate.issue.number,
                body: bodyLines.join('\n')
              });
              core.notice(`Reissued keepalive command for #${candidate.issue.number}`);
            }

            const tableRows = [
              [{ data: 'Issue', header: true }, { data: 'Idle (min)', header: true }, { data: 'Last command', header: true }]
            ];
            for (const entry of triggered) {
              tableRows.push([
                `#${entry.number} ${entry.title}`,
                String(entry.idleMinutes),
                entry.lastCommandAt ? new Date(entry.lastCommandAt).toISOString() : 'never'
              ]);
            }

            summary
              .addRaw(`Processed ${triggered.length} stalled checklist${triggered.length === 1 ? '' : 's'}.`).addEOL()
              .addTable(tableRows);

            await summary.write();
            core.setOutput('triggered', JSON.stringify(triggered));
            core.setOutput('dry_run', String(keepalive.dry_run));

  watchdog:
    if: inputs.enable_watchdog == 'true'
    name: Agent Watchdog
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Basic Repo Sanity
        run: |
          test -f pyproject.toml || { echo 'pyproject.toml missing'; exit 1; }
          echo 'Repository baseline OK.'

  keepalive:
    name: Codex Keepalive Sweep
    runs-on: ubuntu-latest
    steps:
      - name: Resume Codex on unattended checklists
        uses: actions/github-script@v7
        env:
          OPTIONS_JSON: ${{ inputs.options_json }}
        with:
          github-token: ${{ secrets.service_bot_pat || github.token }}
          script: |
            const parseJson = (raw, fallback) => {
              if (!raw || typeof raw !== 'string') {
                return fallback;
              }
              try {
                return JSON.parse(raw);
              } catch (error) {
                core.warning(`Invalid options_json supplied to keepalive: ${error.message}`);
                return fallback;
              }
            };

            const coerceBool = (value, fallback) => {
              if (typeof value === 'boolean') {
                return value;
              }
              if (typeof value === 'string') {
                const normalized = value.trim().toLowerCase();
                if (normalized === 'true') {
                  return true;
                }
                if (normalized === 'false') {
                  return false;
                }
              }
              return fallback;
            };

            const coerceNumber = (value, fallback, { min } = { min: 0 }) => {
              if (value === null || value === undefined) {
                return fallback;
              }
              const num = Number(value);
              if (!Number.isFinite(num) || num <= (min ?? 0)) {
                return fallback;
              }
              return num;
            };

            const rawOptions = process.env.OPTIONS_JSON || '{}';
            const options = parseJson(rawOptions, {});

            const keepaliveEnabled = coerceBool(
              options.enable_keepalive ?? options.keepalive_enabled,
              true
            );
            if (!keepaliveEnabled) {
              core.info('Codex keepalive disabled via options_json.');
              core.summary.addHeading('Codex Keepalive');
              core.summary.addRaw('Skip requested via options_json.');
              core.summary.write();
              return;
            }

            const idleMinutes = coerceNumber(options.keepalive_idle_minutes, 10, { min: 0 });
            const repeatMinutes = coerceNumber(options.keepalive_repeat_minutes, 30, { min: 0 });

            const labelSource = options.keepalive_labels ?? options.keepalive_label ?? 'agent:codex';
            const targetLabels = String(labelSource)
              .split(',')
              .map((value) => value.trim().toLowerCase())
              .filter(Boolean);
            if (!targetLabels.length) {
              targetLabels.push('agent:codex');
            }

            const commandRaw = options.keepalive_command ?? '@codex plan-and-execute';
            const command = String(commandRaw).trim() || '@codex plan-and-execute';
            const commandLower = command.toLowerCase();

            const markerRaw = options.keepalive_marker ?? '<!-- codex-keepalive -->';
            const marker = String(markerRaw);

            const agentSource = options.keepalive_agent_logins ?? 'chatgpt-codex-connector';
            const agentLogins = String(agentSource)
              .split(',')
              .map((value) => value.trim().toLowerCase())
              .filter(Boolean);
            if (!agentLogins.length) {
              agentLogins.push('chatgpt-codex-connector');
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const now = Date.now();
            const triggered = [];

            const paginatePulls = github.paginate.iterator(
              github.rest.pulls.list,
              { owner, repo, state: 'open', per_page: 50 }
            );

            for await (const page of paginatePulls) {
              for (const pr of page.data) {
                const labelNames = (pr.labels || []).map((label) =>
                  (typeof label === 'string' ? label : label?.name || '').toLowerCase()
                );
                const hasTargetLabel = targetLabels.some((label) => labelNames.includes(label));
                if (!hasTargetLabel) {
                  core.info(`#${pr.number}: skipped – missing required label (${targetLabels.join(', ')}).`);
                  continue;
                }

                const prNumber = pr.number;
                const { data: comments } = await github.rest.issues.listComments({
                  owner,
                  repo,
                  issue_number: prNumber,
                  per_page: 100,
                });
                if (!comments.length) {
                  core.info(`#${prNumber}: skipped – no timeline comments.`);
                  continue;
                }

                const commandComments = comments
                  .filter((comment) => (comment.body || '').toLowerCase().includes(commandLower))
                  .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                if (!commandComments.length) {
                  core.info(`#${prNumber}: skipped – no ${command} command yet.`);
                  continue;
                }

                const botComments = comments
                  .filter((comment) => agentLogins.includes((comment.user?.login || '').toLowerCase()))
                  .sort((a, b) => new Date(a.updated_at || a.created_at) - new Date(b.updated_at || b.created_at));
                if (!botComments.length) {
                  core.info(`#${prNumber}: skipped – Codex has not commented yet.`);
                  continue;
                }

                const lastAgentComment = botComments[botComments.length - 1];
                const lastAgentTs = new Date(lastAgentComment.updated_at || lastAgentComment.created_at).getTime();
                if (!Number.isFinite(lastAgentTs)) {
                  core.info(`#${prNumber}: skipped – unable to parse Codex timestamp.`);
                  continue;
                }

                const minutesSinceAgent = (now - lastAgentTs) / 60000;
                if (minutesSinceAgent < idleMinutes) {
                  core.info(`#${prNumber}: skipped – last Codex activity ${minutesSinceAgent.toFixed(1)} minutes ago (< ${idleMinutes}).`);
                  continue;
                }

                const latestCommandTs = new Date(commandComments[commandComments.length - 1].created_at).getTime();
                if (latestCommandTs > lastAgentTs) {
                  core.info(`#${prNumber}: skipped – waiting for Codex response to the latest command.`);
                  continue;
                }

                const checklistComments = botComments
                  .map((comment) => {
                    const body = comment.body || '';
                    const unchecked = (body.match(/- \[ \]/g) || []).length;
                    const checked = (body.match(/- \[x\]/gi) || []).length;
                    const total = unchecked + checked;
                    return { comment, unchecked, total };
                  })
                  .filter((entry) => entry.total > 0 && entry.unchecked > 0)
                  .sort((a, b) => new Date(b.comment.updated_at || b.comment.created_at) - new Date(a.comment.updated_at || a.comment.created_at));

                if (!checklistComments.length) {
                  core.info(`#${prNumber}: skipped – no Codex checklist with outstanding tasks.`);
                  continue;
                }

                const keepaliveComments = comments
                  .filter((comment) => (comment.body || '').includes(marker))
                  .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                if (keepaliveComments.length) {
                  const lastKeepaliveTs = new Date(keepaliveComments[0].created_at).getTime();
                  const minutesSinceKeepalive = (now - lastKeepaliveTs) / 60000;
                  if (minutesSinceKeepalive < repeatMinutes) {
                    core.info(`#${prNumber}: skipped – keepalive sent ${minutesSinceKeepalive.toFixed(1)} minutes ago (< ${repeatMinutes}).`);
                    continue;
                  }
                }

                const bodyParts = [command];
                if (marker) {
                  bodyParts.push('', marker);
                }
                const body = bodyParts.join('\n');
                await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
                const outstanding = checklistComments[0].unchecked;
                triggered.push(`#${prNumber} – keepalive posted (remaining tasks: ${outstanding})`);
                core.info(`#${prNumber}: keepalive posted (remaining tasks: ${outstanding}).`);
              }
            }

            core.summary.addHeading('Codex Keepalive');
            if (triggered.length) {
              core.summary.addList(triggered);
            } else {
              core.summary.addRaw('No unattended Codex tasks detected.');
            }
            core.summary.write();
