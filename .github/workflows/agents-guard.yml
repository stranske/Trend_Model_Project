# Protects the agents workflow suite. This guard runs on pull_request for normal
# checks and on pull_request_target to apply safety gates before any privileged
# context is used. Do not remove the safety step â€“ it ensures we never checkout
# untrusted refs or log repository secrets when running with elevated tokens.
name: Health 45 Agents Guard

on:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
  pull_request_target:
    types:
      - labeled
      - unlabeled

permissions:
  contents: read
  pull-requests: write
  statuses: write

concurrency:
  group: agents-guard-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  guard:
    name: Enforce agents workflow protections
    runs-on: ubuntu-latest

    steps:
      - name: Checkout base ref for safety validation
        if: github.event_name == 'pull_request_target'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.sha }}
          sparse-checkout: |
            .github/scripts/agents-guard.js

      - name: Verify pull_request_target safety invariants
        if: github.event_name == 'pull_request_target'
        uses: actions/github-script@v7
        with:
          script: |
            const path = require('path');
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const guardPath = path.resolve(workspace, '.github/scripts/agents-guard.js');
            const { validatePullRequestTargetSafety } = require(guardPath);

            validatePullRequestTargetSafety({
              eventName: context.eventName,
              workflowPath: '.github/workflows/agents-guard.yml',
              workspaceRoot: workspace,
            });

      - name: Checkout PR head for pull_request event
        if: github.event_name == 'pull_request'
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts/agents-guard.js

      - name: Evaluate protected file changes
        id: evaluate
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const guardRelativePath = '.github/scripts/agents-guard.js';
            const guardPath = path.resolve(workspace, guardRelativePath);
            const prNumber = context.payload.pull_request.number;
            const authorLogin = context.payload.pull_request.user && context.payload.pull_request.user.login;
            const { owner, repo } = context.repo;
            const baseRef = context.payload.pull_request.base.sha;
            const labelName = 'agents:allow-change';
            const protectedPaths = [
              '.github/workflows/agents-*.yml',
            ];

            async function loadGuardModule() {
              if (fs.existsSync(guardPath)) {
                return require(guardPath);
              }

              core.info(`Guard script missing locally; fetching ${guardRelativePath} at ${baseRef}`);
              const response = await github.rest.repos.getContent({
                owner,
                repo,
                path: guardRelativePath,
                ref: baseRef,
              });

              if (Array.isArray(response.data) || response.data.type !== 'file') {
                throw new Error(`Unable to load ${guardRelativePath} from ${baseRef}`);
              }

              const encoding = response.data.encoding || 'base64';
              const source = Buffer.from(response.data.content || '', encoding).toString('utf-8');

              fs.mkdirSync(path.dirname(guardPath), { recursive: true });
              fs.writeFileSync(guardPath, source, { encoding: 'utf-8' });
              return require(guardPath);
            }

            const guardModule = await loadGuardModule();
            const { evaluateGuard, DEFAULT_MARKER } = guardModule;
            const marker = DEFAULT_MARKER || '<!-- agents-guard-marker -->';

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            let codeownersContent = '';
            try {
              const response = await github.rest.repos.getContent({
                owner,
                repo,
                path: '.github/CODEOWNERS',
                ref: baseRef,
              });

              if (!Array.isArray(response.data) && response.data.type === 'file') {
                const encoding = response.data.encoding || 'utf-8';
                const rawContent = response.data.content || '';
                codeownersContent = Buffer.from(rawContent, encoding).toString('utf-8');
              }
            } catch (error) {
              core.warning(`Failed to load CODEOWNERS: ${error.message}`);
            }

            const result = evaluateGuard({
              files,
              labels,
              reviews,
              codeownersContent,
              protectedPaths,
              labelName,
              authorLogin,
              marker,
            });

            core.setOutput('blocked', result.blocked ? 'true' : 'false');
            core.setOutput('summary', result.summary);
            core.setOutput('marker', marker);

            if (result.commentBody) {
              core.setOutput('comment_body_b64', Buffer.from(result.commentBody).toString('base64'));
            }

            for (const warning of result.warnings || []) {
              core.warning(warning);
            }

      - name: Post guard failure comment
        if: steps.evaluate.outputs.blocked == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_BODY_B64: ${{ steps.evaluate.outputs.comment_body_b64 }}
          COMMENT_MARKER: ${{ steps.evaluate.outputs.marker }}
        with:
          script: |
            const path = require('path');
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const guardPath = path.resolve(workspace, '.github/scripts/agents-guard.js');

            let defaultMarker = '<!-- agents-guard-marker -->';
            try {
              const loaded = require(guardPath);
              if (loaded && typeof loaded.DEFAULT_MARKER === 'string' && loaded.DEFAULT_MARKER.trim()) {
                defaultMarker = loaded.DEFAULT_MARKER.trim();
              }
            } catch (error) {
              core.warning(`Failed to load guard marker; using default: ${error.message}`);
            }

            const marker = (process.env.COMMENT_MARKER || '').trim() || defaultMarker;
            if (!marker) {
              core.warning('Resolved guard marker is empty; comment updates may duplicate.');
            }
            const body = Buffer.from(process.env.COMMENT_BODY_B64 || '', 'base64').toString('utf-8');
            if (!body) {
              core.warning('No comment body was provided.');
              return;
            }

            const markedBody = marker && !body.includes(marker)
              ? `${marker}\n\n${body}`
              : body;

            const prNumber = context.payload.pull_request.number;
            const { owner, repo } = context.repo;

            const existingComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const alreadyPosted = marker
              ? existingComments.find((comment) => comment.body && comment.body.includes(marker))
              : null;
            if (alreadyPosted) {
              if (alreadyPosted.body !== markedBody) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: alreadyPosted.id,
                  body: markedBody,
                });
              }
              return;
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: markedBody,
            });

      - name: Report agents guard commit status
        if: always()
        uses: actions/github-script@v7
        env:
          BLOCKED: ${{ steps.evaluate.outputs.blocked || 'false' }}
          SUMMARY: ${{ steps.evaluate.outputs.summary }}
          TARGET_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pullRequest = context.payload.pull_request;
            const sha = pullRequest?.head?.sha || context.sha;

            if (!sha) {
              core.info('Head SHA unavailable; skipping commit status update.');
              return;
            }

            const blocked = (process.env.BLOCKED || '').toLowerCase() === 'true';
            const summary = process.env.SUMMARY || '';
            let state = blocked ? 'failure' : 'success';
            let description = summary || (blocked
              ? 'Health 45 Agents Guard blocked this pull request.'
              : 'Health 45 Agents Guard passed.');

            if (description.length > 140) {
              description = `${description.slice(0, 137)}...`;
            }

            const targetUrl = process.env.TARGET_URL || `${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`;

            try {
              await github.rest.repos.createCommitStatus({
                owner,
                repo,
                sha,
                state,
                context: 'Health 45 Agents Guard / Enforce agents workflow protections',
                description,
                target_url: targetUrl,
              });
              core.info(`Updated Health 45 Agents Guard commit status to ${state}.`);
            } catch (error) {
              core.warning(`Failed to update Health 45 Agents Guard commit status: ${error.message}`);
            }

      - name: Fail when guard blocks the pull request
        if: steps.evaluate.outputs.blocked == 'true'
        run: |
          echo "${{ steps.evaluate.outputs.summary }}"
          exit 1
