name: Agents Guard

on:
  pull_request:
    types:
      - opened
      - reopened
      - synchronize
      - ready_for_review
    paths:
      - 'agents/**'
      - '.github/workflows/agents-*.yml'
      - '.github/scripts/agents-guard.js'
    paths-ignore:
      - 'agents/**/__snapshots__/**'
  pull_request_target:
    types:
      - labeled
      - unlabeled

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: agents-guard-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  guard:
    if: >-
      ${{ github.event_name == 'pull_request' || startsWith(github.event.label.name || '', 'agent:') }}
    name: Enforce agents workflow protections
    runs-on: ubuntu-latest

    steps:
      - name: Evaluate protected file changes
        id: evaluate
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const guardRelativePath = '.github/scripts/agents-guard.js';
            const guardPath = path.resolve(workspace, guardRelativePath);
            const prNumber = context.payload.pull_request.number;
            const { owner, repo } = context.repo;
            const baseRef = context.payload.pull_request.base.sha;
            const labelName = 'agents:allow-change';
            const protectedPaths = [
              '.github/workflows/agents-63-chatgpt-issue-sync.yml',
              '.github/workflows/agents-63-codex-issue-bridge.yml',
              '.github/workflows/agents-70-orchestrator.yml',
            ];

            async function loadGuardModule() {
              if (fs.existsSync(guardPath)) {
                return require(guardPath);
              }

              core.info(`Guard script missing locally; fetching ${guardRelativePath} at ${baseRef}`);
              const response = await github.rest.repos.getContent({
                owner,
                repo,
                path: guardRelativePath,
                ref: baseRef,
              });

              if (Array.isArray(response.data) || response.data.type !== 'file') {
                throw new Error(`Unable to load ${guardRelativePath} from ${baseRef}`);
              }

              const encoding = response.data.encoding || 'base64';
              const source = Buffer.from(response.data.content || '', encoding).toString('utf-8');

              fs.mkdirSync(path.dirname(guardPath), { recursive: true });
              fs.writeFileSync(guardPath, source, { encoding: 'utf-8' });
              return require(guardPath);
            }

            const guardModule = await loadGuardModule();
            const { evaluateGuard, DEFAULT_MARKER } = guardModule;
            const marker = DEFAULT_MARKER || '<!-- agents-guard-marker -->';

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            let codeownersContent = '';
            try {
              const response = await github.rest.repos.getContent({
                owner,
                repo,
                path: '.github/CODEOWNERS',
                ref: baseRef,
              });

              if (!Array.isArray(response.data) && response.data.type === 'file') {
                const encoding = response.data.encoding || 'utf-8';
                const rawContent = response.data.content || '';
                codeownersContent = Buffer.from(rawContent, encoding).toString('utf-8');
              }
            } catch (error) {
              core.warning(`Failed to load CODEOWNERS: ${error.message}`);
            }

            const result = evaluateGuard({
              files,
              labels,
              reviews,
              codeownersContent,
              protectedPaths,
              labelName,
              marker,
            });

            core.setOutput('blocked', result.blocked ? 'true' : 'false');
            core.setOutput('summary', result.summary);
            core.setOutput('marker', marker);

            if (result.commentBody) {
              core.setOutput('comment_body_b64', Buffer.from(result.commentBody).toString('base64'));
            }

            for (const warning of result.warnings || []) {
              core.warning(warning);
            }

      - name: Post guard failure comment
        if: steps.evaluate.outputs.blocked == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_BODY_B64: ${{ steps.evaluate.outputs.comment_body_b64 }}
          COMMENT_MARKER: ${{ steps.evaluate.outputs.marker }}
        with:
          script: |
            const path = require('path');
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const guardPath = path.resolve(workspace, '.github/scripts/agents-guard.js');

            let defaultMarker = '<!-- agents-guard-marker -->';
            try {
              const loaded = require(guardPath);
              if (loaded && typeof loaded.DEFAULT_MARKER === 'string' && loaded.DEFAULT_MARKER.trim()) {
                defaultMarker = loaded.DEFAULT_MARKER.trim();
              }
            } catch (error) {
              core.warning(`Failed to load guard marker; using default: ${error.message}`);
            }

            const marker = (process.env.COMMENT_MARKER || '').trim() || defaultMarker;
            if (!marker) {
              core.warning('Resolved guard marker is empty; comment updates may duplicate.');
            }
            const body = Buffer.from(process.env.COMMENT_BODY_B64 || '', 'base64').toString('utf-8');
            if (!body) {
              core.warning('No comment body was provided.');
              return;
            }

            const markedBody = marker && !body.includes(marker)
              ? `${marker}\n\n${body}`
              : body;

            const prNumber = context.payload.pull_request.number;
            const { owner, repo } = context.repo;

            const existingComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const alreadyPosted = marker
              ? existingComments.find((comment) => comment.body && comment.body.includes(marker))
              : null;
            if (alreadyPosted) {
              if (alreadyPosted.body !== markedBody) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: alreadyPosted.id,
                  body: markedBody,
                });
              }
              return;
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: markedBody,
            });

      - name: Fail when guard blocks the pull request
        if: steps.evaluate.outputs.blocked == 'true'
        run: |
          echo "${{ steps.evaluate.outputs.summary }}"
          exit 1
