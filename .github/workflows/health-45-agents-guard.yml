name: Health 45 Agents Guard

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - labeled
      - unlabeled
      - ready_for_review
  workflow_dispatch: {}

permissions:
  contents: read
  pull-requests: write

jobs:
  guard:
    name: Enforce agents workflow protections
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate protected file changes
        id: evaluate
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const guardRelativePath = '.github/scripts/health-45-guard.js';
            const guardPath = path.resolve(workspace, guardRelativePath);
            const marker = '<!-- health-45-agents-guard -->';
            const prNumber = context.payload.pull_request.number;
            const { owner, repo } = context.repo;
            const baseRef = context.payload.pull_request.base.sha;
            const labelName = 'agents:allow-change';
            const protectedPaths = [
              '.github/workflows/agents-63-chatgpt-issue-sync.yml',
              '.github/workflows/agents-63-codex-issue-bridge.yml',
              '.github/workflows/agents-70-orchestrator.yml',
            ];

            async function loadGuardModule() {
              if (fs.existsSync(guardPath)) {
                return require(guardPath);
              }

              core.info(`Guard script missing locally; fetching ${guardRelativePath} at ${baseRef}`);
              const response = await github.rest.repos.getContent({
                owner,
                repo,
                path: guardRelativePath,
                ref: baseRef,
              });

              if (Array.isArray(response.data) || response.data.type !== 'file') {
                throw new Error(`Unable to load ${guardRelativePath} from ${baseRef}`);
              }

              const encoding = response.data.encoding || 'base64';
              const source = Buffer.from(response.data.content || '', encoding).toString('utf-8');

              fs.mkdirSync(path.dirname(guardPath), { recursive: true });
              fs.writeFileSync(guardPath, source, { encoding: 'utf-8' });
              return require(guardPath);
            }

            const { evaluateGuard } = await loadGuardModule();

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            let codeownersContent = '';
            try {
              const response = await github.rest.repos.getContent({
                owner,
                repo,
                path: '.github/CODEOWNERS',
                ref: baseRef,
              });

              if (!Array.isArray(response.data) && response.data.type === 'file') {
                const encoding = response.data.encoding || 'utf-8';
                const rawContent = response.data.content || '';
                codeownersContent = Buffer.from(rawContent, encoding).toString('utf-8');
              }
            } catch (error) {
              core.warning(`Failed to load CODEOWNERS: ${error.message}`);
            }

            const result = evaluateGuard({
              files,
              labels,
              reviews,
              codeownersContent,
              protectedPaths,
              labelName,
              marker,
            });

            core.setOutput('blocked', result.blocked ? 'true' : 'false');
            core.setOutput('summary', result.summary);
            core.setOutput('marker', marker);

            if (result.commentBody) {
              core.setOutput('comment_body_b64', Buffer.from(result.commentBody).toString('base64'));
            }

            for (const warning of result.warnings || []) {
              core.warning(warning);
            }
      - name: Post guard failure comment
        if: steps.evaluate.outputs.blocked == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_BODY_B64: ${{ steps.evaluate.outputs.comment_body_b64 }}
          COMMENT_MARKER: ${{ steps.evaluate.outputs.marker }}
        with:
          script: |
            const marker = process.env.COMMENT_MARKER;
            const body = Buffer.from(process.env.COMMENT_BODY_B64 || '', 'base64').toString('utf-8');
            if (!body) {
              core.warning('No comment body was provided.');
              return;
            }

            const prNumber = context.payload.pull_request.number;
            const { owner, repo } = context.repo;

            const existingComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const alreadyPosted = existingComments.find((comment) => comment.body && comment.body.includes(marker));
            if (alreadyPosted) {
              if (alreadyPosted.body !== body) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: alreadyPosted.id,
                  body,
                });
              }
              return;
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body,
            });

      - name: Fail when guard blocks the pull request
        if: steps.evaluate.outputs.blocked == 'true'
        run: |
          echo "${{ steps.evaluate.outputs.summary }}"
          exit 1

  publish-stable-contexts:
    name: Publish stable status contexts
    runs-on: ubuntu-latest
    needs: guard
    permissions:
      checks: write
      contents: read
    steps:
      - name: Create stable status contexts
        uses: actions/github-script@v7
        with:
          script: |
            // Two canonical contexts to satisfy branch protection rules that
            // may reference either the raw job name or a composite label.
            const contexts = [
              'Enforce agents workflow protections',
              'Health 45 Agents Guard / Enforce agents workflow protections'
            ];

            const { owner, repo } = context.repo;
            const sha = context.payload.pull_request?.head?.sha || process.env.GITHUB_SHA;

            for (const ctx of contexts) {
              try {
                await github.rest.checks.create({
                  owner,
                  repo,
                  name: ctx,
                  head_sha: sha,
                  status: 'completed',
                  conclusion: 'success',
                  output: {
                    title: ctx,
                    summary: 'Stable status context emitted by Health 45 guard to satisfy branch protection.',
                  },
                });
                core.info(`Published stable context: ${ctx}`);
              } catch (err) {
                core.warning(`Failed to publish context ${ctx}: ${err.message}`);
              }
            }
