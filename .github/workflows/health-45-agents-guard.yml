name: Health 45 Agents Guard

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - labeled
      - unlabeled
      - ready_for_review
    paths:
      - '.github/workflows/agents-*.yml'
      - '.github/workflows/health-45-agents-guard.yml'
      - '.github/scripts/health-45-guard.js'

permissions:
  contents: read
  pull-requests: write

jobs:
  guard:
    name: Enforce agents workflow protections
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate protected file changes
        id: evaluate
        uses: actions/github-script@v7
        with:
          script: |
            const path = require('path');
            const Module = require('module');
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const guardRelativePath = '.github/scripts/health-45-guard.js';
            const guardPath = path.resolve(workspace, guardRelativePath);
            const marker = '<!-- health-45-agents-guard -->';
            const prNumber = context.payload.pull_request.number;
            const { owner, repo } = context.repo;
            const baseRef = context.payload.pull_request.base.sha;
            const labelName = 'agents:allow-change';
            const protectedPaths = [
              '.github/workflows/agents-63-chatgpt-issue-sync.yml',
              '.github/workflows/agents-63-codex-issue-bridge.yml',
              '.github/workflows/agents-70-orchestrator.yml',
            ];

            async function loadGuardModule() {
              if (Module._cache[guardPath]) {
                return Module._cache[guardPath].exports;
              }

              try {
                return require(guardPath);
              } catch (error) {
                if (error.code !== 'MODULE_NOT_FOUND') {
                  throw error;
                }

                core.info(`Guard script missing locally; fetching ${guardRelativePath} at ${baseRef}`);
                const response = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: guardRelativePath,
                  ref: baseRef,
                });

                if (Array.isArray(response.data) || response.data.type !== 'file') {
                  throw new Error(`Unable to load ${guardRelativePath} from ${baseRef}`);
                }

                const encoding = response.data.encoding || 'base64';
                const source = Buffer.from(response.data.content || '', encoding).toString('utf-8');

                const guardModule = new Module(guardPath, module.parent || module);
                guardModule.filename = guardPath;
                guardModule.paths = Module._nodeModulePaths(path.dirname(guardPath));
                guardModule._compile(source, guardPath);
                Module._cache[guardPath] = guardModule;
                return guardModule.exports;
              }
            }

            const { evaluateGuard } = await loadGuardModule();

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            let codeownersContent = '';
            try {
              const response = await github.rest.repos.getContent({
                owner,
                repo,
                path: '.github/CODEOWNERS',
                ref: baseRef,
              });

              if (!Array.isArray(response.data) && response.data.type === 'file') {
                const encoding = response.data.encoding || 'utf-8';
                const rawContent = response.data.content || '';
                codeownersContent = Buffer.from(rawContent, encoding).toString('utf-8');
              }
            } catch (error) {
              core.warning(`Failed to load CODEOWNERS: ${error.message}`);
            }

            const result = evaluateGuard({
              files,
              labels,
              reviews,
              codeownersContent,
              protectedPaths,
              labelName,
              marker,
            });

            core.setOutput('blocked', result.blocked ? 'true' : 'false');
            core.setOutput('summary', result.summary);
            core.setOutput('marker', marker);

            if (result.commentBody) {
              core.setOutput('comment_body_b64', Buffer.from(result.commentBody).toString('base64'));
            }

            for (const warning of result.warnings || []) {
              core.warning(warning);
            }
      - name: Post guard failure comment
        if: steps.evaluate.outputs.blocked == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_BODY_B64: ${{ steps.evaluate.outputs.comment_body_b64 }}
          COMMENT_MARKER: ${{ steps.evaluate.outputs.marker }}
        with:
          script: |
            const marker = process.env.COMMENT_MARKER;
            const body = Buffer.from(process.env.COMMENT_BODY_B64 || '', 'base64').toString('utf-8');
            if (!body) {
              core.warning('No comment body was provided.');
              return;
            }

            const prNumber = context.payload.pull_request.number;
            const { owner, repo } = context.repo;

            const existingComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const alreadyPosted = existingComments.find((comment) => comment.body && comment.body.includes(marker));
            if (alreadyPosted) {
              if (alreadyPosted.body !== body) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: alreadyPosted.id,
                  body,
                });
              }
              return;
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body,
            });
      - name: Fail when guard blocks the pull request
        if: steps.evaluate.outputs.blocked == 'true'
        run: |
          echo "${{ steps.evaluate.outputs.summary }}"
          exit 1
