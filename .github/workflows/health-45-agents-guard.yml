name: Health 45 Agents Guard

on:
  pull_request_target:
    types:
      - opened
      - reopened
      - synchronize
      - labeled
      - unlabeled
      - ready_for_review
    paths:
      - '.github/workflows/agents-*.yml'

permissions:
  contents: read
  pull-requests: write

jobs:
  guard:
    name: Enforce agents workflow protections
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate protected file changes
        id: evaluate
        uses: actions/github-script@v7
        with:
          script: |
            const marker = '<!-- health-45-agents-guard -->';
            const prNumber = context.payload.pull_request.number;
            const { owner, repo } = context.repo;
            const labelName = 'agents:allow-change';
            const protectedPaths = new Set([
              '.github/workflows/agents-63-chatgpt-issue-sync.yml',
              '.github/workflows/agents-63-codex-issue-bridge.yml',
              '.github/workflows/agents-70-orchestrator.yml',
            ]);

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });

            const relevantFiles = files.filter((file) => {
              if (file.filename.startsWith('.github/workflows/agents-')) {
                return true;
              }
              if (file.previous_filename && file.previous_filename.startsWith('.github/workflows/agents-')) {
                return true;
              }
              return false;
            });

            const fatalViolations = [];
            const modifiedProtectedPaths = new Set();
            for (const file of relevantFiles) {
              const current = file.filename;
              const previous = file.previous_filename;

              if (protectedPaths.has(current) || (previous && protectedPaths.has(previous))) {
                if (file.status === 'removed') {
                  fatalViolations.push(`• ${current} was deleted.`);
                  continue;
                }

                if (file.status === 'renamed' && previous) {
                  fatalViolations.push(`• ${previous} was renamed to ${current}.`);
                  continue;
                }

                if (file.status === 'modified') {
                  modifiedProtectedPaths.add(current);
                }
              }
            }

            const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });
            const hasAllowLabel = labels.some((label) => label.name.toLowerCase() === labelName);

            const reviews = await github.paginate(github.rest.pulls.listReviews, {
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100,
            });
            const latestReviewStates = new Map();
            for (const review of reviews) {
              if (!review.user || !review.user.login) {
                continue;
              }
              latestReviewStates.set(review.user.login.toLowerCase(), review.state.toUpperCase());
            }

            const approvedLogins = new Set(
              [...latestReviewStates.entries()]
                .filter(([, state]) => state === 'APPROVED')
                .map(([login]) => login)
            );

            async function loadCodeowners(ref) {
              try {
                const response = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: '.github/CODEOWNERS',
                  ref,
                });

                if (Array.isArray(response.data)) {
                  return '';
                }

                if (response.data.type !== 'file') {
                  return '';
                }

                const encoding = response.data.encoding || 'utf-8';
                return Buffer.from(response.data.content, encoding).toString('utf-8');
              } catch (error) {
                core.warning(`Failed to load CODEOWNERS: ${error.message}`);
                return '';
              }
            }

            function escapeRegex(text) {
              return text.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            }

            function globToRegExp(glob) {
              let result = '';
              let i = 0;
              while (i < glob.length) {
                const char = glob[i];
                if (char === '*') {
                  const nextChar = glob[i + 1];
                  if (nextChar === '*') {
                    result += '.*';
                    i += 2;
                  } else {
                    result += '[^/]*';
                    i += 1;
                  }
                } else if (char === '?') {
                  result += '[^/]';
                  i += 1;
                } else {
                  result += escapeRegex(char);
                  i += 1;
                }
              }
              return new RegExp(`^${result}$`);
            }

            function normalizePattern(pattern) {
              return pattern.replace(/^\/+/, '');
            }

            function parseCodeowners(content) {
              const entries = [];
              const lines = content.split(/\r?\n/);
              for (const rawLine of lines) {
                const line = rawLine.trim();
                if (!line || line.startsWith('#')) {
                  continue;
                }
                const parts = line.split(/\s+/).filter(Boolean);
                if (parts.length < 2) {
                  continue;
                }
                const pattern = parts[0];
                const normalized = normalizePattern(pattern);
                const owners = parts.slice(1);
                entries.push({
                  pattern,
                  owners,
                  regex: globToRegExp(normalized),
                });
              }
              return entries;
            }

            function findCodeowners(entries, filePath) {
              const normalizedPath = filePath.replace(/^\/+/, '');
              let owners = [];
              for (const entry of entries) {
                if (entry.regex.test(normalizedPath)) {
                  owners = entry.owners;
                }
              }
              return owners;
            }

            const baseRef = context.payload.pull_request.base.sha;
            const codeownersContent = await loadCodeowners(baseRef);
            const codeownerEntries = parseCodeowners(codeownersContent);
            const codeownerLogins = new Set();
            for (const path of protectedPaths) {
              const owners = findCodeowners(codeownerEntries, path);
              for (const ownerSlug of owners) {
                if (!ownerSlug.startsWith('@')) {
                  continue;
                }
                const name = ownerSlug.slice(1);
                if (!name) {
                  continue;
                }
                if (name.includes('/')) {
                  core.debug(`Skipping team CODEOWNER ${ownerSlug} for ${path}.`);
                  continue;
                }
                codeownerLogins.add(name.toLowerCase());
              }
            }

            const hasCodeownerApproval = [...codeownerLogins].some((login) => approvedLogins.has(login));

            const needsLabel = modifiedProtectedPaths.size > 0 && !hasAllowLabel;
            const needsApproval = modifiedProtectedPaths.size > 0 && !hasCodeownerApproval;

            const failureReasons = [];
            if (fatalViolations.length > 0) {
              failureReasons.push(...fatalViolations);
            }

            if (modifiedProtectedPaths.size > 0 && (needsLabel || needsApproval)) {
              const modifiedList = [...modifiedProtectedPaths].map((path) => `• ${path}`).join('\n');
              failureReasons.push(`Protected workflows modified:\n${modifiedList}`);
              if (needsLabel) {
                failureReasons.push('Missing `agents:allow-change` label.');
              }
              if (needsApproval) {
                const codeownerHint = codeownerLogins.size > 0
                  ? `Request approval from a CODEOWNER (${[...codeownerLogins].map((login) => `@${login}`).join(', ')}).`
                  : 'Request approval from a CODEOWNER.';
                failureReasons.push(codeownerHint);
              }
            }

            const blocked = failureReasons.length > 0;
            let summary;
            if (blocked) {
              summary = `Health 45 Agents Guard blocked this PR: ${failureReasons[0]}`;
            } else {
              summary = 'Health 45 Agents Guard passed.';
            }

            core.setOutput('blocked', blocked ? 'true' : 'false');
            core.setOutput('summary', summary);
            core.setOutput('marker', marker);

            if (!blocked) {
              return;
            }

            const touchedFiles = relevantFiles.map((file) => {
              if (file.status === 'renamed' && file.previous_filename) {
                return `- ${file.previous_filename} → ${file.filename} (${file.status})`;
              }
              return `- ${file.filename} (${file.status})`;
            }).join('\n');

            const instructions = [];
            if (fatalViolations.length > 0) {
              instructions.push('Restore the deleted or renamed workflows. These files cannot be moved or removed.');
            }
            if (needsLabel) {
              instructions.push('Apply the `agents:allow-change` label to this pull request once the change is justified.');
            }
            if (needsApproval) {
              if (codeownerLogins.size > 0) {
                const ownersList = [...codeownerLogins].map((login) => `@${login}`).join(', ');
                instructions.push(`Ask a CODEOWNER (${ownersList}) to review and approve the change.`);
              } else {
                instructions.push('Ask a CODEOWNER to review and approve the change.');
              }
            }
            instructions.push('Push an update or re-run this workflow after addressing the issues.');

            const commentBody = `${marker}\n**Health 45 Agents Guard** stopped this pull request.\n\n**What we found**\n${failureReasons.map((reason) => `- ${reason}`).join('\n')}\n\n**Next steps**\n${instructions.map((step) => `- ${step}`).join('\n')}\n\n**Files seen in this run**\n${touchedFiles || '- (no files in scope detected)'}`;

            core.setOutput('comment_body_b64', Buffer.from(commentBody).toString('base64'));

            if (fatalViolations.length === 0 && modifiedProtectedPaths.size === 0) {
              core.warning('Guard triggered but no protected file changes were found.');
            }
      - name: Post guard failure comment
        if: steps.evaluate.outputs.blocked == 'true'
        uses: actions/github-script@v7
        env:
          COMMENT_BODY_B64: ${{ steps.evaluate.outputs.comment_body_b64 }}
          COMMENT_MARKER: ${{ steps.evaluate.outputs.marker }}
        with:
          script: |
            const marker = process.env.COMMENT_MARKER;
            const body = Buffer.from(process.env.COMMENT_BODY_B64 || '', 'base64').toString('utf-8');
            if (!body) {
              core.warning('No comment body was provided.');
              return;
            }

            const prNumber = context.payload.pull_request.number;
            const { owner, repo } = context.repo;

            const existingComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const alreadyPosted = existingComments.find((comment) => comment.body && comment.body.includes(marker));
            if (alreadyPosted) {
              if (alreadyPosted.body !== body) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: alreadyPosted.id,
                  body,
                });
              }
              return;
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body,
            });
      - name: Fail when guard blocks the pull request
        if: steps.evaluate.outputs.blocked == 'true'
        run: |
          echo "${{ steps.evaluate.outputs.summary }}"
          exit 1
