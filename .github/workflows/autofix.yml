name: CI Autofix Loop

on:
  pull_request_target:
    types:
      - labeled

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read
  actions: read

concurrency:
  group: ci-autofix-loop-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  autofix:
    name: Trigger bounded autofix branch
    runs-on: ubuntu-latest
    env:
      ACTIONS_BOT_PAT: ${{ secrets.actions_bot_pat != '' && secrets.actions_bot_pat || secrets.ACTIONS_BOT_PAT }}
      ALLOWED_GLOBS: |-
        **/*.py
        **/*.pyi
        requirements.lock
      MAX_ATTEMPTS: '2'
    steps:
      - name: Resolve PR context
        id: context
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const summary = core.summary;
            const maxAttempts = Number(process.env.MAX_ATTEMPTS || '2') || 2;
            const result = {
              should_run: 'false',
              skip_reason: '',
              pr_number: '',
              head_ref: '',
              head_sha: '',
              short_sha: '',
              branch_name: '',
              attempt: '',
              comment_id: '',
              max_attempts: String(maxAttempts),
              workflow_url: '',
              trigger_label: '',
              label_actor: '',
              has_autofix_clean: 'false',
            };

            summary.addHeading('CI autofix loop guard');

            if (context.eventName !== 'pull_request_target') {
              result.skip_reason = 'unsupported-event';
              summary.addRaw('Autofix loop expects a pull_request_target event.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const action = context.payload.action;
            if (action !== 'labeled') {
              result.skip_reason = 'non-label-event';
              summary.addRaw(`Ignoring pull_request_target action "${action}".`).addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const rawLabel = context.payload.label?.name;
            const triggerLabel = typeof rawLabel === 'string' ? rawLabel.toLowerCase() : '';
            result.trigger_label = triggerLabel;
            result.label_actor = String(context.payload.sender?.login || '');

            summary.addRaw(`Trigger label: ${triggerLabel || '(none)'}`).addEOL();

            if (triggerLabel !== 'autofix' && triggerLabel !== 'autofix:clean') {
              result.skip_reason = 'unmatched-label';
              summary.addRaw('Label is not autofix/autofix:clean; skipping.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const prNumber = Number(context.payload.pull_request?.number);
            if (!prNumber) {
              result.skip_reason = 'invalid-pr-number';
              summary.addRaw('Unable to resolve pull request number.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const { owner, repo } = context.repo;
            const prResponse = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const pr = prResponse.data;

            summary.addRaw(`Evaluating PR #${pr.number}: ${pr.title}`).addEOL();

            if (pr.state !== 'open') {
              result.skip_reason = 'pr-closed';
              summary.addRaw('PR is not open; skipping.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            if (pr.draft) {
              result.skip_reason = 'pr-draft';
              summary.addRaw('PR is draft; skipping until ready.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const labelNames = (pr.labels || [])
              .map((label) => {
                if (!label) return '';
                if (typeof label === 'string') return label.toLowerCase();
                if (typeof label.name === 'string') return label.name.toLowerCase();
                return '';
              })
              .filter(Boolean);

            summary.addRaw(`Labels: ${labelNames.join(', ') || '(none)'}`).addEOL();

            const hasAutofixClean = labelNames.includes('autofix:clean');
            result.has_autofix_clean = hasAutofixClean ? 'true' : 'false';

            if (!pr.head || !pr.base || !pr.head.repo || !pr.base.repo) {
              result.skip_reason = 'missing-repo-context';
              summary.addRaw('Unable to determine PR head/base repository.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const sameRepo = pr.head.repo.full_name === pr.base.repo.full_name && pr.head.repo.full_name === `${owner}/${repo}`;
            summary.addRaw(`Same repository PR: ${sameRepo}`).addEOL();

            if (!sameRepo) {
              result.skip_reason = 'fork-pr';
              summary.addRaw('Autofix loop only runs for same-repo branches.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const token = String(process.env.ACTIONS_BOT_PAT || '').trim();
            if (!token) {
              result.skip_reason = 'missing-actions-bot-pat';
              summary.addRaw('ACTIONS_BOT_PAT secret is missing; skipping autofix.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: pr.number,
              per_page: 100,
            });
            const allowedExtensions = ['.py', '.pyi'];
            const pythonFiles = files
              .map((file) => {
                if (!file) return '';
                if (typeof file === 'string') return file;
                if (typeof file.filename === 'string') return file.filename;
                return '';
              })
              .filter(Boolean)
              .filter((filename) => {
                const lower = filename.toLowerCase();
                return allowedExtensions.some((ext) => lower.endsWith(ext));
              });

            const nonPythonFiles = files
              .map((file) => {
                if (!file) return '';
                if (typeof file === 'string') return file;
                if (typeof file.filename === 'string') return file.filename;
                return '';
              })
              .filter(Boolean)
              .filter((filename) => {
                const lower = filename.toLowerCase();
                return !allowedExtensions.some((ext) => lower.endsWith(ext));
              });

            summary.addRaw(`Python files in PR: ${pythonFiles.length}`).addEOL();
            summary.addRaw(`Non-Python files in PR: ${nonPythonFiles.length}`).addEOL();

            if (pythonFiles.length === 0) {
              result.skip_reason = 'no-python-files';
              summary.addRaw('No Python files in PR; skipping autofix loop.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            if (nonPythonFiles.length > 0) {
              summary
                .addRaw(
                  `Note: PR contains non-Python files (${nonPythonFiles.join(', ')}). Autofix will only commit changes to Python files.`
                )
                .addEOL();
            }

            const shortSha = (pr.head.sha || '').slice(0, 7);
            const branchName = `autofix/${pr.number}-${shortSha}`;

            const marker = '<!-- autofix-loop:';
            let previousAttempts = 0;
            let commentId = '';

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: pr.number,
              per_page: 100,
            });

            for (const comment of comments) {
              const body = comment.body || '';
              const markerIndex = body.indexOf(marker);
              if (markerIndex === -1) continue;
              const markerEnd = body.indexOf('-->', markerIndex);
              if (markerEnd === -1) continue;
              const payloadRaw = body.slice(markerIndex + marker.length, markerEnd).trim();
              if (!payloadRaw) continue;
              try {
                const payload = JSON.parse(payloadRaw);
                if (Number(payload.pr) !== pr.number) continue;
                previousAttempts = Number(payload.attempts || payload.attempt || 0) || 0;
                commentId = String(comment.id);
                break;
              } catch (error) {
                core.warning(`Failed to parse autofix marker on comment ${comment.id}: ${error}`);
              }
            }

            summary.addRaw(`Previous attempts: ${previousAttempts}`).addEOL();

            if (previousAttempts >= maxAttempts) {
              result.skip_reason = 'max-attempts-reached';
              summary.addRaw('Maximum autofix attempts reached; skipping.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const attempt = previousAttempts + 1;

            Object.assign(result, {
              should_run: 'true',
              skip_reason: '',
              pr_number: String(pr.number),
              head_ref: pr.head.ref || '',
              head_sha: pr.head.sha || '',
              short_sha: shortSha,
              branch_name: branchName,
              attempt: String(attempt),
              comment_id: commentId,
            });

            summary.addRaw(`Attempt ${attempt} of ${maxAttempts} will run.`).addEOL();
            for (const [key, value] of Object.entries(result)) {
              core.setOutput(key, value);
            }
            await summary.write();

      - name: Ensure ACTIONS_BOT_PAT is configured
        if: steps.context.outputs.should_run == 'true'
        run: |
          if [ -z "${ACTIONS_BOT_PAT}" ]; then
            echo '::error::ACTIONS_BOT_PAT secret is required for autofix pushes.'
            exit 1
          fi

      - name: Skip when guard declined
        if: steps.context.outputs.should_run != 'true'
        run: |
          echo "Autofix loop skipped: ${{ steps.context.outputs.skip_reason || 'no-op' }}"

      - name: Checkout PR head
        if: steps.context.outputs.should_run == 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ env.ACTIONS_BOT_PAT }}
          ref: ${{ steps.context.outputs.head_ref }}
          fetch-depth: 0

      - name: Prepare autofix branch
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          git config user.name "stranske-automation-bot"
          git config user.email "stranske-automation-bot@users.noreply.github.com"
          git checkout -B "${{ steps.context.outputs.branch_name }}" "${{ steps.context.outputs.head_sha }}"

      - name: Extract formatter pins
        if: steps.context.outputs.should_run == 'true'
        id: pins
        run: |
          set -euo pipefail
          python - <<'PY'
          import os
          from pathlib import Path

          env_path = Path('.github/workflows/autofix-versions.env')
          pins = {}
          for line in env_path.read_text(encoding='utf-8').splitlines():
              line = line.strip()
              if not line or line.startswith('#') or '=' not in line:
                  continue
              key, value = line.split('=', 1)
              pins[key.strip()] = value.strip()
          output = os.environ['GITHUB_OUTPUT']
          with open(output, 'a', encoding='utf-8') as handle:
              handle.write(f"ruff={pins.get('RUFF_VERSION', '')}\n")
              handle.write(f"black={pins.get('BLACK_VERSION', '')}\n")
          PY

      - name: Setup Python
        if: steps.context.outputs.should_run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install autofix toolchain
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          python -m venv .venv
          source .venv/bin/activate
          python -m pip install --upgrade pip
          if [ -n "${{ steps.pins.outputs.ruff }}" ]; then
            pip install "ruff==${{ steps.pins.outputs.ruff }}"
          else
            pip install ruff
          fi
          if [ -n "${{ steps.pins.outputs.black }}" ]; then
            pip install "black==${{ steps.pins.outputs.black }}"
          else
            pip install black
          fi

      - name: Apply Ruff import ordering fixes
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          source .venv/bin/activate
          ruff check --select I --fix .

      - name: Apply Ruff lint fixes
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          source .venv/bin/activate
          ruff check --fix .

      - name: Apply Black formatting
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          source .venv/bin/activate
          black .

      - name: Install uv for lockfile management
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Regenerate lockfile if needed
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          if [ ! -f requirements.lock ]; then
            echo "No requirements.lock found; skipping lockfile regeneration."
            exit 0
          fi
          
          # Check if lockfile is out of date by comparing with fresh compile
          echo "Checking lockfile consistency..."
          uv pip compile pyproject.toml > /tmp/requirements.compiled 2>&1 || {
            echo "Warning: uv pip compile failed, skipping lockfile update"
            exit 0
          }
          
          # Normalize and compare (using same logic as test)
          python - <<'PY'
          import re
          import sys
          from pathlib import Path
          
          def normalize(content):
              lines = []
              for line in content.splitlines():
                  stripped = line.strip()
                  if not stripped:
                      continue
                  if stripped.startswith("#"):
                      if re.match(r"^#.*autogenerated.*by.*", stripped, re.IGNORECASE):
                          continue
                      if re.match(r"^#\s*uv pip compile.*", stripped):
                          lines.append("#    uv pip compile pyproject.toml -o requirements.lock")
                          continue
                      if re.search(r"\d{4}-\d{2}-\d{2}", stripped) or re.search(r"\d{2}:\d{2}", stripped):
                          continue
                      lines.append(stripped)
                  else:
                      lines.append(stripped)
              return "\n".join(lines) + ("\n" if lines else "")
          
          compiled = normalize(Path("/tmp/requirements.compiled").read_text())
          existing = normalize(Path("requirements.lock").read_text())
          
          if compiled == existing:
              print("✓ Lockfile is up to date")
              sys.exit(0)
          else:
              print("✗ Lockfile is out of date - will regenerate")
              sys.exit(1)
          PY
          
          if [ $? -eq 0 ]; then
            echo "Lockfile is current; no update needed."
          else
            echo "Lockfile out of date; regenerating..."
            uv pip compile pyproject.toml -o requirements.lock
            echo "✓ requirements.lock updated"
          fi

      - name: Remove temporary virtualenv
        if: steps.context.outputs.should_run == 'true'
        run: rm -rf .venv

      - name: Detect allowed changes
        if: steps.context.outputs.should_run == 'true'
        id: diff
        run: |
          set -euo pipefail
          mapfile -t files < <(git status --short --untracked-files=no | awk '{print $2}')
          if [ "${#files[@]}" -eq 0 ]; then
            {
              echo "changed=false"
              echo "file_count=0"
              echo "files_json=[]"
            } >>"$GITHUB_OUTPUT"
            exit 0
          fi

          printf '%s\n' "${files[@]}" > .autofix-files.txt
          python - <<'PY'
          import json
          import os
          from pathlib import Path
          from pathlib import PurePosixPath

          files = [line.strip() for line in Path('.autofix-files.txt').read_text(encoding='utf-8').splitlines() if line.strip()]
          allowed_raw = os.environ.get('ALLOWED_GLOBS', '')
          globs = [line.strip() for line in allowed_raw.splitlines() if line.strip()]

          python_files = []
          non_python_files = []
          for file in files:
              path = PurePosixPath(file)
              if any(path.match(pattern) for pattern in globs):
                  python_files.append(file)
              else:
                  non_python_files.append(file)

          output = os.environ['GITHUB_OUTPUT']
          with open(output, 'a', encoding='utf-8') as handle:
              handle.write(f'changed={str(len(python_files) > 0).lower()}\n')
              handle.write(f'file_count={len(python_files)}\n')
              handle.write('files_json=' + json.dumps(python_files) + '\n')
              handle.write('non_python_files_json=' + json.dumps(non_python_files) + '\n')
          
          if non_python_files:
              print(f'Warning: Non-Python files modified but will not be committed: {non_python_files}')
              # Reset non-Python files to avoid committing them
              for file in non_python_files:
                  os.system(f'git checkout HEAD -- {file}')
          
          if not python_files:
              print('No Python files were modified by autofix.')
              exit(0)
          PY

      - name: Commit autofix changes
        if: steps.context.outputs.should_run == 'true' && steps.diff.outputs.changed == 'true'
        run: |
          set -euo pipefail
          git add -A
          git commit -m "chore(autofix): format code and update dependencies"

      - name: Push autofix branch
        if: steps.context.outputs.should_run == 'true' && steps.diff.outputs.changed == 'true'
        run: |
          set -euo pipefail
          git push origin "${{ steps.context.outputs.branch_name }}"

      - name: Update PR comment and labels
        if: steps.context.outputs.should_run == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.context.outputs.pr_number }}
          ATTEMPT: ${{ steps.context.outputs.attempt }}
          MAX_ATTEMPTS: ${{ steps.context.outputs.max_attempts }}
          COMMENT_ID: ${{ steps.context.outputs.comment_id }}
          BRANCH_NAME: ${{ steps.context.outputs.branch_name }}
          HEAD_SHA: ${{ steps.context.outputs.head_sha }}
          WORKFLOW_URL: ${{ steps.context.outputs.workflow_url }}
          RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          FILES_JSON: ${{ steps.diff.outputs.files_json || '[]' }}
          FILE_COUNT: ${{ steps.diff.outputs.file_count || '0' }}
          CHANGED: ${{ steps.diff.outputs.changed || 'false' }}
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER || '0');
            if (!prNumber) {
              core.warning('Missing PR number; skipping comment update.');
              return;
            }
            const attempt = Number(process.env.ATTEMPT || '0');
            const maxAttempts = Number(process.env.MAX_ATTEMPTS || '0') || 2;
            const commentIdRaw = process.env.COMMENT_ID || '';
            const commentId = commentIdRaw ? Number(commentIdRaw) : null;
            const branch = process.env.BRANCH_NAME || '';
            const headSha = process.env.HEAD_SHA || '';
            const files = JSON.parse(process.env.FILES_JSON || '[]');
            const fileCount = Number(process.env.FILE_COUNT || '0');
            const changed = (process.env.CHANGED || '').toLowerCase() === 'true';
            const workflowUrl = process.env.WORKFLOW_URL || '';
            const runUrl = process.env.RUN_URL || '';

            const { owner, repo } = context.repo;
            const summary = core.summary;
            summary.addHeading('CI autofix loop result');
            summary.addRaw(`PR #${prNumber} · Attempt ${attempt}/${maxAttempts}`).addEOL();
            summary.addRaw(`Branch: ${branch}`).addEOL();
            summary.addRaw(`Head: ${headSha.slice(0, 7)}`).addEOL();
            summary.addRaw(changed ? `Files changed: ${fileCount}` : 'No changes produced.').addEOL();
            if (files.length) {
              summary.addList(files.map((file) => `\`${file}\``));
            }
            await summary.write();

            const lines = [];
            lines.push(`Autofix attempt ${attempt}/${maxAttempts} for PR #${prNumber}.`);
            lines.push('');
            if (workflowUrl) {
              lines.push(`- Trigger: [upstream CI run](${workflowUrl})`);
            } else {
              lines.push(`- Trigger: [autofix workflow run](${runUrl})`);
            }
            if (branch) {
              lines.push(`- Branch: \`${branch}\``);
            }
            if (headSha) {
              lines.push(`- Head SHA: \`${headSha.slice(0, 7)}\``);
            }
            lines.push(`- Result: ${changed ? `pushed ${fileCount} file${fileCount === 1 ? '' : 's'}` : 'no changes required'}`);
            if (files.length) {
              lines.push('- Files touched:');
              lines.push('');
              for (const file of files) {
                lines.push(`  - \`${file}\``);
              }
            }
            lines.push('');
            const markerPayload = {
              pr: prNumber,
              attempts: attempt,
              max_attempts: maxAttempts,
              head: headSha,
              branch,
              workflow_run: github.runId,
              workflow_url: runUrl,
              upstream_url: workflowUrl,
              updated_at: new Date().toISOString(),
            };
            lines.push(`<!-- autofix-loop:${JSON.stringify(markerPayload)} -->`);
            const body = lines.join('\n');

            if (commentId) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: commentId, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
            }

      - name: Remove autofix labels after success
        if: steps.context.outputs.should_run == 'true' && steps.diff.outputs.changed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number(core.getInput('pr_number'));
            if (!prNumber) {
              core.warning('Missing PR number; skipping label removal.');
              return;
            }

            const { owner, repo } = context.repo;
            const labels = ['autofix', 'autofix:clean'];
            for (const name of labels) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name });
                core.info(`Removed ${name} label.`);
              } catch (error) {
                if (error.status !== 404) {
                  core.warning(`Failed to remove ${name}: ${error}`);
                }
              }
            }
          pr_number: ${{ steps.context.outputs.pr_number }}

      - name: Update keepalive checklist
        if: steps.context.outputs.should_run == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.context.outputs.pr_number }}
          HEAD_SHA: ${{ steps.context.outputs.head_sha }}
          TRIGGER_LABEL: ${{ steps.context.outputs.trigger_label }}
          LABEL_ACTOR: ${{ steps.context.outputs.label_actor }}
          HAS_AUTOFIX_CLEAN: ${{ steps.context.outputs.has_autofix_clean }}
          FILES_JSON: ${{ steps.diff.outputs.files_json || '[]' }}
          FILE_COUNT: ${{ steps.diff.outputs.file_count || '0' }}
          CHANGED: ${{ steps.diff.outputs.changed || 'false' }}
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const { upsertAnchoredComment } = require('./.github/scripts/comment-dedupe.js');

            const toBool = (value) => String(value || '').trim().toLowerCase() === 'true';

            const prNumber = Number(process.env.PR_NUMBER || '0');
            if (!prNumber) {
              core.info('No PR number available for keepalive update.');
              return;
            }

            const headSha = (process.env.HEAD_SHA || '').slice(0, 12);
            const files = JSON.parse(process.env.FILES_JSON || '[]');
            const changed = toBool(process.env.CHANGED);
            const triggerLabel = (process.env.TRIGGER_LABEL || '').toLowerCase();
            const labelActor = (process.env.LABEL_ACTOR || '').toLowerCase();
            const hasAutofixClean = toBool(process.env.HAS_AUTOFIX_CLEAN);
            const autoActor = labelActor === 'github-actions' || labelActor === 'github-actions[bot]';

            const acceptance1 =
              (triggerLabel === 'autofix:clean' && autoActor) ||
              hasAutofixClean;
            const acceptance2 = changed;
            const acceptance3 = files.every((file) => {
              const lower = file.toLowerCase();
              return lower.endsWith('.py') || lower.endsWith('.pyi');
            });

            // Fetch PR body to extract scope/tasks/acceptance from auto-status-summary
            const { owner, repo } = context.repo;
            const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const prBody = pr.data.body || '';
            
            // Extract content from <!-- auto-status-summary:start --> to <!-- auto-status-summary:end -->
            const summaryMatch = prBody.match(/<!-- auto-status-summary:start -->([\\s\\S]*?)<!-- auto-status-summary:end -->/);
            
            const lines = [];
            const anchor = `<!-- keepalive-checklist: pr=${prNumber}${headSha ? ` head=${headSha}` : ''} -->`;
            lines.push(anchor, '### Keepalive checklist', '');
            
            if (summaryMatch && summaryMatch[1]) {
              const summarySection = summaryMatch[1].trim();
              
              // Extract Scope section
              const scopeMatch = summarySection.match(/#### Scope\\s+([\\s\\S]*?)(?=####|$)/);
              if (scopeMatch) {
                const scopeLines = scopeMatch[1].trim().split('\\n');
                lines.push('#### Scope');
                scopeLines.forEach(line => lines.push(line));
                lines.push('');
              }
              
              // Extract Tasks section
              const tasksMatch = summarySection.match(/#### Tasks\\s+([\\s\\S]*?)(?=####|$)/);
              if (tasksMatch) {
                lines.push('#### Tasks');
                const taskLines = tasksMatch[1].trim().split('\\n');
                taskLines.forEach(line => lines.push(line));
                lines.push('');
              }
              
              // Extract Acceptance criteria section
              const acceptanceMatch = summarySection.match(/#### Acceptance criteria\\s+([\\s\\S]*?)(?=####|\\*\\*Head SHA|$)/);
              if (acceptanceMatch) {
                lines.push('#### Acceptance criteria');
                const acceptanceLines = acceptanceMatch[1].trim().split('\\n');
                acceptanceLines.forEach(line => lines.push(line));
                lines.push('');
              }
            } else {
              // Fallback if auto-status-summary not found
              core.warning('Could not extract auto-status-summary from PR body, using fallback');
              lines.push('#### Scope', '_No scope information available_', '');
              lines.push('#### Tasks', '- [ ] _No tasks defined_', '');
              lines.push('#### Acceptance criteria', '- [ ] _No acceptance criteria defined_', '');
            }

            if (changed) {
              const count = Number(process.env.FILE_COUNT || '0');
              const detail = [`- Autofix changed files: ${files.length ? files.join(', ') : '(none)'}`];
              detail.unshift(`- Autofix job touched ${count} file${count === 1 ? '' : 's'}.`);
              lines.push('#### Status notes', ...detail, '');
            }

            const body = lines.join('\n');
            await upsertAnchoredComment({
              github,
              context,
              core,
              prNumber,
              body,
              anchorPattern: /<!--\s*keepalive-checklist:([^>]*)-->/i,
              fallbackMarker: '<!-- keepalive-checklist:',
            });

      - name: Note absence of changes
        if: steps.context.outputs.should_run == 'true' && steps.diff.outputs.changed != 'true'
        run: echo 'Autofix completed without modifications.'
