name: CI Autofix Loop

on:
  workflow_run:
    workflows:
      - PR 00 Gate
    types:
      - completed

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: read
  actions: read

concurrency:
  group: ci-autofix-loop-${{ github.event.workflow_run.head_branch || github.event.workflow_run.id }}
  cancel-in-progress: false

jobs:
  autofix:
    name: Trigger bounded autofix branch
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'failure'
    env:
      ACTIONS_BOT_PAT: ${{ secrets.actions_bot_pat != '' && secrets.actions_bot_pat || secrets.ACTIONS_BOT_PAT }}
      ALLOWED_GLOBS: |-
        **/*.py
        **/*.pyi
      MAX_ATTEMPTS: '2'
    steps:
      - name: Ensure ACTIONS_BOT_PAT is configured
        run: |
          if [ -z "${ACTIONS_BOT_PAT}" ]; then
            echo '::error::ACTIONS_BOT_PAT secret is required for autofix pushes.'
            exit 1
          fi

      - name: Resolve PR context
        id: context
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const run = context.payload.workflow_run;
            const summary = core.summary;
            const maxAttempts = Number(process.env.MAX_ATTEMPTS || '2') || 2;
            const result = {
              should_run: 'false',
              skip_reason: '',
              pr_number: '',
              head_ref: '',
              head_sha: '',
              short_sha: '',
              branch_name: '',
              attempt: '',
              comment_id: '',
              max_attempts: String(maxAttempts),
              workflow_url: run?.html_url || '',
            };

            summary.addHeading('CI autofix loop guard');

            if (!run) {
              result.skip_reason = 'missing-workflow-run';
              summary.addRaw('No workflow_run payload available; skipping.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const { owner, repo } = context.repo;
            summary.addRaw(`Workflow: ${run.name} (#${run.id})`).addEOL();
            summary.addRaw(`Conclusion: ${run.conclusion || 'unknown'}`).addEOL();
            summary.addRaw(`Event: ${run.event || 'unknown'}`).addEOL();

            if (run.conclusion !== 'failure') {
              result.skip_reason = 'non-failure-conclusion';
              summary.addRaw('Only failure conclusions trigger autofix. Skipping.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            if (!Array.isArray(run.pull_requests) || run.pull_requests.length === 0) {
              result.skip_reason = 'no-associated-pr';
              summary.addRaw('Workflow run not associated with a pull request.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const prNumber = Number(run.pull_requests[0].number);
            if (!prNumber) {
              result.skip_reason = 'invalid-pr-number';
              summary.addRaw('Unable to resolve pull request number.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const prResponse = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const pr = prResponse.data;

            summary.addRaw(`Evaluating PR #${pr.number}: ${pr.title}`).addEOL();

            if (pr.state !== 'open') {
              result.skip_reason = 'pr-closed';
              summary.addRaw('PR is not open; skipping.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            if (pr.draft) {
              result.skip_reason = 'pr-draft';
              summary.addRaw('PR is draft; skipping until ready.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const labelNames = (pr.labels || [])
              .map((label) => {
                if (!label) return '';
                if (typeof label === 'string') return label.toLowerCase();
                if (typeof label.name === 'string') return label.name.toLowerCase();
                return '';
              })
              .filter(Boolean);

            const hasAutofix = labelNames.includes('autofix');
            const hasAgent = labelNames.some((name) => name.startsWith('agent:'));

            summary.addRaw(`Labels: ${labelNames.join(', ') || '(none)'}`).addEOL();
            summary.addRaw(`Has autofix label: ${hasAutofix}`).addEOL();
            summary.addRaw(`Has agent:* label: ${hasAgent}`).addEOL();

            if (!hasAutofix) {
              result.skip_reason = 'missing-autofix-label';
              summary.addRaw('Autofix label not present; skipping.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            if (!hasAgent) {
              result.skip_reason = 'missing-agent-label';
              summary.addRaw('Agent label not present; skipping.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            if (!pr.head || !pr.base || !pr.head.repo || !pr.base.repo) {
              result.skip_reason = 'missing-repo-context';
              summary.addRaw('Unable to determine PR head/base repository.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const sameRepo = pr.head.repo.full_name === pr.base.repo.full_name && pr.head.repo.full_name === `${owner}/${repo}`;
            summary.addRaw(`Same repository PR: ${sameRepo}`).addEOL();

            if (!sameRepo) {
              result.skip_reason = 'fork-pr';
              summary.addRaw('Autofix loop only runs for same-repo branches.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            if (pr.head.sha !== run.head_sha) {
              result.skip_reason = 'head-mismatch';
              summary.addRaw('Workflow run SHA no longer matches PR head; skipping.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const shortSha = (pr.head.sha || '').slice(0, 7);
            const branchName = `autofix/${pr.number}-${shortSha}`;

            const marker = '<!-- autofix-loop:';
            let previousAttempts = 0;
            let commentId = '';

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: pr.number,
              per_page: 100,
            });

            for (const comment of comments) {
              const body = comment.body || '';
              const markerIndex = body.indexOf(marker);
              if (markerIndex === -1) continue;
              const markerEnd = body.indexOf('-->', markerIndex);
              if (markerEnd === -1) continue;
              const payloadRaw = body.slice(markerIndex + marker.length, markerEnd).trim();
              if (!payloadRaw) continue;
              try {
                const payload = JSON.parse(payloadRaw);
                if (Number(payload.pr) !== pr.number) continue;
                previousAttempts = Number(payload.attempts || payload.attempt || 0) || 0;
                commentId = String(comment.id);
                break;
              } catch (error) {
                core.warning(`Failed to parse autofix marker on comment ${comment.id}: ${error}`);
              }
            }

            summary.addRaw(`Previous attempts: ${previousAttempts}`).addEOL();

            if (previousAttempts >= maxAttempts) {
              result.skip_reason = 'max-attempts-reached';
              summary.addRaw('Maximum autofix attempts reached; skipping.').addEOL();
              for (const [key, value] of Object.entries(result)) {
                core.setOutput(key, value);
              }
              await summary.write();
              return;
            }

            const attempt = previousAttempts + 1;

            Object.assign(result, {
              should_run: 'true',
              skip_reason: '',
              pr_number: String(pr.number),
              head_ref: pr.head.ref || '',
              head_sha: pr.head.sha || '',
              short_sha: shortSha,
              branch_name: branchName,
              attempt: String(attempt),
              comment_id: commentId,
            });

            summary.addRaw(`Attempt ${attempt} of ${maxAttempts} will run.`).addEOL();
            for (const [key, value] of Object.entries(result)) {
              core.setOutput(key, value);
            }
            await summary.write();

      - name: Skip when guard declined
        if: steps.context.outputs.should_run != 'true'
        run: |
          echo "Autofix loop skipped: ${{ steps.context.outputs.skip_reason || 'no-op' }}"

      - name: Checkout PR head
        if: steps.context.outputs.should_run == 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ env.ACTIONS_BOT_PAT }}
          ref: ${{ steps.context.outputs.head_ref }}
          fetch-depth: 0

      - name: Prepare autofix branch
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          git config user.name "stranske-automation-bot"
          git config user.email "stranske-automation-bot@users.noreply.github.com"
          git checkout -B "${{ steps.context.outputs.branch_name }}" "${{ steps.context.outputs.head_sha }}"

      - name: Extract formatter pins
        if: steps.context.outputs.should_run == 'true'
        id: pins
        run: |
          set -euo pipefail
          python - <<'PY'
          import os
          from pathlib import Path

          env_path = Path('.github/workflows/autofix-versions.env')
          pins = {}
          for line in env_path.read_text(encoding='utf-8').splitlines():
              line = line.strip()
              if not line or line.startswith('#') or '=' not in line:
                  continue
              key, value = line.split('=', 1)
              pins[key.strip()] = value.strip()
          output = os.environ['GITHUB_OUTPUT']
          with open(output, 'a', encoding='utf-8') as handle:
              handle.write(f"ruff={pins.get('RUFF_VERSION', '')}
")
          PY

      - name: Setup Python
        if: steps.context.outputs.should_run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install autofix toolchain
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          python -m venv .venv
          source .venv/bin/activate
          python -m pip install --upgrade pip
          if [ -n "${{ steps.pins.outputs.ruff }}" ]; then
            pip install "ruff==${{ steps.pins.outputs.ruff }}"
          else
            pip install ruff
          fi

      - name: Apply Ruff import ordering fixes
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          source .venv/bin/activate
          ruff check --select I --fix .

      - name: Apply Ruff formatting
        if: steps.context.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          source .venv/bin/activate
          ruff format .

      - name: Remove temporary virtualenv
        if: steps.context.outputs.should_run == 'true'
        run: rm -rf .venv

      - name: Detect allowed changes
        if: steps.context.outputs.should_run == 'true'
        id: diff
        run: |
          set -euo pipefail
          mapfile -t files < <(git status --short --untracked-files=no | awk '{print $2}')
          if [ "${#files[@]}" -eq 0 ]; then
            {
              echo "changed=false"
              echo "file_count=0"
              echo "files_json=[]"
            } >>"$GITHUB_OUTPUT"
            exit 0
          fi

          printf '%s\n' "${files[@]}" > .autofix-files.txt
          python - <<'PY'
          import json
          import os
          from pathlib import Path
          from pathlib import PurePosixPath

          files = [line.strip() for line in Path('.autofix-files.txt').read_text(encoding='utf-8').splitlines() if line.strip()]
          allowed_raw = os.environ.get('ALLOWED_GLOBS', '')
          globs = [line.strip() for line in allowed_raw.splitlines() if line.strip()]

          disallowed = []
          for file in files:
              path = PurePosixPath(file)
              if not any(path.match(pattern) for pattern in globs):
                  disallowed.append(file)

          output = os.environ['GITHUB_OUTPUT']
          with open(output, 'a', encoding='utf-8') as handle:
              handle.write('changed=true\n')
              handle.write(f'file_count={len(files)}\n')
              handle.write('files_json=' + json.dumps(files) + '\n')
          if disallowed:
              raise SystemExit(f'Detected disallowed file edits: {disallowed}')
          PY

      - name: Commit autofix changes
        if: steps.context.outputs.should_run == 'true' && steps.diff.outputs.changed == 'true'
        run: |
          set -euo pipefail
          git add -A
          git commit -m "chore(autofix): format python imports"

      - name: Push autofix branch
        if: steps.context.outputs.should_run == 'true' && steps.diff.outputs.changed == 'true'
        run: |
          set -euo pipefail
          git push origin "${{ steps.context.outputs.branch_name }}"

      - name: Update PR comment and labels
        if: steps.context.outputs.should_run == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.context.outputs.pr_number }}
          ATTEMPT: ${{ steps.context.outputs.attempt }}
          MAX_ATTEMPTS: ${{ steps.context.outputs.max_attempts }}
          COMMENT_ID: ${{ steps.context.outputs.comment_id }}
          BRANCH_NAME: ${{ steps.context.outputs.branch_name }}
          HEAD_SHA: ${{ steps.context.outputs.head_sha }}
          WORKFLOW_URL: ${{ steps.context.outputs.workflow_url }}
          RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          FILES_JSON: ${{ steps.diff.outputs.files_json || '[]' }}
          FILE_COUNT: ${{ steps.diff.outputs.file_count || '0' }}
          CHANGED: ${{ steps.diff.outputs.changed || 'false' }}
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER || '0');
            if (!prNumber) {
              core.warning('Missing PR number; skipping comment update.');
              return;
            }
            const attempt = Number(process.env.ATTEMPT || '0');
            const maxAttempts = Number(process.env.MAX_ATTEMPTS || '0') || 2;
            const commentIdRaw = process.env.COMMENT_ID || '';
            const commentId = commentIdRaw ? Number(commentIdRaw) : null;
            const branch = process.env.BRANCH_NAME || '';
            const headSha = process.env.HEAD_SHA || '';
            const files = JSON.parse(process.env.FILES_JSON || '[]');
            const fileCount = Number(process.env.FILE_COUNT || '0');
            const changed = (process.env.CHANGED || '').toLowerCase() === 'true';
            const workflowUrl = process.env.WORKFLOW_URL || '';
            const runUrl = process.env.RUN_URL || '';

            const { owner, repo } = context.repo;
            const summary = core.summary;
            summary.addHeading('CI autofix loop result');
            summary.addRaw(`PR #${prNumber} Â· Attempt ${attempt}/${maxAttempts}`).addEOL();
            summary.addRaw(`Branch: ${branch}`).addEOL();
            summary.addRaw(`Head: ${headSha.slice(0, 7)}`).addEOL();
            summary.addRaw(changed ? `Files changed: ${fileCount}` : 'No changes produced.').addEOL();
            if (files.length) {
              summary.addList(files.map((file) => `\`${file}\``));
            }
            await summary.write();

            const lines = [];
            lines.push(`Autofix attempt ${attempt}/${maxAttempts} for PR #${prNumber}.`);
            lines.push('');
            if (workflowUrl) {
              lines.push(`- Trigger: [upstream CI run](${workflowUrl})`);
            } else {
              lines.push(`- Trigger: [autofix workflow run](${runUrl})`);
            }
            if (branch) {
              lines.push(`- Branch: \`${branch}\``);
            }
            if (headSha) {
              lines.push(`- Head SHA: \`${headSha.slice(0, 7)}\``);
            }
            lines.push(`- Result: ${changed ? `pushed ${fileCount} file${fileCount === 1 ? '' : 's'}` : 'no changes required'}`);
            if (files.length) {
              lines.push('- Files touched:');
              lines.push('');
              for (const file of files) {
                lines.push(`  - \`${file}\``);
              }
            }
            lines.push('');
            const markerPayload = {
              pr: prNumber,
              attempts: attempt,
              max_attempts: maxAttempts,
              head: headSha,
              branch,
              workflow_run: github.runId,
              workflow_url: runUrl,
              upstream_url: workflowUrl,
              updated_at: new Date().toISOString(),
            };
            lines.push(`<!-- autofix-loop:${JSON.stringify(markerPayload)} -->`);
            const body = lines.join('\n');

            if (commentId) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: commentId, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
            }

            const labelClean = 'autofix:clean';
            const labelReview = 'needs-autofix-review';

            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [labelClean] });
            } catch (error) {
              core.warning(`Failed to add ${labelClean}: ${error}`);
            }

            try {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: labelReview });
            } catch (error) {
              if (error.status !== 404) {
                core.warning(`Failed to remove ${labelReview}: ${error}`);
              }
            }

      - name: Note absence of changes
        if: steps.context.outputs.should_run == 'true' && steps.diff.outputs.changed != 'true'
        run: echo 'Autofix completed without modifications.'
