name: PR Status Summary

on:
  workflow_run:
    workflows: [CI, Docker]
    types: [completed]

concurrency:
  group: pr-status-summary-${{ github.event.workflow_run.head_sha }}
  cancel-in-progress: true

permissions:
  pull-requests: write
  contents: read

jobs:
  summarize:
    if: >
      github.event.workflow_run.event == 'pull_request' &&
      github.event.workflow_run.pull_requests[0].number
    runs-on: ubuntu-latest
    steps:
      - name: Download coverage summary artifact
        id: dl_coverage
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: coverage-summary
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: coverage-summary
      - name: Capture coverage summary content
        id: coverage
        shell: bash
        run: |
          set -euo pipefail
          FILE="coverage-summary/coverage_summary.md"
          if [ -f "$FILE" ]; then
            {
              echo 'body<<EOF'
              cat "$FILE"
              echo 'EOF'
            } >> "$GITHUB_OUTPUT"
          fi
      - name: Prepare summary body
        id: prep
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const run = context.payload.workflow_run;
            const pr = run.pull_requests[0];
            const { owner, repo } = context.repo;

            const sha = run.head_sha;

            // Authoritative job enumeration (includes matrix children)
            const jobsResp = await github.rest.actions.listJobsForWorkflowRun({ owner, repo, run_id: run.id, per_page: 100 });
            const jobs = jobsResp.data.jobs || [];

            const badge = (state) => {
              if (!state) return '⏳';
              const s = state.toLowerCase();
              if (['success'].includes(s)) return '✅';
              if (['failure','cancelled','timed_out'].includes(s)) return '❌';
              if (['skipped'].includes(s)) return '⏭️';
              return '⏳';
            };

            // Determine required baseline heuristically (same logic as before using job names)
            const nameSet = new Set(jobs.map(j => j.name));
            const required = ['CI'];
            if (nameSet.has('Docker')) required.push('Docker');
            const conclusions = Object.fromEntries(jobs.map(j => [j.name, j.conclusion || j.status]));
            const requiredStates = required.map(n => `${n}: ${conclusions[n] || 'missing'}`);

            // Build rows; highlight failed/cancelled at top (enhancement)
            const priorityOrder = (state) => {
              const s = (state || '').toLowerCase();
              if (['failure','timed_out','cancelled'].includes(s)) return 0;
              if (s === 'success') return 1;
              if (s === 'skipped') return 2;
              return 3; // pending / in_progress / unknown
            };

            const rows = jobs
              .slice()
              .sort((a,b) => {
                const pa = priorityOrder(a.conclusion || a.status);
                const pb = priorityOrder(b.conclusion || b.status);
                if (pa !== pb) return pa - pb;
                return a.name.localeCompare(b.name);
              })
              .map(j => {
                const state = j.conclusion || j.status;
                const b = badge(state);
                // Failed rows bold for quick scanning
                const jobName = ['failure','timed_out','cancelled'].includes((state||'').toLowerCase()) ? `**${j.name}**` : j.name;
                return `| ${jobName} | ${b} ${state} | [logs](${j.html_url}) |`;
              });

            const coverageSection = (process.env.COVERAGE_SECTION || '').trim();
            const body = [
              '### Automated Status Summary',
              `**Workflow Run:** ${run.name} (#${run.id})`,
              `**Head SHA:** ${sha}`,
              `**Required:** ${requiredStates.join(', ')}`,
              '',
              '| Job | Result | Logs |',
              '|-----|--------|------|',
              ...rows,
              '',
              ...(coverageSection ? ['### Coverage (soft gate)', coverageSection, ''] : []),
              '_Updated automatically; will refresh on subsequent CI/Docker completions._'
            ].join('\n');

            core.setOutput('body', body);
            core.setOutput('pr_number', pr.number);
        env:
          COVERAGE_SECTION: ${{ steps.coverage.outputs.body }}
      - name: Upsert summary comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr_number = Number(process.env.PR_NUMBER);
            const body = process.env.BODY;
            const { owner, repo } = context.repo;

            // Find existing summary comment
            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number: pr_number, per_page: 100 });
            const marker = 'Automated Status Summary';
            const existing = comments.find(c => c.body && c.body.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: pr_number, body });
            }
        env:
          PR_NUMBER: ${{ steps.prep.outputs.pr_number }}
          BODY: ${{ steps.prep.outputs.body }}
