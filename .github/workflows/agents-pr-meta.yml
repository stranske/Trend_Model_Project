name: Agents PR meta manager

on:
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, synchronize, reopened, edited]
  workflow_run:
    workflows: [Gate]
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to update (leave empty to use trigger context)'
        required: false
        type: string
      debug:
        description: 'Enable debug logging'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: write
  checks: read

concurrency:
  group: agents-pr-meta-${{ github.event.issue.number || github.event.pull_request.number || (github.event.workflow_run && github.event.workflow_run.pull_requests && github.event.workflow_run.pull_requests[0] && github.event.workflow_run.pull_requests[0].number) || inputs.pr_number || github.run_id }}
  cancel-in-progress: false

jobs:
  keepalive_dispatch:
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    name: Detect keepalive round comments
    runs-on: ubuntu-latest
    outputs:
      dispatch: ${{ steps.pre_gate.outputs.ok == 'true' && steps.detect.outputs.dispatch == 'true' && 'true' || 'false' }}
      reason: ${{ steps.detect.outputs.reason || steps.pre_gate.outputs.reason }}
      issue: ${{ steps.detect.outputs.issue }}
      round: ${{ steps.detect.outputs.round }}
      branch: ${{ steps.detect.outputs.branch }}
      base: ${{ steps.detect.outputs.base }}
      trace: ${{ steps.detect.outputs.trace }}
      pr: ${{ steps.detect.outputs.pr }}
      author: ${{ steps.detect.outputs.author }}
      comment_id: ${{ steps.detect.outputs.comment_id }}
      comment_url: ${{ steps.detect.outputs.comment_url }}
      gate_reason: ${{ steps.pre_gate.outputs.reason }}
      agent_alias: ${{ steps.pre_gate.outputs.agent_alias }}
      has_human_activation: ${{ steps.pre_gate.outputs.has_human_activation }}
      has_keepalive_label: ${{ steps.pre_gate.outputs.has_keepalive_label }}
      has_activated_label: ${{ steps.pre_gate.outputs.has_activated_label }}
      gate_concluded: ${{ steps.pre_gate.outputs.gate_concluded }}
      gate_succeeded: ${{ steps.pre_gate.outputs.gate_succeeded }}
      under_run_cap: ${{ steps.pre_gate.outputs.under_run_cap }}
      active_runs: ${{ steps.pre_gate.outputs.active_runs }}
      run_cap: ${{ steps.pre_gate.outputs.run_cap }}
      require_human_activation: ${{ steps.pre_gate.outputs.require_human_activation }}
      activation_comment: ${{ steps.pre_gate.outputs.activation_comment }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Evaluate keepalive pre-gate
        id: pre_gate
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { evaluateKeepaliveGate } = require('./.github/scripts/keepalive_gate.js');

            const issueNumber = Number(context.payload?.issue?.number || 0);
            const comment = context.payload?.comment ? [context.payload.comment] : [];

            const result = await evaluateKeepaliveGate({
              core,
              github,
              context,
              options: {
                prNumber: issueNumber,
                comments: comment,
                requireHumanActivation: true,
              },
            });

            const bool = (value) => (value ? 'true' : 'false');
            core.setOutput('ok', bool(result.ok));
            core.setOutput('reason', result.reason || '');
            core.setOutput('has_keepalive_label', bool(result.hasKeepaliveLabel));
            core.setOutput('has_human_activation', bool(result.hasHumanActivation));
            core.setOutput('gate_concluded', bool(result.gateConcluded));
            core.setOutput('gate_succeeded', bool(result.gateSucceeded));
            core.setOutput('under_run_cap', bool(result.underRunCap));
            core.setOutput('run_cap', String(result.runCap ?? ''));
            core.setOutput('active_runs', String(result.activeRuns ?? ''));
            core.setOutput('agent_alias', result.primaryAgent || '');
            core.setOutput('head_sha', result.headSha || '');
            core.setOutput('pr_number', issueNumber > 0 ? String(issueNumber) : '');
            core.setOutput('has_activated_label', bool(result.hasActivatedLabel));
            core.setOutput('require_human_activation', bool(result.requireHumanActivation));
            core.setOutput('activation_comment', result.activationComment ? JSON.stringify(result.activationComment) : '');

            if (result.ok) {
              core.info('Keepalive pre-gate satisfied; continuing detection.');
            } else {
              core.info(`Keepalive pre-gate blocked dispatch: ${result.reason || 'unspecified'}`);
            }

      - name: Record gate summary
        run: |
          set -euo pipefail
          ok="${OK:-false}"
          reason="${REASON:-unspecified}"
          pr_num="${PR_NUMBER:-}"
          if [[ -n "${pr_num}" ]]; then
            pr_value="#${pr_num}"
          else
            pr_value="#?"
          fi
          agent="${AGENT_ALIAS:-codex}"
          if [[ -z "${agent}" ]]; then
            agent='?'
          fi
          cap="${RUN_CAP:-}"
          if [[ -z "${cap}" ]]; then
            cap='?'
          fi
          active="${ACTIVE_RUNS:-}"
          if [[ -z "${active}" ]]; then
            active='0'
          fi
          head="${HEAD_SHA:-}"
          if [[ -n "${head}" ]]; then
            head="${head:0:7}"
          else
            head='unknown'
          fi
          printf 'GATE: ok=%s reason=%s pr=%s agent=%s cap=%s active=%s head=%s\n' \
            "${ok}" "${reason}" "${pr_value}" "${agent}" "${cap}" "${active}" "${head}" >>"$GITHUB_STEP_SUMMARY"
        env:
          OK: ${{ steps.pre_gate.outputs.ok || 'false' }}
          REASON: ${{ steps.pre_gate.outputs.reason || 'unspecified' }}
          PR_NUMBER: ${{ steps.pre_gate.outputs.pr_number || '' }}
          AGENT_ALIAS: ${{ steps.pre_gate.outputs.agent_alias || '' }}
          RUN_CAP: ${{ steps.pre_gate.outputs.run_cap || '2' }}
          ACTIVE_RUNS: ${{ steps.pre_gate.outputs.active_runs || '0' }}
          HEAD_SHA: ${{ steps.pre_gate.outputs.head_sha || '' }}

      - name: Persist keepalive activation label (actions)
        if: steps.pre_gate.outputs.ok == 'true' && steps.pre_gate.outputs.has_activated_label != 'true' && secrets.ACTIONS_BOT_PAT != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT != '' && secrets.ACTIONS_BOT_PAT || (secrets.SERVICE_BOT_PAT != '' && secrets.SERVICE_BOT_PAT) || github.token }}
          script: |
            const prNumber = Number('${{ steps.pre_gate.outputs.pr_number || '0' }}');
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.warning('Activation label requires a valid pull request number.');
              return;
            }

            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: ['agents:activated'],
              });
              core.info(`Added agents:activated label to PR #${prNumber}.`);
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add agents:activated label to PR #${prNumber}: ${message}`);
            }

      - name: Persist keepalive activation label (fallback)
        if: steps.pre_gate.outputs.ok == 'true' && steps.pre_gate.outputs.has_activated_label != 'true' && secrets.ACTIONS_BOT_PAT == '' && secrets.SERVICE_BOT_PAT != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SERVICE_BOT_PAT }}
          script: |
            const prNumber = Number('${{ steps.pre_gate.outputs.pr_number || '0' }}');
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.warning('Activation label requires a valid pull request number.');
              return;
            }

            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: ['agents:activated'],
              });
              core.info(`Added agents:activated label to PR #${prNumber} (fallback token).`);
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add agents:activated label to PR #${prNumber}: ${message}`);
            }

      - name: Evaluate keepalive comment
        id: detect
        if: steps.pre_gate.outputs.ok == 'true'
        uses: actions/github-script@v7
        env:
          ALLOWED_LOGINS: chatgpt-codex-connector,stranske-automation-bot,stranske
          KEEPALIVE_MARKER: '<!-- codex-keepalive-marker -->'
          KEEPALIVE_AGENT_ALIAS: ${{ steps.pre_gate.outputs.agent_alias }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { detectKeepalive } = require('./.github/scripts/agents_pr_meta_keepalive.js');
            await detectKeepalive({ core, github, context, env: process.env });

      - name: Prepare keepalive summary context
        id: summary_context
        run: |
          set -euo pipefail
          comment_id="${COMMENT_ID:-}"
          comment_url="${COMMENT_URL:-}"

          if [[ -n "${comment_id}" && -n "${comment_url}" ]]; then
            value="[#${comment_id}](${comment_url})"
          elif [[ -n "${comment_id}" ]]; then
            value="${comment_id}"
          else
            value="—"
          fi

          printf 'comment=%s\n' "${value}" >>"${GITHUB_OUTPUT}"
        env:
          COMMENT_ID: ${{ steps.detect.outputs.comment_id }}
          COMMENT_URL: ${{ steps.detect.outputs.comment_url }}

      - name: Summarise keepalive evaluation
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          ## Keepalive detection
          | ok | reason | author | comment | pr | round | trace |
          | --- | --- | --- | --- | --- | --- | --- |
          | ${{ steps.detect.outputs.dispatch == 'true' && 'true' || 'false' }} | ${{ steps.detect.outputs.reason || steps.pre_gate.outputs.reason || '(none)' }} | ${{ steps.detect.outputs.author || '—' }} | ${{ steps.summary_context.outputs.comment || '—' }} | ${{ steps.detect.outputs.pr || steps.pre_gate.outputs.pr_number || '—' }} | ${{ steps.detect.outputs.round || '—' }} | ${{ steps.detect.outputs.trace || '—' }} |
          
          **Gate inputs**
          
          - keepalive label: ${{ steps.pre_gate.outputs.has_keepalive_label || 'false' }}
          - human activation: ${{ steps.pre_gate.outputs.has_human_activation || 'false' }}
          - gate concluded: ${{ steps.pre_gate.outputs.gate_concluded || 'false' }}
          - run cap: ${{ steps.pre_gate.outputs.active_runs || '0' }}/${{ steps.pre_gate.outputs.run_cap || '2' }}
          EOF

      - name: Register keepalive detection
        if: steps.detect.outputs.dispatch == 'true'
        run: |
          echo "Keepalive round ${{ steps.detect.outputs.round }} detected for issue ${{ steps.detect.outputs.issue }} on branch ${{ steps.detect.outputs.branch }} (trace ${{ steps.detect.outputs.trace }})"

      - name: Report keepalive dispatch outcome
        if: steps.detect.outputs.dispatch != 'true'
        run: |
          echo "Keepalive dispatch skipped: ${{ steps.detect.outputs.reason || steps.pre_gate.outputs.reason }}"

  keepalive_from_gate:
    if: >-
      ${{ github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success' }}
    name: Resume keepalive after Gate
    runs-on: ubuntu-latest
    outputs:
      dispatch: ${{ steps.detect.outputs.dispatch == 'true' && 'true' || 'false' }}
      reason: ${{ steps.detect.outputs.reason || steps.gate.outputs.reason }}
      issue: ${{ steps.detect.outputs.issue }}
      round: ${{ steps.detect.outputs.round }}
      branch: ${{ steps.detect.outputs.branch }}
      base: ${{ steps.detect.outputs.base }}
      trace: ${{ steps.detect.outputs.trace }}
      pr: ${{ steps.detect.outputs.pr || steps.gate.outputs.pr_number }}
      author: ${{ steps.detect.outputs.author }}
      comment_id: ${{ steps.detect.outputs.comment_id }}
      comment_url: ${{ steps.detect.outputs.comment_url }}
      gate_reason: ${{ steps.gate.outputs.reason }}
      agent_alias: ${{ steps.gate.outputs.agent_alias }}
      has_human_activation: ${{ steps.gate.outputs.has_human_activation }}
      has_keepalive_label: ${{ steps.gate.outputs.has_keepalive_label }}
      has_activated_label: ${{ steps.gate.outputs.has_activated_label }}
      gate_concluded: ${{ steps.gate.outputs.gate_concluded }}
      gate_succeeded: ${{ steps.gate.outputs.gate_succeeded }}
      under_run_cap: ${{ steps.gate.outputs.under_run_cap }}
      active_runs: ${{ steps.gate.outputs.active_runs }}
      run_cap: ${{ steps.gate.outputs.run_cap }}
      require_human_activation: ${{ steps.gate.outputs.require_human_activation }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Evaluate keepalive gate after workflow_run
        id: gate
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { evaluateKeepaliveGate } = require('./.github/scripts/keepalive_gate.js');

            const workflowRun = context.payload?.workflow_run || {};
            const pullRequests = Array.isArray(workflowRun.pull_requests) ? workflowRun.pull_requests : [];
            const primaryPull = pullRequests.length > 0 ? pullRequests[0] : null;

            const prNumber = Number(primaryPull?.number || 0);
            const headSha = workflowRun.head_sha || '';
            const headRef = primaryPull?.head?.ref || workflowRun.head_branch || '';

            const result = await evaluateKeepaliveGate({
              core,
              github,
              context,
              options: {
                prNumber,
                headSha,
                requireHumanActivation: true,
                currentRunId: workflowRun.id,
              },
            });

            const bool = (value) => (value ? 'true' : 'false');
            core.setOutput('ok', bool(result.ok));
            core.setOutput('reason', result.reason || '');
            core.setOutput('has_keepalive_label', bool(result.hasKeepaliveLabel));
            core.setOutput('has_human_activation', bool(result.hasHumanActivation));
            core.setOutput('has_activated_label', bool(result.hasActivatedLabel));
            core.setOutput('gate_concluded', bool(result.gateConcluded));
            core.setOutput('gate_succeeded', bool(result.gateSucceeded));
            core.setOutput('under_run_cap', bool(result.underRunCap));
            core.setOutput('run_cap', String(result.runCap ?? ''));
            core.setOutput('active_runs', String(result.activeRuns ?? ''));
            core.setOutput('agent_alias', result.primaryAgent || '');
            core.setOutput('head_sha', result.headSha || headSha || '');
            core.setOutput('head_ref', result.headRef || headRef || '');
            core.setOutput('pr_number', Number.isFinite(prNumber) && prNumber > 0 ? String(prNumber) : '');
            core.setOutput('require_human_activation', bool(result.requireHumanActivation));
            core.setOutput('activation_comment', result.activationComment ? JSON.stringify(result.activationComment) : '');

            if (result.ok) {
              core.info('Gate-triggered keepalive evaluation passed.');
            } else {
              core.info(`Gate-triggered keepalive evaluation blocked: ${result.reason || 'unspecified'}`);
            }

      - name: Record gate summary
        run: |
          set -euo pipefail
          ok="${OK:-false}"
          reason="${REASON:-unspecified}"
          pr_num="${PR_NUMBER:-}"
          if [[ -n "${pr_num}" ]]; then
            pr_value="#${pr_num}"
          else
            pr_value="#?"
          fi
          agent="${AGENT_ALIAS:-codex}"
          if [[ -z "${agent}" ]]; then
            agent='?'
          fi
          cap="${RUN_CAP:-}"
          if [[ -z "${cap}" ]]; then
            cap='?'
          fi
          active="${ACTIVE_RUNS:-}"
          if [[ -z "${active}" ]]; then
            active='0'
          fi
          head="${HEAD_SHA:-}"
          if [[ -n "${head}" ]]; then
            head="${head:0:7}"
          else
            head='unknown'
          fi
          printf 'GATE: ok=%s reason=%s pr=%s agent=%s cap=%s active=%s head=%s\n' \
            "${ok}" "${reason}" "${pr_value}" "${agent}" "${cap}" "${active}" "${head}" >>"$GITHUB_STEP_SUMMARY"
        env:
          OK: ${{ steps.gate.outputs.ok || 'false' }}
          REASON: ${{ steps.gate.outputs.reason || 'unspecified' }}
          PR_NUMBER: ${{ steps.gate.outputs.pr_number || '' }}
          AGENT_ALIAS: ${{ steps.gate.outputs.agent_alias || '' }}
          RUN_CAP: ${{ steps.gate.outputs.run_cap || '2' }}
          ACTIVE_RUNS: ${{ steps.gate.outputs.active_runs || '0' }}
          HEAD_SHA: ${{ steps.gate.outputs.head_sha || '' }}

      - name: Persist keepalive activation label (actions)
        if: steps.gate.outputs.ok == 'true' && steps.gate.outputs.has_activated_label != 'true' && secrets.ACTIONS_BOT_PAT != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT != '' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const prNumber = Number('${{ steps.gate.outputs.pr_number || '0' }}');
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.warning('Activation label requires a valid pull request number.');
              return;
            }

            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: ['agents:activated'],
              });
              core.info(`Added agents:activated label to PR #${prNumber}.`);
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add agents:activated label to PR #${prNumber}: ${message}`);
            }

      - name: Persist keepalive activation label (fallback)
        if: steps.gate.outputs.ok == 'true' && steps.gate.outputs.has_activated_label != 'true' && secrets.ACTIONS_BOT_PAT == '' && secrets.SERVICE_BOT_PAT != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SERVICE_BOT_PAT }}
          script: |
            const prNumber = Number('${{ steps.gate.outputs.pr_number || '0' }}');
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.warning('Activation label requires a valid pull request number.');
              return;
            }

            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: ['agents:activated'],
              });
              core.info(`Added agents:activated label to PR #${prNumber} (fallback token).`);
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add agents:activated label to PR #${prNumber}: ${message}`);
            }

      - name: Evaluate keepalive request after Gate
        id: detect
        if: steps.gate.outputs.ok == 'true'
        uses: actions/github-script@v7
        env:
          ALLOWED_LOGINS: chatgpt-codex-connector,stranske-automation-bot,stranske
          KEEPALIVE_MARKER: '<!-- codex-keepalive-marker -->'
          KEEPALIVE_AGENT_ALIAS: ${{ steps.gate.outputs.agent_alias }}
          ACTIVATION_COMMENT: ${{ steps.gate.outputs.activation_comment }}
          PR_NUMBER: ${{ steps.gate.outputs.pr_number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { detectKeepalive } = require('./.github/scripts/agents_pr_meta_keepalive.js');

            const prNumber = Number(process.env.PR_NUMBER || 0);
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setOutput('dispatch', 'false');
              core.setOutput('reason', 'missing-pr-number');
              return;
            }

            const commentPayload = process.env.ACTIVATION_COMMENT || '';
            if (!commentPayload) {
              core.setOutput('dispatch', 'false');
              core.setOutput('reason', 'missing-activation-comment');
              return;
            }

            let comment;
            try {
              comment = JSON.parse(commentPayload);
            } catch (error) {
              core.setOutput('dispatch', 'false');
              core.setOutput('reason', 'invalid-activation-comment');
              core.warning(`Unable to parse activation comment payload: ${error.message}`);
              return;
            }

            const commentId = Number(comment?.id || 0);
            if (!Number.isFinite(commentId) || commentId <= 0) {
              core.setOutput('dispatch', 'false');
              core.setOutput('reason', 'invalid-activation-comment');
              core.warning('Activation comment missing a valid id.');
              return;
            }

            const { owner, repo } = context.repo;
            let enrichedComment = comment;
            try {
              const { data } = await github.rest.issues.getComment({
                owner,
                repo,
                comment_id: commentId,
              });
              enrichedComment = data || comment;
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to refresh activation comment ${commentId}: ${message}`);
              enrichedComment = {
                ...comment,
                id: commentId,
              };
            }

            const detectionContext = {
              ...context,
              payload: {
                comment: enrichedComment,
                issue: { number: prNumber },
              },
            };

            await detectKeepalive({ core, github, context: detectionContext, env: process.env });

      - name: Prepare keepalive summary context
        id: summary_context
        if: steps.gate.outputs.ok == 'true'
        run: |
          set -euo pipefail
          comment_id="${COMMENT_ID:-}"
          comment_url="${COMMENT_URL:-}"

          if [[ -n "${comment_id}" && -n "${comment_url}" ]]; then
            value="[#${comment_id}](${comment_url})"
          elif [[ -n "${comment_id}" ]]; then
            value="${comment_id}"
          else
            value="—"
          fi

          printf 'comment=%s\n' "${value}" >>"${GITHUB_OUTPUT}"
        env:
          COMMENT_ID: ${{ steps.detect.outputs.comment_id }}
          COMMENT_URL: ${{ steps.detect.outputs.comment_url }}

      - name: Summarise keepalive evaluation
        if: steps.gate.outputs.ok == 'true'
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          ## Keepalive detection (Gate)
          | ok | reason | author | comment | pr | round | trace |
          | --- | --- | --- | --- | --- | --- | --- |
          | ${{ steps.detect.outputs.dispatch == 'true' && 'true' || 'false' }} | ${{ steps.detect.outputs.reason || steps.gate.outputs.reason || '(none)' }} | ${{ steps.detect.outputs.author || '—' }} | ${{ steps.summary_context.outputs.comment || '—' }} | ${{ steps.detect.outputs.pr || steps.gate.outputs.pr_number || '—' }} | ${{ steps.detect.outputs.round || '—' }} | ${{ steps.detect.outputs.trace || '—' }} |

          **Gate inputs**

          - keepalive label: ${{ steps.gate.outputs.has_keepalive_label || 'false' }}
          - activated label: ${{ steps.gate.outputs.has_activated_label || 'false' }}
          - human activation: ${{ steps.gate.outputs.has_human_activation || 'false' }}
          - gate success: ${{ steps.gate.outputs.gate_succeeded || 'false' }}
          - run cap: ${{ steps.gate.outputs.active_runs || '0' }}/${{ steps.gate.outputs.run_cap || '2' }}
          EOF

      - name: Register keepalive detection
        if: steps.detect.outputs.dispatch == 'true'
        run: |
          echo "Gate-triggered keepalive round ${{ steps.detect.outputs.round }} detected for PR ${{ steps.detect.outputs.pr }} (trace ${{ steps.detect.outputs.trace }})."

      - name: Report keepalive dispatch outcome
        if: steps.gate.outputs.ok == 'true' && steps.detect.outputs.dispatch != 'true'
        run: |
          echo "Gate-triggered keepalive dispatch skipped: ${{ steps.detect.outputs.reason || steps.gate.outputs.reason }}"

      - name: Ensure keepalive dispatch token available
        if: steps.detect.outputs.dispatch == 'true'
        env:
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT }}
          SERVICE_TOKEN: ${{ secrets.SERVICE_BOT_PAT }}
        run: |
          if [ -z "${ACTIONS_TOKEN}" ] && [ -z "${SERVICE_TOKEN}" ]; then
            echo "::error::Keepalive orchestrator dispatch requires ACTIONS_BOT_PAT or SERVICE_BOT_PAT." >&2
            exit 1
          fi

      - name: Dispatch Agents 70 run for keepalive
        if: steps.detect.outputs.dispatch == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.detect.outputs.issue }}');
            const prNumber = Number('${{ steps.detect.outputs.pr || steps.gate.outputs.pr_number }}');
            const branch = '${{ steps.detect.outputs.branch }}';
            const base = '${{ steps.detect.outputs.base }}';
            const round = Number('${{ steps.detect.outputs.round }}');
            const trace = '${{ steps.detect.outputs.trace }}';

            const { owner, repo } = context.repo;
            const workflowId = 'agents-70-orchestrator.yml';
            const ref = context.payload?.repository?.default_branch || 'phase-2-dev';

            const params = {
              enable_keepalive: true,
              dispatcher_force_issue: issue ? String(issue) : '',
            };

            const roundValue = Number.isFinite(round) && round > 0 ? String(round) : '';
            const prValue = Number.isFinite(prNumber) && prNumber > 0 ? prNumber : '';

            const options = {
              keepalive_trace: trace,
              round: roundValue,
              pr: prValue,
            };

            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id: workflowId,
              ref,
              inputs: {
                keepalive_enabled: 'true',
                params_json: JSON.stringify(params),
                options_json: JSON.stringify(options),
                dry_run: 'false',
              },
            });

            core.summary
              .addHeading('Keepalive orchestrator dispatch (Gate)')
              .addRaw(`Workflow: ${workflowId}`)
              .addEOL()
              .addRaw(`PR: ${prNumber ? `#${prNumber}` : '(unknown)'}`)
              .addEOL()
              .addRaw(`Round: ${round || 'n/a'}`)
              .addEOL()
              .addRaw(`Trace: ${trace || '(not detected)'}`)
              .addEOL()
              .addRaw(`Branch: ${branch || '(not detected)'}`)
              .addEOL()
              .addRaw(`Base: ${base || '(not detected)'}`)
              .write();

      - name: Ensure connector dispatch token available
        if: steps.detect.outputs.dispatch == 'true'
        env:
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT }}
          SERVICE_TOKEN: ${{ secrets.SERVICE_BOT_PAT }}
        run: |
          if [ -z "${ACTIONS_TOKEN}" ] && [ -z "${SERVICE_TOKEN}" ]; then
            echo "::error::Codex keepalive command dispatch requires ACTIONS_BOT_PAT or SERVICE_BOT_PAT." >&2
            exit 1
          fi

      - name: Dispatch codex keepalive command
        if: steps.detect.outputs.dispatch == 'true'
        uses: actions/github-script@v7
        env:
          BASE: ${{ steps.detect.outputs.base }}
          HEAD: ${{ steps.detect.outputs.branch }}
          ROUND: ${{ steps.detect.outputs.round }}
          TRACE: ${{ steps.detect.outputs.trace }}
          COMMENT_ID: ${{ steps.detect.outputs.comment_id }}
          COMMENT_URL: ${{ steps.detect.outputs.comment_url }}
          AGENT_ALIAS: ${{ steps.gate.outputs.agent_alias }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;

            const prNumber = Number('${{ steps.detect.outputs.pr || steps.gate.outputs.pr_number }}');
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setFailed('Unable to determine pull request number from Gate-triggered context.');
              return;
            }

            const base = process.env.BASE || '';
            const head = process.env.HEAD || '';
            const round = process.env.ROUND || '';
            const trace = process.env.TRACE || '';
            const agentAlias = (process.env.AGENT_ALIAS || '').trim() || 'codex';

            let resolvedBase = base;
            let resolvedHead = head;

            if (!resolvedBase || !resolvedHead) {
              const pull = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber,
              });

              resolvedBase = resolvedBase || pull.data.base?.ref || '';
              resolvedHead = resolvedHead || pull.data.head?.ref || '';
            }

            if (!resolvedBase || !resolvedHead) {
              core.setFailed('Unable to determine pull request base/head branches.');
              return;
            }

            const commentId = process.env.COMMENT_ID || '';
            const commentUrl = process.env.COMMENT_URL || '';

            if (!commentId || !commentUrl) {
              core.setFailed('Comment metadata missing id or url.');
              return;
            }

            const clientPayload = {
              issue: prNumber,
              base: resolvedBase,
              head: resolvedHead,
              agent: agentAlias,
              comment_id: commentId,
              comment_url: commentUrl,
              round,
              trace,
            };

            await github.rest.repos.createDispatchEvent({
              owner,
              repo,
              event_type: 'codex-pr-comment-command',
              client_payload: clientPayload,
            });

            core.summary
              .addHeading('Codex keepalive dispatch (Gate)')
              .addRaw(`Pull request: #${prNumber}`)
              .addEOL()
              .addRaw(`Base branch: ${clientPayload.base}`)
              .addEOL()
              .addRaw(`Head branch: ${clientPayload.head}`)
              .addEOL()
              .addRaw(`Comment ID: ${clientPayload.comment_id}`)
              .addEOL()
              .addLink('Comment URL', clientPayload.comment_url)
              .addEOL()
              .addRaw(`Round: ${round || '(unknown)'}`)
              .addEOL()
              .addRaw(`Trace: ${trace || '(missing)'}`)
              .write();

            core.info(`repository_dispatch emitted for PR #${prNumber} (Gate-triggered).`);

  keepalive_orchestrator:
    needs: keepalive_dispatch
    if: needs.keepalive_dispatch.outputs.dispatch == 'true'
    name: Dispatch keepalive orchestrator
    runs-on: ubuntu-latest
    steps:
      - name: Ensure keepalive dispatch token available
        env:
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT }}
          SERVICE_TOKEN: ${{ secrets.SERVICE_BOT_PAT }}
        run: |
          if [ -z "${ACTIONS_TOKEN}" ] && [ -z "${SERVICE_TOKEN}" ]; then
            echo "::error::Keepalive orchestrator dispatch requires ACTIONS_BOT_PAT or SERVICE_BOT_PAT." >&2
            exit 1
          fi

      - name: Dispatch Agents 70 run for keepalive
        id: orchestrator
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const issue = Number('${{ needs.keepalive_dispatch.outputs.issue }}');
            const prNumber = Number('${{ needs.keepalive_dispatch.outputs.pr }}');
            const branch = '${{ needs.keepalive_dispatch.outputs.branch }}';
            const base = '${{ needs.keepalive_dispatch.outputs.base }}';
            const round = Number('${{ needs.keepalive_dispatch.outputs.round }}');
            const trace = '${{ needs.keepalive_dispatch.outputs.trace }}';

            const { owner, repo } = context.repo;
            const workflowId = 'agents-70-orchestrator.yml';
            const ref = context.payload?.repository?.default_branch || 'phase-2-dev';

            const params = {
              enable_keepalive: true,
              dispatcher_force_issue: issue ? String(issue) : '',
            };

            const roundValue = Number.isFinite(round) && round > 0 ? String(round) : '';
            const fallbackPr = Number(context.payload?.issue?.number || 0);
            const prValue = Number.isFinite(prNumber) && prNumber > 0 ? prNumber : fallbackPr;

            const options = {
              keepalive_trace: trace,
              round: roundValue,
              pr: prValue,
            };

            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id: workflowId,
              ref,
              inputs: {
                keepalive_enabled: 'true',
                params_json: JSON.stringify(params),
                options_json: JSON.stringify(options),
                dry_run: 'false',
              },
            });

            core.summary
              .addHeading('Keepalive orchestrator dispatch')
              .addRaw(`Workflow: ${workflowId}`)
              .addEOL()
              .addRaw(`Issue: ${issue ? `#${issue}` : 'unknown'}`)
              .addEOL()
              .addRaw(`PR: ${prNumber ? `#${prNumber}` : (context.payload?.issue?.number ? `#${context.payload.issue.number}` : 'unknown')}`)
              .addEOL()
              .addRaw(`Round: ${round || 'n/a'}`)
              .addEOL()
              .addRaw(`Trace: ${trace || '(not detected)'}`)
              .addEOL()
              .addRaw(`Branch: ${branch || '(not detected)'}`)
              .addEOL()
              .addRaw(`Base: ${base || '(not detected)'}`)
              .write();

  listen_commands:
    needs: keepalive_dispatch
    if: >-
      ${{ github.event_name == 'issue_comment'
          && github.event.issue.pull_request
          && needs.keepalive_dispatch.outputs.dispatch == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Ensure connector dispatch token available
        env:
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT }}
          SERVICE_TOKEN: ${{ secrets.SERVICE_BOT_PAT }}
        run: |
          if [ -z "${ACTIONS_TOKEN}" ] && [ -z "${SERVICE_TOKEN}" ]; then
            echo "::error::Codex keepalive command dispatch requires ACTIONS_BOT_PAT or SERVICE_BOT_PAT." >&2
            exit 1
          fi

      - name: Dispatch codex keepalive command
        id: dispatch
        uses: actions/github-script@v7
        env:
          BASE: ${{ needs.keepalive_dispatch.outputs.base }}
          HEAD: ${{ needs.keepalive_dispatch.outputs.branch }}
          ROUND: ${{ needs.keepalive_dispatch.outputs.round }}
          TRACE: ${{ needs.keepalive_dispatch.outputs.trace }}
          COMMENT_ID: ${{ needs.keepalive_dispatch.outputs.comment_id }}
          COMMENT_URL: ${{ needs.keepalive_dispatch.outputs.comment_url }}
          AGENT_ALIAS: ${{ needs.keepalive_dispatch.outputs.agent_alias }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const { payload } = context;
            const { owner, repo } = context.repo;

            const pullNumber = payload.issue?.number;
            if (!pullNumber) {
              core.setFailed('Unable to determine pull request number from issue_comment payload.');
              return;
            }

            const base = process.env.BASE || '';
            const head = process.env.HEAD || '';
            const round = process.env.ROUND || '';
            const trace = process.env.TRACE || '';
            const agentAlias = (process.env.AGENT_ALIAS || '').trim() || 'codex';

            if (!base || !head) {
              core.warning('Keepalive metadata missing base/head from detection; fetching pull request details.');
            }

            let resolvedBase = base;
            let resolvedHead = head;

            if (!resolvedBase || !resolvedHead) {
              const pull = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pullNumber,
              });

              resolvedBase = resolvedBase || pull.data.base?.ref || '';
              resolvedHead = resolvedHead || pull.data.head?.ref || '';
            }

            if (!resolvedBase || !resolvedHead) {
              core.setFailed('Unable to determine pull request base/head branches.');
              return;
            }

            const commentId = payload.comment?.id;
            const commentUrl = payload.comment?.html_url;

            const fallbackCommentId = process.env.COMMENT_ID || '';
            const fallbackCommentUrl = process.env.COMMENT_URL || '';

            if (!commentId || !commentUrl) {
              if (!fallbackCommentId || !fallbackCommentUrl) {
                core.setFailed('Comment metadata missing id or url.');
                return;
              }
            }

            const clientPayload = {
              issue: pullNumber,
              base: resolvedBase,
              head: resolvedHead,
              agent: agentAlias,
              comment_id: commentId || fallbackCommentId,
              comment_url: commentUrl || fallbackCommentUrl,
              round,
              trace,
            };

            await github.rest.repos.createDispatchEvent({
              owner,
              repo,
              event_type: 'codex-pr-comment-command',
              client_payload: clientPayload,
            });

            core.summary
              .addHeading('Codex keepalive dispatch')
              .addRaw(`Pull request: #${pullNumber}`)
              .addEOL()
              .addRaw(`Base branch: ${clientPayload.base}`)
              .addEOL()
              .addRaw(`Head branch: ${clientPayload.head}`)
              .addEOL()
              .addRaw(`Comment ID: ${clientPayload.comment_id}`)
              .addEOL()
              .addLink('Comment URL', clientPayload.comment_url)
              .addEOL()
              .addRaw(`Round: ${round || '(unknown)'}`)
              .addEOL()
              .addRaw(`Trace: ${trace || '(missing)'}`)
              .write();

            core.info(`repository_dispatch emitted for PR #${pullNumber} (comment ${commentId}).`);

  update_body:
    if: github.event_name != 'issue_comment'
    name: Upsert PR body sections
    runs-on: ubuntu-latest
    steps:
      - name: Update PR body
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function discoverPr() {
              if (context.eventName === 'workflow_dispatch') {
                const prNumber = '${{ inputs.pr_number || '' }}';
                if (prNumber && prNumber.trim()) {
                  const num = Number.parseInt(prNumber.trim(), 10);
                  if (!Number.isNaN(num)) {
                    core.info(`Manual trigger: using PR #${num}`);
                    const {data: pr} = await github.rest.pulls.get({owner, repo, pull_number: num});
                    return {number: num, headSha: pr.head.sha};
                  }
                }
                core.warning('workflow_dispatch without valid pr_number; skipping');
                return null;
              }

              if (context.eventName === 'pull_request') {
                const pr = context.payload.pull_request;
                return {number: pr.number, headSha: pr.head.sha};
              }

              if (context.eventName === 'workflow_run') {
                const run = context.payload.workflow_run;
                if (!run || run.event !== 'pull_request') {
                  core.info('Workflow run not associated with a pull request.');
                  return null;
                }

                const headSha = run.head_sha;
                if (Array.isArray(run.pull_requests) && run.pull_requests.length > 0) {
                  const directMatch = run.pull_requests.find((item) => item && item.head_sha === headSha);
                  const candidate = directMatch || run.pull_requests[0];
                  if (candidate && typeof candidate.number === 'number') {
                    return {number: candidate.number, headSha};
                  }
                }
                const prs = await github.paginate(
                  github.rest.repos.listPullRequestsAssociatedWithCommit,
                  {
                    owner,
                    repo,
                    commit_sha: headSha,
                    per_page: 100,
                  },
                );

                const matching = prs.find((item) => item.head && item.head.sha === headSha);
                if (!matching) {
                  core.info(`No pull request found for commit ${headSha}.`);
                  return null;
                }

                return {number: matching.number, headSha};
              }

              core.info(`Unsupported event: ${context.eventName}`);
              return null;
            }

            function extractIssueNumber(pr) {
              const branch = pr.head.ref || '';
              const candidates = [];
              const branchMatch = branch.match(/issue-+([0-9]+)/i);
              if (branchMatch) {
                candidates.push(branchMatch[1]);
              }

              const titleMatch = (pr.title || '').match(/#([0-9]+)/);
              if (titleMatch) {
                candidates.push(titleMatch[1]);
              }

              const bodyMatches = [...((pr.body || '').matchAll(/#([0-9]+)/g))].map((m) => m[1]);
              candidates.push(...bodyMatches);

              for (const value of candidates) {
                const parsed = Number.parseInt(value, 10);
                if (!Number.isNaN(parsed)) {
                  return parsed;
                }
              }

              return null;
            }

            function extractSection(body, heading) {
              if (!body) {
                core.debug(`extractSection: body is empty for heading "${heading}"`);
                return '';
              }

              // Flexible regex: allow ## headers OR standalone text on its own line
              const escapedHeading = heading.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
              // Match either "## Heading" or just "Heading" at start of line
              const pattern = new RegExp(`(^|\\n)(#{1,3}\\s+)?${escapedHeading}\\s*\\r?\\n`, 'i');
              const match = body.match(pattern);

              if (!match) {
                core.debug(`extractSection: No match for heading "${heading}"`);
                core.debug(`  Pattern: ${pattern}`);
                core.debug(`  Body preview: ${body.slice(0, 200).replace(/\n/g, '\\n')}`);
                return '';
              }

              core.debug(`extractSection: Found "${heading}" at index ${match.index}`);
              const start = match.index + match[0].length;
              const rest = body.slice(start);

              // Look for next section: either ## heading OR a known section name at start of line
              const knownSections = ['Why', 'Scope', 'Non-Goals', 'Goal', 'Tasks', 'Acceptance criteria', 'Success criteria', 'Definition of done', 'Implementation notes', 'Technical notes', 'Summary', 'Description', 'Overview', 'Testing', 'Test Plan', 'Validation', 'CI readiness'];
              const sectionPattern = knownSections.map(s => s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
              const nextPattern = new RegExp(`\\r?\\n(#{2,3}\\s+|(?:${sectionPattern})\\s*\\r?\\n)`, 'i');
              const nextMatch = rest.match(nextPattern);
              const end = nextMatch ? nextMatch.index + 1 : rest.length;
              const content = rest.slice(0, end).trim();

              core.debug(`  Extracted ${content.length} characters`);
              return content;
            }

            function normalizeWhitespace(value) {
              if (!value) return '';
              return value
                .replace(/\r\n/g, '\n')
                .split('\n')
                .map((line) => line.trimEnd())
                .join('\n')
                .trim();
            }

            function ensureChecklist(section) {
              const cleaned = normalizeWhitespace(section);
              if (!cleaned) {
                return '';
              }

              return cleaned
                .split('\n')
                .map((line) => {
                  const match = line.match(/^(\s*)([-*])\s+(.*)$/);
                  if (!match) {
                    return line.trim();
                  }
                  const [, indent = '', , contentRaw] = match;
                  const content = contentRaw.trim();
                  const checkbox = content.match(/^\[( |x|X)\]\s*/);
                  if (checkbox) {
                    const state = checkbox[1].toLowerCase() === 'x' ? 'x' : ' ';
                    const remainder = content.slice(checkbox[0].length).trimStart();
                    return `${indent}- [${state}] ${remainder}`;
                  }
                  return `${indent}- [ ] ${content}`;
                })
                .join('\n');
            }

            function fallbackChecklist(message) {
              return `- [ ] ${message}`;
            }

            function buildPreamble(sections) {
              const lines = ['<!-- pr-preamble:start -->'];
              
              // Only include sections that have actual content from the issue
              if (sections.summary && sections.summary.trim()) {
                lines.push('## Summary', sections.summary, '');
              }
              
              if (sections.testing && sections.testing.trim()) {
                lines.push('## Testing', sections.testing, '');
              }
              
              if (sections.ci && sections.ci.trim()) {
                lines.push('## CI readiness', sections.ci, '');
              }
              
              lines.push('<!-- pr-preamble:end -->');
              return lines.join('\n');
            }

            function iconForStatus(status) {
              switch (status) {
                case 'success':
                  return '✅';
                case 'skipped':
                  return '⏭️';
                case 'cancelled':
                  return '⏹️';
                case 'timed_out':
                  return '⏱️';
                case 'failure':
                  return '❌';
                case 'neutral':
                  return '⚪';
                case 'pending':
                case 'waiting':
                case 'queued':
                case 'requested':
                  return '⏳';
                default:
                  return '❔';
              }
            }

            function friendlyStatus(status) {
              return (status || 'unknown').replace(/_/g, ' ');
            }

            function combineStatus(run) {
              if (!run) {
                return {icon: '❔', label: 'unknown'};
              }
              if (run.conclusion) {
                const normalized = run.conclusion.toLowerCase();
                return {icon: iconForStatus(normalized), label: friendlyStatus(normalized)};
              }
              if (run.status) {
                const normalized = run.status.toLowerCase();
                return {icon: iconForStatus(normalized), label: friendlyStatus(normalized)};
              }
              return {icon: '❔', label: 'unknown'};
            }

            function selectLatestWorkflows(runs) {
              const latest = new Map();
              for (const run of runs) {
                const name = run.name || 'Unnamed workflow';
                const key = name.toLowerCase();
                const existing = latest.get(key);
                if (!existing) {
                  latest.set(key, run);
                  continue;
                }
                if (new Date(run.created_at) > new Date(existing.created_at)) {
                  latest.set(key, run);
                }
              }
              return latest;
            }

            function buildStatusBlock({scope, tasks, acceptance, headSha, workflowRuns, requiredChecks}) {
              const statusLines = ['<!-- auto-status-summary:start -->', '## Automated Status Summary'];

              statusLines.push('#### Scope');
              const scopeFormatted = scope ? ensureChecklist(scope) : fallbackChecklist('Scope section missing from source issue.');
              statusLines.push(scopeFormatted);
              statusLines.push('');

              statusLines.push('#### Tasks');
              const tasksFormatted = tasks ? ensureChecklist(tasks) : fallbackChecklist('Tasks section missing from source issue.');
              statusLines.push(tasksFormatted);
              statusLines.push('');

              statusLines.push('#### Acceptance criteria');
              const acceptanceFormatted = acceptance ? ensureChecklist(acceptance) : fallbackChecklist('Acceptance criteria section missing from source issue.');
              statusLines.push(acceptanceFormatted);
              statusLines.push('');

              statusLines.push(`**Head SHA:** ${headSha}`);

              const latestRuns = Array.from(workflowRuns.values()).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              let latestLine = '—';
              if (latestRuns.length > 0) {
                const gate = latestRuns.find((run) => (run.name || '').toLowerCase() === 'gate');
                const chosen = gate || latestRuns[0];
                const status = combineStatus(chosen);
                latestLine = `${status.icon} ${status.label} — ${chosen.name}`;
              }
              statusLines.push(`**Latest Runs:** ${latestLine}`);

              const requiredParts = [];
              for (const name of requiredChecks) {
                const run = Array.from(workflowRuns.values()).find((item) => (item.name || '').toLowerCase() === name.toLowerCase());
                if (!run) {
                  requiredParts.push(`${name}: ⏸️ not started`);
                } else {
                  const status = combineStatus(run);
                  requiredParts.push(`${name}: ${status.icon} ${status.label}`);
                }
              }
              statusLines.push(`**Required:** ${requiredParts.length > 0 ? requiredParts.join(', ') : '—'}`);
              statusLines.push('');

              const table = ['| Workflow / Job | Result | Logs |', '|----------------|--------|------|'];
              const runs = Array.from(workflowRuns.values()).sort((a, b) => (a.name || '').localeCompare(b.name || ''));

              if (runs.length === 0) {
                table.push('| _(no workflow runs yet for this commit)_ | — | — |');
              } else {
                for (const run of runs) {
                  const status = combineStatus(run);
                  const link = run.html_url ? `[View run](${run.html_url})` : '—';
                  table.push(`| ${run.name || 'Unnamed workflow'} | ${status.icon} ${status.label} | ${link} |`);
                }
              }

              statusLines.push(...table);
              statusLines.push('<!-- auto-status-summary:end -->');

              return statusLines.join('\n');
            }

            function upsertBlock(body, marker, replacement) {
              const start = `<!-- ${marker}:start -->`;
              const end = `<!-- ${marker}:end -->`;

              const startIndex = body.indexOf(start);
              const endIndex = body.indexOf(end);
              if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                return `${body.slice(0, startIndex)}${replacement}${body.slice(endIndex + end.length)}`;
              }

              const trimmed = body.trimEnd();
              const prefix = trimmed ? `${trimmed}\n\n` : '';
              return `${prefix}${replacement}`;
            }

            async function fetchRequiredChecks(baseRef) {
              const qualified = baseRef.startsWith('refs/') ? baseRef : `refs/heads/${baseRef}`;
              try {
                const result = await github.graphql(
                  `query($owner: String!, $repo: String!, $qualified: String!) {
                    repository(owner: $owner, name: $repo) {
                      ref(qualifiedName: $qualified) {
                        branchProtectionRule {
                          requiresStatusChecks
                          requiredStatusCheckContexts
                        }
                      }
                    }
                  }`,
                  {owner, repo, qualified},
                );
                const rule = result?.repository?.ref?.branchProtectionRule;
                if (rule && rule.requiresStatusChecks && Array.isArray(rule.requiredStatusCheckContexts)) {
                  return rule.requiredStatusCheckContexts.filter((item) => typeof item === 'string' && item.trim());
                }
              } catch (error) {
                core.info(`Branch protection lookup failed: ${error.message}`);
              }
              return [];
            }

            const prInfo = await discoverPr();
            if (!prInfo) {
              return 'No pull request context detected; skipping update.';
            }

            const prResponse = await github.rest.pulls.get({owner, repo, pull_number: prInfo.number});
            const pr = prResponse.data;
            if (pr.state === 'closed') {
              return `Pull request #${pr.number} is closed; skipping update.`;
            }

            if (prInfo.headSha && pr.head && pr.head.sha && pr.head.sha !== prInfo.headSha) {
              return `Skipping update for PR #${pr.number} because workflow run head ${prInfo.headSha} does not match current head ${pr.head.sha}.`;
            }

            const issueNumber = extractIssueNumber(pr);
            if (!issueNumber) {
              return `Unable to determine source issue for PR #${pr.number}; skipping.`;
            }

            core.info(`Fetching content from issue #${issueNumber} for PR #${pr.number}`);
            const issueResponse = await github.rest.issues.get({owner, repo, issue_number: issueNumber});
            const issueBody = issueResponse.data.body || '';

            if (!issueBody) {
              core.warning(`Issue #${issueNumber} has no body content`);
            } else {
              core.debug(`Issue body length: ${issueBody.length} characters`);
              core.debug(`Issue body preview: ${issueBody.slice(0, 300).replace(/\n/g, '\\n')}`);
            }

            function extractWithAliases(body, aliases) {
              for (const alias of aliases) {
                const content = extractSection(body, alias);
                if (content) return content;
              }
              return '';
            }

            function buildRichSummary(body) {
              core.info('Building rich summary from issue sections...');
              const why = normalizeWhitespace(extractSection(body, 'Why'));
              const scopeRaw = normalizeWhitespace(extractSection(body, 'Scope'));
              const nonGoals = normalizeWhitespace(extractSection(body, 'Non-Goals'));
              const goal = normalizeWhitespace(extractSection(body, 'Goal'));

              core.info(`  Why: ${why ? `${why.length} chars` : 'NOT FOUND'}`);
              core.info(`  Scope: ${scopeRaw ? `${scopeRaw.length} chars` : 'NOT FOUND'}`);
              core.info(`  Non-Goals: ${nonGoals ? `${nonGoals.length} chars` : 'NOT FOUND'}`);
              core.info(`  Goal: ${goal ? `${goal.length} chars` : 'NOT FOUND'}`);

              const parts = [];
              if (why) parts.push(why);
              if (goal) parts.push(goal);
              if (scopeRaw) parts.push(`\n**Scope:** ${scopeRaw}`);
              if (nonGoals) parts.push(`**Non-Goals:** ${nonGoals}`);

              const result = parts.join('\n\n');
              core.info(`Rich summary result: ${result ? `${result.length} chars` : 'EMPTY'}`);
              return result;
            }

            const summaryRich = buildRichSummary(issueBody);
            const summary = summaryRich || normalizeWhitespace(extractWithAliases(issueBody, ['Summary', 'Description', 'Overview']));
            const testing = normalizeWhitespace(extractWithAliases(issueBody, ['Testing', 'Test Plan', 'Validation']));
            const ci = normalizeWhitespace(extractWithAliases(issueBody, ['CI readiness', 'Implementation notes', 'Technical notes']));

            core.info(`Final sections - Summary: ${summary ? 'OK' : 'EMPTY'}, Testing: ${testing ? 'OK' : 'EMPTY'}, CI: ${ci ? 'OK' : 'EMPTY'}`);

            const scope = extractSection(issueBody, 'Scope') || '';
            const tasks = extractSection(issueBody, 'Tasks') || '';
            const acceptance = extractWithAliases(issueBody, ['Acceptance criteria', 'Success criteria', 'Definition of done']) || '';

            core.info(`Status block sections - Scope: ${scope ? 'OK' : 'EMPTY'}, Tasks: ${tasks ? 'OK' : 'EMPTY'}, Acceptance: ${acceptance ? 'OK' : 'EMPTY'}`);

            const preamble = buildPreamble({summary, testing, ci});

            const workflowRunResponse = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              head_sha: pr.head.sha,
              per_page: 100,
            });
            const workflowRuns = selectLatestWorkflows(workflowRunResponse.data.workflow_runs || []);

            const requiredChecks = await fetchRequiredChecks(pr.base.ref);
            if (!requiredChecks.includes('gate') && pr.base.ref) {
              requiredChecks.push('gate');
            }

            const statusBlock = buildStatusBlock({
              scope,
              tasks,
              acceptance,
              headSha: prInfo.headSha,
              workflowRuns,
              requiredChecks,
            });

            const bodyWithPreamble = upsertBlock(pr.body || '', 'pr-preamble', preamble);
            const newBody = upsertBlock(bodyWithPreamble, 'auto-status-summary', statusBlock);

            if (newBody !== (pr.body || '')) {
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: pr.number,
                body: newBody,
              });
              return `Updated PR #${pr.number} body with synchronized sections from issue #${issueNumber}.`;
            }

            return 'PR body already up to date; no changes required.';

