name: Agents PR meta manager

on:
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, synchronize, reopened, edited]
  workflow_run:
    workflows: [Gate]
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to update (leave empty to use trigger context)'
        required: false
        type: string
      debug:
        description: 'Enable debug logging'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: write
  checks: read

concurrency:
  group: >-
    ${{
      github.event_name == 'issue_comment'
      && github.event.comment
      && github.event.comment.id
      && format('agents-pr-meta-comment-{0}', github.event.comment.id)
      || format('agents-pr-meta-run-{0}', github.run_id)
    }}
  cancel-in-progress: false

jobs:
  comment_event_context:
    if: >-
      ${{ github.event_name == 'issue_comment'
          && github.event.action == 'created'
          && github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    outputs:
      pr: ${{ steps.resolve.outputs.pr }}
    steps:
      - name: Resolve pull request number
        id: resolve
        env:
          PR_NUMBER: ${{ github.event.issue.number }}
        run: |
          set -euo pipefail
          pr="${PR_NUMBER:-}"
          if [[ -z "${pr}" ]]; then
            pr="unknown"
          fi
          printf 'pr=%s\n' "${pr}" >>"${GITHUB_OUTPUT}"

  keepalive_dispatch:
    needs: comment_event_context
    if: >-
      ${{ github.event_name == 'issue_comment'
          && github.event.action == 'created'
          && github.event.issue.pull_request }}
    name: Detect keepalive round comments
    concurrency:
      group: >-
        ${{ format('pr-meta-dispatch-{0}', needs.comment_event_context.outputs.pr) }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    outputs:
      dispatch: >-
        ${{
          steps.pre_gate.outputs.ok == 'true'
          && steps.detect.outputs.dispatch == 'true'
          && 'true'
          || 'false'
        }}
      reason: >-
        ${{
          steps.detect.outputs.reason
          || steps.pre_gate.outputs.reason
        }}
      issue: ${{ steps.detect.outputs.issue }}
      round: ${{ steps.detect.outputs.round }}
      branch: ${{ steps.detect.outputs.branch }}
      base: ${{ steps.detect.outputs.base }}
      trace: ${{ steps.detect.outputs.trace }}
      pr: ${{ steps.detect.outputs.pr }}
      author: ${{ steps.detect.outputs.author }}
      comment_id: ${{ steps.detect.outputs.comment_id }}
      comment_url: ${{ steps.detect.outputs.comment_url }}
      processed_reaction: ${{ steps.detect.outputs.processed_reaction }}
      deduped: ${{ steps.detect.outputs.deduped }}
      gate_reason: ${{ steps.pre_gate.outputs.reason }}
      gate_ok: ${{ steps.pre_gate.outputs.ok }}
      agent_alias: ${{ steps.pre_gate.outputs.agent_alias }}
      has_human_activation: ${{ steps.pre_gate.outputs.has_human_activation }}
      has_keepalive_label: ${{ steps.pre_gate.outputs.has_keepalive_label }}
      has_activated_label: ${{ steps.pre_gate.outputs.has_activated_label }}
      gate_concluded: ${{ steps.pre_gate.outputs.gate_concluded }}
      gate_succeeded: ${{ steps.pre_gate.outputs.gate_succeeded }}
      pending_gate: ${{ steps.pre_gate.outputs.pending_gate }}
      under_run_cap: ${{ steps.pre_gate.outputs.under_run_cap }}
      active_runs: ${{ steps.pre_gate.outputs.active_runs }}
      run_cap: ${{ steps.pre_gate.outputs.run_cap }}
      require_human_activation: ${{ steps.pre_gate.outputs.require_human_activation }}
      activation_comment: ${{ steps.pre_gate.outputs.activation_comment }}
      instruction_body: ${{ steps.detect.outputs.instruction_body }}
      instruction_bytes: ${{ steps.detect.outputs.instruction_bytes }}
      head_sha: ${{ steps.pre_gate.outputs.head_sha }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Evaluate keepalive pre-gate
        id: pre_gate
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { evaluateKeepaliveGate } = require('./.github/scripts/keepalive_gate.js');

            const issueNumber = Number(context.payload?.issue?.number || 0);
            const comment = context.payload?.comment ? [context.payload.comment] : [];

            const result = await evaluateKeepaliveGate({
              core,
              github,
              context,
              options: {
                prNumber: issueNumber,
                comments: comment,
                requireHumanActivation: true,
                requireGateSuccess: true,
              },
            });

            const bool = (value) => (value ? 'true' : 'false');
            core.setOutput('ok', bool(result.ok));
            core.setOutput('reason', result.reason || '');
            core.setOutput('has_keepalive_label', bool(result.hasKeepaliveLabel));
            core.setOutput('has_human_activation', bool(result.hasHumanActivation));
            core.setOutput('gate_concluded', bool(result.gateConcluded));
            core.setOutput('gate_succeeded', bool(result.gateSucceeded));
            core.setOutput('under_run_cap', bool(result.underRunCap));
            core.setOutput('run_cap', String(result.runCap ?? ''));
            core.setOutput('active_runs', String(result.activeRuns ?? ''));
            core.setOutput('cap', String(result.cap ?? result.runCap ?? ''));
            core.setOutput('active', String(result.active ?? result.activeRuns ?? ''));
            core.setOutput('agent_alias', result.primaryAgent || '');
            core.setOutput('head_sha', result.headSha || '');
            core.setOutput('last_green_sha', result.lastGreenSha || '');
            core.setOutput('pr_number', issueNumber > 0 ? String(issueNumber) : '');
            core.setOutput('has_activated_label', bool(result.hasActivatedLabel));
            core.setOutput('require_human_activation', bool(result.requireHumanActivation));
            core.setOutput('pending_gate', bool(result.pendingGate));
            core.setOutput('activation_comment', result.activationComment ? JSON.stringify(result.activationComment) : '');

            if (result.ok) {
              core.info('Keepalive pre-gate satisfied; continuing detection.');
            } else {
              core.info(`Keepalive pre-gate blocked dispatch: ${result.reason || 'unspecified'}`);
            }

      - name: Record gate summary
        run: |
          set -euo pipefail
          ok="${OK:-false}"
          reason="${REASON:-unspecified}"
          pr_num="${PR_NUMBER:-}"
          if [[ -n "${pr_num}" ]]; then
            pr_value="#${pr_num}"
          else
            pr_value="#?"
          fi
          agent="${AGENT_ALIAS:-codex}"
          if [[ -z "${agent}" ]]; then
            agent='?'
          fi
          cap="${CAP:-}"
          if [[ -z "${cap}" ]]; then
            cap='?'
          fi
          active="${ACTIVE:-}"
          if [[ -z "${active}" ]]; then
            active='0'
          fi
          head="${HEAD_SHA:-}"
          if [[ -n "${head}" ]]; then
            head="${head:0:7}"
          else
            head='unknown'
          fi
          if [[ "${reason}" == 'run-cap-reached' ]]; then
            printf 'CAP: ok=%s reason=%s pr=%s cap=%s active=%s\n' \
              "${ok}" "${reason}" "${pr_value}" "${cap}" "${active}"
          else
            printf 'GATE: ok=%s reason=%s pr=%s agent=%s cap=%s active=%s head=%s\n' \
              "${ok}" "${reason}" "${pr_value}" "${agent}" "${cap}" "${active}" "${head}"
          fi
        env:
          OK: ${{ steps.pre_gate.outputs.ok || 'false' }}
          REASON: ${{ steps.pre_gate.outputs.reason || 'unspecified' }}
          PR_NUMBER: ${{ steps.pre_gate.outputs.pr_number || '' }}
          AGENT_ALIAS: ${{ steps.pre_gate.outputs.agent_alias || '' }}
          CAP: ${{ steps.pre_gate.outputs.cap || steps.pre_gate.outputs.run_cap || '2' }}
          ACTIVE: ${{ steps.pre_gate.outputs.active || steps.pre_gate.outputs.active_runs || '0' }}
          HEAD_SHA: ${{ steps.pre_gate.outputs.head_sha || '' }}

      - name: Persist keepalive activation label
        if: steps.pre_gate.outputs.ok == 'true' && steps.pre_gate.outputs.has_activated_label != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const prNumber = Number('${{ steps.pre_gate.outputs.pr_number || '0' }}');
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.warning('Activation label requires a valid pull request number.');
              return;
            }

            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: ['agents:activated'],
              });
              core.info(`Added agents:activated label to PR #${prNumber}.`);
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add agents:activated label to PR #${prNumber}: ${message}`);
            }

      - name: Evaluate keepalive comment
        id: detect
        uses: actions/github-script@v7
        env:
          ALLOWED_LOGINS: chatgpt-codex-connector,stranske-automation-bot,stranske
          KEEPALIVE_MARKER: '<!-- codex-keepalive-marker -->'
          KEEPALIVE_AGENT_ALIAS: ${{ steps.pre_gate.outputs.agent_alias }}
          GATE_OK: ${{ steps.pre_gate.outputs.ok || 'false' }}
          GATE_REASON: ${{ steps.pre_gate.outputs.reason || '' }}
          GATE_PENDING: ${{ steps.pre_gate.outputs.pending_gate || 'false' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { detectKeepalive } = require('./.github/scripts/agents_pr_meta_keepalive.js');
            await detectKeepalive({ core, github, context, env: process.env });

      - name: Register keepalive detection
        if: steps.detect.outputs.dispatch == 'true' || steps.detect.outputs.reason == 'lock-held'
        run: |
          set -euo pipefail
          comment_id="${{ steps.detect.outputs.comment_id || '?' }}"
          trace="${{ steps.detect.outputs.trace || '(missing)' }}"
          source="${{ steps.detect.outputs.author || 'unknown' }}"
          seen="${{ steps.detect.outputs.processed_reaction || 'false' }}"
          deduped="${{ steps.detect.outputs.deduped || 'false' }}"
          printf 'INSTRUCTION: comment_id=%s trace=%s source=%s seen=%s deduped=%s\n' \
            "${comment_id}" "${trace}" "${source}" "${seen}" "${deduped}"

      - name: Report keepalive dispatch outcome
        if: steps.detect.outputs.dispatch != 'true'
        run: |
          echo "Keepalive dispatch skipped: ${{ steps.detect.outputs.reason || steps.pre_gate.outputs.reason }}"

  keepalive_orchestrator:
    needs:
      - keepalive_dispatch
    if: needs.keepalive_dispatch.outputs.dispatch == 'true'
    name: Dispatch keepalive orchestrator
    concurrency:
      group: >-
        ${{ format('pr-meta-keepalive-orchestrator-{0}', needs.keepalive_dispatch.outputs.pr || github.run_id) }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Select keepalive dispatch token
        id: select_token
        env:
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT }}
          SERVICE_TOKEN: ${{ secrets.SERVICE_BOT_PAT }}
        run: |
          set -euo pipefail
          if [[ -n "${ACTIONS_TOKEN}" ]]; then
            {
              printf 'allowed=true\n'
              printf 'token_source=ACTIONS_BOT_PAT\n'
              printf 'reason=ok\n'
            } >>"${GITHUB_OUTPUT}"
          elif [[ -n "${SERVICE_TOKEN}" ]]; then
            {
              printf 'allowed=true\n'
              printf 'token_source=SERVICE_BOT_PAT\n'
              printf 'reason=ok\n'
            } >>"${GITHUB_OUTPUT}"
          else
            echo "::error::Keepalive orchestrator dispatch requires ACTIONS_BOT_PAT or SERVICE_BOT_PAT." >&2
            {
              printf 'allowed=false\n'
              printf 'token_source=\n'
              printf 'reason=forbidden-token\n'
            } >>"${GITHUB_OUTPUT}"
          fi

      - name: Identify dispatch token
        id: identify_token
        if: steps.select_token.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_token.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const response = await github.rest.users.getAuthenticated();
            const login = response.data?.login || 'unknown';
            const id = response.data?.id ? String(response.data.id) : '';
            const identity = id ? `${login} (${id})` : login;
            core.info(`TOKEN_IDENTITY: ${identity}`);
            core.setOutput('login', login);
            core.setOutput('user_id', id);

      - name: Acquire activation lock
        id: activation_lock
        if: steps.select_token.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_token.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const rawCommentId = '${{ needs.keepalive_dispatch.outputs.comment_id || github.event.comment.id || '' }}';
            const commentId = Number(rawCommentId);
            if (!Number.isFinite(commentId) || commentId <= 0) {
              core.setOutput('status', 'missing');
              core.setOutput('reason', 'no-activation-found');
              return;
            }

            const { owner, repo } = context.repo;
            try {
              await github.rest.reactions.createForIssueComment({
                owner,
                repo,
                comment_id: commentId,
                content: 'rocket',
              });
              core.info(`Activation lock applied to comment ${commentId}.`);
              core.setOutput('status', 'ok');
              core.setOutput('reason', 'ok');
            } catch (error) {
              const status = Number(error?.status || 0);
              const message = error instanceof Error ? error.message : String(error);
              if (status === 409) {
                core.info(`Activation lock already present on comment ${commentId}.`);
              } else {
                core.warning(`Failed to add activation lock to comment ${commentId}: ${message}`);
              }
              core.setOutput('status', 'lock-held');
              core.setOutput('reason', 'lock-held');
            }

      - name: Snapshot orchestrator runs
        id: snapshot_runs
        if: steps.select_token.outputs.allowed == 'true' && steps.activation_lock.outputs.status != 'lock-held'
        env:
          PR_NUMBER: ${{ needs.keepalive_dispatch.outputs.pr || github.event.issue.number || '' }}
          TRACE: ${{ needs.keepalive_dispatch.outputs.trace || '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_token.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER || 0);
            const trace = (process.env.TRACE || '').trim();
            const { owner, repo } = context.repo;
            const response = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: 'agents-70-orchestrator.yml',
              event: 'workflow_dispatch',
              per_page: 50,
            });
            const runs = Array.isArray(response.data?.workflow_runs) ? response.data.workflow_runs : [];
            const ids = runs.map((run) => Number(run?.id)).filter((value) => Number.isFinite(value));
            core.info(`Snapshot captured ${ids.length} workflow_dispatch runs for agents-70-orchestrator.yml.`);
            core.setOutput('ids', JSON.stringify(ids));
            core.setOutput('timestamp', new Date().toISOString());
            core.setOutput('pr', prNumber > 0 ? String(prNumber) : '');
            core.setOutput('trace', trace);

      - name: Dispatch Agents 70 run for keepalive
        id: dispatch_orchestrator
        if: steps.select_token.outputs.allowed == 'true' && steps.activation_lock.outputs.status != 'lock-held'
        uses: actions/github-script@v7
        env:
          ISSUE: ${{ needs.keepalive_dispatch.outputs.issue }}
          PR_NUMBER: ${{ needs.keepalive_dispatch.outputs.pr || github.event.issue.number || '' }}
          BRANCH: ${{ needs.keepalive_dispatch.outputs.branch }}
          BASE: ${{ needs.keepalive_dispatch.outputs.base }}
          ROUND: ${{ needs.keepalive_dispatch.outputs.round }}
          TRACE: ${{ needs.keepalive_dispatch.outputs.trace }}
          INSTRUCTION_BODY: ${{ needs.keepalive_dispatch.outputs.instruction_body }}
        with:
          github-token: ${{ steps.select_token.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const issueNumber = Number(process.env.ISSUE || 0);
            const prNumber = Number(process.env.PR_NUMBER || 0);
            const branch = process.env.BRANCH || '';
            const base = process.env.BASE || '';
            const roundRaw = Number(process.env.ROUND || 0);
            const trace = process.env.TRACE || '';
            const instructionBody = process.env.INSTRUCTION_BODY || '';

            const { owner, repo } = context.repo;
            const workflowId = 'agents-70-orchestrator.yml';
            const ref = context.payload?.repository?.default_branch || 'phase-2-dev';

            const params = { enable_keepalive: true };
            if (Number.isFinite(issueNumber) && issueNumber > 0) {
              params.dispatcher_force_issue = String(issueNumber);
            }
            if (branch) {
              params.keepalive_branch = branch;
            }
            if (base) {
              params.keepalive_base = base;
            }

            const round = Number.isFinite(roundRaw) && roundRaw > 0 ? String(roundRaw) : '';
            const prValue = Number.isFinite(prNumber) && prNumber > 0 ? String(prNumber) : '';

            const options = {
              keepalive_trace: trace,
              round,
              pr: prValue,
            };
            if (instructionBody) {
              options.keepalive_instruction = instructionBody;
            }

            try {
              await github.rest.actions.createWorkflowDispatch({
                owner,
                repo,
                workflow_id: workflowId,
                ref,
                inputs: {
                  keepalive_enabled: 'true',
                  params_json: JSON.stringify(params),
                  options_json: JSON.stringify(options),
                  dry_run: 'false',
                  pr_number: prValue,
                },
              });
              core.info(`Dispatched ${workflowId} for keepalive (pr=${prValue || 'n/a'}, trace=${trace || '-' }).`);
              core.setOutput('ok', 'true');
              core.setOutput('reason', 'ok');
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.error(`Failed to dispatch ${workflowId}: ${message}`);
              core.setOutput('ok', 'false');
              core.setOutput('reason', 'dispatch-error');
              throw error;
            }

      - name: Confirm orchestrator dispatch
        id: confirm_dispatch
        if: steps.dispatch_orchestrator.outputs.ok == 'true'
        env:
          BASELINE_IDS: ${{ steps.snapshot_runs.outputs.ids }}
          PR_NUMBER: ${{ steps.snapshot_runs.outputs.pr || needs.keepalive_dispatch.outputs.pr || github.event.issue.number || '' }}
          TRACE: ${{ steps.snapshot_runs.outputs.trace || needs.keepalive_dispatch.outputs.trace || '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_token.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const parseIds = (value) => {
              if (!value) {
                return new Set();
              }
              try {
                const parsed = JSON.parse(value);
                if (Array.isArray(parsed)) {
                  return new Set(parsed.map((entry) => Number(entry)).filter((entry) => Number.isFinite(entry)));
                }
              } catch (error) {
                core.warning(`Unable to parse baseline ids: ${error.message || error}`);
              }
              return new Set();
            };

            const baseline = parseIds(process.env.BASELINE_IDS || '[]');
            const prNumber = Number(process.env.PR_NUMBER || 0);
            const trace = (process.env.TRACE || '').trim();
            const { owner, repo } = context.repo;

            const matches = (run) => {
              if (!run) {
                return false;
              }
              const runId = Number(run.id);
              if (baseline.has(runId)) {
                return false;
              }
              if (prNumber > 0) {
                const concurrency = String(run.concurrency || '');
                if (concurrency.includes(`pr-${prNumber}-`)) {
                  return true;
                }
                const pulls = Array.isArray(run.pull_requests) ? run.pull_requests : [];
                if (pulls.some((pull) => Number(pull?.number) === prNumber)) {
                  return true;
                }
              }
              if (trace) {
                const candidates = [run.name, run.display_title, run.head_branch, run.head_sha];
                if (candidates.some((value) => typeof value === 'string' && value.includes(trace))) {
                  return true;
                }
              }
              return false;
            };

            const poll = async () => {
              const response = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: 'agents-70-orchestrator.yml',
                event: 'workflow_dispatch',
                per_page: 50,
              });
              const runs = Array.isArray(response.data?.workflow_runs) ? response.data.workflow_runs : [];
              return runs.find((run) => matches(run)) || null;
            };

            const attempts = 6;
            const delayMs = 5000;
            let matched = null;
            for (let attempt = 1; attempt <= attempts; attempt += 1) {
              matched = await poll();
              if (matched) {
                break;
              }
              await new Promise((resolve) => setTimeout(resolve, delayMs));
            }

            if (!matched) {
              core.setOutput('confirmed', 'false');
              core.setOutput('reason', 'dispatch-unconfirmed');
              core.setFailed('dispatch-unconfirmed');
              return;
            }

            const runId = String(matched.id);
            const runUrl = matched.html_url || '';
            core.info(`DISPATCH_CONFIRMED: run ${runId}${runUrl ? ` (${runUrl})` : ''}`);
            core.setOutput('confirmed', 'true');
            core.setOutput('reason', 'ok');
            core.setOutput('run_id', runId);
            core.setOutput('run_url', runUrl);

      - name: Dispatch codex keepalive command
        if: steps.confirm_dispatch.outputs.confirmed == 'true'
        uses: actions/github-script@v7
        env:
          BASE: ${{ needs.keepalive_dispatch.outputs.base }}
          HEAD: ${{ needs.keepalive_dispatch.outputs.branch }}
          ROUND: ${{ needs.keepalive_dispatch.outputs.round }}
          TRACE: ${{ needs.keepalive_dispatch.outputs.trace }}
          COMMENT_ID: ${{ needs.keepalive_dispatch.outputs.comment_id }}
          COMMENT_URL: ${{ needs.keepalive_dispatch.outputs.comment_url }}
          AGENT_ALIAS: ${{ needs.keepalive_dispatch.outputs.agent_alias }}
          INSTRUCTION_BODY: ${{ needs.keepalive_dispatch.outputs.instruction_body }}
        with:
          github-token: ${{ steps.select_token.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;

            const prNumber = Number('${{ needs.keepalive_dispatch.outputs.pr || github.event.issue.number || '' }}');
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setFailed('Unable to determine pull request number for keepalive dispatch.');
              return;
            }

            const base = process.env.BASE || '';
            const head = process.env.HEAD || '';
            const round = process.env.ROUND || '';
            const trace = process.env.TRACE || '';
            const agentAlias = (process.env.AGENT_ALIAS || '').trim() || 'codex';

            let resolvedBase = base;
            let resolvedHead = head;

            if (!resolvedBase || !resolvedHead) {
              const pull = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber,
              });

              resolvedBase = resolvedBase || pull.data.base?.ref || '';
              resolvedHead = resolvedHead || pull.data.head?.ref || '';
            }

            if (!resolvedBase || !resolvedHead) {
              core.setFailed('Unable to determine pull request base/head branches.');
              return;
            }

            const commentId = process.env.COMMENT_ID || '';
            const commentUrl = process.env.COMMENT_URL || '';

            if (!commentId || !commentUrl) {
              core.setFailed('Comment metadata missing id or url.');
              return;
            }

            const instructionBody = process.env.INSTRUCTION_BODY || '';
            if (!instructionBody) {
              core.setFailed('Instruction body unavailable for keepalive dispatch.');
              return;
            }

            const clientPayload = {
              issue: prNumber,
              base: resolvedBase,
              head: resolvedHead,
              agent: agentAlias,
              comment_id: commentId,
              comment_url: commentUrl,
              round,
              trace,
              instruction_body: instructionBody,
              quiet: true,
              reply: 'none',
            };

            await github.rest.repos.createDispatchEvent({
              owner,
              repo,
              event_type: 'codex-pr-comment-command',
              client_payload: clientPayload,
            });

            core.info(`repository_dispatch emitted for PR #${prNumber} (comment ${commentId}).`);

      - name: Write dispatch summary
        if: ${{ always() }}
        env:
          PATH_LABEL: comment
          DISPATCH: >-
            ${{
              steps.select_token.outputs.allowed != 'false'
              && steps.activation_lock.outputs.status != 'lock-held'
              && steps.dispatch_orchestrator.outputs.ok == 'true'
              && steps.confirm_dispatch.outputs.confirmed == 'true'
              && 'true'
              || 'false'
            }}
          TRACE: ${{ needs.keepalive_dispatch.outputs.trace || '-' }}
          PR_NUMBER: ${{ needs.keepalive_dispatch.outputs.pr || github.event.issue.number }}
          ACTIVATION_ID: ${{ needs.keepalive_dispatch.outputs.comment_id || github.event.comment.id || '' }}
          DISPATCH_REASON: >-
            ${{
              steps.confirm_dispatch.outputs.reason
              || steps.dispatch_orchestrator.outputs.reason
              || steps.activation_lock.outputs.reason
              || steps.select_token.outputs.reason
              || needs.keepalive_dispatch.outputs.reason
              || ''
            }}
          DISPATCH_AGENT: ${{ needs.keepalive_dispatch.outputs.agent_alias || 'codex' }}
          HEAD_SHA: ${{ needs.keepalive_dispatch.outputs.head_sha || '' }}
          ACTIVE_RUNS: ${{ needs.keepalive_dispatch.outputs.active_runs || '0' }}
          RUN_CAP: ${{ needs.keepalive_dispatch.outputs.run_cap || '' }}
          GATE_OK: ${{ needs.keepalive_dispatch.outputs.gate_ok || 'false' }}
          GATE_REASON: ${{ needs.keepalive_dispatch.outputs.gate_reason || '' }}
        run: |
          set -euo pipefail

          GATE_OK="${GATE_OK:-}"
          GATE_REASON="${GATE_REASON:-}"

          normalise_bool() {
            local raw="${1:-false}"
            raw=$(printf '%s' "${raw}" | tr '[:upper:]' '[:lower:]')
            case "${raw}" in
              true|1|yes) printf 'true' ;;
              *) printf 'false' ;;
            esac
          }

          normalise_path() {
            local raw
            raw=$(printf '%s' "${1:-unknown}" | tr '[:upper:]' '[:lower:]')
            case "${raw}" in
              gate|comment) printf '%s' "${raw}" ;;
              *) printf 'unknown' ;;
            esac
          }

          normalise_reason() {
            local raw
            raw=$(printf '%s' "${1:-}" | tr '[:upper:]' '[:lower:]')
            case "${raw}" in
              ok|success) printf 'ok' ;;
              forbidden-token) printf 'forbidden-token' ;;
              lock-held) printf 'lock-held' ;;
              dispatch-unconfirmed|dispatch-error) printf 'dispatch-unconfirmed' ;;
              cap-reached|run-cap-reached) printf 'cap-reached' ;;
              no-activation-found|missing-activation-comment|invalid-activation-comment) printf 'no-activation-found' ;;
              instruction-empty|instruction-missing|instruction-parse-failed|missing-trace|missing-sentinel|missing-round|invalid-round|missing-comment-id|instruction-reaction-failed|missing-instruction-reaction|automation-comment) printf 'instruction-empty' ;;
              gate-pending|gate-not-concluded|gate-blocked:gate-pending|gate-blocked:pending|gate-blocked:gate-not-concluded) printf 'gate-pending' ;;
              gate-failed|gate-not-success|gate-run-missing|sync-required|gate-error|ignored-comment-action|unsupported-event|pull-fetch-failed|fork-pr|gate-blocked|gate-blocked:gate-run-missing|gate-blocked:gate-not-success|gate-blocked:sync-required|gate-blocked:gate-error|gate-blocked:gate-failed) printf 'gate-failed' ;;
              no-human-activation|unauthorised-author) printf 'no-human-activation' ;;
              missing-keepalive-label|keepalive-label-missing|missing-label) printf 'missing-label' ;;
              no-linked-pr|missing-pr-number|missing-pr|missing-issue-reference) printf 'no-linked-pr' ;;
              gate-blocked:*) printf 'gate-failed' ;;
              *) printf '%s' "${raw:-gate-failed}" ;;
            esac
          }

          pr_value() {
            local raw="${1:-}"
            if [[ -n "${raw}" && "${raw}" != 'unknown' && "${raw}" != '0' ]]; then
              printf '#%s' "${raw}"
            else
              printf '#?'
            fi
          }

          activation_value() {
            local raw="${1:-}"
            if [[ -n "${raw}" && "${raw}" != 'unknown' && "${raw}" != '0' ]]; then
              printf '%s' "${raw}"
            else
              printf 'none'
            fi
          }

          head_value='unknown'
          if [[ -n "${HEAD_SHA}" && "${HEAD_SHA}" != 'unknown' ]]; then
            head_value=$(printf '%.7s' "${HEAD_SHA}")
          fi

          active_value=${ACTIVE_RUNS:-0}
          if [[ -z "${active_value}" || "${active_value}" == 'unknown' ]]; then
            active_value='0'
          fi

          cap_value=${RUN_CAP:-}
          if [[ -z "${cap_value}" || "${cap_value}" == 'unknown' ]]; then
            cap_value='?'
          fi

          dispatch_ok=$(normalise_bool "${DISPATCH}")
          reason_value=$(normalise_reason "${DISPATCH_REASON}")
          if [[ "${dispatch_ok}" == 'true' ]]; then
            reason_value='ok'
          fi

          path_value=$(normalise_path "${PATH_LABEL}")
          pr_text=$(pr_value "${PR_NUMBER}")
          activation_text=$(activation_value "${ACTIVATION_ID}")
          trace_value=${TRACE:--}
          agent_value=${DISPATCH_AGENT:-?}

          summary_line="DISPATCH: ok=${dispatch_ok} path=${path_value} reason=${reason_value} pr=${pr_text} activation=${activation_text} agent=${agent_value:-?} head=${head_value} cap=${active_value}/${cap_value} trace=${trace_value}"

          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            printf '%s\n' "${summary_line}" >>"${GITHUB_STEP_SUMMARY}"
          fi
          printf '%s\n' "${summary_line}"

          gate_ok=$(normalise_bool "${GATE_OK}")
          gate_reason=$(normalise_reason "${GATE_REASON}")
          pr_gate=$(pr_value "${PR_NUMBER}")
          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            printf 'GATE: ok=%s reason=%s pr=%s head=%s\n' "${gate_ok}" "${gate_reason}" "${pr_gate}" "${head_value}" >>"${GITHUB_STEP_SUMMARY}"
          fi
          printf 'GATE: ok=%s reason=%s pr=%s head=%s\n' "${gate_ok}" "${gate_reason}" "${pr_gate}" "${head_value}"

  gate_event_context:
    if: >-
      ${{ github.event_name == 'workflow_run'
          && github.event.workflow_run.name == 'Gate'
          && github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      pr: ${{ steps.resolve.outputs.pr }}
      has_pr: ${{ steps.resolve.outputs.has_pr }}
    steps:
      - name: Resolve Gate pull request context
        id: resolve
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pullRequests = Array.isArray(context.payload?.workflow_run?.pull_requests)
              ? context.payload.workflow_run.pull_requests
              : [];
            const first = pullRequests.length > 0 ? pullRequests[0] : null;
            const prNumber = Number(first?.number || 0);
            const hasPr = Number.isFinite(prNumber) && prNumber > 0;
            core.setOutput('has_pr', hasPr ? 'true' : 'false');
            core.setOutput('pr', hasPr ? String(prNumber) : 'unknown');

  keepalive_from_gate:
    needs: gate_event_context
    if: >-
      ${{ github.event_name == 'workflow_run'
          && github.event.workflow_run.name == 'Gate'
          && github.event.workflow_run.conclusion == 'success'
          && github.event.workflow_run.pull_requests
          && github.event.workflow_run.pull_requests[0].number }}
    name: Resume keepalive after Gate
    concurrency:
      group: >-
        ${{ format('pr-meta-dispatch-{0}', needs.gate_event_context.outputs.pr) }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    outputs:
      dispatch: >-
        ${{
          steps.gate.outputs.ok == 'true'
          && steps.detect.outputs.dispatch == 'true'
          && steps.select_token_gate.outputs.allowed != 'false'
          && steps.activation_lock_gate.outputs.status != 'lock-held'
          && steps.dispatch_orchestrator_gate.outputs.ok == 'true'
          && steps.confirm_dispatch_gate.outputs.confirmed == 'true'
          && 'true'
          || 'false'
        }}
      reason: >-
        ${{
          steps.confirm_dispatch_gate.outputs.reason
          || steps.dispatch_orchestrator_gate.outputs.reason
          || steps.activation_lock_gate.outputs.reason
          || steps.select_token_gate.outputs.reason
          || steps.detect.outputs.reason
          || steps.activation_fallback_gate.outputs.reason
          || steps.gate.outputs.reason
        }}
      issue: ${{ steps.detect.outputs.issue }}
      round: ${{ steps.detect.outputs.round }}
      branch: ${{ steps.detect.outputs.branch }}
      base: ${{ steps.detect.outputs.base }}
      trace: ${{ steps.detect.outputs.trace }}
      pr: ${{ steps.detect.outputs.pr || steps.gate.outputs.pr_number }}
      author: ${{ steps.detect.outputs.author }}
      comment_id: ${{ steps.detect.outputs.comment_id || steps.activation_fallback_gate.outputs.comment_id }}
      comment_url: ${{ steps.detect.outputs.comment_url }}
      processed_reaction: ${{ steps.detect.outputs.processed_reaction }}
      deduped: ${{ steps.detect.outputs.deduped }}
      gate_reason: ${{ steps.gate.outputs.reason }}
      agent_alias: ${{ steps.gate.outputs.agent_alias }}
      has_human_activation: ${{ steps.gate.outputs.has_human_activation }}
      has_keepalive_label: ${{ steps.gate.outputs.has_keepalive_label }}
      has_activated_label: ${{ steps.gate.outputs.has_activated_label }}
      gate_concluded: ${{ steps.gate.outputs.gate_concluded }}
      gate_succeeded: ${{ steps.gate.outputs.gate_succeeded }}
      pending_gate: ${{ steps.gate.outputs.pending_gate }}
      under_run_cap: ${{ steps.gate.outputs.under_run_cap }}
      active_runs: ${{ steps.gate.outputs.active_runs }}
      run_cap: ${{ steps.gate.outputs.run_cap }}
      require_human_activation: ${{ steps.gate.outputs.require_human_activation }}
      head_sha: ${{ steps.gate.outputs.head_sha }}
      token_source: ${{ steps.select_token_gate.outputs.token_source }}
      token_login: ${{ steps.identify_token_gate.outputs.login }}
      dispatch_run_id: ${{ steps.confirm_dispatch_gate.outputs.run_id }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Evaluate keepalive gate after workflow_run
        id: gate
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { evaluateKeepaliveGate } = require('./.github/scripts/keepalive_gate.js');

            const workflowRun = context.payload?.workflow_run || {};
            const pullRequests = Array.isArray(workflowRun.pull_requests) ? workflowRun.pull_requests : [];
            const primaryPull = pullRequests.length > 0 ? pullRequests[0] : null;

            const prNumber = Number(primaryPull?.number || 0);
            const headSha = workflowRun.head_sha || '';
            const headRef = primaryPull?.head?.ref || workflowRun.head_branch || '';

            const result = await evaluateKeepaliveGate({
              core,
              github,
              context,
              options: {
                prNumber,
                headSha,
                requireHumanActivation: true,
                requireGateSuccess: true,
                currentRunId: workflowRun.id,
              },
            });

            const bool = (value) => (value ? 'true' : 'false');
            core.setOutput('ok', bool(result.ok));
            core.setOutput('reason', result.reason || '');
            core.setOutput('has_keepalive_label', bool(result.hasKeepaliveLabel));
            core.setOutput('has_human_activation', bool(result.hasHumanActivation));
            core.setOutput('has_activated_label', bool(result.hasActivatedLabel));
            core.setOutput('gate_concluded', bool(result.gateConcluded));
            core.setOutput('gate_succeeded', bool(result.gateSucceeded));
            core.setOutput('pending_gate', bool(result.pendingGate));
            core.setOutput('under_run_cap', bool(result.underRunCap));
            core.setOutput('run_cap', String(result.runCap ?? ''));
            core.setOutput('active_runs', String(result.activeRuns ?? ''));
            core.setOutput('agent_alias', result.primaryAgent || '');
            core.setOutput('head_sha', result.headSha || headSha || '');
            core.setOutput('head_ref', result.headRef || headRef || '');
            core.setOutput('pr_number', Number.isFinite(prNumber) && prNumber > 0 ? String(prNumber) : '');
            core.setOutput('require_human_activation', bool(result.requireHumanActivation));
            core.setOutput('activation_comment', result.activationComment ? JSON.stringify(result.activationComment) : '');

            if (result.ok) {
              core.info('Gate-triggered keepalive evaluation passed.');
            } else {
              core.info(`Gate-triggered keepalive evaluation blocked: ${result.reason || 'unspecified'}`);
            }

      - name: Restore activation comment fallback
        id: activation_fallback_gate
        if: steps.gate.outputs.activation_comment == ''
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.gate.outputs.pr_number || '' }}
          HEAD_SHA: ${{ steps.gate.outputs.head_sha || github.event.workflow_run.head_sha || '' }}
          AGENT_ALIAS: ${{ steps.gate.outputs.agent_alias || '' }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const workflowRun = context.payload?.workflow_run || {};
            const pullRequests = Array.isArray(workflowRun.pull_requests) ? workflowRun.pull_requests : [];
            const firstPull = pullRequests.length > 0 ? pullRequests[0] : null;

            const parseNumber = (value) => {
              const parsed = Number(value);
              return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
            };

            let prNumber = parseNumber(process.env.PR_NUMBER);
            if (!prNumber && firstPull?.number) {
              prNumber = parseNumber(firstPull.number);
            }

            const { owner, repo } = context.repo;

            const headSha = (process.env.HEAD_SHA || '').trim();
            if (!prNumber && headSha) {
              try {
                const { data } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                  owner,
                  repo,
                  commit_sha: headSha,
                });
                const associated = Array.isArray(data) ? data : [];
                const firstMatch =
                  associated.find((pull) => pull && pull.number && pull.state !== 'closed') ||
                  associated.find((pull) => pull && pull.number);
                if (firstMatch?.number) {
                  prNumber = parseNumber(firstMatch.number);
                }
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to resolve PR from head SHA ${headSha}: ${message}`);
              }
            }

            if (!prNumber) {
              core.setOutput('activation_comment', '');
              core.setOutput('comment_id', '');
              core.setOutput('reason', 'no-activation-found');
              core.setOutput('found', 'false');
              return;
            }

            const normaliseAlias = (value) => String(value || '').trim().toLowerCase();
            const agentAlias = normaliseAlias(process.env.AGENT_ALIAS);

            const loadMentionCandidates = () => {
              const candidates = new Set(['codex', 'claude', 'octavia']);
              if (agentAlias) {
                candidates.add(agentAlias);
              }

              const agentsPath = path.join(process.cwd(), '.github', 'agents.json');
              try {
                const buffer = fs.readFileSync(agentsPath, 'utf8');
                const parsed = JSON.parse(buffer);
                for (const value of Object.values(parsed || {})) {
                  if (!value || typeof value !== 'object') {
                    continue;
                  }
                  const mention = normaliseAlias(value.mention || '');
                  if (mention) {
                    const mentionValue = mention.replace(/^@/, '');
                    if (mentionValue) {
                      candidates.add(mentionValue);
                    }
                  }
                  if (Array.isArray(value.aliases)) {
                    for (const alias of value.aliases) {
                      const normalised = normaliseAlias(alias);
                      if (normalised) {
                        candidates.add(normalised);
                      }
                    }
                  }
                }
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                core.warning(`Unable to read agents mention list (${agentsPath}): ${message}`);
              }

              return candidates;
            };

            const mentionCandidates = loadMentionCandidates();

            const buildMentionPattern = (alias) => {
              const escaped = alias.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              return new RegExp(`(^|[^A-Za-z0-9_-])@${escaped}(?![A-Za-z0-9_-])`, 'i');
            };

            const mentionPatterns = Array.from(mentionCandidates).map((alias) => buildMentionPattern(alias));
            const keepalivePatterns = [
              /<!--\s*codex-keepalive-marker\s*-->/i,
              /<!--\s*keepalive-round\s*:/i,
              /<!--\s*codex-keepalive-trace\s*:/i,
            ];

            const isHumanUser = (user) => {
              if (!user) {
                return false;
              }
              const type = String(user.type || '').toLowerCase();
              if (type === 'bot' || type === 'app') {
                return false;
              }
              const login = String(user.login || '').toLowerCase();
              if (!login) {
                return false;
              }
              return !login.endsWith('[bot]');
            };

            let comments = [];
            try {
              comments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: prNumber,
                per_page: 100,
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to read comments for PR #${prNumber}: ${message}`);
              comments = [];
            }

            const allowComment = (comment) => {
              if (!comment) {
                return false;
              }
              if (!isHumanUser(comment.user)) {
                return false;
              }
              const body = String(comment.body || '');
              if (!body) {
                return false;
              }
              if (!mentionPatterns.some((pattern) => pattern.test(body))) {
                return false;
              }
              if (keepalivePatterns.some((pattern) => pattern.test(body))) {
                return false;
              }
              return true;
            };

            const sorted = comments
              .filter((comment) => allowComment(comment))
              .sort((a, b) => {
                const aTime = Date.parse(a?.created_at || a?.updated_at || 0) || 0;
                const bTime = Date.parse(b?.created_at || b?.updated_at || 0) || 0;
                return bTime - aTime;
              });

            const activationComment = sorted.length > 0 ? sorted[0] : null;

            if (!activationComment) {
              core.setOutput('activation_comment', '');
              core.setOutput('comment_id', '');
              core.setOutput('reason', 'no-activation-found');
              core.setOutput('found', 'false');
              core.info(`No eligible human activation comment found for PR #${prNumber}.`);
              return;
            }

            const minimalComment = {
              id: activationComment.id,
              body: activationComment.body,
              user: activationComment.user
                ? { login: activationComment.user.login, type: activationComment.user.type }
                : null,
              html_url: activationComment.html_url,
              created_at: activationComment.created_at,
              updated_at: activationComment.updated_at,
            };

            core.setOutput('activation_comment', JSON.stringify(minimalComment));
            core.setOutput('comment_id', String(activationComment.id || ''));
            core.setOutput('found', 'true');
            core.setOutput('reason', 'ok');
            core.info(`Recovered activation comment ${activationComment.id} for PR #${prNumber}.`);

      - name: Record gate summary
        run: |
          set -euo pipefail
          ok="${OK:-false}"
          reason="${REASON:-unspecified}"
          pr_num="${PR_NUMBER:-}"
          if [[ -n "${pr_num}" ]]; then
            pr_value="#${pr_num}"
          else
            pr_value="#?"
          fi
          agent="${AGENT_ALIAS:-codex}"
          if [[ -z "${agent}" ]]; then
            agent='?'
          fi
          cap="${RUN_CAP:-}"
          if [[ -z "${cap}" ]]; then
            cap='?'
          fi
          active="${ACTIVE_RUNS:-}"
          if [[ -z "${active}" ]]; then
            active='0'
          fi
          head="${HEAD_SHA:-}"
          if [[ -n "${head}" ]]; then
            head="${head:0:7}"
          else
            head='unknown'
          fi
          if [[ "${reason}" == 'run-cap-reached' ]]; then
            printf 'CAP: ok=%s reason=%s pr=%s cap=%s active=%s\n' \
              "${ok}" "${reason}" "${pr_value}" "${cap}" "${active}"
          else
            printf 'GATE: ok=%s reason=%s pr=%s agent=%s cap=%s active=%s head=%s\n' \
              "${ok}" "${reason}" "${pr_value}" "${agent}" "${cap}" "${active}" "${head}"
          fi
        env:
          OK: ${{ steps.gate.outputs.ok || 'false' }}
          REASON: ${{ steps.gate.outputs.reason || 'unspecified' }}
          PR_NUMBER: ${{ steps.gate.outputs.pr_number || '' }}
          AGENT_ALIAS: ${{ steps.gate.outputs.agent_alias || '' }}
          RUN_CAP: ${{ steps.gate.outputs.run_cap || '2' }}
          ACTIVE_RUNS: ${{ steps.gate.outputs.active_runs || '0' }}
          HEAD_SHA: ${{ steps.gate.outputs.head_sha || '' }}

      - name: Persist keepalive activation label
        if: steps.gate.outputs.ok == 'true' && steps.gate.outputs.has_activated_label != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const prNumber = Number('${{ steps.gate.outputs.pr_number || '0' }}');
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.warning('Activation label requires a valid pull request number.');
              return;
            }

            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: ['agents:activated'],
              });
              core.info(`Added agents:activated label to PR #${prNumber}.`);
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to add agents:activated label to PR #${prNumber}: ${message}`);
            }

      - name: Evaluate keepalive request after Gate
        id: detect
        if: steps.gate.outputs.activation_comment != '' || steps.activation_fallback_gate.outputs.activation_comment != ''
        uses: actions/github-script@v7
        env:
          ALLOWED_LOGINS: chatgpt-codex-connector,stranske-automation-bot,stranske
          KEEPALIVE_MARKER: '<!-- codex-keepalive-marker -->'
          KEEPALIVE_AGENT_ALIAS: ${{ steps.gate.outputs.agent_alias }}
          ACTIVATION_COMMENT: ${{ steps.activation_fallback_gate.outputs.activation_comment || steps.gate.outputs.activation_comment }}
          PR_NUMBER: ${{ steps.gate.outputs.pr_number }}
          GATE_OK: ${{ steps.gate.outputs.ok || 'false' }}
          GATE_REASON: ${{ steps.gate.outputs.reason || '' }}
          GATE_PENDING: ${{ steps.gate.outputs.pending_gate || 'false' }}
          ALLOW_REPLAY: 'true'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { detectKeepalive } = require('./.github/scripts/agents_pr_meta_keepalive.js');

            const prNumber = Number(process.env.PR_NUMBER || 0);
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setOutput('dispatch', 'false');
              core.setOutput('reason', 'missing-pr-number');
              return;
            }

            const commentPayload = process.env.ACTIVATION_COMMENT || '';
            if (!commentPayload) {
              core.setOutput('dispatch', 'false');
              core.setOutput('reason', 'missing-activation-comment');
              return;
            }

            let comment;
            try {
              comment = JSON.parse(commentPayload);
            } catch (error) {
              core.setOutput('dispatch', 'false');
              core.setOutput('reason', 'invalid-activation-comment');
              core.warning(`Unable to parse activation comment payload: ${error.message}`);
              return;
            }

            const commentId = Number(comment?.id || 0);
            if (!Number.isFinite(commentId) || commentId <= 0) {
              core.setOutput('dispatch', 'false');
              core.setOutput('reason', 'invalid-activation-comment');
              core.warning('Activation comment missing a valid id.');
              return;
            }

            const { owner, repo } = context.repo;
            let enrichedComment = comment;
            try {
              const { data } = await github.rest.issues.getComment({
                owner,
                repo,
                comment_id: commentId,
              });
              enrichedComment = data || comment;
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to refresh activation comment ${commentId}: ${message}`);
              enrichedComment = {
                ...comment,
                id: commentId,
              };
            }

            const detectionContext = {
              ...context,
              payload: {
                comment: enrichedComment,
                issue: { number: prNumber },
              },
            };

            await detectKeepalive({ core, github, context: detectionContext, env: process.env });

      - name: Register keepalive detection
        if: steps.detect.outputs.dispatch == 'true' || steps.detect.outputs.reason == 'lock-held'
        run: |
          set -euo pipefail
          comment_id="${{ steps.detect.outputs.comment_id || '?' }}"
          trace="${{ steps.detect.outputs.trace || '(missing)' }}"
          source="${{ steps.detect.outputs.author || 'unknown' }}"
          seen="${{ steps.detect.outputs.processed_reaction || 'false' }}"
          deduped="${{ steps.detect.outputs.deduped || 'false' }}"
          printf 'INSTRUCTION: comment_id=%s trace=%s source=%s seen=%s deduped=%s\n' \
            "${comment_id}" "${trace}" "${source}" "${seen}" "${deduped}"

      - name: Select keepalive dispatch token (Gate)
        id: select_token_gate
        if: steps.gate.outputs.ok == 'true' && steps.detect.outputs.dispatch == 'true'
        env:
          ACTIONS_TOKEN: ${{ secrets.ACTIONS_BOT_PAT }}
          SERVICE_TOKEN: ${{ secrets.SERVICE_BOT_PAT }}
        run: |
          set -euo pipefail
          if [[ -n "${ACTIONS_TOKEN}" ]]; then
            {
              printf 'allowed=true\n'
              printf 'token_source=ACTIONS_BOT_PAT\n'
              printf 'reason=ok\n'
            } >>"${GITHUB_OUTPUT}"
          elif [[ -n "${SERVICE_TOKEN}" ]]; then
            {
              printf 'allowed=true\n'
              printf 'token_source=SERVICE_BOT_PAT\n'
              printf 'reason=ok\n'
            } >>"${GITHUB_OUTPUT}"
          else
            echo "::error::Keepalive orchestrator dispatch requires ACTIONS_BOT_PAT or SERVICE_BOT_PAT." >&2
            {
              printf 'allowed=false\n'
              printf 'token_source=\n'
              printf 'reason=forbidden-token\n'
            } >>"${GITHUB_OUTPUT}"
          fi

      - name: Identify dispatch token (Gate)
        id: identify_token_gate
        if: steps.select_token_gate.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_token_gate.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const response = await github.rest.users.getAuthenticated();
            const login = response.data?.login || 'unknown';
            const id = response.data?.id ? String(response.data.id) : '';
            const identity = id ? `${login} (${id})` : login;
            core.info(`TOKEN_IDENTITY: ${identity}`);
            core.setOutput('login', login);
            core.setOutput('user_id', id);

      - name: Acquire activation lock (Gate)
        id: activation_lock_gate
        if: steps.select_token_gate.outputs.allowed == 'true' && steps.detect.outputs.dispatch == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_token_gate.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const rawCommentId = '${{ steps.detect.outputs.comment_id || steps.activation_fallback_gate.outputs.comment_id || '' }}';
            const commentId = Number(rawCommentId);
            if (!Number.isFinite(commentId) || commentId <= 0) {
              core.setOutput('status', 'missing');
              core.setOutput('reason', 'no-activation-found');
              return;
            }

            const { owner, repo } = context.repo;
            try {
              await github.rest.reactions.createForIssueComment({
                owner,
                repo,
                comment_id: commentId,
                content: 'rocket',
              });
              core.info(`Activation lock applied to comment ${commentId}.`);
              core.setOutput('status', 'ok');
              core.setOutput('reason', 'ok');
            } catch (error) {
              const status = Number(error?.status || 0);
              const message = error instanceof Error ? error.message : String(error);
              if (status === 409) {
                core.info(`Activation lock already present on comment ${commentId}.`);
              } else {
                core.warning(`Failed to add activation lock to comment ${commentId}: ${message}`);
              }
              core.setOutput('status', 'lock-held');
              core.setOutput('reason', 'lock-held');
            }

      - name: Snapshot orchestrator runs (Gate)
        id: snapshot_runs_gate
        if: steps.select_token_gate.outputs.allowed == 'true' && steps.detect.outputs.dispatch == 'true' && steps.activation_lock_gate.outputs.status != 'lock-held'
        env:
          PR_NUMBER: ${{ steps.detect.outputs.pr || steps.gate.outputs.pr_number || '' }}
          TRACE: ${{ steps.detect.outputs.trace || '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_token_gate.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER || 0);
            const trace = (process.env.TRACE || '').trim();
            const { owner, repo } = context.repo;
            const response = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: 'agents-70-orchestrator.yml',
              event: 'workflow_dispatch',
              per_page: 50,
            });
            const runs = Array.isArray(response.data?.workflow_runs) ? response.data.workflow_runs : [];
            const ids = runs.map((run) => Number(run?.id)).filter((value) => Number.isFinite(value));
            core.info(`Snapshot captured ${ids.length} workflow_dispatch runs for agents-70-orchestrator.yml.`);
            core.setOutput('ids', JSON.stringify(ids));
            core.setOutput('timestamp', new Date().toISOString());
            core.setOutput('pr', prNumber > 0 ? String(prNumber) : '');
            core.setOutput('trace', trace);

      - name: Dispatch Agents 70 run for keepalive (Gate)
        id: dispatch_orchestrator_gate
        if: steps.select_token_gate.outputs.allowed == 'true' && steps.detect.outputs.dispatch == 'true' && steps.activation_lock_gate.outputs.status != 'lock-held'
        uses: actions/github-script@v7
        env:
          ISSUE: ${{ steps.detect.outputs.issue }}
          PR_NUMBER: ${{ steps.detect.outputs.pr || steps.gate.outputs.pr_number || '' }}
          BRANCH: ${{ steps.detect.outputs.branch }}
          BASE: ${{ steps.detect.outputs.base }}
          ROUND: ${{ steps.detect.outputs.round }}
          TRACE: ${{ steps.detect.outputs.trace }}
          INSTRUCTION_BODY: ${{ steps.detect.outputs.instruction_body }}
        with:
          github-token: ${{ steps.select_token_gate.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const issueNumber = Number(process.env.ISSUE || 0);
            const prNumber = Number(process.env.PR_NUMBER || 0);
            const branch = process.env.BRANCH || '';
            const base = process.env.BASE || '';
            const roundRaw = Number(process.env.ROUND || 0);
            const trace = process.env.TRACE || '';
            const instructionBody = process.env.INSTRUCTION_BODY || '';

            const { owner, repo } = context.repo;
            const workflowId = 'agents-70-orchestrator.yml';
            const ref = context.payload?.repository?.default_branch || 'phase-2-dev';

            const params = { enable_keepalive: true };
            if (Number.isFinite(issueNumber) && issueNumber > 0) {
              params.dispatcher_force_issue = String(issueNumber);
            }
            if (branch) {
              params.keepalive_branch = branch;
            }
            if (base) {
              params.keepalive_base = base;
            }

            const round = Number.isFinite(roundRaw) && roundRaw > 0 ? String(roundRaw) : '';
            const prValue = Number.isFinite(prNumber) && prNumber > 0 ? String(prNumber) : '';

            const options = {
              keepalive_trace: trace,
              round,
              pr: prValue,
            };
            if (instructionBody) {
              options.keepalive_instruction = instructionBody;
            }

            try {
              await github.rest.actions.createWorkflowDispatch({
                owner,
                repo,
                workflow_id: workflowId,
                ref,
                inputs: {
                  keepalive_enabled: 'true',
                  params_json: JSON.stringify(params),
                  options_json: JSON.stringify(options),
                  dry_run: 'false',
                  pr_number: prValue,
                },
              });
              core.info(`Dispatched ${workflowId} for keepalive (pr=${prValue || 'n/a'}, trace=${trace || '-' }).`);
              core.setOutput('ok', 'true');
              core.setOutput('reason', 'ok');
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.error(`Failed to dispatch ${workflowId}: ${message}`);
              core.setOutput('ok', 'false');
              core.setOutput('reason', 'dispatch-error');
              throw error;
            }

      - name: Confirm orchestrator dispatch (Gate)
        id: confirm_dispatch_gate
        if: steps.dispatch_orchestrator_gate.outputs.ok == 'true'
        env:
          BASELINE_IDS: ${{ steps.snapshot_runs_gate.outputs.ids }}
          PR_NUMBER: ${{ steps.snapshot_runs_gate.outputs.pr || steps.detect.outputs.pr || steps.gate.outputs.pr_number || '' }}
          TRACE: ${{ steps.snapshot_runs_gate.outputs.trace || steps.detect.outputs.trace || '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.select_token_gate.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const parseIds = (value) => {
              if (!value) {
                return new Set();
              }
              try {
                const parsed = JSON.parse(value);
                if (Array.isArray(parsed)) {
                  return new Set(parsed.map((entry) => Number(entry)).filter((entry) => Number.isFinite(entry)));
                }
              } catch (error) {
                core.warning(`Unable to parse baseline ids: ${error.message || error}`);
              }
              return new Set();
            };

            const baseline = parseIds(process.env.BASELINE_IDS || '[]');
            const prNumber = Number(process.env.PR_NUMBER || 0);
            const trace = (process.env.TRACE || '').trim();
            const { owner, repo } = context.repo;

            const matches = (run) => {
              if (!run) {
                return false;
              }
              const runId = Number(run.id);
              if (baseline.has(runId)) {
                return false;
              }
              if (prNumber > 0) {
                const concurrency = String(run.concurrency || '');
                if (concurrency.includes(`pr-${prNumber}-`)) {
                  return true;
                }
                const pulls = Array.isArray(run.pull_requests) ? run.pull_requests : [];
                if (pulls.some((pull) => Number(pull?.number) === prNumber)) {
                  return true;
                }
              }
              if (trace) {
                const candidates = [run.name, run.display_title, run.head_branch, run.head_sha];
                if (candidates.some((value) => typeof value === 'string' && value.includes(trace))) {
                  return true;
                }
              }
              return false;
            };

            const poll = async () => {
              const response = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: 'agents-70-orchestrator.yml',
                event: 'workflow_dispatch',
                per_page: 50,
              });
              const runs = Array.isArray(response.data?.workflow_runs) ? response.data.workflow_runs : [];
              return runs.find((run) => matches(run)) || null;
            };

            const attempts = 6;
            const delayMs = 5000;
            let matched = null;
            for (let attempt = 1; attempt <= attempts; attempt += 1) {
              matched = await poll();
              if (matched) {
                break;
              }
              await new Promise((resolve) => setTimeout(resolve, delayMs));
            }

            if (!matched) {
              core.setOutput('confirmed', 'false');
              core.setOutput('reason', 'dispatch-unconfirmed');
              core.setFailed('dispatch-unconfirmed');
              return;
            }

            const runId = String(matched.id);
            const runUrl = matched.html_url || '';
            core.info(`DISPATCH_CONFIRMED: run ${runId}${runUrl ? ` (${runUrl})` : ''}`);
            core.setOutput('confirmed', 'true');
            core.setOutput('reason', 'ok');
            core.setOutput('run_id', runId);
            core.setOutput('run_url', runUrl);

      - name: Dispatch codex keepalive command (Gate)
        if: steps.confirm_dispatch_gate.outputs.confirmed == 'true'
        uses: actions/github-script@v7
        env:
          BASE: ${{ steps.detect.outputs.base }}
          HEAD: ${{ steps.detect.outputs.branch }}
          ROUND: ${{ steps.detect.outputs.round }}
          TRACE: ${{ steps.detect.outputs.trace }}
          COMMENT_ID: ${{ steps.detect.outputs.comment_id || steps.activation_fallback_gate.outputs.comment_id }}
          COMMENT_URL: ${{ steps.detect.outputs.comment_url }}
          AGENT_ALIAS: ${{ steps.gate.outputs.agent_alias }}
          INSTRUCTION_BODY: ${{ steps.detect.outputs.instruction_body }}
        with:
          github-token: ${{ steps.select_token_gate.outputs.token_source == 'ACTIONS_BOT_PAT' && secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;

            const prNumber = Number('${{ steps.detect.outputs.pr || steps.gate.outputs.pr_number }}');
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              core.setFailed('Unable to determine pull request number for keepalive dispatch.');
              return;
            }

            const base = process.env.BASE || '';
            const head = process.env.HEAD || '';
            const round = process.env.ROUND || '';
            const trace = process.env.TRACE || '';
            const agentAlias = (process.env.AGENT_ALIAS || '').trim() || 'codex';

            let resolvedBase = base;
            let resolvedHead = head;

            if (!resolvedBase || !resolvedHead) {
              const pull = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber,
              });

              resolvedBase = resolvedBase || pull.data.base?.ref || '';
              resolvedHead = resolvedHead || pull.data.head?.ref || '';
            }

            if (!resolvedBase || !resolvedHead) {
              core.setFailed('Unable to determine pull request base/head branches.');
              return;
            }

            const commentId = process.env.COMMENT_ID || '';
            const commentUrl = process.env.COMMENT_URL || '';

            if (!commentId || !commentUrl) {
              core.setFailed('Comment metadata missing id or url.');
              return;
            }

            const instructionBody = process.env.INSTRUCTION_BODY || '';
            if (!instructionBody) {
              core.setFailed('Instruction body unavailable for keepalive dispatch.');
              return;
            }

            const clientPayload = {
              issue: prNumber,
              base: resolvedBase,
              head: resolvedHead,
              agent: agentAlias,
              comment_id: commentId,
              comment_url: commentUrl,
              round,
              trace,
              instruction_body: instructionBody,
              quiet: true,
              reply: 'none',
            };

            await github.rest.repos.createDispatchEvent({
              owner,
              repo,
              event_type: 'codex-pr-comment-command',
              client_payload: clientPayload,
            });

            core.info(`repository_dispatch emitted for PR #${prNumber} (comment ${commentId}).`);

      - name: Write dispatch summary (Gate)
        if: ${{ always() }}
        env:
          PATH_LABEL: gate
          DISPATCH: >-
            ${{
              steps.gate.outputs.ok == 'true'
              && steps.detect.outputs.dispatch == 'true'
              && steps.select_token_gate.outputs.allowed != 'false'
              && steps.activation_lock_gate.outputs.status != 'lock-held'
              && steps.dispatch_orchestrator_gate.outputs.ok == 'true'
              && steps.confirm_dispatch_gate.outputs.confirmed == 'true'
              && 'true'
              || 'false'
            }}
          TRACE: ${{ steps.detect.outputs.trace || '-' }}
          PR_NUMBER: ${{ steps.detect.outputs.pr || steps.gate.outputs.pr_number || github.event.workflow_run.pull_requests[0].number || '' }}
          ACTIVATION_ID: ${{ steps.detect.outputs.comment_id || steps.activation_fallback_gate.outputs.comment_id || '' }}
          DISPATCH_REASON: >-
            ${{
              steps.confirm_dispatch_gate.outputs.reason
              || steps.dispatch_orchestrator_gate.outputs.reason
              || steps.activation_lock_gate.outputs.reason
              || steps.select_token_gate.outputs.reason
              || steps.detect.outputs.reason
              || steps.activation_fallback_gate.outputs.reason
              || steps.gate.outputs.reason
              || ''
            }}
          DISPATCH_AGENT: ${{ steps.gate.outputs.agent_alias || 'codex' }}
          HEAD_SHA: ${{ steps.gate.outputs.head_sha || github.event.workflow_run.head_sha || '' }}
          ACTIVE_RUNS: ${{ steps.gate.outputs.active_runs || '0' }}
          RUN_CAP: ${{ steps.gate.outputs.run_cap || '0' }}
          GATE_OK: ${{ steps.gate.outputs.ok || 'false' }}
          GATE_REASON: ${{ steps.gate.outputs.reason || '' }}
        run: |
          set -euo pipefail

          # Ensure shellcheck observes explicit assignments for env-scoped gate vars.
          GATE_OK="${GATE_OK:-}"
          GATE_REASON="${GATE_REASON:-}"

          normalise_bool() {
            local raw="${1:-false}"
            raw=$(printf '%s' "${raw}" | tr '[:upper:]' '[:lower:]')
            case "${raw}" in
              true|1|yes) printf 'true' ;;
              *) printf 'false' ;;
            esac
          }

          normalise_path() {
            local raw
            raw=$(printf '%s' "${1:-unknown}" | tr '[:upper:]' '[:lower:]')
            case "${raw}" in
              gate|comment) printf '%s' "${raw}" ;;
              *) printf 'unknown' ;;
            esac
          }

            normalise_reason() {
              local raw
              raw=$(printf '%s' "${1:-}" | tr '[:upper:]' '[:lower:]')
            case "${raw}" in
              ok|success) printf 'ok' ;;
              forbidden-token) printf 'forbidden-token' ;;
              lock-held) printf 'lock-held' ;;
              dispatch-unconfirmed|dispatch-error) printf 'dispatch-unconfirmed' ;;
              cap-reached|run-cap-reached) printf 'cap-reached' ;;
              no-activation-found|missing-activation-comment|invalid-activation-comment) printf 'no-activation-found' ;;
              instruction-empty|instruction-missing|instruction-parse-failed|missing-trace|missing-sentinel|missing-round|invalid-round|missing-comment-id|instruction-reaction-failed|missing-instruction-reaction|automation-comment) printf 'instruction-empty' ;;
              gate-pending|gate-not-concluded|gate-blocked:gate-pending|gate-blocked:pending|gate-blocked:gate-not-concluded) printf 'gate-pending' ;;
              gate-failed|gate-not-success|gate-run-missing|sync-required|gate-error|ignored-comment-action|unsupported-event|pull-fetch-failed|fork-pr|gate-blocked|gate-blocked:gate-run-missing|gate-blocked:gate-not-success|gate-blocked:sync-required|gate-blocked:gate-error|gate-blocked:gate-failed) printf 'gate-failed' ;;
              no-human-activation|unauthorised-author) printf 'no-human-activation' ;;
              missing-keepalive-label|keepalive-label-missing|missing-label) printf 'missing-label' ;;
              no-linked-pr|missing-pr-number|missing-pr|missing-issue-reference) printf 'no-linked-pr' ;;
              gate-blocked:*) printf 'gate-failed' ;;
              *) printf '%s' "${raw:-gate-failed}" ;;
            esac
          }

          pr_value() {
            local raw="${1:-}"
            if [[ -n "${raw}" && "${raw}" != 'unknown' && "${raw}" != '0' ]]; then
              printf '#%s' "${raw}"
            else
              printf '#?'
            fi
          }

          activation_value() {
            local raw="${1:-}"
            if [[ -n "${raw}" && "${raw}" != 'unknown' && "${raw}" != '0' ]]; then
              printf '%s' "${raw}"
            else
              printf 'none'
            fi
          }

          head_value='unknown'
          if [[ -n "${HEAD_SHA}" && "${HEAD_SHA}" != 'unknown' ]]; then
            head_value=$(printf '%.7s' "${HEAD_SHA}")
          fi

          active_value=${ACTIVE_RUNS:-0}
          if [[ -z "${active_value}" || "${active_value}" == 'unknown' ]]; then
            active_value='0'
          fi

          cap_value=${RUN_CAP:-}
          if [[ -z "${cap_value}" || "${cap_value}" == 'unknown' ]]; then
            cap_value='?'
          fi

          dispatch_ok=$(normalise_bool "${DISPATCH}")
          reason_value=$(normalise_reason "${DISPATCH_REASON}")
          if [[ "${dispatch_ok}" == 'true' ]]; then
            reason_value='ok'
          fi

          path_value=$(normalise_path "${PATH_LABEL}")
          pr_text=$(pr_value "${PR_NUMBER}")
          activation_text=$(activation_value "${ACTIVATION_ID}")
          trace_value=${TRACE:--}
          agent_value=${DISPATCH_AGENT:-?}

          summary_line="DISPATCH: ok=${dispatch_ok} path=${path_value} reason=${reason_value} pr=${pr_text} activation=${activation_text} agent=${agent_value:-?} head=${head_value} cap=${active_value}/${cap_value} trace=${trace_value}"

          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            printf '%s\n' "${summary_line}" >>"${GITHUB_STEP_SUMMARY}"
          fi
          printf '%s\n' "${summary_line}"

          gate_ok=$(normalise_bool "${GATE_OK}")
          gate_reason=$(normalise_reason "${GATE_REASON}")
          pr_gate=$(pr_value "${PR_NUMBER}")
          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            printf 'GATE: ok=%s reason=%s pr=%s head=%s\n' "${gate_ok}" "${gate_reason}" "${pr_gate}" "${head_value}" >>"${GITHUB_STEP_SUMMARY}"
          fi
          printf 'GATE: ok=%s reason=%s pr=%s head=%s\n' "${gate_ok}" "${gate_reason}" "${pr_gate}" "${head_value}"


  gate_no_pr_summary:
    needs: gate_event_context
    if: >-
      ${{ github.event_name == 'workflow_run'
          && github.event.workflow_run.name == 'Gate'
          && github.event.workflow_run.conclusion == 'success'
          && needs.gate_event_context.outputs.has_pr != 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Write dispatch summary
        env:
          TRACE: '-'
          PR_NUMBER: ${{ needs.gate_event_context.outputs.pr }}
        run: |
          set -euo pipefail

          pr_value() {
            local raw="${1:-}"
            if [[ -n "${raw}" && "${raw}" != 'unknown' && "${raw}" != '0' ]]; then
              printf '#%s' "${raw}"
            else
              printf '#?'
            fi
          }

          dispatch_line="DISPATCH: ok=false path=gate reason=no-linked-pr pr=$(pr_value "${PR_NUMBER}") activation=none agent=codex head=unknown cap=0/? trace=${TRACE}"

          if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
            printf '%s\n' "${dispatch_line}" >>"${GITHUB_STEP_SUMMARY}"
            printf 'GATE: ok=false reason=no-linked-pr pr=%s head=unknown\n' "$(pr_value "${PR_NUMBER}")" >>"${GITHUB_STEP_SUMMARY}"
          fi

          printf '%s\n' "${dispatch_line}"
          printf 'GATE: ok=false reason=no-linked-pr pr=%s head=unknown\n' "$(pr_value "${PR_NUMBER}")"

  update_body:
    if: github.event_name == 'pull_request'
    name: Upsert PR body sections
    runs-on: ubuntu-latest
    steps:
      - name: Update PR body
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

            async function withRetries(fn, options = {}) {
              const attempts = Number(options.attempts) || 3;
              const baseDelay = Number(options.delayMs) || 1000;
              const label = options.description || 'operation';
              let lastError;
              for (let attempt = 1; attempt <= attempts; attempt += 1) {
                try {
                  return await fn();
                } catch (error) {
                  lastError = error;
                  const status = error && typeof error.status === 'number' ? error.status : null;
                  const message = error instanceof Error ? error.message : String(error);
                  const retryable = !status || status >= 500 || status === 429;
                  if (!retryable || attempt === attempts) {
                    core.error(`Failed ${label}: ${message}`);
                    throw error;
                  }
                  const delay = baseDelay * attempt;
                  core.warning(`Retrying ${label} after ${delay}ms (attempt ${attempt + 1}/${attempts}) due to ${status || 'error'}`);
                  await sleep(delay);
                }
              }
              throw lastError;
            }

            async function discoverPr() {
              if (context.eventName === 'workflow_dispatch') {
                const prNumber = '${{ inputs.pr_number || '' }}';
                if (prNumber && prNumber.trim()) {
                  const num = Number.parseInt(prNumber.trim(), 10);
                  if (!Number.isNaN(num)) {
                    core.info(`Manual trigger: using PR #${num}`);
                    const response = await withRetries(
                      () => github.rest.pulls.get({owner, repo, pull_number: num}),
                      {description: `pulls.get #${num}`},
                    );
                    return {number: num, headSha: response.data.head.sha};
                  }
                }
                core.warning('workflow_dispatch without valid pr_number; skipping');
                return null;
              }

              if (context.eventName === 'pull_request') {
                const pr = context.payload.pull_request;
                return {number: pr.number, headSha: pr.head.sha};
              }

              if (context.eventName === 'workflow_run') {
                const run = context.payload.workflow_run;
                if (!run || run.event !== 'pull_request') {
                  core.info('Workflow run not associated with a pull request.');
                  return null;
                }

                const headSha = run.head_sha;
                if (Array.isArray(run.pull_requests) && run.pull_requests.length > 0) {
                  const directMatch = run.pull_requests.find((item) => item && item.head_sha === headSha);
                  const candidate = directMatch || run.pull_requests[0];
                  if (candidate && typeof candidate.number === 'number') {
                    return {number: candidate.number, headSha};
                  }
                }
                const prs = await withRetries(
                  () => github.paginate(
                    github.rest.repos.listPullRequestsAssociatedWithCommit,
                    {
                      owner,
                      repo,
                      commit_sha: headSha,
                      per_page: 100,
                    },
                  ),
                  {description: `list PRs for commit ${headSha}`},
                );

                const matching = prs.find((item) => item.head && item.head.sha === headSha);
                if (!matching) {
                  core.info(`No pull request found for commit ${headSha}.`);
                  return null;
                }

                return {number: matching.number, headSha};
              }

              core.info(`Unsupported event: ${context.eventName}`);
              return null;
            }

            function extractIssueNumber(pr) {
              const branch = pr.head.ref || '';
              const candidates = [];
              const branchMatch = branch.match(/issue-+([0-9]+)/i);
              if (branchMatch) {
                candidates.push(branchMatch[1]);
              }

              const titleMatch = (pr.title || '').match(/#([0-9]+)/);
              if (titleMatch) {
                candidates.push(titleMatch[1]);
              }

              const bodyMatches = [...((pr.body || '').matchAll(/#([0-9]+)/g))].map((m) => m[1]);
              candidates.push(...bodyMatches);

              for (const value of candidates) {
                const parsed = Number.parseInt(value, 10);
                if (!Number.isNaN(parsed)) {
                  return parsed;
                }
              }

              return null;
            }

            function extractSection(body, heading) {
              if (!body) {
                core.debug(`extractSection: body is empty for heading "${heading}"`);
                return '';
              }

              // Flexible regex: allow ## headers OR standalone text on its own line
              const escapedHeading = heading.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
              // Match either "## Heading" or just "Heading" at start of line
              const pattern = new RegExp(`(^|\\n)(#{1,3}\\s+)?${escapedHeading}\\s*\\r?\\n`, 'i');
              const match = body.match(pattern);

              if (!match) {
                core.debug(`extractSection: No match for heading "${heading}"`);
                core.debug(`  Pattern: ${pattern}`);
                core.debug(`  Body preview: ${body.slice(0, 200).replace(/\n/g, '\\n')}`);
                return '';
              }

              core.debug(`extractSection: Found "${heading}" at index ${match.index}`);
              const start = match.index + match[0].length;
              const rest = body.slice(start);

              // Look for next section: either ## heading OR a known section name at start of line
              const knownSections = ['Why', 'Scope', 'Non-Goals', 'Goal', 'Tasks', 'Acceptance criteria', 'Success criteria', 'Definition of done', 'Implementation notes', 'Technical notes', 'Summary', 'Description', 'Overview', 'Testing', 'Test Plan', 'Validation', 'CI readiness'];
              const sectionPattern = knownSections.map(s => s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
              const nextPattern = new RegExp(`\\r?\\n(#{2,3}\\s+|(?:${sectionPattern})\\s*\\r?\\n)`, 'i');
              const nextMatch = rest.match(nextPattern);
              const end = nextMatch ? nextMatch.index + 1 : rest.length;
              const content = rest.slice(0, end).trim();

              core.debug(`  Extracted ${content.length} characters`);
              return content;
            }

            function normalizeWhitespace(value) {
              if (!value) return '';
              return value
                .replace(/\r\n/g, '\n')
                .split('\n')
                .map((line) => line.trimEnd())
                .join('\n')
                .trim();
            }

            function ensureChecklist(section) {
              const cleaned = normalizeWhitespace(section);
              if (!cleaned) {
                return '';
              }

              return cleaned
                .split('\n')
                .map((line) => {
                  const match = line.match(/^(\s*)([-*])\s+(.*)$/);
                  if (!match) {
                    return line.trim();
                  }
                  const [, indent = '', , contentRaw] = match;
                  const content = contentRaw.trim();
                  const checkbox = content.match(/^\[( |x|X)\]\s*/);
                  if (checkbox) {
                    const state = checkbox[1].toLowerCase() === 'x' ? 'x' : ' ';
                    const remainder = content.slice(checkbox[0].length).trimStart();
                    return `${indent}- [${state}] ${remainder}`;
                  }
                  return `${indent}- [ ] ${content}`;
                })
                .join('\n');
            }

            function fallbackChecklist(message) {
              return `- [ ] ${message}`;
            }

            function buildPreamble(sections) {
              const lines = ['<!-- pr-preamble:start -->'];
              
              // Only include sections that have actual content from the issue
              if (sections.summary && sections.summary.trim()) {
                lines.push('## Summary', sections.summary, '');
              }
              
              if (sections.testing && sections.testing.trim()) {
                lines.push('## Testing', sections.testing, '');
              }
              
              if (sections.ci && sections.ci.trim()) {
                lines.push('## CI readiness', sections.ci, '');
              }
              
              lines.push('<!-- pr-preamble:end -->');
              return lines.join('\n');
            }

            function iconForStatus(status) {
              switch (status) {
                case 'success':
                  return '';
                case 'skipped':
                  return '';
                case 'cancelled':
                  return '';
                case 'timed_out':
                  return '';
                case 'failure':
                  return '';
                case 'neutral':
                  return '';
                case 'pending':
                case 'waiting':
                case 'queued':
                case 'requested':
                  return '';
                default:
                  return '';
              }
            }

            function friendlyStatus(status) {
              return (status || 'unknown').replace(/_/g, ' ');
            }

            function combineStatus(run) {
              if (!run) {
                return {icon: '', label: 'unknown'};
              }
              if (run.conclusion) {
                const normalized = run.conclusion.toLowerCase();
                return {icon: iconForStatus(normalized), label: friendlyStatus(normalized)};
              }
              if (run.status) {
                const normalized = run.status.toLowerCase();
                return {icon: iconForStatus(normalized), label: friendlyStatus(normalized)};
              }
              return {icon: '', label: 'unknown'};
            }

            function selectLatestWorkflows(runs) {
              const latest = new Map();
              for (const run of runs) {
                const name = run.name || 'Unnamed workflow';
                const key = name.toLowerCase();
                const existing = latest.get(key);
                if (!existing) {
                  latest.set(key, run);
                  continue;
                }
                if (new Date(run.created_at) > new Date(existing.created_at)) {
                  latest.set(key, run);
                }
              }
              return latest;
            }

            function buildStatusBlock({scope, tasks, acceptance, headSha, workflowRuns, requiredChecks}) {
              const statusLines = ['<!-- auto-status-summary:start -->', '## Automated Status Summary'];

              statusLines.push('#### Scope');
              const scopeFormatted = scope ? ensureChecklist(scope) : fallbackChecklist('Scope section missing from source issue.');
              statusLines.push(scopeFormatted);
              statusLines.push('');

              statusLines.push('#### Tasks');
              const tasksFormatted = tasks ? ensureChecklist(tasks) : fallbackChecklist('Tasks section missing from source issue.');
              statusLines.push(tasksFormatted);
              statusLines.push('');

              statusLines.push('#### Acceptance criteria');
              const acceptanceFormatted = acceptance ? ensureChecklist(acceptance) : fallbackChecklist('Acceptance criteria section missing from source issue.');
              statusLines.push(acceptanceFormatted);
              statusLines.push('');

              statusLines.push(`**Head SHA:** ${headSha}`);

              const latestRuns = Array.from(workflowRuns.values()).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              let latestLine = '';
              if (latestRuns.length > 0) {
                const gate = latestRuns.find((run) => (run.name || '').toLowerCase() === 'gate');
                const chosen = gate || latestRuns[0];
                const status = combineStatus(chosen);
                latestLine = `${status.icon} ${status.label}  ${chosen.name}`;
              }
              statusLines.push(`**Latest Runs:** ${latestLine}`);

              const requiredParts = [];
              for (const name of requiredChecks) {
                const run = Array.from(workflowRuns.values()).find((item) => (item.name || '').toLowerCase() === name.toLowerCase());
                if (!run) {
                  requiredParts.push(`${name}:  not started`);
                } else {
                  const status = combineStatus(run);
                  requiredParts.push(`${name}: ${status.icon} ${status.label}`);
                }
              }
              statusLines.push(`**Required:** ${requiredParts.length > 0 ? requiredParts.join(', ') : ''}`);
              statusLines.push('');

              const table = ['| Workflow / Job | Result | Logs |', '|----------------|--------|------|'];
              const runs = Array.from(workflowRuns.values()).sort((a, b) => (a.name || '').localeCompare(b.name || ''));

              if (runs.length === 0) {
                table.push('| _(no workflow runs yet for this commit)_ |  |  |');
              } else {
                for (const run of runs) {
                  const status = combineStatus(run);
                  const link = run.html_url ? `[View run](${run.html_url})` : '';
                  table.push(`| ${run.name || 'Unnamed workflow'} | ${status.icon} ${status.label} | ${link} |`);
                }
              }

              statusLines.push(...table);
              statusLines.push('<!-- auto-status-summary:end -->');

              return statusLines.join('\n');
            }

            function upsertBlock(body, marker, replacement) {
              const start = `<!-- ${marker}:start -->`;
              const end = `<!-- ${marker}:end -->`;

              const startIndex = body.indexOf(start);
              const endIndex = body.indexOf(end);
              if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                return `${body.slice(0, startIndex)}${replacement}${body.slice(endIndex + end.length)}`;
              }

              const trimmed = body.trimEnd();
              const prefix = trimmed ? `${trimmed}\n\n` : '';
              return `${prefix}${replacement}`;
            }

            async function fetchRequiredChecks(baseRef) {
              const qualified = baseRef.startsWith('refs/') ? baseRef : `refs/heads/${baseRef}`;
              try {
                const result = await withRetries(
                  () => github.graphql(
                    `query($owner: String!, $repo: String!, $qualified: String!) {
                    repository(owner: $owner, name: $repo) {
                      ref(qualifiedName: $qualified) {
                        branchProtectionRule {
                          requiresStatusChecks
                          requiredStatusCheckContexts
                        }
                      }
                    }
                  }`,
                    {owner, repo, qualified},
                  ),
                  {description: 'branch protection graphql'},
                );
                const rule = result?.repository?.ref?.branchProtectionRule;
                if (rule && rule.requiresStatusChecks && Array.isArray(rule.requiredStatusCheckContexts)) {
                  return rule.requiredStatusCheckContexts.filter((item) => typeof item === 'string' && item.trim());
                }
              } catch (error) {
                const status = error && typeof error.status === 'number' ? error.status : null;
                if (status === 403) {
                  core.info('Branch protection lookup unauthorized; skipping required check enrichment.');
                  return [];
                }
                core.info(`Branch protection lookup failed: ${error.message}`);
              }
              return [];
            }

            const prInfo = await discoverPr();
            if (!prInfo) {
              return 'No pull request context detected; skipping update.';
            }

            const prResponse = await withRetries(
              () => github.rest.pulls.get({owner, repo, pull_number: prInfo.number}),
              {description: `pulls.get #${prInfo.number}`},
            );
            const pr = prResponse.data;
            if (pr.state === 'closed') {
              return `Pull request #${pr.number} is closed; skipping update.`;
            }

            if (prInfo.headSha && pr.head && pr.head.sha && pr.head.sha !== prInfo.headSha) {
              return `Skipping update for PR #${pr.number} because workflow run head ${prInfo.headSha} does not match current head ${pr.head.sha}.`;
            }

            const issueNumber = extractIssueNumber(pr);
            if (!issueNumber) {
              return `Unable to determine source issue for PR #${pr.number}; skipping.`;
            }

            core.info(`Fetching content from issue #${issueNumber} for PR #${pr.number}`);
            const issueResponse = await withRetries(
              () => github.rest.issues.get({owner, repo, issue_number: issueNumber}),
              {description: `issues.get #${issueNumber}`},
            );
            const issueBody = issueResponse.data.body || '';

            if (!issueBody) {
              core.warning(`Issue #${issueNumber} has no body content`);
            } else {
              core.debug(`Issue body length: ${issueBody.length} characters`);
              core.debug(`Issue body preview: ${issueBody.slice(0, 300).replace(/\n/g, '\\n')}`);
            }

            function extractWithAliases(body, aliases) {
              for (const alias of aliases) {
                const content = extractSection(body, alias);
                if (content) return content;
              }
              return '';
            }

            function buildRichSummary(body) {
              core.info('Building rich summary from issue sections...');
              const why = normalizeWhitespace(extractSection(body, 'Why'));
              const scopeRaw = normalizeWhitespace(extractSection(body, 'Scope'));
              const nonGoals = normalizeWhitespace(extractSection(body, 'Non-Goals'));
              const goal = normalizeWhitespace(extractSection(body, 'Goal'));

              core.info(`  Why: ${why ? `${why.length} chars` : 'NOT FOUND'}`);
              core.info(`  Scope: ${scopeRaw ? `${scopeRaw.length} chars` : 'NOT FOUND'}`);
              core.info(`  Non-Goals: ${nonGoals ? `${nonGoals.length} chars` : 'NOT FOUND'}`);
              core.info(`  Goal: ${goal ? `${goal.length} chars` : 'NOT FOUND'}`);

              const parts = [];
              if (why) parts.push(why);
              if (goal) parts.push(goal);
              if (scopeRaw) parts.push(`\n**Scope:** ${scopeRaw}`);
              if (nonGoals) parts.push(`**Non-Goals:** ${nonGoals}`);

              const result = parts.join('\n\n');
              core.info(`Rich summary result: ${result ? `${result.length} chars` : 'EMPTY'}`);
              return result;
            }

            const summaryRich = buildRichSummary(issueBody);
            const summary = summaryRich || normalizeWhitespace(extractWithAliases(issueBody, ['Summary', 'Description', 'Overview']));
            const testing = normalizeWhitespace(extractWithAliases(issueBody, ['Testing', 'Test Plan', 'Validation']));
            const ci = normalizeWhitespace(extractWithAliases(issueBody, ['CI readiness', 'Implementation notes', 'Technical notes']));

            core.info(`Final sections - Summary: ${summary ? 'OK' : 'EMPTY'}, Testing: ${testing ? 'OK' : 'EMPTY'}, CI: ${ci ? 'OK' : 'EMPTY'}`);

            const scope = extractSection(issueBody, 'Scope') || '';
            const tasks = extractSection(issueBody, 'Tasks') || '';
            const acceptance = extractWithAliases(issueBody, ['Acceptance criteria', 'Success criteria', 'Definition of done']) || '';

            core.info(`Status block sections - Scope: ${scope ? 'OK' : 'EMPTY'}, Tasks: ${tasks ? 'OK' : 'EMPTY'}, Acceptance: ${acceptance ? 'OK' : 'EMPTY'}`);

            const preamble = buildPreamble({summary, testing, ci});

            const workflowRunResponse = await withRetries(
              () => github.rest.actions.listWorkflowRunsForRepo({
                owner,
                repo,
                head_sha: pr.head.sha,
                per_page: 100,
              }),
              {description: 'list workflow runs'},
            );
            const workflowRuns = selectLatestWorkflows(workflowRunResponse.data.workflow_runs || []);

            const requiredChecks = await fetchRequiredChecks(pr.base.ref);
            if (!requiredChecks.includes('gate') && pr.base.ref) {
              requiredChecks.push('gate');
            }

            const statusBlock = buildStatusBlock({
              scope,
              tasks,
              acceptance,
              headSha: prInfo.headSha,
              workflowRuns,
              requiredChecks,
            });

            const bodyWithPreamble = upsertBlock(pr.body || '', 'pr-preamble', preamble);
            const newBody = upsertBlock(bodyWithPreamble, 'auto-status-summary', statusBlock);

            if (newBody !== (pr.body || '')) {
              await withRetries(
                () => github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: pr.number,
                  body: newBody,
                }),
                {description: `pulls.update #${pr.number}`, delayMs: 1500},
              );
              return `Updated PR #${pr.number} body with synchronized sections from issue #${issueNumber}.`;
            }

            return 'PR body already up to date; no changes required.';

