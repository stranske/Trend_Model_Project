name: Agents PR meta manager

on:
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, synchronize, reopened, edited]
  workflow_run:
    workflows: [Gate]
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to update (leave empty to use trigger context)'
        required: false
        type: string
      debug:
        description: 'Enable debug logging'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: write
  checks: read

concurrency:
  group: agents-pr-meta-${{ github.event.issue.number || github.event.pull_request.number || (github.event.workflow_run && github.event.workflow_run.pull_requests && github.event.workflow_run.pull_requests[0] && github.event.workflow_run.pull_requests[0].number) || inputs.pr_number || github.run_id }}
  cancel-in-progress: false

jobs:
  keepalive_dispatch:
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    name: Detect keepalive round comments
    runs-on: ubuntu-latest
    outputs:
      dispatch: ${{ steps.detect.outputs.dispatch }}
      reason: ${{ steps.detect.outputs.reason }}
      issue: ${{ steps.detect.outputs.issue }}
      round: ${{ steps.detect.outputs.round }}
      branch: ${{ steps.detect.outputs.branch }}
      base: ${{ steps.detect.outputs.base }}
      trace: ${{ steps.detect.outputs.trace }}
      pr: ${{ steps.detect.outputs.pr }}
    steps:
      - name: Evaluate keepalive comment
        id: detect
        uses: actions/github-script@v7
        env:
          ALLOWED_LOGINS: chatgpt-codex-connector,stranske-automation-bot,stranske
          KEEPALIVE_MARKER: '<!-- codex-keepalive-marker -->'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { detectKeepalive } = require('./.github/scripts/agents_pr_meta_keepalive.js');
            await detectKeepalive({ core, github, context, env: process.env });

      - name: Summarise keepalive evaluation
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          ## Keepalive detection
          | ok | reason | round | trace | pr |
          | --- | --- | --- | --- | --- |
          | ${{ steps.detect.outputs.dispatch == 'true' && 'true' || 'false' }} | ${{ steps.detect.outputs.reason || '(none)' }} | ${{ steps.detect.outputs.round || '—' }} | ${{ steps.detect.outputs.trace || '—' }} | ${{ steps.detect.outputs.pr || '—' }} |
          EOF

      - name: Register keepalive detection
        if: steps.detect.outputs.dispatch == 'true'
        run: |
          echo "Keepalive round ${{ steps.detect.outputs.round }} detected for issue ${{ steps.detect.outputs.issue }} on branch ${{ steps.detect.outputs.branch }} (trace ${{ steps.detect.outputs.trace }})"

      - name: Report keepalive dispatch outcome
        if: steps.detect.outputs.dispatch != 'true'
        run: |
          echo "Keepalive dispatch skipped: ${{ steps.detect.outputs.reason }}"

  keepalive_orchestrator:
    needs: keepalive_dispatch
    if: needs.keepalive_dispatch.outputs.dispatch == 'true'
    name: Dispatch keepalive orchestrator
    runs-on: ubuntu-latest
    steps:
      - name: Dispatch Agents 70 run for keepalive
        id: orchestrator
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ needs.keepalive_dispatch.outputs.issue }}');
            const prNumber = Number('${{ needs.keepalive_dispatch.outputs.pr }}');
            const branch = '${{ needs.keepalive_dispatch.outputs.branch }}';
            const base = '${{ needs.keepalive_dispatch.outputs.base }}';
            const round = Number('${{ needs.keepalive_dispatch.outputs.round }}');
            const trace = '${{ needs.keepalive_dispatch.outputs.trace }}';

            const { owner, repo } = context.repo;
            const workflowId = 'agents-70-orchestrator.yml';
            const ref = context.payload?.repository?.default_branch || 'phase-2-dev';

            const params = {
              enable_keepalive: true,
              dispatcher_force_issue: issue ? String(issue) : '',
            };

            const options = {
              keepalive_trace: trace,
              round: round || 0,
              pr: prNumber || Number(context.payload?.issue?.number || 0),
              keepalive_enabled: true,
              keepalive_source: 'agents-pr-meta',
              keepalive_round: round || 0,
              keepalive_branch: branch,
              keepalive_base: base,
            };

            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id: workflowId,
              ref,
              inputs: {
                keepalive_enabled: 'true',
                params_json: JSON.stringify(params),
                options_json: JSON.stringify(options),
                dry_run: 'false',
              },
            });

            core.summary
              .addHeading('Keepalive orchestrator dispatch')
              .addRaw(`Workflow: ${workflowId}`)
              .addEOL()
              .addRaw(`Issue: ${issue ? `#${issue}` : 'unknown'}`)
              .addEOL()
              .addRaw(`PR: ${prNumber ? `#${prNumber}` : (context.payload?.issue?.number ? `#${context.payload.issue.number}` : 'unknown')}`)
              .addEOL()
              .addRaw(`Round: ${round || 'n/a'}`)
              .addEOL()
              .addRaw(`Trace: ${trace || '(not detected)'}`)
              .addEOL()
              .addRaw(`Branch: ${branch || '(not detected)'}`)
              .addEOL()
              .addRaw(`Base: ${base || '(not detected)'}`)
              .write();

  listen_commands:
    needs: keepalive_dispatch
    if: >-
      ${{ github.event_name == 'issue_comment'
          && github.event.issue.pull_request
          && needs.keepalive_dispatch.outputs.dispatch == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Dispatch codex keepalive command
        id: dispatch
        uses: actions/github-script@v7
        env:
          BASE: ${{ needs.keepalive_dispatch.outputs.base }}
          HEAD: ${{ needs.keepalive_dispatch.outputs.branch }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT }}
          script: |
            const { payload } = context;
            const { owner, repo } = context.repo;

            const pullNumber = payload.issue?.number;
            if (!pullNumber) {
              core.setFailed('Unable to determine pull request number from issue_comment payload.');
              return;
            }

            const base = process.env.BASE || '';
            const head = process.env.HEAD || '';

            if (!base || !head) {
              core.warning('Keepalive metadata missing base/head from detection; fetching pull request details.');
            }

            let resolvedBase = base;
            let resolvedHead = head;

            if (!resolvedBase || !resolvedHead) {
              const pull = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: pullNumber,
              });

              resolvedBase = resolvedBase || pull.data.base?.ref || '';
              resolvedHead = resolvedHead || pull.data.head?.ref || '';
            }

            if (!resolvedBase || !resolvedHead) {
              core.setFailed('Unable to determine pull request base/head branches.');
              return;
            }

            const commentId = payload.comment?.id;
            const commentUrl = payload.comment?.html_url;

            if (!commentId || !commentUrl) {
              core.setFailed('Comment metadata missing id or url.');
              return;
            }

            const clientPayload = {
              issue: pullNumber,
              base: resolvedBase,
              head: resolvedHead,
              agent: 'codex',
              comment_id: commentId,
              comment_url: commentUrl,
            };

            await github.rest.repos.createDispatchEvent({
              owner,
              repo,
              event_type: 'codex-pr-comment-command',
              client_payload: clientPayload,
            });

            core.summary
              .addHeading('Codex keepalive dispatch')
              .addRaw(`Pull request: #${pullNumber}`)
              .addEOL()
              .addRaw(`Base branch: ${clientPayload.base}`)
              .addEOL()
              .addRaw(`Head branch: ${clientPayload.head}`)
              .addEOL()
              .addRaw(`Comment ID: ${clientPayload.comment_id}`)
              .addEOL()
              .addLink('Comment URL', clientPayload.comment_url)
              .write();

            core.info(`repository_dispatch emitted for PR #${pullNumber} (comment ${commentId}).`);

  update_body:
    if: github.event_name != 'issue_comment'
    name: Upsert PR body sections
    runs-on: ubuntu-latest
    steps:
      - name: Update PR body
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function discoverPr() {
              if (context.eventName === 'workflow_dispatch') {
                const prNumber = '${{ inputs.pr_number || '' }}';
                if (prNumber && prNumber.trim()) {
                  const num = Number.parseInt(prNumber.trim(), 10);
                  if (!Number.isNaN(num)) {
                    core.info(`Manual trigger: using PR #${num}`);
                    const {data: pr} = await github.rest.pulls.get({owner, repo, pull_number: num});
                    return {number: num, headSha: pr.head.sha};
                  }
                }
                core.warning('workflow_dispatch without valid pr_number; skipping');
                return null;
              }

              if (context.eventName === 'pull_request') {
                const pr = context.payload.pull_request;
                return {number: pr.number, headSha: pr.head.sha};
              }

              if (context.eventName === 'workflow_run') {
                const run = context.payload.workflow_run;
                if (!run || run.event !== 'pull_request') {
                  core.info('Workflow run not associated with a pull request.');
                  return null;
                }

                const headSha = run.head_sha;
                if (Array.isArray(run.pull_requests) && run.pull_requests.length > 0) {
                  const directMatch = run.pull_requests.find((item) => item && item.head_sha === headSha);
                  const candidate = directMatch || run.pull_requests[0];
                  if (candidate && typeof candidate.number === 'number') {
                    return {number: candidate.number, headSha};
                  }
                }
                const prs = await github.paginate(
                  github.rest.repos.listPullRequestsAssociatedWithCommit,
                  {
                    owner,
                    repo,
                    commit_sha: headSha,
                    per_page: 100,
                  },
                );

                const matching = prs.find((item) => item.head && item.head.sha === headSha);
                if (!matching) {
                  core.info(`No pull request found for commit ${headSha}.`);
                  return null;
                }

                return {number: matching.number, headSha};
              }

              core.info(`Unsupported event: ${context.eventName}`);
              return null;
            }

            function extractIssueNumber(pr) {
              const branch = pr.head.ref || '';
              const candidates = [];
              const branchMatch = branch.match(/issue-+([0-9]+)/i);
              if (branchMatch) {
                candidates.push(branchMatch[1]);
              }

              const titleMatch = (pr.title || '').match(/#([0-9]+)/);
              if (titleMatch) {
                candidates.push(titleMatch[1]);
              }

              const bodyMatches = [...((pr.body || '').matchAll(/#([0-9]+)/g))].map((m) => m[1]);
              candidates.push(...bodyMatches);

              for (const value of candidates) {
                const parsed = Number.parseInt(value, 10);
                if (!Number.isNaN(parsed)) {
                  return parsed;
                }
              }

              return null;
            }

            function extractSection(body, heading) {
              if (!body) {
                core.debug(`extractSection: body is empty for heading "${heading}"`);
                return '';
              }

              // Flexible regex: allow ## headers OR standalone text on its own line
              const escapedHeading = heading.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
              // Match either "## Heading" or just "Heading" at start of line
              const pattern = new RegExp(`(^|\\n)(#{1,3}\\s+)?${escapedHeading}\\s*\\r?\\n`, 'i');
              const match = body.match(pattern);

              if (!match) {
                core.debug(`extractSection: No match for heading "${heading}"`);
                core.debug(`  Pattern: ${pattern}`);
                core.debug(`  Body preview: ${body.slice(0, 200).replace(/\n/g, '\\n')}`);
                return '';
              }

              core.debug(`extractSection: Found "${heading}" at index ${match.index}`);
              const start = match.index + match[0].length;
              const rest = body.slice(start);

              // Look for next section: either ## heading OR a known section name at start of line
              const knownSections = ['Why', 'Scope', 'Non-Goals', 'Goal', 'Tasks', 'Acceptance criteria', 'Success criteria', 'Definition of done', 'Implementation notes', 'Technical notes', 'Summary', 'Description', 'Overview', 'Testing', 'Test Plan', 'Validation', 'CI readiness'];
              const sectionPattern = knownSections.map(s => s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
              const nextPattern = new RegExp(`\\r?\\n(#{2,3}\\s+|(?:${sectionPattern})\\s*\\r?\\n)`, 'i');
              const nextMatch = rest.match(nextPattern);
              const end = nextMatch ? nextMatch.index + 1 : rest.length;
              const content = rest.slice(0, end).trim();

              core.debug(`  Extracted ${content.length} characters`);
              return content;
            }

            function normalizeWhitespace(value) {
              if (!value) return '';
              return value
                .replace(/\r\n/g, '\n')
                .split('\n')
                .map((line) => line.trimEnd())
                .join('\n')
                .trim();
            }

            function ensureChecklist(section) {
              const cleaned = normalizeWhitespace(section);
              if (!cleaned) {
                return '';
              }

              return cleaned
                .split('\n')
                .map((line) => {
                  const match = line.match(/^(\s*)([-*])\s+(.*)$/);
                  if (!match) {
                    return line.trim();
                  }
                  const [, indent = '', , contentRaw] = match;
                  const content = contentRaw.trim();
                  const checkbox = content.match(/^\[( |x|X)\]\s*/);
                  if (checkbox) {
                    const state = checkbox[1].toLowerCase() === 'x' ? 'x' : ' ';
                    const remainder = content.slice(checkbox[0].length).trimStart();
                    return `${indent}- [${state}] ${remainder}`;
                  }
                  return `${indent}- [ ] ${content}`;
                })
                .join('\n');
            }

            function fallbackChecklist(message) {
              return `- [ ] ${message}`;
            }

            function buildPreamble(sections) {
              const lines = ['<!-- pr-preamble:start -->'];
              
              // Only include sections that have actual content from the issue
              if (sections.summary && sections.summary.trim()) {
                lines.push('## Summary', sections.summary, '');
              }
              
              if (sections.testing && sections.testing.trim()) {
                lines.push('## Testing', sections.testing, '');
              }
              
              if (sections.ci && sections.ci.trim()) {
                lines.push('## CI readiness', sections.ci, '');
              }
              
              lines.push('<!-- pr-preamble:end -->');
              return lines.join('\n');
            }

            function iconForStatus(status) {
              switch (status) {
                case 'success':
                  return '✅';
                case 'skipped':
                  return '⏭️';
                case 'cancelled':
                  return '⏹️';
                case 'timed_out':
                  return '⏱️';
                case 'failure':
                  return '❌';
                case 'neutral':
                  return '⚪';
                case 'pending':
                case 'waiting':
                case 'queued':
                case 'requested':
                  return '⏳';
                default:
                  return '❔';
              }
            }

            function friendlyStatus(status) {
              return (status || 'unknown').replace(/_/g, ' ');
            }

            function combineStatus(run) {
              if (!run) {
                return {icon: '❔', label: 'unknown'};
              }
              if (run.conclusion) {
                const normalized = run.conclusion.toLowerCase();
                return {icon: iconForStatus(normalized), label: friendlyStatus(normalized)};
              }
              if (run.status) {
                const normalized = run.status.toLowerCase();
                return {icon: iconForStatus(normalized), label: friendlyStatus(normalized)};
              }
              return {icon: '❔', label: 'unknown'};
            }

            function selectLatestWorkflows(runs) {
              const latest = new Map();
              for (const run of runs) {
                const name = run.name || 'Unnamed workflow';
                const key = name.toLowerCase();
                const existing = latest.get(key);
                if (!existing) {
                  latest.set(key, run);
                  continue;
                }
                if (new Date(run.created_at) > new Date(existing.created_at)) {
                  latest.set(key, run);
                }
              }
              return latest;
            }

            function buildStatusBlock({scope, tasks, acceptance, headSha, workflowRuns, requiredChecks}) {
              const statusLines = ['<!-- auto-status-summary:start -->', '## Automated Status Summary'];

              statusLines.push('#### Scope');
              const scopeFormatted = scope ? ensureChecklist(scope) : fallbackChecklist('Scope section missing from source issue.');
              statusLines.push(scopeFormatted);
              statusLines.push('');

              statusLines.push('#### Tasks');
              const tasksFormatted = tasks ? ensureChecklist(tasks) : fallbackChecklist('Tasks section missing from source issue.');
              statusLines.push(tasksFormatted);
              statusLines.push('');

              statusLines.push('#### Acceptance criteria');
              const acceptanceFormatted = acceptance ? ensureChecklist(acceptance) : fallbackChecklist('Acceptance criteria section missing from source issue.');
              statusLines.push(acceptanceFormatted);
              statusLines.push('');

              statusLines.push(`**Head SHA:** ${headSha}`);

              const latestRuns = Array.from(workflowRuns.values()).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              let latestLine = '—';
              if (latestRuns.length > 0) {
                const gate = latestRuns.find((run) => (run.name || '').toLowerCase() === 'gate');
                const chosen = gate || latestRuns[0];
                const status = combineStatus(chosen);
                latestLine = `${status.icon} ${status.label} — ${chosen.name}`;
              }
              statusLines.push(`**Latest Runs:** ${latestLine}`);

              const requiredParts = [];
              for (const name of requiredChecks) {
                const run = Array.from(workflowRuns.values()).find((item) => (item.name || '').toLowerCase() === name.toLowerCase());
                if (!run) {
                  requiredParts.push(`${name}: ⏸️ not started`);
                } else {
                  const status = combineStatus(run);
                  requiredParts.push(`${name}: ${status.icon} ${status.label}`);
                }
              }
              statusLines.push(`**Required:** ${requiredParts.length > 0 ? requiredParts.join(', ') : '—'}`);
              statusLines.push('');

              const table = ['| Workflow / Job | Result | Logs |', '|----------------|--------|------|'];
              const runs = Array.from(workflowRuns.values()).sort((a, b) => (a.name || '').localeCompare(b.name || ''));

              if (runs.length === 0) {
                table.push('| _(no workflow runs yet for this commit)_ | — | — |');
              } else {
                for (const run of runs) {
                  const status = combineStatus(run);
                  const link = run.html_url ? `[View run](${run.html_url})` : '—';
                  table.push(`| ${run.name || 'Unnamed workflow'} | ${status.icon} ${status.label} | ${link} |`);
                }
              }

              statusLines.push(...table);
              statusLines.push('<!-- auto-status-summary:end -->');

              return statusLines.join('\n');
            }

            function upsertBlock(body, marker, replacement) {
              const start = `<!-- ${marker}:start -->`;
              const end = `<!-- ${marker}:end -->`;

              const startIndex = body.indexOf(start);
              const endIndex = body.indexOf(end);
              if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                return `${body.slice(0, startIndex)}${replacement}${body.slice(endIndex + end.length)}`;
              }

              const trimmed = body.trimEnd();
              const prefix = trimmed ? `${trimmed}\n\n` : '';
              return `${prefix}${replacement}`;
            }

            async function fetchRequiredChecks(baseRef) {
              const qualified = baseRef.startsWith('refs/') ? baseRef : `refs/heads/${baseRef}`;
              try {
                const result = await github.graphql(
                  `query($owner: String!, $repo: String!, $qualified: String!) {
                    repository(owner: $owner, name: $repo) {
                      ref(qualifiedName: $qualified) {
                        branchProtectionRule {
                          requiresStatusChecks
                          requiredStatusCheckContexts
                        }
                      }
                    }
                  }`,
                  {owner, repo, qualified},
                );
                const rule = result?.repository?.ref?.branchProtectionRule;
                if (rule && rule.requiresStatusChecks && Array.isArray(rule.requiredStatusCheckContexts)) {
                  return rule.requiredStatusCheckContexts.filter((item) => typeof item === 'string' && item.trim());
                }
              } catch (error) {
                core.info(`Branch protection lookup failed: ${error.message}`);
              }
              return [];
            }

            const prInfo = await discoverPr();
            if (!prInfo) {
              return 'No pull request context detected; skipping update.';
            }

            const prResponse = await github.rest.pulls.get({owner, repo, pull_number: prInfo.number});
            const pr = prResponse.data;
            if (pr.state === 'closed') {
              return `Pull request #${pr.number} is closed; skipping update.`;
            }

            if (prInfo.headSha && pr.head && pr.head.sha && pr.head.sha !== prInfo.headSha) {
              return `Skipping update for PR #${pr.number} because workflow run head ${prInfo.headSha} does not match current head ${pr.head.sha}.`;
            }

            const issueNumber = extractIssueNumber(pr);
            if (!issueNumber) {
              return `Unable to determine source issue for PR #${pr.number}; skipping.`;
            }

            core.info(`Fetching content from issue #${issueNumber} for PR #${pr.number}`);
            const issueResponse = await github.rest.issues.get({owner, repo, issue_number: issueNumber});
            const issueBody = issueResponse.data.body || '';

            if (!issueBody) {
              core.warning(`Issue #${issueNumber} has no body content`);
            } else {
              core.debug(`Issue body length: ${issueBody.length} characters`);
              core.debug(`Issue body preview: ${issueBody.slice(0, 300).replace(/\n/g, '\\n')}`);
            }

            function extractWithAliases(body, aliases) {
              for (const alias of aliases) {
                const content = extractSection(body, alias);
                if (content) return content;
              }
              return '';
            }

            function buildRichSummary(body) {
              core.info('Building rich summary from issue sections...');
              const why = normalizeWhitespace(extractSection(body, 'Why'));
              const scopeRaw = normalizeWhitespace(extractSection(body, 'Scope'));
              const nonGoals = normalizeWhitespace(extractSection(body, 'Non-Goals'));
              const goal = normalizeWhitespace(extractSection(body, 'Goal'));

              core.info(`  Why: ${why ? `${why.length} chars` : 'NOT FOUND'}`);
              core.info(`  Scope: ${scopeRaw ? `${scopeRaw.length} chars` : 'NOT FOUND'}`);
              core.info(`  Non-Goals: ${nonGoals ? `${nonGoals.length} chars` : 'NOT FOUND'}`);
              core.info(`  Goal: ${goal ? `${goal.length} chars` : 'NOT FOUND'}`);

              const parts = [];
              if (why) parts.push(why);
              if (goal) parts.push(goal);
              if (scopeRaw) parts.push(`\n**Scope:** ${scopeRaw}`);
              if (nonGoals) parts.push(`**Non-Goals:** ${nonGoals}`);

              const result = parts.join('\n\n');
              core.info(`Rich summary result: ${result ? `${result.length} chars` : 'EMPTY'}`);
              return result;
            }

            const summaryRich = buildRichSummary(issueBody);
            const summary = summaryRich || normalizeWhitespace(extractWithAliases(issueBody, ['Summary', 'Description', 'Overview']));
            const testing = normalizeWhitespace(extractWithAliases(issueBody, ['Testing', 'Test Plan', 'Validation']));
            const ci = normalizeWhitespace(extractWithAliases(issueBody, ['CI readiness', 'Implementation notes', 'Technical notes']));

            core.info(`Final sections - Summary: ${summary ? 'OK' : 'EMPTY'}, Testing: ${testing ? 'OK' : 'EMPTY'}, CI: ${ci ? 'OK' : 'EMPTY'}`);

            const scope = extractSection(issueBody, 'Scope') || '';
            const tasks = extractSection(issueBody, 'Tasks') || '';
            const acceptance = extractWithAliases(issueBody, ['Acceptance criteria', 'Success criteria', 'Definition of done']) || '';

            core.info(`Status block sections - Scope: ${scope ? 'OK' : 'EMPTY'}, Tasks: ${tasks ? 'OK' : 'EMPTY'}, Acceptance: ${acceptance ? 'OK' : 'EMPTY'}`);

            const preamble = buildPreamble({summary, testing, ci});

            const workflowRunResponse = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              head_sha: pr.head.sha,
              per_page: 100,
            });
            const workflowRuns = selectLatestWorkflows(workflowRunResponse.data.workflow_runs || []);

            const requiredChecks = await fetchRequiredChecks(pr.base.ref);
            if (!requiredChecks.includes('gate') && pr.base.ref) {
              requiredChecks.push('gate');
            }

            const statusBlock = buildStatusBlock({
              scope,
              tasks,
              acceptance,
              headSha: prInfo.headSha,
              workflowRuns,
              requiredChecks,
            });

            const bodyWithPreamble = upsertBlock(pr.body || '', 'pr-preamble', preamble);
            const newBody = upsertBlock(bodyWithPreamble, 'auto-status-summary', statusBlock);

            if (newBody !== (pr.body || '')) {
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: pr.number,
                body: newBody,
              });
              return `Updated PR #${pr.number} body with synchronized sections from issue #${issueNumber}.`;
            }

            return 'PR body already up to date; no changes required.';

