name: Agents PR meta manager

on:
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, synchronize, reopened, edited]
  workflow_run:
    workflows: [Gate]
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to update (leave empty to use trigger context)'
        required: false
        type: string
      debug:
        description: 'Enable debug logging'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  issues: write
  pull-requests: write
  actions: write
  checks: read

concurrency:
  group: agents-pr-meta-${{ github.event.issue.number || github.event.pull_request.number || (github.event.workflow_run && github.event.workflow_run.pull_requests && github.event.workflow_run.pull_requests[0] && github.event.workflow_run.pull_requests[0].number) || inputs.pr_number || github.run_id }}
  cancel-in-progress: false

jobs:
  keepalive_dispatch:
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    name: Detect keepalive round comments
    runs-on: ubuntu-latest
    steps:
      - name: Evaluate keepalive comment
        id: detect
        uses: actions/github-script@v7
        env:
          ALLOWED_LOGINS: chatgpt-codex-connector,stranske-automation-bot
          KEEPALIVE_MARKER: '<!-- codex-keepalive-marker -->'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const normaliseLogin = (login) => (login || '').trim().toLowerCase().replace(/\[bot\]$/i, '');

            const allowedLogins = new Set(
              (process.env.ALLOWED_LOGINS || '')
                .split(',')
                .map((value) => normaliseLogin(value))
                .filter(Boolean)
            );

            const { comment, issue } = context.payload;
            const { owner, repo } = context.repo;
            const body = comment?.body || '';
            const author = normaliseLogin(comment?.user?.login);

            const roundMatch = body.match(/<!--\s*keepalive-round:(\d+)\s*-->/i);
            const hasKeepaliveMarker = body.includes(process.env.KEEPALIVE_MARKER || '');

            const result = {
              dispatch: 'false',
              reason: 'not-keepalive',
            };

            if (!roundMatch) {
              core.info('Comment does not contain keepalive round marker; skipping.');
              core.setOutput('dispatch', result.dispatch);
              core.setOutput('reason', result.reason);
              return;
            }

            if (!allowedLogins.has(author)) {
              result.reason = 'unauthorised-author';
              core.info(`Keepalive dispatch skipped: author ${author || '(unknown)'} not in allow list.`);
              core.setOutput('dispatch', result.dispatch);
              core.setOutput('reason', result.reason);
              return;
            }

            if (!hasKeepaliveMarker) {
              result.reason = 'missing-sentinel';
              core.info('Keepalive dispatch skipped: comment missing codex keepalive marker.');
              core.setOutput('dispatch', result.dispatch);
              core.setOutput('reason', result.reason);
              return;
            }

            const round = Number.parseInt(roundMatch[1], 10);
            if (!Number.isFinite(round) || round <= 0) {
              result.reason = 'invalid-round';
              core.info('Keepalive dispatch skipped: invalid round marker.');
              core.setOutput('dispatch', result.dispatch);
              core.setOutput('reason', result.reason);
              return;
            }

            const prNumber = issue.number;
            let pull;
            try {
              const response = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              pull = response.data;
            } catch (error) {
              result.reason = 'pull-fetch-failed';
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Keepalive dispatch skipped: unable to load PR #${prNumber} (${message}).`);
              core.setOutput('dispatch', result.dispatch);
              core.setOutput('reason', result.reason);
              return;
            }

            const extractIssueNumber = (pr) => {
              const candidates = [];
              const branch = pr?.head?.ref || '';
              const branchMatch = branch.match(/issue-([0-9]+)/i);
              if (branchMatch) {
                candidates.push(branchMatch[1]);
              }

              const title = pr?.title || '';
              const titleMatch = title.match(/#([0-9]+)/);
              if (titleMatch) {
                candidates.push(titleMatch[1]);
              }

              const bodyText = pr?.body || '';
              for (const match of bodyText.matchAll(/#([0-9]+)/g)) {
                if (match[1]) {
                  candidates.push(match[1]);
                }
              }

              for (const value of candidates) {
                const parsed = Number.parseInt(value, 10);
                if (!Number.isNaN(parsed)) {
                  return parsed;
                }
              }

              return null;
            };

            const issueNumber = extractIssueNumber(pull);
            if (!issueNumber) {
              result.reason = 'missing-issue-reference';
              core.info('Keepalive dispatch skipped: unable to determine linked issue number.');
              core.setOutput('dispatch', result.dispatch);
              core.setOutput('reason', result.reason);
              return;
            }

            result.dispatch = 'true';
            result.reason = 'keepalive-detected';

            core.setOutput('dispatch', result.dispatch);
            core.setOutput('reason', result.reason);
            core.setOutput('issue', String(issueNumber));
            core.setOutput('round', String(round));
            core.setOutput('branch', pull?.head?.ref || '');

      - name: Dispatch orchestrator keepalive
        if: steps.detect.outputs.dispatch == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = '${{ steps.detect.outputs.issue }}';
            const round = '${{ steps.detect.outputs.round }}';
            const { owner, repo } = context.repo;

            const payload = {
              keepalive_enabled: true,
              params: {
                dispatcher_force_issue: issueNumber,
                worker_max_parallel: 1,
              },
            };

            await github.rest.repos.createDispatchEvent({
              owner,
              repo,
              event_type: 'agents-orchestrator-ping',
              client_payload: payload,
            });

            core.info(`Dispatched Agents 70 Orchestrator for issue #${issueNumber} (keepalive round ${round}).`);

      - name: Report keepalive dispatch outcome
        if: steps.detect.outputs.dispatch != 'true'
        run: |
          echo "Keepalive dispatch skipped: ${{ steps.detect.outputs.reason }}"

  listen_commands:
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    runs-on: ubuntu-latest
    steps:
      - name: Handle PR comment command
        id: handle
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const marker = '<!-- codex-activation-marker -->';
            const errorMarker = '<!-- codex-activation-error -->';
            const aliasCommands = ['/codex run', '/agent run'];
            const aliasCommandList = aliasCommands.map((value) => value.toLowerCase());
            const aliasCommandSet = new Set(aliasCommandList);

            const { payload } = context;
            const { owner, repo } = context.repo;
            const issueNumber = payload.issue.number;
            const comment = payload.comment;
            const labels = (payload.issue.labels || []).map(label => {
              if (typeof label === 'string') return label;
              return label?.name || '';
            });

            const agentLabels = labels.filter(name => typeof name === 'string' && name.toLowerCase().startsWith('agent:'));
            if (agentLabels.length !== 1) {
              const reason = agentLabels.length === 0
                ? 'No `agent:*` label found on this pull request.'
                : `Multiple agent labels found (${agentLabels.join(', ')}).`;

              const guidance = agentLabels.length === 0
                ? 'Add exactly one `agent:*` label (for example, `agent:codex`) and re-run the command.'
                : 'Remove the extra `agent:*` labels so only one remains, then re-run the command.';

              const labelList = agentLabels.length > 0
                ? `\n\nApplied agent labels: ${agentLabels.join(', ')}`
                : '';

              const body = `${errorMarker}\n`
                + '**Codex activation blocked**\n\n'
                + `${reason}${labelList}\n\n`
                + `${guidance}`;

              const existingComments = await github.paginate(
                github.rest.issues.listComments,
                {
                  owner,
                  repo,
                  issue_number: issueNumber,
                  per_page: 100,
                }
              );

              const existing = existingComments.find(c => (c.body || '').includes(errorMarker));

              if (existing) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body,
                });
              }

              core.setOutput('dispatched', 'false');
              core.setOutput('reason', 'invalid-agent-label');
              return;
            }

            const agentLabel = agentLabels[0];
            const agent = agentLabel.split(':')[1]?.trim();
            if (!agent) {
              core.setFailed(`Unable to resolve agent from label: ${agentLabel}`);
              return;
            }

            const commandPrefix = `@${agent} use the scope, acceptance criteria, and task list so the keepalive workflow continues nudging until everything is complete. Work through the tasks, checking them off only after each acceptance criterion is satisfied, but check during each comment implementation and check off tasks and acceptance criteria that have been satisfied and repost the current version of the initial scope, task list and acceptance criteria each time that any have been newly completed.`;

            const extractNormalizedLines = (text) => {
              if (!text) return [];

              const lines = [];
              let inCodeFence = false;

              for (const rawLine of text.split(/\r?\n/)) {
                if (!rawLine) {
                  continue;
                }

                const trimmedLine = rawLine.trim();
                if (!trimmedLine) {
                  continue;
                }

                if (trimmedLine.startsWith('```')) {
                  inCodeFence = !inCodeFence;
                  continue;
                }

                if (inCodeFence) {
                  continue;
                }

                const withoutQuote = trimmedLine.replace(/^>+\s*/, '').trim();
                if (!withoutQuote) {
                  continue;
                }

                lines.push(withoutQuote);
              }

              return lines;
            };

            const getActivationCommand = (rawText) => {
              if (!rawText) return null;

              const trimmed = rawText.trim();
              if (!trimmed) return null;

              if (trimmed.startsWith(commandPrefix)) {
                return { type: 'full', value: commandPrefix };
              }

              const normalizedLines = extractNormalizedLines(rawText);
              for (const line of normalizedLines) {
                const lowered = line.toLowerCase();
                for (const alias of aliasCommandList) {
                  if (lowered === alias || lowered.startsWith(`${alias} `)) {
                    return { type: 'alias', value: alias };
                  }
                }
              }

              return null;
            };

            const bodyText = (comment.body || '').trim();
            const activationCommand = getActivationCommand(bodyText);
            if (!activationCommand) {
              core.setOutput('dispatched', 'false');
              core.setOutput('reason', 'no-match');
              return;
            }

            const comments = await github.paginate(
              github.rest.issues.listComments,
              {
                owner,
                repo,
                issue_number: issueNumber,
                per_page: 100,
              }
            );

            const activationComments = comments.filter(c => getActivationCommand((c.body || '').trim()));
            if (activationComments.length === 0 || activationComments[activationComments.length - 1].id !== comment.id) {
              core.info('Command superseded by a newer comment; skipping dispatch.');
              core.setOutput('dispatched', 'false');
              core.setOutput('reason', 'superseded');
              return;
            }

            const pull = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: issueNumber,
            });

            const payloadData = {
              issue: issueNumber,
              base: pull.data.base.ref,
              head: pull.data.head.ref,
              agent,
              comment_id: comment.id,
              comment_url: comment.html_url,
            };

            await github.rest.repos.createDispatchEvent({
              owner,
              repo,
              event_type: 'codex-pr-comment-command',
              client_payload: payloadData,
            });

            const errorComment = comments.find(c => (c.body || '').includes(errorMarker));
            if (errorComment) {
              await github.rest.issues.deleteComment({
                owner,
                repo,
                comment_id: errorComment.id,
              });
            }

            const activationBody = `${marker}\n`
              + `Codex activation dispatched for **@${agent}** from [comment #${comment.id}](${comment.html_url}).\n\n`
              + `- Pull request: #${issueNumber}\n`
              + `- Base branch: ${pull.data.base.ref}\n`
              + `- Head branch: ${pull.data.head.ref}\n`
              + `- Comment ID: ${comment.id}`;

            const activationComment = comments.find(c => (c.body || '').includes(marker));
            if (activationComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: activationComment.id,
                body: activationBody,
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: activationBody,
              });
            }

            core.setOutput('dispatched', 'true');
            core.setOutput('agent', agent);
            core.setOutput('comment-id', String(comment.id));

      - name: Log dispatch result
        if: steps.handle.outputs.dispatched == 'true'
        run: |
          echo "Dispatched agent ${AGENT} for comment ${COMMENT}"
        env:
          AGENT: ${{ steps.handle.outputs.agent }}
          COMMENT: ${{ steps.handle.outputs['comment-id'] }}

      - name: Report skipped reason
        if: steps.handle.outputs.dispatched != 'true'
        run: |
          echo "Dispatch skipped: ${{ steps.handle.outputs.reason }}"

  update_body:
    if: github.event_name != 'issue_comment'
    name: Upsert PR body sections
    runs-on: ubuntu-latest
    steps:
      - name: Update PR body
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function discoverPr() {
              if (context.eventName === 'workflow_dispatch') {
                const prNumber = '${{ inputs.pr_number || '' }}';
                if (prNumber && prNumber.trim()) {
                  const num = Number.parseInt(prNumber.trim(), 10);
                  if (!Number.isNaN(num)) {
                    core.info(`Manual trigger: using PR #${num}`);
                    const {data: pr} = await github.rest.pulls.get({owner, repo, pull_number: num});
                    return {number: num, headSha: pr.head.sha};
                  }
                }
                core.warning('workflow_dispatch without valid pr_number; skipping');
                return null;
              }

              if (context.eventName === 'pull_request') {
                const pr = context.payload.pull_request;
                return {number: pr.number, headSha: pr.head.sha};
              }

              if (context.eventName === 'workflow_run') {
                const run = context.payload.workflow_run;
                if (!run || run.event !== 'pull_request') {
                  core.info('Workflow run not associated with a pull request.');
                  return null;
                }

                const headSha = run.head_sha;
                if (Array.isArray(run.pull_requests) && run.pull_requests.length > 0) {
                  const directMatch = run.pull_requests.find((item) => item && item.head_sha === headSha);
                  const candidate = directMatch || run.pull_requests[0];
                  if (candidate && typeof candidate.number === 'number') {
                    return {number: candidate.number, headSha};
                  }
                }
                const prs = await github.paginate(
                  github.rest.repos.listPullRequestsAssociatedWithCommit,
                  {
                    owner,
                    repo,
                    commit_sha: headSha,
                    per_page: 100,
                  },
                );

                const matching = prs.find((item) => item.head && item.head.sha === headSha);
                if (!matching) {
                  core.info(`No pull request found for commit ${headSha}.`);
                  return null;
                }

                return {number: matching.number, headSha};
              }

              core.info(`Unsupported event: ${context.eventName}`);
              return null;
            }

            function extractIssueNumber(pr) {
              const branch = pr.head.ref || '';
              const candidates = [];
              const branchMatch = branch.match(/issue-+([0-9]+)/i);
              if (branchMatch) {
                candidates.push(branchMatch[1]);
              }

              const titleMatch = (pr.title || '').match(/#([0-9]+)/);
              if (titleMatch) {
                candidates.push(titleMatch[1]);
              }

              const bodyMatches = [...((pr.body || '').matchAll(/#([0-9]+)/g))].map((m) => m[1]);
              candidates.push(...bodyMatches);

              for (const value of candidates) {
                const parsed = Number.parseInt(value, 10);
                if (!Number.isNaN(parsed)) {
                  return parsed;
                }
              }

              return null;
            }

            function extractSection(body, heading) {
              if (!body) {
                core.debug(`extractSection: body is empty for heading "${heading}"`);
                return '';
              }

              // Flexible regex: allow ## headers OR standalone text on its own line
              const escapedHeading = heading.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
              // Match either "## Heading" or just "Heading" at start of line
              const pattern = new RegExp(`(^|\\n)(#{1,3}\\s+)?${escapedHeading}\\s*\\r?\\n`, 'i');
              const match = body.match(pattern);

              if (!match) {
                core.debug(`extractSection: No match for heading "${heading}"`);
                core.debug(`  Pattern: ${pattern}`);
                core.debug(`  Body preview: ${body.slice(0, 200).replace(/\n/g, '\\n')}`);
                return '';
              }

              core.debug(`extractSection: Found "${heading}" at index ${match.index}`);
              const start = match.index + match[0].length;
              const rest = body.slice(start);

              // Look for next section: either ## heading OR a known section name at start of line
              const knownSections = ['Why', 'Scope', 'Non-Goals', 'Goal', 'Tasks', 'Acceptance criteria', 'Success criteria', 'Definition of done', 'Implementation notes', 'Technical notes', 'Summary', 'Description', 'Overview', 'Testing', 'Test Plan', 'Validation', 'CI readiness'];
              const sectionPattern = knownSections.map(s => s.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|');
              const nextPattern = new RegExp(`\\r?\\n(#{2,3}\\s+|(?:${sectionPattern})\\s*\\r?\\n)`, 'i');
              const nextMatch = rest.match(nextPattern);
              const end = nextMatch ? nextMatch.index + 1 : rest.length;
              const content = rest.slice(0, end).trim();

              core.debug(`  Extracted ${content.length} characters`);
              return content;
            }

            function normalizeWhitespace(value) {
              if (!value) return '';
              return value
                .replace(/\r\n/g, '\n')
                .split('\n')
                .map((line) => line.trimEnd())
                .join('\n')
                .trim();
            }

            function ensureChecklist(section) {
              const cleaned = normalizeWhitespace(section);
              if (!cleaned) {
                return '';
              }

              return cleaned
                .split('\n')
                .map((line) => {
                  const match = line.match(/^(\s*)([-*])\s+(.*)$/);
                  if (!match) {
                    return line.trim();
                  }
                  const [, indent = '', , contentRaw] = match;
                  const content = contentRaw.trim();
                  const checkbox = content.match(/^\[( |x|X)\]\s*/);
                  if (checkbox) {
                    const state = checkbox[1].toLowerCase() === 'x' ? 'x' : ' ';
                    const remainder = content.slice(checkbox[0].length).trimStart();
                    return `${indent}- [${state}] ${remainder}`;
                  }
                  return `${indent}- [ ] ${content}`;
                })
                .join('\n');
            }

            function fallbackChecklist(message) {
              return `- [ ] ${message}`;
            }

            function buildPreamble(sections) {
              const lines = ['<!-- pr-preamble:start -->'];
              
              // Only include sections that have actual content from the issue
              if (sections.summary && sections.summary.trim()) {
                lines.push('## Summary', sections.summary, '');
              }
              
              if (sections.testing && sections.testing.trim()) {
                lines.push('## Testing', sections.testing, '');
              }
              
              if (sections.ci && sections.ci.trim()) {
                lines.push('## CI readiness', sections.ci, '');
              }
              
              lines.push('<!-- pr-preamble:end -->');
              return lines.join('\n');
            }

            function iconForStatus(status) {
              switch (status) {
                case 'success':
                  return '✅';
                case 'skipped':
                  return '⏭️';
                case 'cancelled':
                  return '⏹️';
                case 'timed_out':
                  return '⏱️';
                case 'failure':
                  return '❌';
                case 'neutral':
                  return '⚪';
                case 'pending':
                case 'waiting':
                case 'queued':
                case 'requested':
                  return '⏳';
                default:
                  return '❔';
              }
            }

            function friendlyStatus(status) {
              return (status || 'unknown').replace(/_/g, ' ');
            }

            function combineStatus(run) {
              if (!run) {
                return {icon: '❔', label: 'unknown'};
              }
              if (run.conclusion) {
                const normalized = run.conclusion.toLowerCase();
                return {icon: iconForStatus(normalized), label: friendlyStatus(normalized)};
              }
              if (run.status) {
                const normalized = run.status.toLowerCase();
                return {icon: iconForStatus(normalized), label: friendlyStatus(normalized)};
              }
              return {icon: '❔', label: 'unknown'};
            }

            function selectLatestWorkflows(runs) {
              const latest = new Map();
              for (const run of runs) {
                const name = run.name || 'Unnamed workflow';
                const key = name.toLowerCase();
                const existing = latest.get(key);
                if (!existing) {
                  latest.set(key, run);
                  continue;
                }
                if (new Date(run.created_at) > new Date(existing.created_at)) {
                  latest.set(key, run);
                }
              }
              return latest;
            }

            function buildStatusBlock({scope, tasks, acceptance, headSha, workflowRuns, requiredChecks}) {
              const statusLines = ['<!-- auto-status-summary:start -->', '## Automated Status Summary'];

              statusLines.push('#### Scope');
              const scopeFormatted = scope ? ensureChecklist(scope) : fallbackChecklist('Scope section missing from source issue.');
              statusLines.push(scopeFormatted);
              statusLines.push('');

              statusLines.push('#### Tasks');
              const tasksFormatted = tasks ? ensureChecklist(tasks) : fallbackChecklist('Tasks section missing from source issue.');
              statusLines.push(tasksFormatted);
              statusLines.push('');

              statusLines.push('#### Acceptance criteria');
              const acceptanceFormatted = acceptance ? ensureChecklist(acceptance) : fallbackChecklist('Acceptance criteria section missing from source issue.');
              statusLines.push(acceptanceFormatted);
              statusLines.push('');

              statusLines.push(`**Head SHA:** ${headSha}`);

              const latestRuns = Array.from(workflowRuns.values()).sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
              let latestLine = '—';
              if (latestRuns.length > 0) {
                const gate = latestRuns.find((run) => (run.name || '').toLowerCase() === 'gate');
                const chosen = gate || latestRuns[0];
                const status = combineStatus(chosen);
                latestLine = `${status.icon} ${status.label} — ${chosen.name}`;
              }
              statusLines.push(`**Latest Runs:** ${latestLine}`);

              const requiredParts = [];
              for (const name of requiredChecks) {
                const run = Array.from(workflowRuns.values()).find((item) => (item.name || '').toLowerCase() === name.toLowerCase());
                if (!run) {
                  requiredParts.push(`${name}: ⏸️ not started`);
                } else {
                  const status = combineStatus(run);
                  requiredParts.push(`${name}: ${status.icon} ${status.label}`);
                }
              }
              statusLines.push(`**Required:** ${requiredParts.length > 0 ? requiredParts.join(', ') : '—'}`);
              statusLines.push('');

              const table = ['| Workflow / Job | Result | Logs |', '|----------------|--------|------|'];
              const runs = Array.from(workflowRuns.values()).sort((a, b) => (a.name || '').localeCompare(b.name || ''));

              if (runs.length === 0) {
                table.push('| _(no workflow runs yet for this commit)_ | — | — |');
              } else {
                for (const run of runs) {
                  const status = combineStatus(run);
                  const link = run.html_url ? `[View run](${run.html_url})` : '—';
                  table.push(`| ${run.name || 'Unnamed workflow'} | ${status.icon} ${status.label} | ${link} |`);
                }
              }

              statusLines.push(...table);
              statusLines.push('<!-- auto-status-summary:end -->');

              return statusLines.join('\n');
            }

            function upsertBlock(body, marker, replacement) {
              const start = `<!-- ${marker}:start -->`;
              const end = `<!-- ${marker}:end -->`;

              const startIndex = body.indexOf(start);
              const endIndex = body.indexOf(end);
              if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                return `${body.slice(0, startIndex)}${replacement}${body.slice(endIndex + end.length)}`;
              }

              const trimmed = body.trimEnd();
              const prefix = trimmed ? `${trimmed}\n\n` : '';
              return `${prefix}${replacement}`;
            }

            async function fetchRequiredChecks(baseRef) {
              const qualified = baseRef.startsWith('refs/') ? baseRef : `refs/heads/${baseRef}`;
              try {
                const result = await github.graphql(
                  `query($owner: String!, $repo: String!, $qualified: String!) {
                    repository(owner: $owner, name: $repo) {
                      ref(qualifiedName: $qualified) {
                        branchProtectionRule {
                          requiresStatusChecks
                          requiredStatusCheckContexts
                        }
                      }
                    }
                  }`,
                  {owner, repo, qualified},
                );
                const rule = result?.repository?.ref?.branchProtectionRule;
                if (rule && rule.requiresStatusChecks && Array.isArray(rule.requiredStatusCheckContexts)) {
                  return rule.requiredStatusCheckContexts.filter((item) => typeof item === 'string' && item.trim());
                }
              } catch (error) {
                core.info(`Branch protection lookup failed: ${error.message}`);
              }
              return [];
            }

            const prInfo = await discoverPr();
            if (!prInfo) {
              return 'No pull request context detected; skipping update.';
            }

            const prResponse = await github.rest.pulls.get({owner, repo, pull_number: prInfo.number});
            const pr = prResponse.data;
            if (pr.state === 'closed') {
              return `Pull request #${pr.number} is closed; skipping update.`;
            }

            if (prInfo.headSha && pr.head && pr.head.sha && pr.head.sha !== prInfo.headSha) {
              return `Skipping update for PR #${pr.number} because workflow run head ${prInfo.headSha} does not match current head ${pr.head.sha}.`;
            }

            const issueNumber = extractIssueNumber(pr);
            if (!issueNumber) {
              return `Unable to determine source issue for PR #${pr.number}; skipping.`;
            }

            core.info(`Fetching content from issue #${issueNumber} for PR #${pr.number}`);
            const issueResponse = await github.rest.issues.get({owner, repo, issue_number: issueNumber});
            const issueBody = issueResponse.data.body || '';

            if (!issueBody) {
              core.warning(`Issue #${issueNumber} has no body content`);
            } else {
              core.debug(`Issue body length: ${issueBody.length} characters`);
              core.debug(`Issue body preview: ${issueBody.slice(0, 300).replace(/\n/g, '\\n')}`);
            }

            function extractWithAliases(body, aliases) {
              for (const alias of aliases) {
                const content = extractSection(body, alias);
                if (content) return content;
              }
              return '';
            }

            function buildRichSummary(body) {
              core.info('Building rich summary from issue sections...');
              const why = normalizeWhitespace(extractSection(body, 'Why'));
              const scopeRaw = normalizeWhitespace(extractSection(body, 'Scope'));
              const nonGoals = normalizeWhitespace(extractSection(body, 'Non-Goals'));
              const goal = normalizeWhitespace(extractSection(body, 'Goal'));

              core.info(`  Why: ${why ? `${why.length} chars` : 'NOT FOUND'}`);
              core.info(`  Scope: ${scopeRaw ? `${scopeRaw.length} chars` : 'NOT FOUND'}`);
              core.info(`  Non-Goals: ${nonGoals ? `${nonGoals.length} chars` : 'NOT FOUND'}`);
              core.info(`  Goal: ${goal ? `${goal.length} chars` : 'NOT FOUND'}`);

              const parts = [];
              if (why) parts.push(why);
              if (goal) parts.push(goal);
              if (scopeRaw) parts.push(`\n**Scope:** ${scopeRaw}`);
              if (nonGoals) parts.push(`**Non-Goals:** ${nonGoals}`);

              const result = parts.join('\n\n');
              core.info(`Rich summary result: ${result ? `${result.length} chars` : 'EMPTY'}`);
              return result;
            }

            const summaryRich = buildRichSummary(issueBody);
            const summary = summaryRich || normalizeWhitespace(extractWithAliases(issueBody, ['Summary', 'Description', 'Overview']));
            const testing = normalizeWhitespace(extractWithAliases(issueBody, ['Testing', 'Test Plan', 'Validation']));
            const ci = normalizeWhitespace(extractWithAliases(issueBody, ['CI readiness', 'Implementation notes', 'Technical notes']));

            core.info(`Final sections - Summary: ${summary ? 'OK' : 'EMPTY'}, Testing: ${testing ? 'OK' : 'EMPTY'}, CI: ${ci ? 'OK' : 'EMPTY'}`);

            const scope = extractSection(issueBody, 'Scope') || '';
            const tasks = extractSection(issueBody, 'Tasks') || '';
            const acceptance = extractWithAliases(issueBody, ['Acceptance criteria', 'Success criteria', 'Definition of done']) || '';

            core.info(`Status block sections - Scope: ${scope ? 'OK' : 'EMPTY'}, Tasks: ${tasks ? 'OK' : 'EMPTY'}, Acceptance: ${acceptance ? 'OK' : 'EMPTY'}`);

            const preamble = buildPreamble({summary, testing, ci});

            const workflowRunResponse = await github.rest.actions.listWorkflowRunsForRepo({
              owner,
              repo,
              head_sha: pr.head.sha,
              per_page: 100,
            });
            const workflowRuns = selectLatestWorkflows(workflowRunResponse.data.workflow_runs || []);

            const requiredChecks = await fetchRequiredChecks(pr.base.ref);
            if (!requiredChecks.includes('gate') && pr.base.ref) {
              requiredChecks.push('gate');
            }

            const statusBlock = buildStatusBlock({
              scope,
              tasks,
              acceptance,
              headSha: prInfo.headSha,
              workflowRuns,
              requiredChecks,
            });

            const bodyWithPreamble = upsertBlock(pr.body || '', 'pr-preamble', preamble);
            const newBody = upsertBlock(bodyWithPreamble, 'auto-status-summary', statusBlock);

            if (newBody !== (pr.body || '')) {
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: pr.number,
                body: newBody,
              });
              return `Updated PR #${pr.number} body with synchronized sections from issue #${issueNumber}.`;
            }

            return 'PR body already up to date; no changes required.';

