# Reusable agents issue bridge workflow
# 
# This workflow provides shared steps for creating agent bootstrap PRs from GitHub issues.
# It supports multiple agents (codex, claude, etc.) through parameterization.
# 
# Expected labels:
# - agent:<agent_name> or agents:<agent_name> - triggers bridge for specified agent
# - agent:<agent_name>-invite - overrides PR mode to 'invite' (human opens PR)
# - agents:keepalive - enables keepalive monitoring for the agent workflow
# 
# Inputs:
# - agent: The agent identifier (e.g., 'codex', 'claude')
# - issue_number: Issue number to process (required for workflow_dispatch)
# - mode: PR creation mode ('create' or 'invite')
# - post_agent_comment: Whether to auto-post '@<agent> start' command
# - agent_pr_draft: Whether created PRs should be drafts
# - service_bot_pat: PAT for service bot operations
# - owner_pr_pat: PAT for PR creation operations

name: Reusable Agents Issue Bridge

on:
  workflow_call:
    inputs:
      agent:
        description: "Agent identifier (e.g., codex, claude)"
        required: true
        type: string
      issue_number:
        description: "Issue number to process (for workflow_dispatch)"
        required: false
        type: string
        default: ""
      mode:
        description: "PR creation mode (create|invite)"
        required: false
        type: string
        default: "invite"
      post_agent_comment:
        description: "Auto-post '@<agent> start' command (true/false)"
        required: false
        type: string
        default: "true"
      agent_pr_draft:
        description: "Force created PR to be draft (true/false)"
        required: false
        type: string
        default: "false"
    secrets:
      service_bot_pat:
        description: "PAT for service bot operations"
        required: false
      owner_pr_pat:
        description: "PAT for PR creation operations"
        required: false

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  bridge:
    runs-on: ubuntu-latest
    outputs:
      issue: ${{ steps.ctx.outputs.issue }}
      has_issue: ${{ steps.ctx.outputs.has_issue }}
      base: ${{ steps.refs.outputs.base }}
      head: ${{ steps.mk.outputs.branch || steps.refs.outputs.head || '' }}
      mode: ${{ steps.mode.outputs.mode }}
    env:
      SERVICE_BOT_PAT: ${{ secrets.service_bot_pat }}
      AGENT: ${{ inputs.agent }}

    steps:
      - name: Resolve issue number
        id: ctx
        uses: actions/github-script@v7
        with:
          script: |
            const issueFromEvent = context.payload.issue && context.payload.issue.number;
            const issueFromInput = '${{ inputs.issue_number }}';
            const num = Number(issueFromEvent || issueFromInput || 0);
            core.setOutput('issue', num > 0 ? String(num) : '');
            core.setOutput('has_issue', num > 0 ? 'true' : 'false');

      - name: Resolve agent label
        if: ${{ steps.ctx.outputs.has_issue == 'true' }}
        id: agent_label
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = Number('${{ steps.ctx.outputs.issue }}');
            const { owner, repo } = context.repo;

            const loadLabels = async () => {
              if (!issueNumber) {
                return [];
              }
              const issueFromEvent = context.payload.issue;
              if (issueFromEvent && Number(issueFromEvent.number) === issueNumber) {
                return issueFromEvent.labels || [];
              }
              const { data } = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
              return data.labels || [];
            };

            const rawLabels = await loadLabels();
            const prefixes = ['agent:', 'agents:'];
            const inviteSuffix = '-invite';
            const candidates = new Map();

            for (const label of rawLabels) {
              const name = (typeof label === 'string' ? label : label?.name || '').trim();
              if (!name) continue;
              const lower = name.toLowerCase();
              const prefix = prefixes.find((pref) => lower.startsWith(pref));
              if (!prefix) continue;
              let suffix = lower.slice(prefix.length).trim();
              if (!suffix || suffix === 'keepalive') {
                continue;
              }
              let base = suffix;
              let invite = false;
              if (base.endsWith(inviteSuffix)) {
                base = base.slice(0, -inviteSuffix.length).trim();
                if (!base) continue;
                invite = true;
              }
              const canonical = `agent:${base}`;
              if (!candidates.has(canonical)) {
                candidates.set(canonical, {
                  base,
                  labels: new Set(),
                  inviteLabels: new Set(),
                });
              }
              const entry = candidates.get(canonical);
              if (invite) {
                entry.inviteLabels.add(name);
              } else {
                entry.labels.add(name);
              }
            }

            const withBase = Array.from(candidates.values()).filter((entry) => entry.labels.size > 0);
            if (withBase.length === 0) {
              const inviteOnly = Array.from(candidates.values())
                .flatMap((entry) => Array.from(entry.inviteLabels))
                .join(', ');
              if (inviteOnly) {
                core.setFailed(
                  `agent:* invite labels (${inviteOnly}) require the matching base agent:* label. Add agent:<name> before running the bridge.`,
                );
              } else {
                core.setFailed('Exactly one agent:* label is required to run the bridge.');
              }
              return;
            }
            if (withBase.length > 1) {
              const names = withBase
                .map((entry) => Array.from(entry.labels)[0] || `agent:${entry.base}`)
                .join(', ');
              core.setFailed(`Expected exactly one agent:* label but found multiple: ${names}`);
              return;
            }

            const entry = withBase[0];
            const original = Array.from(entry.labels)[0] || `agent:${entry.base}`;
            const suffix = entry.base;
            const slugify = (value) =>
              value
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '-')
                .replace(/^-+|-+$/g, '');
            const agent = slugify(suffix);
            if (!agent) {
              core.setFailed(`Agent label \"${original}\" could not be normalized to a slug.`);
              return;
            }
            const mention = `@${agent}`;
            const title = agent
              .split('-')
              .filter(Boolean)
              .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
              .join(' ') || original;

            core.exportVariable('BRIDGE_AGENT_LABEL', original);
            core.exportVariable('BRIDGE_AGENT_NAME', agent);
            core.exportVariable('BRIDGE_AGENT_MENTION', mention);
            core.exportVariable('BRIDGE_AGENT_TITLE', title);
            core.exportVariable('AGENT', agent);

            core.setOutput('label', original);
            core.setOutput('agent', agent);
            core.setOutput('mention', mention);
            core.setOutput('title', title);

      - name: Resolve base and head refs
        id: refs
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const { data } = await github.rest.repos.get({ owner, repo });
            const base = data.default_branch || 'main';
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const head = issue ? `codex/issue-${issue}` : '';
            core.setOutput('base', base);
            if (head) {
              core.setOutput('head', head);
            }

      - name: Fail fast on missing issue (manual run)
        if: ${{ github.event_name == 'workflow_dispatch' && steps.ctx.outputs.has_issue != 'true' }}
        run: |
          echo "::error::Missing issue number for workflow_dispatch. Provide an issue number when manually running this workflow." && exit 1

      - name: Checkout default
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.refs.outputs.base }}
          fetch-depth: 0
          persist-credentials: true

      - name: Select PR mode
        id: mode
        uses: actions/github-script@v7
        env:
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
        with:
          script: |
            const agent = (process.env.AGENT || '').trim();
            if (!agent || agent === 'unknown') {
              core.setFailed('Agent resolution failed; ensure exactly one agent:* label is present or provide the agent input.');
              return;
            }
            const ev = context.eventName;
            let mode = '${{ inputs.mode }}' || 'invite';
            let reason = 'input-default';
            
            if (ev === 'issues') {
              const labels = (context.payload.issue && Array.isArray(context.payload.issue.labels)) ? context.payload.issue.labels : [];
              const hasInvite = labels.some((lbl) => String(lbl.name || '').toLowerCase() === `agent:${agent}-invite`);
              if (hasInvite) {
                mode = 'invite';
                reason = 'issue-label-override';
              }
            }
            
            core.setOutput('mode', mode);
            core.setOutput('reason', reason);

      - name: Resolve draft flag
        id: draft
        uses: actions/github-script@v7
        with:
          script: |
            const val = '${{ inputs.agent_pr_draft }}' === 'true';
            core.setOutput('draft', val ? 'true' : 'false');

      - name: Resolve post-agent comment flag
        id: agent_comment
        uses: actions/github-script@v7
        with:
          script: |
            const val = '${{ inputs.post_agent_comment }}' === 'true';
            core.setOutput('post', val ? 'true' : 'false');

      - name: Resolve keepalive opt-in
        if: ${{ steps.ctx.outputs.has_issue == 'true' }}
        id: keepalive
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = Number('${{ steps.ctx.outputs.issue }}');
            const { owner, repo } = context.repo;
            const sentinel = /\[keepalive\]/i;
            const keepaliveLabel = 'agents:keepalive';

            let enabled = false;
            let source = 'default';
            let evidence = '';

            if (!issueNumber) {
              core.setOutput('enabled', 'false');
              core.setOutput('mode', 'OFF');
              core.setOutput('source', 'missing');
              core.setOutput('options_json', JSON.stringify({ keepalive: { enabled: false } }));
              return;
            }

            let issue = context.payload.issue;
            if (!issue || Number(issue.number) !== issueNumber) {
              try {
                const { data } = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                issue = data;
              } catch (error) {
                core.warning(`Failed to fetch issue #${issueNumber}: ${error.message}`);
              }
            }

            const labels = Array.isArray(issue?.labels) ? issue.labels : [];
            const labelMatch = labels.some((label) => {
              const name = typeof label === 'string' ? label : label?.name || '';
              return name.trim().toLowerCase() === keepaliveLabel;
            });

            if (labelMatch) {
              enabled = true;
              source = 'label';
              evidence = 'agents:keepalive label present';
            }

            if (!enabled) {
              try {
                const iterator = github.paginate.iterator(
                  github.rest.issues.listComments,
                  { owner, repo, issue_number: issueNumber, per_page: 100 }
                );
                for await (const page of iterator) {
                  for (const comment of page.data) {
                    if (sentinel.test(comment.body || '')) {
                      enabled = true;
                      source = 'comment';
                      evidence = comment.html_url || `comment ${comment.id}`;
                      break;
                    }
                  }
                  if (enabled) {
                    break;
                  }
                }
              } catch (error) {
                core.warning(`Failed to scan comments for keepalive sentinel: ${error.message}`);
              }
            }

            const mode = enabled ? 'ON' : 'OFF';
            const options = { keepalive: { enabled } };
            core.setOutput('enabled', enabled ? 'true' : 'false');
            core.setOutput('mode', mode);
            core.setOutput('source', source);
            core.setOutput('options_json', JSON.stringify(options));
            if (evidence) {
              core.setOutput('evidence', evidence);
            }

            const summary = core.summary;
            summary
              .addHeading('Keepalive opt-in resolution')
              .addTable([
                [{ data: 'Issue', header: true }, { data: 'Mode', header: true }, { data: 'Source', header: true }, { data: 'Evidence', header: true }],
                [`#${issueNumber}`, mode, source, evidence || '(none)']
              ]);
            await summary.write();

      - name: Log chosen mode & draft
        env:
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
        run: |
          echo "Agent: $AGENT"
          echo "Chosen PR mode: ${{ steps.mode.outputs.mode }} (reason: ${{ steps.mode.outputs.reason }})"
          echo "Base branch: ${{ steps.refs.outputs.base }}"
          echo "Head branch: ${{ steps.refs.outputs.head || 'unresolved' }}"
          echo "Resolved draft flag: ${{ steps.draft.outputs.draft }}"
          echo "Post agent comment: ${{ steps.agent_comment.outputs.post }}"
          echo "Keepalive mode: ${{ steps.keepalive.outputs.mode || 'OFF' }} (source: ${{ steps.keepalive.outputs.source || 'default' }})"

      - name: Publish bridge summary
        uses: actions/github-script@v7
        with:
          script: |
            const agent = (process.env.AGENT || '').trim();
            if (!agent || agent === 'unknown') {
              core.setFailed('Agent resolution failed; ensure exactly one agent:* label is present or provide the agent input.');
              return;
            }
            const issueNo = context.payload.issue && context.payload.issue.number;
            const manualIssue = '${{ inputs.issue_number }}';
            const base = '${{ steps.refs.outputs.base }}';
            const head = '${{ steps.refs.outputs.head || '' }}';
            const mode = '${{ steps.mode.outputs.mode }}';
            await core.summary
              .addHeading(`${agent.charAt(0).toUpperCase() + agent.slice(1)} Bridge Event Summary`)
              .addTable([
                [
                  { data: 'Agent', header: true },
                  { data: 'Issue (event)', header: true },
                  { data: 'Issue (input)', header: true },
                  { data: 'Mode', header: true },
                  { data: 'Base', header: true },
                  { data: 'Head', header: true }
                ],
                [agent, String(issueNo || ''), String(manualIssue || ''), mode, base, head || '(pending)']
              ])
              .write();

      - name: Create branch and bootstrap file (fallback)
        if: ${{ steps.ctx.outputs.has_issue == 'true' }}
        id: mk
        env:
          ISSUE: ${{ steps.ctx.outputs.issue }}
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
          BASE: ${{ steps.refs.outputs.base }}
          HEAD: ${{ steps.refs.outputs.head || '' }}
        run: |
          set -euo pipefail

          ISSUE_NUM="${ISSUE}"
          BASE_BRANCH="${BASE}"
          HEAD_BRANCH="${HEAD}"

          if [ -z "$ISSUE_NUM" ] || [ -z "$HEAD_BRANCH" ]; then
            echo "Resolved issue/head missing; skipping branch creation."
            exit 0
          fi

          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git fetch origin "$BASE_BRANCH" || true

          if git ls-remote --exit-code --heads origin "$HEAD_BRANCH" > /dev/null 2>&1; then
            echo "Reusing existing branch ${HEAD_BRANCH} for issue #${ISSUE_NUM}."
            git fetch origin "$HEAD_BRANCH"
            git checkout -B "$HEAD_BRANCH" "origin/${HEAD_BRANCH}"
            git pull --ff-only origin "$HEAD_BRANCH"
            echo "branch=${HEAD_BRANCH}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git checkout -B "$HEAD_BRANCH" "origin/${BASE_BRANCH}"
          mkdir -p agents
          printf "<!-- bootstrap for %s on issue #%s -->\n" "$AGENT" "$ISSUE_NUM" > "agents/${AGENT}-${ISSUE_NUM}.md"
          git add -A || true
          if ! git diff --cached --quiet; then
            git commit -m "chore(${AGENT}): bootstrap PR for issue #${ISSUE_NUM}"
          else
            echo "No changes to commit; proceeding to push branch with existing tree."
          fi
          git push origin "HEAD:${HEAD_BRANCH}"
          echo "branch=${HEAD_BRANCH}" >> "$GITHUB_OUTPUT"

      - name: Invite human to open PR (invite mode)
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.mode.outputs.mode == 'invite' }}
        uses: actions/github-script@v7
        env:
          BRANCH: ${{ steps.mk.outputs.branch }}
          KEEPALIVE_MODE: ${{ steps.keepalive.outputs.mode || 'OFF' }}
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
        with:
          script: |
            const {owner, repo} = context.repo;
            const issue_number = Number('${{ steps.ctx.outputs.issue }}');
            const base = "${{ steps.refs.outputs.base }}";
            const branch = process.env.BRANCH;
            const agent = (process.env.AGENT || '').trim();
            if (!agent || agent === 'unknown') {
              core.setFailed('Agent resolution failed; ensure exactly one agent:* label is present or provide the agent input.');
              return;
            }
            const agentTitle = process.env.BRIDGE_AGENT_TITLE || agent.charAt(0).toUpperCase() + agent.slice(1);
            const mention = process.env.BRIDGE_AGENT_MENTION || `@${agent}`;
            const instruction = `${mention} use the scope, acceptance criteria, and task list so the keepalive workflow continues nudging until everything is complete. Work through the tasks, checking them off only after each acceptance criterion is satisfied, but check during each comment implementation and check off tasks and acceptance criteria that have been satisfied and repost the current version of the initial scope, task list and acceptance criteria each time that any have been newly completed.`;
            const rawMode = (process.env.KEEPALIVE_MODE || 'OFF').trim().toUpperCase();
            const keepaliveMode = rawMode === 'ON' ? 'ON' : 'OFF';

            if (!branch) {
              core.setFailed('Resolved branch name missing; cannot post invite instructions.');
              return;
            }
            let issueTitle = '';
            let issueBody = '';
            try {
              const { data: is } = await github.rest.issues.get({ owner, repo, issue_number });
              issueTitle = is.title || '';
              issueBody = is.body || ''; 
            } catch (err) { 
              core.error('Failed to fetch issue: ' + err); 
            }
            
            const issueUrl = `https://github.com/${owner}/${repo}/issues/${issue_number}`;
            const keepaliveHeader = `### Keepalive: ${keepaliveMode}`;
            const header = `### Source Issue #${issue_number}: ${issueTitle}`;
            const quoted = (issueBody || '').split('\n').map(l => `> ${l}`).join('\n');
            
            const bodySections = [
              keepaliveHeader,
              '',
              header,
              '',
              `Base: ${base}`,
              `Head: ${branch}`,
              '',
              `Source: ${issueUrl}`,
              '',
              quoted,
              '',
              `${mention} start`,
              '',
              `${agentTitle}, please derive and propose:`,
              '- Scope / key constraints',
              '- Acceptance criteria / definition of done',
              '- Initial task checklist to iterate through',
              '',
              'Use the issue details above to draft the plan, then proceed with implementation.',
              '',
              '---',
              '',
              'Once the plan is posted, comment the snippet below to start execution and enable keepalive:',
              '',
              'The following block should be pasted as a separate PR comment:',
              '',
              '```markdown',
              instruction,
              '```'
            ];
            
            const suggestion = bodySections.join('\n');
            const compareUrl = `https://github.com/${owner}/${repo}/compare/${base}...${branch}?expand=1`;
            
            if (!issue_number) { 
              core.setFailed('Resolved issue number missing; cannot post invite.'); 
              return; 
            }
            
            await github.rest.issues.createComment({ 
              owner, 
              repo, 
              issue_number, 
              body: `Branch \`${branch}\` created from \`${base}\`.\n\nOption 1 (Invite) is enforced on issue events. PR creation is disabled by design so you are the PR author. ${agentTitle} only engages on human-authored PRs.\n\nPlease open the PR as the author so ${agentTitle} can work on it:\n\n- Compare link: ${compareUrl}\n- Suggested title: \`${agentTitle} bootstrap for #${issue_number}\`\n- Suggested body (copy/paste):\n\n\n${'```markdown'}\n${suggestion}\n${'```'}` 
            });

      - name: Skip PR creation when inviting
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.mode.outputs.mode == 'invite' }}
        env:
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
        run: |
          echo "Invite mode: skipping PR creation; waiting for human author to create PR for $AGENT."

      - name: Open or reuse PR (create mode)
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.mode.outputs.mode != 'invite' }}
        id: pr
        uses: actions/github-script@v7
        env:
          BRANCH: ${{ steps.mk.outputs.branch }}
          KEEPALIVE_MODE: ${{ steps.keepalive.outputs.mode || 'OFF' }}
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
        with:
          github-token: ${{ secrets.owner_pr_pat || secrets.service_bot_pat || github.token }}
          script: |
            const {owner, repo} = context.repo;
            const issue_number = Number('${{ steps.ctx.outputs.issue }}');
            const base = "${{ steps.refs.outputs.base }}";
            const head = process.env.BRANCH;
            const draftFlag = "${{ steps.draft.outputs.draft }}" === 'true';
            const keepaliveModeRaw = (process.env.KEEPALIVE_MODE || 'OFF').trim().toUpperCase();
            const keepaliveStatus = keepaliveModeRaw === 'ON' ? 'ON' : 'OFF';
            const agent = (process.env.AGENT || '').trim();
            if (!agent || agent === 'unknown') {
              core.setFailed('Agent resolution failed; ensure exactly one agent:* label is present or provide the agent input.');
              return;
            }
            const agentTitle = process.env.BRIDGE_AGENT_TITLE || agent.charAt(0).toUpperCase() + agent.slice(1);
            const mention = process.env.BRIDGE_AGENT_MENTION || `@${agent}`;
            const instruction = `${mention} use the scope, acceptance criteria, and task list so the keepalive workflow continues nudging until everything is complete. Work through the tasks, checking them off only after each acceptance criterion is satisfied, but check during each comment implementation and check off tasks and acceptance criteria that have been satisfied and repost the current version of the initial scope, task list and acceptance criteria each time that any have been newly completed.`;

            if (!issue_number) {
              core.setFailed('Resolved issue number missing; cannot open PR.');
              return;
            }
            if (!head) {
              core.setFailed('Resolved branch name missing; cannot open or reuse PR.');
              return;
            }

            const existing = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${head}` });
            let pr = existing.data[0];
            let prCreated = false;

            let issueTitle = '';
            let issueBody = '';
            try {
              const { data: is } = await github.rest.issues.get({ owner, repo, issue_number });
              issueTitle = is.title || '';
              issueBody = is.body || '';
            } catch (error) {
              core.warning(`Failed to fetch issue #${issue_number}: ${error.message}`);
            }

            if (!pr) {
              const issueUrl = `https://github.com/${owner}/${repo}/issues/${issue_number}`;
              const keepaliveHeader = `### Keepalive: ${keepaliveStatus}`;
              const header = `### Source Issue #${issue_number}: ${issueTitle}`;
              const quoted = (issueBody || '').split('\n').map((line) => `> ${line}`).join('\n');
              const baseLine = base ? `Base: ${base}` : '';
              const headLine = head ? `Head: ${head}` : '';

              const normalise = (value) => String(value || '').replace(/\r\n/g, '\n');
              const escape = (value) => value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
              const extractSection = (body, heading, aliases = []) => {
                const names = [heading].concat(aliases || []);
                const pattern = new RegExp(`(^|\n)(#{1,3}\s+)?(${names.map(escape).join('|')})\s*\r?\n`, 'i');
                const source = normalise(body);
                const match = source.match(pattern);
                if (!match) {
                  return '';
                }
                const start = match.index + match[0].length;
                const rest = source.slice(start);
                const nextPattern = /\r?\n(#{2,3}\s+|Why\s*\r?\n|Scope\s*\r?\n|Non-Goals\s*\r?\n|Goal\s*\r?\n|Tasks\s*\r?\n|Acceptance criteria\s*\r?\n|Success criteria\s*\r?\n|Definition of done\s*\r?\n|Implementation notes\s*\r?\n|Technical notes\s*\r?\n|Summary\s*\r?\n|Description\s*\r?\n|Overview\s*\r?\n|Testing\s*\r?\n|Test Plan\s*\r?\n|Validation\s*\r?\n|CI readiness\s*\r?\n)/i;
                const nextMatch = rest.match(nextPattern);
                const end = nextMatch ? nextMatch.index + 1 : rest.length;
                return rest.slice(0, end).trim();
              };

              const ensureChecklist = (section, fallback) => {
                const lines = normalise(section)
                  .split('\n')
                  .map((line) => line.trimEnd());
                const hasContent = lines.some((line) => line.trim().length > 0);
                if (!hasContent) {
                  return fallback;
                }
                return lines
                  .map((line) => {
                    if (!line.trim()) {
                      return '';
                    }
                    const bullet = line.match(/^(\s*)([-*])\s+(.*)$/);
                    const [, indent = ''] = bullet || [];
                    const raw = bullet ? bullet[3] : line;
                    const content = raw.trim();
                    if (!content) {
                      return '';
                    }
                    const checkbox = content.match(/^\[( |x|X)\]\s*(.*)$/);
                    if (checkbox) {
                      const state = checkbox[1].toLowerCase() === 'x' ? 'x' : ' ';
                      return `${indent}- [${state}] ${checkbox[2].trim()}`;
                    }
                    return `${indent}- [ ] ${content}`;
                  })
                  .filter((line) => line.length > 0)
                  .join('\n');
              };

              const scopeChecklist = ensureChecklist(
                extractSection(issueBody, 'Scope'),
                '- [ ] Scope section missing from source issue.'
              );
              const tasksChecklist = ensureChecklist(
                extractSection(issueBody, 'Tasks'),
                '- [ ] Tasks section missing from source issue.'
              );
              const acceptanceChecklist = ensureChecklist(
                extractSection(issueBody, 'Acceptance criteria', ['Success criteria', 'Definition of done']),
                '- [ ] Acceptance criteria section missing from source issue.'
              );

              const preambleBlock = ['<!-- pr-preamble:start -->', '<!-- pr-preamble:end -->'].join('\n');
              const statusBlock = [
                '<!-- auto-status-summary:start -->',
                '## Automated Status Summary',
                '#### Scope',
                scopeChecklist,
                '',
                '#### Tasks',
                tasksChecklist,
                '',
                '#### Acceptance criteria',
                acceptanceChecklist,
                '',
                '**Head SHA:** _(pending first sync)_',
                '**Latest Runs:** ⏳ pending — _(no workflow runs yet)_',
                '**Required:** ⏳ pending',
                '',
                '| Workflow / Job | Result | Logs |',
                '|----------------|--------|------|',
                '| _(no workflow runs yet for this commit)_ | — | — |',
                '<!-- auto-status-summary:end -->'
              ].join('\n');

              const prBody = [
                keepaliveHeader,
                '',
                header,
                '',
                baseLine,
                headLine,
                '',
                `Source: ${issueUrl}`,
                '',
                quoted,
                '',
                '—',
                `PR created automatically to engage ${agentTitle}.`,
                '',
                preambleBlock,
                '',
                statusBlock
              ].join('\n');

              ({ data: pr } = await github.rest.pulls.create({
                owner,
                repo,
                head,
                base,
                draft: draftFlag,
                title: `${agentTitle} bootstrap for #${issue_number}`,
                body: prBody,
              }));
              prCreated = true;
            }

            core.setOutput('number', String(pr.number));
            core.setOutput('created', prCreated ? 'true' : 'false');
            core.setOutput('issue', issue_number ? String(issue_number) : '');
            core.setOutput('issue_body', issueBody || '');
            core.setOutput('issue_title', issueTitle || '');
            core.setOutput('instruction', instruction);
            core.setOutput('agent', agent);
            core.setOutput('keepalive_mode', keepaliveStatus);

            const assignees = ['chatgpt-codex-connector', 'stranske-automation-bot'];
            try { 
              await github.rest.issues.addAssignees({ owner, repo, issue_number: pr.number, assignees }); 
            } catch (e) { 
              core.warning(`PR assign failed: ${e.message}`); 
            }
            try { 
              await github.rest.issues.addAssignees({ owner, repo, issue_number, assignees }); 
            } catch (e) { 
              core.warning(`Issue assign failed: ${e.message}`); 
            }

      - name: Seed scope/tasks checklist comment
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.mode.outputs.mode != 'invite' && steps.pr.outputs.created == 'true' }}
        uses: actions/github-script@v7
        env:
          PR: ${{ steps.pr.outputs.number }}
          ISSUE_BODY: ${{ steps.pr.outputs.issue_body }}
          INSTRUCTION: ${{ steps.pr.outputs.instruction }}
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
        with:
          script: |
            const {owner, repo} = context.repo;
            const prNumber = Number(process.env.PR || '0');
            if (!prNumber) {
              core.warning('Checklist seed skipped: PR number missing.');
              return;
            }

            const issueBody = String(process.env.ISSUE_BODY || '');
            const agent = (process.env.AGENT || '').trim() || 'codex';
            const mention = process.env.BRIDGE_AGENT_MENTION || `@${agent}`;
            const defaultInstruction = `${mention} use the scope, acceptance criteria, and task list so the keepalive workflow continues nudging until everything is complete. Work through the tasks, checking them off only after each acceptance criterion is satisfied, but check during each comment implementation and check off tasks and acceptance criteria that have been satisfied and repost the current version of the initial scope, task list and acceptance criteria each time that any have been newly completed.`;
            const instruction = (process.env.INSTRUCTION || '').trim() || defaultInstruction;

            const normalise = (value) => String(value || '').replace(/\r\n/g, '\n');
            const escape = (value) => value.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
            const extractSection = (body, heading, aliases = []) => {
              const names = [heading].concat(aliases);
              const pattern = new RegExp(`(^|\n)(#{1,3}\s+)?(${names.map(escape).join('|')})\s*\r?\n`, 'i');
              const source = normalise(body);
              const match = source.match(pattern);
              if (!match) {
                return '';
              }
              const start = match.index + match[0].length;
              const rest = source.slice(start);
              const nextPattern = /\r?\n(#{2,3}\s+|Why\s*\r?\n|Scope\s*\r?\n|Non-Goals\s*\r?\n|Goal\s*\r?\n|Tasks\s*\r?\n|Acceptance criteria\s*\r?\n|Success criteria\s*\r?\n|Definition of done\s*\r?\n|Implementation notes\s*\r?\n|Technical notes\s*\r?\n|Summary\s*\r?\n|Description\s*\r?\n|Overview\s*\r?\n|Testing\s*\r?\n|Test Plan\s*\r?\n|Validation\s*\r?\n|CI readiness\s*\r?\n)/i;
              const nextMatch = rest.match(nextPattern);
              const end = nextMatch ? nextMatch.index + 1 : rest.length;
              return rest.slice(0, end).trim();
            };

            const ensureChecklist = (section, fallback) => {
              const lines = normalise(section)
                .split('\n')
                .map((line) => line.trimEnd());
              const hasContent = lines.some((line) => line.trim().length > 0);
              if (!hasContent) {
                return fallback;
              }
              return lines
                .map((line) => {
                  if (!line.trim()) {
                    return '';
                  }
                  const bullet = line.match(/^(\s*)([-*])\s+(.*)$/);
                  const [, indent = ''] = bullet || [];
                  const raw = bullet ? bullet[3] : line;
                  const content = raw.trim();
                  if (!content) {
                    return '';
                  }
                  const checkbox = content.match(/^\[( |x|X)\]\s*(.*)$/);
                  if (checkbox) {
                    const state = checkbox[1].toLowerCase() === 'x' ? 'x' : ' ';
                    return `${indent}- [${state}] ${checkbox[2].trim()}`;
                  }
                  return `${indent}- [ ] ${content}`;
                })
                .filter((line) => line.length > 0)
                .join('\n');
            };

            const scope = ensureChecklist(
              extractSection(issueBody, 'Scope'),
              '- [ ] Scope section missing from source issue.'
            );
            const tasks = ensureChecklist(
              extractSection(issueBody, 'Tasks'),
              '- [ ] Tasks section missing from source issue.'
            );
            const acceptance = ensureChecklist(
              extractSection(issueBody, 'Acceptance criteria', ['Success criteria', 'Definition of done']),
              '- [ ] Acceptance criteria section missing from source issue.'
            );

            const marker = '<!-- issue-bridge-checklist -->';
            const commentBody = [
              marker,
              instruction,
              '',
              '#### Scope',
              scope,
              '',
              '#### Tasks',
              tasks,
              '',
              '#### Acceptance criteria',
              acceptance,
            ].join('\n');

            const existing = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });
            const duplicate = existing.find((entry) => (entry.body || '').includes(marker));
            if (duplicate) {
              core.info(`Checklist comment already present (id=${duplicate.id}); skipping.`);
              return;
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: commentBody,
            });


      - name: Label PR with agent
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.mode.outputs.mode != 'invite' }}
        uses: actions/github-script@v7
        env:
          PR: ${{ steps.pr.outputs.number }}
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
        with:
          script: |
            const {owner, repo} = context.repo;
            const prNumber = Number(process.env.PR);
            const agent = (process.env.AGENT || '').trim();
            if (!agent || agent === 'unknown') {
              core.setFailed('Agent resolution failed; ensure exactly one agent:* label is present or provide the agent input.');
              return;
            }
            await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [`agent:${agent}`] });

      - name: Post agent command as service user
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.mode.outputs.mode != 'invite' && env.SERVICE_BOT_PAT != '' && steps.agent_comment.outputs.post == 'true' }}
        uses: actions/github-script@v7
        env:
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
        with:
          github-token: ${{ env.SERVICE_BOT_PAT }}
          script: |
            const {owner, repo} = context.repo;
            const prNumber = Number("${{ steps.pr.outputs.number }}");
            const agent = (process.env.AGENT || '').trim();
            if (!agent || agent === 'unknown') {
              core.setFailed('Agent resolution failed; ensure exactly one agent:* label is present or provide the agent input.');
              return;
            }
            const cmd = `@${agent} start`;
            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `${cmd}\n\nPlease create commits on this branch, run tests, and keep the PR updated.` });

      - name: Post agent command (fallback as github-actions)
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.mode.outputs.mode != 'invite' && env.SERVICE_BOT_PAT == '' && steps.agent_comment.outputs.post == 'true' }}
        uses: actions/github-script@v7
        env:
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
        with:
          script: |
            const {owner, repo} = context.repo;
            const prNumber = Number("${{ steps.pr.outputs.number }}");
            const agent = (process.env.AGENT || '').trim();
            if (!agent || agent === 'unknown') {
              core.setFailed('Agent resolution failed; ensure exactly one agent:* label is present or provide the agent input.');
              return;
            }
            const cmd = `@${agent} start`;
            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `${cmd}\n\nPlease create commits on this branch, run tests, and keep the PR updated.` });

      - name: Prompt human to post agent command
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.mode.outputs.mode != 'invite' && steps.agent_comment.outputs.post != 'true' }}
        uses: actions/github-script@v7
        env:
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
        with:
          script: |
            const {owner, repo} = context.repo;
            const prNumber = Number("${{ steps.pr.outputs.number }}");
            const agent = (process.env.AGENT || '').trim();
            if (!agent || agent === 'unknown') {
              core.setFailed('Agent resolution failed; ensure exactly one agent:* label is present or provide the agent input.');
              return;
            }
            const agentTitle = process.env.BRIDGE_AGENT_TITLE || agent.charAt(0).toUpperCase() + agent.slice(1);
            const mention = process.env.BRIDGE_AGENT_MENTION || `@${agent}`;
            const instruction = `${mention} use the scope, acceptance criteria, and task list so the keepalive workflow continues nudging until everything is complete. Work through the tasks, checking them off only after each acceptance criterion is satisfied, but check during each comment implementation and check off tasks and acceptance criteria that have been satisfied and repost the current version of the initial scope, task list and acceptance criteria each time that any have been newly completed.`;
            const codexPromptMsg = [
              "PR created.",
              `Comment \`@${agent} start\` to request the plan.`,
              `Tell ${agentTitle} to reuse the scope, acceptance criteria, and task list from the source issue and publish them here with \`- [ ]\` checklists so keepalive keeps watching.`,
              `After ${agentTitle} replies, follow the instructions posted on the source issue to begin execution.`
            ].join(' ');
            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: codexPromptMsg });

      - name: Link PR on original issue (fallback)
        if: ${{ steps.ctx.outputs.has_issue == 'true' && steps.mode.outputs.mode != 'invite' }}
        uses: actions/github-script@v7
        env:
          KEEPALIVE_MODE: ${{ steps.keepalive.outputs.mode || 'OFF' }}
          AGENT: ${{ steps.agent_label.outputs.agent || inputs.agent }}
          BRANCH: ${{ steps.mk.outputs.branch }}
          BASE: ${{ steps.refs.outputs.base }}
        with:
          script: |
            const {owner, repo} = context.repo;
            const issue_number = Number('${{ steps.ctx.outputs.issue }}');
            if (!issue_number) {
              core.warning('No issue context available to link PR back.');
              return;
            }

            let issueTitle = '';
            let issueBody = '';
            try {
              const { data: is } = await github.rest.issues.get({ owner, repo, issue_number });
              issueTitle = is.title || '';
              issueBody = is.body || '';
            } catch (e) {
              core.warning(`Failed to fetch issue #${issue_number}: ${e.message}`);
            }

            const agent = (process.env.AGENT || '').trim();
            if (!agent || agent === 'unknown') {
              core.setFailed('Agent resolution failed; ensure exactly one agent:* label is present or provide the agent input.');
              return;
            }
            const agentTitle = process.env.BRIDGE_AGENT_TITLE || agent.charAt(0).toUpperCase() + agent.slice(1);
            const mention = process.env.BRIDGE_AGENT_MENTION || `@${agent}`;
            const instruction = `${mention} use the scope, acceptance criteria, and task list so the keepalive workflow continues nudging until everything is complete. Work through the tasks, checking them off only after each acceptance criterion is satisfied, but check during each comment implementation and check off tasks and acceptance criteria that have been satisfied and repost the current version of the initial scope, task list and acceptance criteria each time that any have been newly completed.`;
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            const issueUrl = `https://github.com/${owner}/${repo}/issues/${issue_number}`;
            const header = `### Source Issue #${issue_number}: ${issueTitle}`.trim();
            const keepaliveMode = process.env.KEEPALIVE_MODE || 'OFF';
            const keepaliveLine = `Keepalive: ${keepaliveMode}`;
            const base = (process.env.BASE || '').trim();
            const head = (process.env.BRANCH || '').trim();
            const quoted = (issueBody || '')
              .split('\n')
              .map((line) => `> ${line}`)
              .join('\n');
            const snippetLines = [header, keepaliveLine];
            if (base) {
              snippetLines.push(`Base: ${base}`);
            }
            if (head) {
              snippetLines.push(`Head: ${head}`);
            }
            snippetLines.push('', `Source: ${issueUrl}`, '', quoted);
            const snippet = snippetLines.join('\n');
            
            const message = [
              `Opened PR #${prNumber} to engage ${agentTitle}.`,
              '',
              `Keepalive mode: **${keepaliveMode}**`,
              '',
              'Next steps for the PR author:',
              `- Comment \`${mention} start\` (auto-posted when possible) so ${agentTitle} drafts the plan.`,
              `- After ${agentTitle} replies with the checklist, post the execution command below to begin delivery and enable keepalive.`,
              '',
              'Execution command (copy into a standalone PR comment):',
              '```markdown',
              instruction,
              '```',
              '',
              'Issue context (optional: copy into the PR description):',
              '',
              '```markdown',
              snippet,
              '```'
            ].join('\n');
            
            await github.rest.issues.createComment({ owner, repo, issue_number, body: message });

      # Disabled: keepalive now runs exclusively via the orchestrator sweep to avoid
      # duplicate nudges from workflow dispatches.
      # - name: Dispatch Agents Orchestrator (keepalive sync)
