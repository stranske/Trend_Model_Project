name: agent readiness (copilot + codex)

on:
  workflow_dispatch:
    inputs:
      agents:
        description: "Comma-separated agent keys to test"
        default: "copilot,codex"
        required: false
      require_all:
        description: "Fail if any requested agent is not assignable (true/false)"
        default: "true"
        required: false
      copilot_logins:
        description: "Candidate GitHub logins for Copilot (comma-separated)"
        default: "copilot,copilot-swe-agent"
        required: false
      codex_logins:
        description: "Candidate GitHub logins for Codex (comma-separated)"
        default: "chatgpt-codex-connector"
        required: false
      custom_logins_json:
        description: "JSON object mapping agent keys to candidate logins"
        default: ""
        required: false

permissions:
  contents: read
  issues: write

jobs:
  probe:
    runs-on: ubuntu-latest
    steps:
      - name: Probe assignable actors via GraphQL
        id: gql
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const q = `
              query($owner:String!, $repo:String!) {
                repository(owner:$owner, name:$repo) {
                  suggestedActors(capabilities:[CAN_BE_ASSIGNED], first:100) {
                    nodes { login }
                  }
                }
              }`;
            const res = await github.graphql(q, { owner, repo });
            const actors = (res.repository?.suggestedActors?.nodes || [])
              .map(n => (n.login || '').toLowerCase());
            core.info("Assignable actors: " + JSON.stringify(actors));
            core.setOutput('actors', JSON.stringify(actors));

      - name: Create temporary issue
        id: tmp
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const { data: issue } = await github.rest.issues.create({
              owner, repo,
              title: "[readiness] agent assignability probe",
              body: "Temporary issue for readiness checks. Safe to close."
            });
            core.info(`Temp issue #${issue.number} created`);
            core.setOutput('num', String(issue.number));

      - name: Try assigning agents
        id: try
        env:
          ACTORS_JSON: ${{ steps.gql.outputs.actors }}
          INPUT_AGENTS: ${{ github.event.inputs.agents }}
          INPUT_REQUIRE_ALL: ${{ github.event.inputs.require_all }}
          INPUT_COPILOT_LOGINS: ${{ github.event.inputs.copilot_logins }}
          INPUT_CODEX_LOGINS: ${{ github.event.inputs.codex_logins }}
          INPUT_CUSTOM_LOGINS_JSON: ${{ github.event.inputs.custom_logins_json }}
          ISSUE_NUM: ${{ steps.tmp.outputs.num }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const num = Number(process.env.ISSUE_NUM || '0');

            // Safe JSON parse of actors list from env
            let actors = [];
            try { actors = JSON.parse(process.env.ACTORS_JSON || '[]'); }
            catch (e) { core.warning("Could not parse ACTORS_JSON; using []"); actors = []; }

            // Inputs (from env to avoid expression quoting issues)
            const requireAll = String(process.env.INPUT_REQUIRE_ALL || 'true').toLowerCase() === 'true';
            const agentsRequested = (process.env.INPUT_AGENTS || 'copilot,codex')
              .split(',').map(s => s.trim().toLowerCase()).filter(Boolean);

            // Candidate login lists
            const CANDIDATES = {
              copilot: (process.env.INPUT_COPILOT_LOGINS || 'copilot,copilot-swe-agent')
                        .split(',').map(s => s.trim().toLowerCase()).filter(Boolean),
              codex:   (process.env.INPUT_CODEX_LOGINS   || 'chatgpt-codex-connector')
                        .split(',').map(s => s.trim().toLowerCase()).filter(Boolean),
            };

            const customLoginsRaw = process.env.INPUT_CUSTOM_LOGINS_JSON || '';
            if (customLoginsRaw.trim()) {
              // Input size validation
              if (customLoginsRaw.length > 10000) {
                core.warning('custom_logins_json input too large (max 10,000 characters allowed)');
              } else {
                try {
                  const parsed = JSON.parse(customLoginsRaw);
                  if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
                    core.warning('custom_logins_json must be a JSON object mapping agent -> logins');
                  } else {
                    const agentEntries = Object.entries(parsed);
                    if (agentEntries.length > 10) {
                      core.warning('custom_logins_json has too many agent keys (max 10 allowed)');
                    }
                    for (const [agentKey, value] of agentEntries.slice(0, 10)) {
                      if (!agentKey) continue;
                      const key = agentKey.trim().toLowerCase();
                      if (!key) continue;
                      let rawList;
                      if (Array.isArray(value)) {
                        rawList = value.filter(v => typeof v === 'string');
                      } else if (typeof value === 'string') {
                        rawList = value.split(',').map(s => s.trim()).filter(Boolean);
                      } else {
                        core.warning(`custom_logins_json entry for ${agentKey} is not a string or array`);
                        continue;
                      }
                      // Limit number of logins per agent
                      if (rawList.length > 20) {
                        core.warning(`custom_logins_json entry for ${agentKey} has too many logins (max 20 allowed)`);
                        rawList = rawList.slice(0, 20);
                      }
                      const list = rawList.map(s => s.toLowerCase()).filter(Boolean);
                      if (list.length) {
                        CANDIDATES[key] = list;
                      } else {
                        core.warning(`custom_logins_json entry for ${agentKey} is empty after parsing`);
                      }
                    }
                  }
                } catch (err) {
                  core.warning(`Unable to parse custom_logins_json: ${err.message || err}`);
                }
              }
            }

            async function tryAssign(oneLogin) {
              try {
                const res = await github.rest.issues.addAssignees({
                  owner, repo, issue_number: num, assignees: [oneLogin]
                });
                return { ok: res.status >= 200 && res.status < 300, status: res.status, login: oneLogin };
              } catch (err) {
                return { ok: false, status: err.status || 'ERR', login: oneLogin, message: err.message || String(err) };
              }
            }

            const report = {};
            for (const agentKey of agentsRequested) {
              const candidates = CANDIDATES[agentKey] || [];
              if (!candidates.length) {
                report[agentKey] = { ok: false, reason: 'no candidates configured', candidates: [] };
                continue;
              }

              core.info(`\n== Testing ${agentKey.toUpperCase()} ==`);
              core.info(`Candidates: ${JSON.stringify(candidates)}`);
              const inSuggested = candidates.some(c => actors.includes(c));
              core.info(`GraphQL suggestedActors contains any candidate? ${inSuggested}`);

              let outcome = { ok: false, status: 'NA', used: null, inSuggested, candidates, attempts: [] };
              for (const cand of candidates) {
                const res = await tryAssign(cand);
                core.info(`addAssignees(${cand}) -> ${res.status} ok=${res.ok}`);
                outcome.attempts.push({ login: cand, ok: res.ok, status: res.status });
                if (res.ok) { outcome = { ...outcome, ok: true, status: res.status, used: cand }; break; }
                if (!outcome.message && res.message) outcome.message = res.message;
              }
              report[agentKey] = outcome;
            }

            core.info("Report: " + JSON.stringify(report, null, 2));
            core.setOutput('report', JSON.stringify(report));
            if (Object.values(report).some(v => v && typeof v === 'object' && v.ok === false) && requireAll) {
              core.setFailed("One or more requested agents are not assignable here. See report above.");
            }

      - name: Close temporary issue
        if: always()
        env:
          ISSUE_NUM: ${{ steps.tmp.outputs.num }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const num = Number(process.env.ISSUE_NUM || '0');
            if (num) {
              await github.rest.issues.update({ owner, repo, issue_number: num, state: 'closed' });
              core.info(`Temp issue #${num} closed`);
            }

      - name: Summary
        if: always()
        uses: actions/github-script@v7
        env:
          REPORT: ${{ steps.try.outputs.report }}
          INPUT_AGENTS: ${{ github.event.inputs.agents }}
          INPUT_REQUIRE_ALL: ${{ github.event.inputs.require_all }}
        with:
          script: |
            function parseAgents(raw) {
              return String(raw || '')
                .split(',')
                .map(s => s.trim().toLowerCase())
                .filter(Boolean);
            }

            let report = {};
            try {
              report = JSON.parse(process.env.REPORT || '{}');
            } catch (err) {
              core.warning(`Unable to parse report JSON: ${err.message || err}`);
              report = {};
            }

            const requestedAgents = parseAgents(process.env.INPUT_AGENTS || 'copilot,codex');
            const requireAll = String(process.env.INPUT_REQUIRE_ALL || 'true').toLowerCase() === 'true';

            const rows = [
              [
                { data: 'Agent', header: true },
                { data: 'Result', header: true },
                { data: 'Details', header: true, markdown: true },
              ],
            ];

            const seen = new Set();
            const fmtCode = value => `\`${value}\``;
            const detailLines = agent => {
              const entry = report[agent] || {};
              const lines = [];
              if (entry.used) lines.push(`Assigned as ${fmtCode(entry.used)}`);
              if (entry.candidates && entry.candidates.length) {
                lines.push(`Candidates: ${entry.candidates.map(fmtCode).join(', ')}`);
              }
              if (Array.isArray(entry.attempts) && entry.attempts.length) {
                const attempts = entry.attempts
                  .map(a => `${fmtCode(a.login)} (${a.ok ? 'ok' : 'fail'}:${a.status})`)
                  .join(', ');
                lines.push(`Attempts: ${attempts}`);
              }
              if (typeof entry.inSuggested === 'boolean') {
                lines.push(entry.inSuggested ? 'Listed in suggestedActors' : 'Not in suggestedActors');
              }
              if (entry.reason) lines.push(entry.reason);
              if (entry.message) lines.push(entry.message);
              return lines.length ? lines.join('<br/>') : '—';
            };

            const ordered = requestedAgents.length ? requestedAgents : Object.keys(report);
            for (const agent of ordered) {
              if (!agent) continue;
              seen.add(agent);
              const entry = report[agent] || {};
              rows.push([
                { data: agent },
                { data: entry.ok ? '✅ Ready' : '❌ Not ready' },
                { data: detailLines(agent), markdown: true },
              ]);
            }

            for (const agent of Object.keys(report)) {
              if (seen.has(agent)) continue;
              const entry = report[agent] || {};
              rows.push([
                { data: agent },
                { data: entry.ok ? '✅ Ready' : '❌ Not ready' },
                { data: detailLines(agent), markdown: true },
              ]);
            }

            core.info('=== Agent readiness report ===');
            for (const row of rows.slice(1)) {
              core.info(`${row[0].data}: ${row[1].data} — ${row[2].data.replace(/<br\/>/g, '; ')}`);
            }

            await core.summary
              .addHeading('Agent readiness results', 3)
              .addRaw(`**Requested agents:** ${requestedAgents.length ? requestedAgents.join(', ') : '_none_'}`)
              .addRaw('\n\n')
              .addRaw(`**require_all:** ${requireAll}`)
              .addRaw('\n\n')
              .addTable(rows)
              .write();
