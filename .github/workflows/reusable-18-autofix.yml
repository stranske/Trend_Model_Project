---
name: Reusable 18 Autofix

on:
  workflow_call:
    inputs:
      opt_in_label:
        description: 'Label to opt-in when PR is draft'
        required: false
        default: 'autofix'
        type: string
      commit_prefix:
        description: 'Commit message prefix'
        required: false
        default: 'chore(autofix):'
        type: string

permissions:
  contents: read
  pull-requests: read

concurrency:
  group: pr-02-autofix-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  autofix:
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest
    if: >-
      ${{ github.event_name == 'pull_request' &&
          github.actor != 'github-actions' &&
          github.actor != 'github-actions[bot]' &&
          !startsWith(github.event.pull_request.title, inputs.commit_prefix) &&
          ( !github.event.pull_request.draft || contains(github.event.pull_request.labels.*.name, inputs.opt_in_label) ) }}
    steps:
      - name: Set commit prefix env
        id: prefix
        run: echo "AUTOFIX_COMMIT_PREFIX=${{ inputs.commit_prefix }}" >> "$GITHUB_ENV"
      - name: Set sanitized PR head ref
        if: ${{ github.event_name == 'pull_request' }}
        env:
          RAW_HEAD_REF: ${{ github.event.pull_request.head.ref }}
        run: |
          set -euo pipefail
          echo "PR_HEAD_REF=${RAW_HEAD_REF}" >> "$GITHUB_ENV"
      - name: Checkout PR HEAD
        uses: actions/checkout@v4
        with:
          ref: ${{ env.PR_HEAD_REF || github.ref }}
          fetch-depth: 0
          persist-credentials: true
      - name: Guard against loops (Issue #1347)
        id: guard
        shell: bash
        run: |
          set -euo pipefail
          skip=false
          if [ "${{ github.actor }}" = "github-actions" ] || [ "${{ github.actor }}" = "github-actions[bot]" ]; then
            head_msg="$(git log -1 --pretty=%s 2>/dev/null || echo '')"
            head_msg_lc=$(printf '%s' "$head_msg" | tr '[:upper:]' '[:lower:]')
            prefix_lc=$(printf '%s' "${{ inputs.commit_prefix }}" | tr '[:upper:]' '[:lower:]')
            if [ -n "$prefix_lc" ]; then
              msg_prefix=$(printf '%.*s' "${#prefix_lc}" "$head_msg_lc")
              if [ "$msg_prefix" = "$prefix_lc" ]; then
                echo "[autofix] Skipping: detected prior autofix commit (${head_msg})"
                skip=true
              fi
            fi
          fi
          echo "skip=$skip" >> "$GITHUB_OUTPUT"
          if [ "$skip" = "true" ]; then
            exit 0
          fi

      - name: Detect same-repo PR
        if: steps.guard.outputs.skip != 'true'
        id: same_repo
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const same = pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`;
            core.setOutput('same', String(same));

      - name: Guard remove legacy autofix history file
        if: steps.guard.outputs.skip != 'true'
        shell: bash
        run: |
          if [ -f ci/autofix/history.json ]; then
            echo "[autofix-guard] Removing legacy tracked ci/autofix/history.json to prevent churn";
            git rm -f ci/autofix/history.json || rm -f ci/autofix/history.json || true;
          else
            echo "[autofix-guard] No legacy history.json present";
          fi

      - name: Ensure autofix label present
        if: steps.guard.outputs.skip != 'true' && steps.same_repo.outputs.same == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull request context; skipping label application.');
              return;
            }
            const label = "${{ inputs.opt_in_label }}";
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: [label],
              });
            } catch (error) {
              core.warning(`Failed to ensure autofix label: ${error.message}`);
            }

      - name: Install Ruff for safe sweep
        if: steps.guard.outputs.skip != 'true'
        shell: bash
        run: |
          set -euo pipefail
          pin_file=".github/workflows/autofix-versions.env"
          if [[ ! -f "${pin_file}" ]]; then
            echo "Missing ${pin_file}; unable to install Ruff for safe sweep." >&2
            exit 1
          fi
          # shellcheck disable=SC1090
          source "${pin_file}"
          if [[ -z "${RUFF_VERSION:-}" ]]; then
            echo "${pin_file} did not define RUFF_VERSION" >&2
            exit 1
          fi
          echo "RUFF_VERSION=${RUFF_VERSION}" >> "${GITHUB_ENV}"
          python3 -m pip install --upgrade --user "ruff==${RUFF_VERSION}"
          echo "${HOME}/.local/bin" >> "${GITHUB_PATH}"

      - name: Ruff safe autofix sweep
        if: steps.guard.outputs.skip != 'true'
        shell: bash
        run: |
          set -euo pipefail
          ruff --version
          ruff check --fix --exit-zero .

      - name: Autofix
        if: steps.guard.outputs.skip != 'true'
        id: autofix
        uses: ./.github/actions/autofix

      - name: Commit changes (same-repo)
        if: steps.guard.outputs.skip != 'true' && steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "${AUTOFIX_COMMIT_PREFIX} formatting/lint"
          echo "AUTOFIX_COMMIT_SHA=$(git rev-parse HEAD)" >> "$GITHUB_ENV"

      - name: Push changes (same-repo with rebase+retry)
        if: steps.guard.outputs.skip != 'true' && steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same == 'true'
        shell: bash
        run: |
          set -euo pipefail
          branch="${PR_HEAD_REF}"
          for attempt in 1 2 3; do
            echo "[autofix] Push attempt $attempt"
            if git push origin HEAD:"$branch"; then
              echo "[autofix] Push succeeded"
              exit 0
            fi
            echo "[autofix] Push failed - attempting rebase (attempt $attempt)"
            git fetch origin "$branch" --prune
            if git rebase --autostash --strategy-option theirs origin/"$branch"; then
              echo "[autofix] Rebase completed"
            else
              echo "[autofix] Rebase conflict; aborting rebase"; git rebase --abort || true
            fi
          done
          echo "[autofix] Failed to push after 3 attempts" >&2
          exit 1

      - name: Prepare commit summary (same-repo)
        if: steps.guard.outputs.skip != 'true' && steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same == 'true'
        env:
          SERVER_URL: ${{ github.server_url }}
          REPOSITORY: ${{ github.repository }}
          COMMIT_SHA: ${{ env.AUTOFIX_COMMIT_SHA }}
        shell: bash
        run: |
          if [ -n "$COMMIT_SHA" ]; then
            url="$SERVER_URL/$REPOSITORY/commit/$COMMIT_SHA"
            short_sha=$(printf '%.12s' "$COMMIT_SHA")
            {
              echo "AUTOFIX_RESULT_BLOCK<<'EOF'"
              echo "Autofix commit: [${short_sha}]($url)"
              echo "Labels: `autofix:applied`"
              echo "EOF"
            } >> "$GITHUB_ENV"
          fi

      - name: Create patch artifact (fork PR)
        if: steps.guard.outputs.skip != 'true' && steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same != 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "${AUTOFIX_COMMIT_PREFIX} formatting/lint (patch)" || true
          git format-patch -1 --stdout > autofix.patch

      - name: Upload patch artifact
        if: steps.guard.outputs.skip != 'true' && steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: autofix-patch-pr-${{ github.event.pull_request.number }}
          path: autofix.patch

      - name: Label PR (autofix patch available)
        if: steps.guard.outputs.skip != 'true' && steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull request context; skipping patch label.');
              return;
            }
            const baseLabel = "${{ inputs.opt_in_label }}";
            const labels = [baseLabel, 'autofix:patch'];
            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels,
              });
            } catch (error) {
              core.warning(`Failed to add autofix patch label: ${error.message}`);
            }


      - name: Prepare patch summary (fork PR)
        if: steps.guard.outputs.skip != 'true' && steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same != 'true'
        env:
          SERVER_URL: ${{ github.server_url }}
          REPOSITORY: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
        shell: bash
        run: |
          url="$SERVER_URL/$REPOSITORY/actions/runs/$RUN_ID#artifacts"
          name="autofix-patch-pr-$PR_NUMBER"
          {
            echo "AUTOFIX_RESULT_BLOCK<<'EOF'"
            echo "Patch ready: [${name}](${url})"
            echo "Labels: `autofix:patch`"
            echo ""
            echo "Apply locally:"
            echo "1. Download the artifact from the Actions run."
            echo "2. In your repository root, run:"
            echo "   git am < autofix.patch"
            echo "3. Push to your PR branch:"
            echo "   git push origin HEAD:${HEAD_REF}"
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Prepare no-change summary
        if: steps.guard.outputs.skip != 'true' && steps.autofix.outputs.changed != 'true'
        run: |
          {
            echo "AUTOFIX_RESULT_BLOCK<<'EOF'"
            echo "No changes required."
            echo "Labels: `autofix:clean`"
            echo "EOF"
          } >> "$GITHUB_ENV"

      - name: Manage autofix outcome labels
        if: steps.guard.outputs.skip != 'true'
        uses: actions/github-script@v7
        env:
          AUTO_CHANGED: ${{ steps.autofix.outputs.changed }}
          SAME_REPO: ${{ steps.same_repo.outputs.same }}
          REMAINING_ISSUES: ${{ steps.autofix.outputs.remaining_issues }}
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull request context; skipping outcome labels.');
              return;
            }
            const changed = (process.env.AUTO_CHANGED || '').toLowerCase() === 'true';
            const sameRepo = (process.env.SAME_REPO || '').toLowerCase() === 'true';
            const remaining = Number.parseInt(process.env.REMAINING_ISSUES || '0', 10) || 0;
            const appliedLabel = 'autofix:applied';
            const cleanLabel = 'autofix:clean';
            const debtLabel = 'autofix:debt';
            const patchLabel = 'autofix:patch';

            async function addLabel(label) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  labels: [label],
                });
              } catch (error) {
                core.warning(`Failed to add ${label}: ${error.message}`);
              }
            }

            async function removeLabel(label) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: pr.number,
                  name: label,
                });
              } catch (error) {
                if (error.status !== 404) {
                  core.warning(`Failed to remove ${label}: ${error.message}`);
                }
              }
            }

            const desired = new Set();
            if (remaining > 0) {
              desired.add(debtLabel);
            }
            if (!changed && remaining === 0) {
              desired.add(cleanLabel);
            }
            if (changed && sameRepo) {
              desired.add(appliedLabel);
            }
            if (changed && !sameRepo) {
              desired.add(patchLabel);
            }

            for (const label of desired) {
              await addLabel(label);
            }

            const managed = [appliedLabel, cleanLabel, debtLabel, patchLabel];
            for (const label of managed) {
              if (!desired.has(label)) {
                await removeLabel(label);
              }
            }

      - name: Restore prior autofix history artifact (same-repo)
        if: steps.guard.outputs.skip != 'true' && steps.same_repo.outputs.same == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_TOKEN: ${{ github.token }}
          TARGET_REPO: ${{ github.repository }}
          TARGET_RUN_ID: ${{ github.run_id }}
          TARGET_PR: ${{ github.event.pull_request.number }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ci/autofix
          rm -f ci/autofix/history.json
          artifact_name="autofix-history-pr-${TARGET_PR}"
          echo "[history] Attempting to restore ${artifact_name} from previous runs"
          set +e
          response=$(gh api "repos/${TARGET_REPO}/actions/artifacts" --paginate)
          status=$?
          set -e
          if [ $status -ne 0 ] || [ -z "$response" ]; then
            echo "[history] No prior artifact found"
            exit 0
          fi
          artifact_lines=$(printf '%s' "$response" | jq -r --arg name "$artifact_name" --arg run "${TARGET_RUN_ID}" '.artifacts[]? | select(.name==$name and .expired==false and (.workflow_run.id|tostring)!=$run) | [.id, .created_at] | @tsv')
          if [ -z "$artifact_lines" ]; then
            echo "[history] No prior artifact found"
            exit 0
          fi
          latest=$(printf '%s\n' "$artifact_lines" | sort -k2 | tail -n1)
          artifact_id=${latest%%$'\t'*}
          tmpdir=$(mktemp -d)
          echo "[history] Downloading artifact id ${artifact_id}"
          if ! gh api "repos/${TARGET_REPO}/actions/artifacts/${artifact_id}/zip" >"$tmpdir/artifact.zip"; then
            echo "[history] Failed to download artifact ${artifact_id}"
            exit 0
          fi
          target_tmp="$tmpdir/history.json"
          if unzip -p "$tmpdir/artifact.zip" ci/autofix/history.json > "$target_tmp" 2>/dev/null; then
            mv "$target_tmp" ci/autofix/history.json
            echo "[history] Restored previous history.json"
          else
            echo "[history] Artifact ${artifact_id} did not contain ci/autofix/history.json"
            rm -f ci/autofix/history.json
          fi
          rm -rf "$tmpdir"

      - name: Update residual history (same-repo)
        if: steps.guard.outputs.skip != 'true' && steps.same_repo.outputs.same == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f autofix_report_enriched.json ]; then echo "[history] missing enriched report"; exit 0; fi
          python scripts/update_residual_history.py || echo "[history] update failed"
          # No longer committing history.json (noise in PRs). It will be uploaded as an artifact instead.
          if [ -f ci/autofix/history.json ] && [ -s ci/autofix/history.json ] && jq empty ci/autofix/history.json >/dev/null 2>&1; then
            echo "[history] Prepared updated history.json (artifact-only mode)"
          else
            echo "[history] history.json not produced or invalid"
          fi

      - name: Upload autofix history artifact (same-repo)
        if: steps.guard.outputs.skip != 'true' && steps.same_repo.outputs.same == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: autofix-history-pr-${{ github.event.pull_request.number }}
          path: ci/autofix/history.json
          if-no-files-found: ignore

      - name: Generate trend sparkline (same-repo)
        if: steps.guard.outputs.skip != 'true' && steps.same_repo.outputs.same == 'true'
        shell: bash
        run: |
          if [ -f scripts/generate_residual_trend.py ]; then python scripts/generate_residual_trend.py || true; fi
          if [ -f ci/autofix/trend.json ]; then echo "Trend:"; cat ci/autofix/trend.json; fi

      - name: Build consolidated PR comment
        if: steps.guard.outputs.skip != 'true'
        uses: ./.github/actions/build-pr-comment
        with:
          output: autofix_pr_comment.md
          pr-number: ${{ github.event.pull_request.number }}

      - name: Upsert consolidated PR comment
        if: steps.guard.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const marker = '<!-- autofix-status: DO NOT EDIT -->';
            const body = fs.readFileSync('autofix_pr_comment.md', 'utf8');
            const pr = context.payload.pull_request;
            // Fetch existing comments once (first 100 is ample for typical PRs)
            const comments = await github.paginate(github.rest.issues.listComments, { owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, per_page: 100 });
            const existing = comments.find(c => c.body && c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: existing.id, body });
              console.log('Updated existing autofix status comment.');
            } else {
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body });
              console.log('Created new autofix status comment.');
            }

      - name: Regression detector (same-repo)
        if: steps.guard.outputs.skip != 'true' && steps.same_repo.outputs.same == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let hist=[]; try { hist = JSON.parse(fs.readFileSync('ci/autofix/history.json','utf8')); } catch(e) {}
            if (!Array.isArray(hist) || hist.length < 5) { return; }
            const last = hist.slice(-1)[0];
            const prev = hist.slice(-6,-1); // previous 5 points
            const avgPrev = prev.reduce((a,b)=>a+(b.remaining||0),0)/prev.length;
            const spike = avgPrev > 0 ? (last.remaining - avgPrev)/avgPrev : 0;
            const THRESH = 0.35; // 35% jump threshold
            if (spike <= THRESH) return;
            const issueTitle = 'lint regression: residual spike';
            // Check for existing open issue
            const issues = await github.rest.issues.listForRepo({ owner: context.repo.owner, repo: context.repo.repo, state:'open', labels:'autofix:regression' });
            if (issues.data.some(i => i.title === issueTitle)) return;
            const body = [
              'Detected residual lint spike exceeding threshold.',
              `Latest remaining: ${last.remaining}`,
              `Previous avg (5 runs): ${avgPrev.toFixed(2)}`,
              `Relative increase: ${(spike*100).toFixed(1)}%`,
              '',
              'Action items:',
              '- Investigate new codes in last run classification',
              '- Consider targeted fixes or allowlist pruning',
              '',
              'This issue was auto-generated.'
            ].join('\n');
            await github.rest.issues.create({ owner: context.repo.owner, repo: context.repo.repo, title: issueTitle, body, labels:['autofix:regression'] });

      - name: Emit JSON report (same-repo)
        if: steps.guard.outputs.skip != 'true' && steps.same_repo.outputs.same == 'true'
        shell: bash
        run: |
          set -euo pipefail
          ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          if [ -f autofix_report_enriched.json ]; then
            python -c "import json,os;from datetime import datetime,timezone as TZ;meta={'pull_request':os.environ.get('PR_NUMBER'),'timestamp_utc':datetime.now(TZ.utc).strftime('%Y-%m-%dT%H:%M:%SZ')};\nimport pathlib;\ntry: data=json.load(open('autofix_report_enriched.json'));\nexcept Exception: data={};data.update(meta);json.dump(data, open('autofix_report.json','w'), indent=2, sort_keys=True)" || echo '{"error":"merge_failed"}' > autofix_report.json
          else
            printf '{\n  "changed": "%s",\n  "remaining_issues": "%s",\n  "new_issues": "%s",\n  "pull_request": "%s",\n  "timestamp_utc": "%s"\n}\n' \
              "${{ steps.autofix.outputs.changed }}" \
              "${{ steps.autofix.outputs.remaining_issues }}" \
              "${{ steps.autofix.outputs.new_issues }}" \
              "${{ github.event.pull_request.number }}" \
              "$ts" > autofix_report.json
          fi
          echo "Enriched report ready.";
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}

      - name: Upload JSON report
        if: steps.guard.outputs.skip != 'true' && steps.same_repo.outputs.same == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: autofix-report-pr-${{ github.event.pull_request.number }}
          path: autofix_report.json

      - name: Summary
        if: always()
        run: |
          {
            echo "### Reusable Autofix Summary"
            echo "Loop guard skip: ${{ steps.guard.outputs.skip || 'false' }}"
            echo "Applied changes: ${{ steps.autofix.outputs.changed }}"
            echo "Same repo: ${{ steps.same_repo.outputs.same }}"
            echo "Remaining ruff issues: ${{ steps.autofix.outputs.remaining_issues }}"
            echo "New (non-allowlisted) ruff issues: ${{ steps.autofix.outputs.new_issues }}"
            if [ "${{ steps.autofix.outputs.changed }}" = "true" ] && [ "${{ steps.same_repo.outputs.same }}" != "true" ]; then
              echo "Patch artifact: autofix-patch-pr-${{ github.event.pull_request.number }}"
            fi
          } >> "$GITHUB_STEP_SUMMARY"
