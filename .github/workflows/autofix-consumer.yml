name: Autofix (Consumer)

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled]
    branches: [phase-2-dev, main]

permissions:
  contents: write
  pull-requests: write

jobs:
  guard:
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.guard.outputs.skip }}
    steps:
      - name: Guard against loops
        id: guard
        uses: actions/github-script@v7
        with:
          script: |
            const prefix = process.env.COMMIT_PREFIX || 'chore(autofix):';
            const actor = (context.actor || '').toLowerCase();
            const isActionsActor = actor === 'github-actions' || actor === 'github-actions[bot]';
            if (!isActionsActor) {
              core.setOutput('skip', 'false');
              return;
            }

            const sha = context.payload.pull_request?.head?.sha;
            if (!sha) {
              core.warning('Guard: pull_request.head.sha missing; continuing.');
              core.setOutput('skip', 'false');
              return;
            }

            try {
              const commit = await github.rest.repos.getCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: sha,
              });
              const message = commit.data.commit.message.split('\n')[0];
              if (message.startsWith(prefix)) {
                core.info('Skipping: autofix commit detected');
                core.setOutput('skip', 'true');
                return;
              }
            } catch (error) {
              core.warning(`Guard: failed to inspect commit message (${error.message}).`);
            }

            core.setOutput('skip', 'false');
        env:
          COMMIT_PREFIX: 'chore(autofix):'

  call-reusable:
    needs: guard
    if: ${{ needs.guard.outputs.skip != 'true' }}
    uses: ./.github/workflows/reuse-autofix.yml
    with:
      opt_in_label: ${{ vars.AUTOFIX_OPT_IN_LABEL || 'autofix' }}
      commit_prefix: 'chore(autofix):'
  label-applied:
    needs: [guard, call-reusable]
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' && needs.guard.outputs.skip != 'true' }}
    steps:
      - name: Checkout PR HEAD
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
      - name: Check latest commit message for autofix
        id: msg
        run: |
          git fetch --depth=2 origin ${{ github.event.pull_request.head.ref }}
          git checkout FETCH_HEAD
          msg=$(git log -1 --pretty=%B | tr -d '\r')
          echo "message<<END" >> $GITHUB_OUTPUT
          echo "$msg" >> $GITHUB_OUTPUT
          echo "END" >> $GITHUB_OUTPUT
          if echo "$msg" | grep -q '^chore(autofix):'; then echo "applied=true" >> $GITHUB_OUTPUT; else echo "applied=false" >> $GITHUB_OUTPUT; fi
      - name: Add label
        if: steps.msg.outputs.applied == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const label = process.env.APPLIED_LABEL || 'autofix:applied';
            const pr = context.payload.pull_request.number;
            try {
              await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr, labels: [label] });
            } catch (e) { core.warning('Could not add label: ' + e.message); }
        env:
          APPLIED_LABEL: ${{ vars.AUTOFIX_APPLIED_LABEL || 'autofix:applied' }}
