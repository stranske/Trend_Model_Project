name: Reusable 16 Agents

on:
  workflow_call:
    inputs:
      enable_readiness:
        description: 'Run agent readiness (assignability) probe (true/false)'
        required: false
        default: 'false'
        type: string
      readiness_agents:
        description: 'Comma-separated agent keys (copilot,codex)'
        required: false
        default: 'copilot,codex'
        type: string
      readiness_custom_logins:
        description: 'Comma-separated additional raw bot logins (exact usernames)'
        required: false
        default: ''
        type: string
      require_all:
        description: 'Fail readiness job if any requested agent/custom login not assignable (true/false)'
        required: false
        default: 'false'
        type: string
      enable_preflight:
        description: 'Run codex preflight probe (true/false)'
        required: false
        default: 'false'
        type: string
      codex_user:
        description: 'Codex connector login override'
        required: false
        default: ''
        type: string
      codex_command_phrase:
        description: 'Command phrase to post for Codex'
        required: false
        default: ''
        type: string
      enable_diagnostic:
        description: 'Run bootstrap diagnostic job (true/false)'
        required: false
        default: 'false'
        type: string
      diagnostic_attempt_branch:
        description: 'Attempt branch create in diagnostic (true/false)'
        required: false
        default: 'false'
        type: string
      diagnostic_dry_run:
        description: 'Diagnostic dry run (true/false)'
        required: false
        default: 'true'
        type: string
      enable_verify_issue:
        description: 'Verify a specific issue has an agent assignee (true/false)'
        required: false
        default: 'false'
        type: string
      verify_issue_number:
        description: 'Issue number to verify when enable_verify_issue=true'
        required: false
        default: ''
        type: string
      verify_issue_valid_assignees:
        description: 'Comma-separated list of acceptable agent logins for verification'
        required: false
        default: 'copilot,chatgpt-codex-connector,stranske-automation-bot'
        type: string
      enable_watchdog:
        description: 'Run watchdog checks (true/false)'
        required: false
        default: 'true'
        type: string
      enable_keepalive:
        description: 'Run Codex keepalive sweeps (true/false)'
        required: false
        default: 'true'
        type: string
      enable_bootstrap:
        description: 'Run Codex bootstrap job (true/false)'
        required: false
        default: 'false'
        type: string
      bootstrap_issues_label:
        description: 'Label to trigger Codex bootstrap'
        required: false
        default: 'agent:codex'
        type: string
      draft_pr:
        description: 'Open bootstrap PRs as draft (true/false)'
        required: false
        default: 'false'
        type: string
      options_json:
        description: 'JSON configuration for optional automation (keepalive sweep, etc)'
        required: false
        default: '{}'
        type: string
    secrets:
      service_bot_pat:
        required: false
    outputs:
      readiness_report:
        description: 'JSON report emitted by the readiness probe when enabled'
        value: ${{ jobs.readiness.outputs.report_json }}
      readiness_table:
        description: 'Markdown table emitted by the readiness probe when enabled'
        value: ${{ jobs.readiness.outputs.table_md }}

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  readiness:
    if: inputs.enable_readiness == 'true'
    name: Agent Readiness Probe
    runs-on: ubuntu-latest
    timeout-minutes: 15
    outputs:
      report_json: ${{ steps.try.outputs.report || '{}' }}
      table_md: ${{ steps.try.outputs.table || '' }}
    permissions:
      contents: read
      issues: write
    steps:
      - name: Probe assignable actors
        id: gql
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const q = `query($owner:String!, $repo:String!) { repository(owner:$owner, name:$repo) { suggestedActors(capabilities:[CAN_BE_ASSIGNED], first:100) { nodes { login } } } }`;
            const res = await github.graphql(q, { owner, repo });
            const actors = (res.repository?.suggestedActors?.nodes || []).map(n => (n.login || '').toLowerCase());
            core.setOutput('actors', JSON.stringify(actors));
      - name: Create temp issue
        id: tmp
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const { data: issue } = await github.rest.issues.create({ owner, repo, title: '[readiness] probe', body: 'temp' });
            core.setOutput('num', String(issue.number));
      - name: Try agent assignment
        id: try
        env:
          ACTORS_JSON: ${{ steps.gql.outputs.actors }}
          AGENTS_REQ: ${{ inputs.readiness_agents }}
          CUSTOM_LOGINS: ${{ inputs.readiness_custom_logins }}
          REQUIRE_ALL: ${{ inputs.require_all }}
        uses: actions/github-script@v7
        with:
          script: |
            const num = Number(core.getInput('issue_number') || process.env.ISSUE_NUM || '${{ steps.tmp.outputs.num }}');
            const actors = JSON.parse(process.env.ACTORS_JSON || '[]');
            const requested = (process.env.AGENTS_REQ || 'copilot,codex').split(',').map(s=>s.trim()).filter(Boolean);
            const custom = (process.env.CUSTOM_LOGINS || '').split(',').map(s=>s.trim()).filter(Boolean);
            const CANDIDATES = {
              copilot: ['copilot','copilot-swe-agent'],
              codex: ['chatgpt-codex-connector']
            };
            const rows = [];
            const report = {};
            // Handle keyed agents
            for (const key of requested) {
              const cands = CANDIDATES[key]||[];
              let ok=false, used='';
              for (const c of cands) { if (actors.includes(c)) { ok=true; used=c; break; } }
              report[key]={ok, used};
              rows.push({ label:key, type:'builtin', requested:true, ok, used });
            }
            // Handle custom explicit logins (exact matches)
            for (const login of custom) {
              const ok = actors.includes(login.toLowerCase());
              report[`custom:${login}`] = { ok, used: ok ? login.toLowerCase(): '' };
              rows.push({ label:login.toLowerCase(), type:'custom', requested:true, ok, used: ok? login.toLowerCase(): '' });
            }
            // Build markdown table
            const header = '| Agent | Kind | Requested | Assignable | Resolved Login |';
            const sep = '|-------|------|-----------|-----------|---------------|';
            const mdRows = rows.map(r => `| ${r.label} | ${r.type} | yes | ${r.ok? '':''} | ${r.used} |`);
            const table = [header, sep, ...mdRows].join('\n');
            core.setOutput('report', JSON.stringify(report));
            core.setOutput('table', table);
            const requireAll = (process.env.REQUIRE_ALL||'false').toLowerCase()==='true';
            if (requireAll) {
              const missing = rows.filter(r=>!r.ok).map(r=>r.label);
              if (missing.length) {
                core.setFailed('Missing assignable agents: '+missing.join(', '));
              }
            }
      - name: Close temp
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo; await github.rest.issues.update({ owner, repo, issue_number: Number('${{ steps.tmp.outputs.num }}'), state: 'closed' });
      - name: Summary
        if: always()
        run: |
          {
            printf '### Agent Readiness Report %s\n' "${{ steps.try.outcome == 'failure' && '' || '' }}"
            printf '\n```json\n'
            printf '%s\n' "${{ steps.try.outputs.report }}"
            printf '```\n\n'
            printf '%s\n\n' "${{ steps.try.outputs.table }}"
            printf 'Require all: %s\n' "${{ inputs.require_all }}"
            printf 'Custom logins: %s\n' "${{ inputs.readiness_custom_logins }}"
            printf 'Overall: %s\n' "${{ steps.try.outcome == 'failure' && 'failure (missing required agents)' || 'success' }}"
          } >>"$GITHUB_STEP_SUMMARY"

  preflight:
    if: inputs.enable_preflight == 'true'
    name: Codex Preflight
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Preflight probe
        uses: actions/github-script@v7
        env:
          CODEX_USER: ${{ inputs.codex_user }}
          CODEX_COMMAND: ${{ inputs.codex_command_phrase }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const user = process.env.CODEX_USER;
            if (!user) { core.warning('No CODEX_USER provided'); return; }
            const { data: issue } = await github.rest.issues.create({ owner, repo, title: '[probe] codex-assignability', body: 'temp' });
            try { await github.rest.issues.addAssignees({ owner, repo, issue_number: issue.number, assignees: [user] }); core.info('Assignable'); }
            catch (e) { core.warning('Not assignable: '+e.message); }
            if (process.env.CODEX_COMMAND) { await github.rest.issues.createComment({ owner, repo, issue_number: issue.number, body: process.env.CODEX_COMMAND }); }
            await github.rest.issues.update({ owner, repo, issue_number: issue.number, state: 'closed' });

  diagnostic:
    if: inputs.enable_diagnostic == 'true'
    name: Bootstrap Diagnostic
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4
      - name: Token / Env Probe
        shell: bash
        env:
          DRY_RUN: ${{ inputs.diagnostic_dry_run }}
          ATTEMPT: ${{ inputs.diagnostic_attempt_branch }}
        run: |
          set -euo pipefail
          echo "Diagnostic dry_run=$DRY_RUN attempt_branch=$ATTEMPT"
          echo "Tokens present: GITHUB_TOKEN=${GITHUB_TOKEN:+yes} SERVICE_BOT_PAT=${SERVICE_BOT_PAT:+yes}"
      - name: Attempt branch create
        if: inputs.diagnostic_attempt_branch == 'true'
        shell: bash
        run: |
          set -euo pipefail
          base=$(git rev-parse HEAD)
            ts=$(date -u +%Y%m%d%H%M%S)
            target="diagnostic/codex-${ts}"
            echo "Creating $target from $base"
            curl -s -o /tmp/create.json -w '%{http_code}' -X POST \
              -H "Authorization: Bearer ${GITHUB_TOKEN}" \
              -H 'Accept: application/vnd.github+json' \
              https://api.github.com/repos/${{ github.repository }}/git/refs \
              -d '{"ref":"refs/heads/'"$target"'","sha":"'"$base"'"}' || true

  verify_issue:
    if: inputs.enable_verify_issue == 'true' && inputs.verify_issue_number != ''
    uses: ./.github/workflows/agents-64-verify-agent-assignment.yml
    secrets: inherit
    with:
      issue_number: ${{ inputs.verify_issue_number }}
      valid_assignees: ${{ inputs.verify_issue_valid_assignees }}

  verify_issue_summary:
    name: Publish Verify Issue Summary
    needs:
      - verify_issue
    if: ${{ always() && needs.verify_issue.result != 'skipped' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Append verify assignment results
        uses: actions/github-script@v7
        env:
          STATUS: ${{ needs.verify_issue.outputs.status || '' }}
          MESSAGE: ${{ needs.verify_issue.outputs.message || '' }}
          SUMMARY_TABLE: ${{ needs.verify_issue.outputs.summary_table || '' }}
          MATCHED: ${{ needs.verify_issue.outputs.matched_assignee || '' }}
          HAS_LABEL: ${{ needs.verify_issue.outputs.has_label || '' }}
          ISSUE_URL: ${{ needs.verify_issue.outputs.issue_url || '' }}
        with:
          script: |
            const rawStatus = (process.env.STATUS || 'unknown').trim();
            const status = rawStatus.toLowerCase();
            const message = process.env.MESSAGE || '';
            const table = process.env.SUMMARY_TABLE || '';
            const matched = process.env.MATCHED || '';
            const hasLabel = (process.env.HAS_LABEL || '').trim() || 'unknown';
            const issueUrl = process.env.ISSUE_URL || '';

            const issueNumber = (() => {
              const match = issueUrl.match(/\/issues\/(\d+)(?:$|\D)/);
              return match ? `#${match[1]}` : (issueUrl || '—');
            })();

            const matchedCell = matched ? `\`${matched}\`` : '_none_';

            core.info(`Verify issue status: ${status || 'unknown'}`);
            core.info(`Issue reference: ${issueNumber}`);
            core.info(`Has agent:codex label: ${hasLabel}`);
            if (matched) {
              core.info(`Matched assignee: ${matched}`);
            }

            const summary = core.summary;
            summary.addHeading('Agent Assignment Verification', 2);

            if (table.trim()) {
              summary.addRaw(table, true).addEOL();
            } else {
              const linkCell = issueUrl ? `[${issueNumber}](${issueUrl})` : '—';
              summary.addTable([
                [{ data: 'Issue', header: true }, { data: 'Has agent:codex', header: true }, { data: 'Matched assignee', header: true }, { data: 'Status', header: true }],
                [linkCell, hasLabel, matchedCell, rawStatus || 'unknown']
              ]);
            }

            if (issueUrl) {
              summary.addLink('Inspect issue', issueUrl).addEOL();
            }

            if (message) {
              summary.addRaw(message).addEOL();
            }

            summary.addList([
              `Status: **${rawStatus || 'unknown'}**`,
              `Has agent:codex label: ${hasLabel}`,
              `Matched assignee: ${matchedCell}`
            ]);

            await summary.write();

            if (status === 'pass') {
              core.notice(message || 'Agent assignment verification passed.');
            } else if (status === 'skipped') {
              core.notice(message || 'Agent assignment verification skipped.');
            } else if (status === 'fail') {
              core.warning(message || 'Agent assignment verification reported a failure.');
            } else {
              core.info(message || 'Agent assignment verification completed with status unavailable.');
            }

  bootstrap-codex:
    if: inputs.enable_bootstrap == 'true'
    name: Bootstrap Codex PRs
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
      - name: Find Ready Issues
        id: ready
        uses: actions/github-script@v7
        env:
          LABEL: ${{ inputs.bootstrap_issues_label }}
        with:
          script: |
            const summary = core.summary;
            summary.addHeading('Codex Bootstrap', 2);

            const raw = process.env.LABEL || '';
            const labels = raw
              .split(',')
              .map((value) => value.trim())
              .filter(Boolean);

            if (!labels.length) {
              const message = 'bootstrap_issues_label input must be set to a non-empty label.';
              core.setFailed(message);
              summary.addRaw(message).addEOL();
              await summary.write();
              core.setOutput('issue_numbers', '');
              core.setOutput('issue_numbers_json', '[]');
              core.setOutput('first_issue', '');
              return;
            }

            if (labels.length > 1) {
              const message =
                'bootstrap_issues_label input must define exactly one label to avoid sweeping unintended issues.';
              core.setFailed(message);
              summary.addRaw(message).addEOL();
              await summary.write();
              core.setOutput('issue_numbers', '');
              core.setOutput('issue_numbers_json', '[]');
              core.setOutput('first_issue', '');
              return;
            }

            const label = labels[0];
            const labelLower = label.toLowerCase();

            summary.addRaw(`Bootstrap label: **${label}**`).addEOL();

            const skipped = [];
            const accepted = [];
            const logSkip = (issue, reason) => {
              const message = `#${issue.number}: skipped – ${reason}`;
              core.info(message);
              skipped.push(message);
            };

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const { data: issues } = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: label,
              per_page: 30
            });

            for (const issue of issues) {
              if (issue.pull_request) {
                logSkip(issue, 'pull request detected');
                continue;
              }

              const labelNames = (issue.labels || [])
                .map((entry) => (typeof entry === 'string' ? entry : entry?.name || '').toLowerCase())
                .filter(Boolean);
              if (!labelNames.includes(labelLower)) {
                logSkip(issue, `missing required label ${label}`);
                continue;
              }

              if ((issue.title || '').toLowerCase().includes('wip')) {
                logSkip(issue, 'title flagged as work-in-progress');
                continue;
              }

              accepted.push(issue);
            }

            if (accepted.length) {
              const formatIssue = (issue) => {
                const title = (issue.title || 'untitled').trim();
                const number = issue.number;
                return (
                  '[#' +
                  number +
                  '](https://github.com/' +
                  owner +
                  '/' +
                  repo +
                  '/issues/' +
                  number +
                  ') – ' +
                  title
                );
              };

              summary.addList(accepted.map((issue) => formatIssue(issue)));
            } else {
              summary.addRaw('No eligible issues found.').addEOL();
            }

            summary.addDetails('Skipped issues', skipped.length ? skipped : ['None']);
            summary.addList([
              `Accepted issues: ${accepted.length}`,
              `Skipped issues: ${skipped.length}`
            ]);
            await summary.write();

            const numbers = accepted.map((issue) => issue.number);
            core.setOutput('issue_numbers', numbers.join(','));
            core.setOutput('issue_numbers_json', JSON.stringify(numbers));
            core.setOutput('first_issue', numbers.length ? String(numbers[0]) : '');
      - name: Bootstrap First Issue (if any)
        if: steps.ready.outputs.first_issue != ''
        uses: ./.github/actions/codex-bootstrap-lite
        with:
          issue: ${{ fromJson(steps.ready.outputs.issue_numbers_json)[0] }}
          service_bot_pat: ${{ secrets.service_bot_pat || '' }}
          draft: ${{ inputs.draft_pr }}

  watchdog:
    if: inputs.enable_watchdog == 'true'
    name: Agent Watchdog
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - uses: actions/checkout@v4
      - name: Basic Repo Sanity
        run: |
          test -f pyproject.toml || { echo 'pyproject.toml missing'; exit 1; }
          echo 'Repository baseline OK.'

  keepalive:
    name: Codex Keepalive Sweep
    runs-on: ubuntu-latest
    if: ${{ always() && inputs.enable_keepalive == 'true' }}
    timeout-minutes: 25
    steps:
      - name: Resume Codex on unattended checklists
        uses: actions/github-script@v7
        env:
          OPTIONS_JSON: ${{ inputs.options_json }}
        with:
          github-token: ${{ secrets.service_bot_pat || github.token }}
          script: |
            const parseJson = (raw, fallback) => {
              if (!raw || typeof raw !== 'string') {
                return fallback;
              }
              try {
                return JSON.parse(raw);
              } catch (error) {
                core.warning(`Invalid options_json supplied to keepalive: ${error.message}`);
                return fallback;
              }
            };

            const coerceBool = (value, fallback) => {
              if (typeof value === 'boolean') {
                return value;
              }
              if (typeof value === 'string') {
                const normalized = value.trim().toLowerCase();
                if (normalized === 'true') {
                  return true;
                }
                if (normalized === 'false') {
                  return false;
                }
              }
              return fallback;
            };

            const coerceNumber = (value, fallback, { min } = { min: 0 }) => {
              if (value === null || value === undefined) {
                return fallback;
              }
              const num = Number(value);
              if (!Number.isFinite(num) || num <= (min ?? 0)) {
                return fallback;
              }
              return num;
            };

            const rawOptions = process.env.OPTIONS_JSON || '{}';
            const options = parseJson(rawOptions, {});
            const summary = core.summary;

            const keepaliveEnabled = coerceBool(
              options.enable_keepalive ?? options.keepalive_enabled,
              true
            );
            if (!keepaliveEnabled) {
              core.info('Codex keepalive disabled via options_json.');
              summary.addHeading('Codex Keepalive');
              summary.addRaw('Skip requested via options_json.');
              await summary.write();
              return;
            }

            const idleMinutes = coerceNumber(options.keepalive_idle_minutes, 10, { min: 0 });
            const repeatMinutes = coerceNumber(options.keepalive_repeat_minutes, 30, { min: 0 });

            const labelSource = options.keepalive_labels ?? options.keepalive_label ?? 'agent:codex';
            const targetLabels = Array.from(
              new Set(
                String(labelSource)
                  .split(',')
                  .map((value) => value.trim().toLowerCase())
                  .filter(Boolean)
              )
            );
            if (!targetLabels.length) {
              targetLabels.push('agent:codex');
            }

            const commandRaw = options.keepalive_command ?? '@codex plan-and-execute';
            const command = String(commandRaw).trim() || '@codex plan-and-execute';
            const commandLower = command.toLowerCase();

            const markerRaw = options.keepalive_marker ?? '<!-- codex-keepalive -->';
            const marker = String(markerRaw);

            const agentSource = options.keepalive_agent_logins ?? 'chatgpt-codex-connector';
            const agentLogins = Array.from(
              new Set(
                String(agentSource)
                  .split(',')
                  .map((value) => value.trim().toLowerCase())
                  .filter(Boolean)
              )
            );
            if (!agentLogins.length) {
              agentLogins.push('chatgpt-codex-connector');
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const now = Date.now();
            const triggered = [];
            summary.addHeading('Codex Keepalive');
            summary
              .addRaw(`Target labels: ${targetLabels.map((label) => `**${label}**`).join(', ')}`)
              .addEOL();
            summary
              .addRaw(`Agent logins: ${agentLogins.map((login) => `**${login}**`).join(', ')}`)
              .addEOL();

            const paginatePulls = github.paginate.iterator(
              github.rest.pulls.list,
              { owner, repo, state: 'open', per_page: 50 }
            );

            for await (const page of paginatePulls) {
              for (const pr of page.data) {
                const labelNames = (pr.labels || []).map((label) =>
                  (typeof label === 'string' ? label : label?.name || '').toLowerCase()
                );
                const hasTargetLabel = targetLabels.some((label) => labelNames.includes(label));
                if (!hasTargetLabel) {
                  core.info(`#${pr.number}: skipped – missing required label (${targetLabels.join(', ')}).`);
                  continue;
                }

                const prNumber = pr.number;
                const { data: comments } = await github.rest.issues.listComments({
                  owner,
                  repo,
                  issue_number: prNumber,
                  per_page: 100,
                });
                if (!comments.length) {
                  core.info(`#${prNumber}: skipped – no timeline comments.`);
                  continue;
                }

                const commandComments = comments
                  .filter((comment) => (comment.body || '').toLowerCase().includes(commandLower))
                  .sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
                if (!commandComments.length) {
                  core.info(`#${prNumber}: skipped – no ${command} command yet.`);
                  continue;
                }

                const botComments = comments
                  .filter((comment) => agentLogins.includes((comment.user?.login || '').toLowerCase()))
                  .sort((a, b) => new Date(a.updated_at || a.created_at) - new Date(b.updated_at || b.created_at));
                if (!botComments.length) {
                  core.info(`#${prNumber}: skipped – Codex has not commented yet.`);
                  continue;
                }

                const lastAgentComment = botComments[botComments.length - 1];
                const lastAgentTs = new Date(lastAgentComment.updated_at || lastAgentComment.created_at).getTime();
                if (!Number.isFinite(lastAgentTs)) {
                  core.info(`#${prNumber}: skipped – unable to parse Codex timestamp.`);
                  continue;
                }

                const minutesSinceAgent = (now - lastAgentTs) / 60000;
                if (minutesSinceAgent < idleMinutes) {
                  core.info(`#${prNumber}: skipped – last Codex activity ${minutesSinceAgent.toFixed(1)} minutes ago (< ${idleMinutes}).`);
                  continue;
                }

                const latestCommandTs = new Date(commandComments[commandComments.length - 1].created_at).getTime();
                if (latestCommandTs > lastAgentTs) {
                  core.info(`#${prNumber}: skipped – waiting for Codex response to the latest command.`);
                  continue;
                }

                const checklistComments = botComments
                  .map((comment) => {
                    const body = comment.body || '';
                    const unchecked = (body.match(/- \[ \]/g) || []).length;
                    const checked = (body.match(/- \[x\]/gi) || []).length;
                    const total = unchecked + checked;
                    return { comment, unchecked, total };
                  })
                  .filter((entry) => entry.total > 0 && entry.unchecked > 0)
                  .sort((a, b) => new Date(b.comment.updated_at || b.comment.created_at) - new Date(a.comment.updated_at || a.comment.created_at));

                if (!checklistComments.length) {
                  core.info(`#${prNumber}: skipped – no Codex checklist with outstanding tasks.`);
                  continue;
                }

                const keepaliveComments = comments
                  .filter((comment) => (comment.body || '').includes(marker))
                  .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                if (keepaliveComments.length) {
                  const lastKeepaliveTs = new Date(keepaliveComments[0].created_at).getTime();
                  const minutesSinceKeepalive = (now - lastKeepaliveTs) / 60000;
                  if (minutesSinceKeepalive < repeatMinutes) {
                    core.info(`#${prNumber}: skipped – keepalive sent ${minutesSinceKeepalive.toFixed(1)} minutes ago (< ${repeatMinutes}).`);
                    continue;
                  }
                }

                const bodyParts = [command];
                if (marker) {
                  bodyParts.push('', marker);
                }
                const body = bodyParts.join('\n');
                await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
                const outstanding = checklistComments[0].unchecked;
                triggered.push(`#${prNumber} – keepalive posted (remaining tasks: ${outstanding})`);
                core.info(`#${prNumber}: keepalive posted (remaining tasks: ${outstanding}).`);
              }
            }

            if (triggered.length) {
              summary.addList(triggered);
            } else {
              summary.addRaw('No unattended Codex tasks detected.');
            }
            summary.addRaw(`Triggered keepalive count: ${triggered.length}`).addEOL();
            await summary.write();
