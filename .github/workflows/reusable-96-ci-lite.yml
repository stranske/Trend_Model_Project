name: Reusable 96 CI Lite

on:
  workflow_call:
    inputs:
      python-version:
        description: Python version to run under
        required: false
        default: "3.11"
        type: string
      marker:
        description: Optional pytest marker expression
        required: false
        default: ""
        type: string
      coverage-min:
        description: Minimum coverage percentage required
        required: false
        default: "70"
        type: string

jobs:
  tests:
    name: ci / python (${{ inputs.python-version }})
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      PYTHON_VERSION: ${{ inputs['python-version'] }}
      PYTEST_MARKER: ${{ inputs.marker }}
      COVERAGE_MINIMUM: ${{ inputs['coverage-min'] }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load formatter pins
        shell: bash
        run: |
          set -euo pipefail
          pin_file=".github/workflows/autofix-versions.env"
          if [[ ! -f "${pin_file}" ]]; then
            echo "Missing ${pin_file}; aborting." >&2
            exit 1
          fi
          echo "PIN_FILE=${pin_file}" >> "$GITHUB_ENV"
          # shellcheck disable=SC1090
          source "${pin_file}"
          for var in RUFF_VERSION BLACK_VERSION MYPY_VERSION PYTEST_VERSION PYTEST_COV_VERSION COVERAGE_VERSION; do
            if [[ -z "${!var:-}" ]]; then
              echo "${pin_file} is missing a value for ${var}" >&2
              exit 1
            fi
          done
          grep -E '^[A-Za-z_][A-Za-z0-9_]*=' "${pin_file}" >> "${GITHUB_ENV}"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: "pip"
          cache-dependency-path: |
            requirements.txt
            pyproject.toml

      - name: Create virtual environment
        run: |
          python -m venv .venv
          echo "${{ github.workspace }}/.venv/bin" >> "$GITHUB_PATH"
          echo "VIRTUAL_ENV=${{ github.workspace }}/.venv" >> "$GITHUB_ENV"

      - name: Install dependencies
        shell: bash
        run: |
          set -euo pipefail
          source .venv/bin/activate
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install -e '.[dev]' || pip install -e .
          pip install \
            "black==${BLACK_VERSION}" \
            "ruff==${RUFF_VERSION}" \
            "mypy==${MYPY_VERSION}" \
            "pytest==${PYTEST_VERSION}" \
            "pytest-cov==${PYTEST_COV_VERSION}" \
            "coverage==${COVERAGE_VERSION}" \
            jq

      - name: Ruff (lint)
        run: |
          source .venv/bin/activate
          ruff check --output-format github .

      - name: Mypy (type check)
        run: |
          source .venv/bin/activate
          mypy --config-file pyproject.toml src/trend_analysis src/trend_portfolio_app

      - name: Pytest (unit tests with coverage)
        env:
          PYTEST_ADDOPTS: "-ra"
        shell: bash
        run: |
          source .venv/bin/activate
          marker_args=()
          if [[ -n "${PYTEST_MARKER:-}" ]]; then
            marker_args+=("-m" "${PYTEST_MARKER}")
          fi
          pytest --junitxml=pytest-junit.xml \
            --cov=src --cov-report=xml:coverage.xml \
            --cov-report=term-missing --cov-report=json:coverage.json \
            "${marker_args[@]}"

      - name: Analyze coverage trend
        if: always()
        id: coverage_trend
        env:
          BASELINE_PATH: config/coverage-baseline.json
          SUMMARY_PATH: ${{ github.step_summary }}
        run: |
          python - <<'PY'
          import json
          import os
          import sys
          from pathlib import Path
          import xml.etree.ElementTree as ET

          workspace = Path.cwd()
          coverage_xml = workspace / "coverage.xml"
          coverage_json = workspace / "coverage.json"
          baseline_path = Path(os.environ.get("BASELINE_PATH", ""))
          summary_path = Path(os.environ.get("SUMMARY_PATH", ""))
          artifacts_dir = workspace / "artifacts"
          artifacts_dir.mkdir(exist_ok=True)

          def read_coverage():
              if coverage_xml.exists():
                  try:
                      root = ET.parse(coverage_xml).getroot()
                  except ET.ParseError as exc:
                      print(f"Failed to parse {coverage_xml}: {exc}", file=sys.stderr)
                  else:
                      rate = root.get("line-rate")
                      if rate is not None:
                          try:
                              return float(rate) * 100.0
                          except ValueError:
                              print(f"Invalid line-rate value: {rate}", file=sys.stderr)
              if coverage_json.exists():
                  try:
                      payload = json.loads(coverage_json.read_text(encoding="utf-8"))
                      totals = payload.get("totals") or {}
                      covered = float(totals.get("covered_lines", 0))
                      total = float(totals.get("num_statements", 0))
                  except Exception as exc:  # noqa: BLE001
                      print(f"Failed to read {coverage_json}: {exc}", file=sys.stderr)
                  else:
                      if total:
                          return covered / total * 100.0
              return None

          current = read_coverage()
          baseline = None
          warn_drop = 1.0
          if baseline_path.is_file():
              try:
                  data = json.loads(baseline_path.read_text(encoding="utf-8"))
              except json.JSONDecodeError as exc:
                  print(f"Unable to parse baseline file {baseline_path}: {exc}", file=sys.stderr)
              else:
                  value = data.get("line")
                  if isinstance(value, (int, float)):
                      baseline = float(value)
                  else:
                      print(f"Baseline file {baseline_path} missing numeric 'line' entry", file=sys.stderr)
                  warn_val = data.get("warn_drop")
                  if isinstance(warn_val, (int, float)) and warn_val >= 0:
                      warn_drop = float(warn_val)
          else:
              if baseline_path:
                  print(f"Baseline file {baseline_path} not found", file=sys.stderr)

          delta = None
          status = "no-data"
          if current is not None and baseline is not None:
              delta = current - baseline
              if delta < -warn_drop:
                  status = "warn"
              else:
                  status = "ok"
          elif current is not None:
              status = "no-baseline"

          summary_lines = ["### Coverage Trend"]
          if current is not None:
              summary_lines.append(f"- Current: {current:.2f}%")
          else:
              summary_lines.append("- Current: unavailable")
          if baseline is not None:
              summary_lines.append(f"- Baseline: {baseline:.2f}%")
          else:
              summary_lines.append("- Baseline: unavailable")
          if delta is not None:
              summary_lines.append(f"- Change: {delta:+.2f} pts")
              if status == "warn":
                  summary_lines.append(f"- Warning: drop exceeds {warn_drop:.2f}-pt soft limit")
          elif status == "no-baseline" and warn_drop is not None:
              summary_lines.append(f"- Soft drop limit: {warn_drop:.2f} pts")
          minimum = os.environ.get("COVERAGE_MINIMUM")
          if minimum:
              summary_lines.append(f"- Required minimum: {minimum}%")

          if summary_path:
              with summary_path.open("a", encoding="utf-8") as handle:
                  handle.write("\n".join(summary_lines) + "\n")
          else:
              print("\n".join(summary_lines))

          artifact_payload = {
              "current": current,
              "baseline": baseline,
              "delta": delta,
              "warn_drop": warn_drop,
              "status": status,
          }
          (artifacts_dir / "coverage-trend.json").write_text(
              json.dumps(artifact_payload, indent=2, sort_keys=True),
              encoding="utf-8",
          )

          comment_text = ""
          if status == "warn" and delta is not None and current is not None and baseline is not None:
              comment_lines = [
                  "ðŸ”¶ Coverage drop alert",
                  "",
                  f"Baseline coverage: {baseline:.2f}%",
                  f"Current coverage: {current:.2f}%",
                  f"Change: {delta:+.2f} percentage points",
                  "",
                  f"The drop exceeds the soft limit of {warn_drop:.2f} points. This is a warning only; CI remains green.",
                  "",
                  "Update config/coverage-baseline.json if the new level is expected.",
              ]
              comment_text = "\n".join(comment_lines)

          output_lines = []
          if current is not None:
              output_lines.append(f"current={current:.2f}")
          if baseline is not None:
              output_lines.append(f"baseline={baseline:.2f}")
          if delta is not None:
              output_lines.append(f"delta={delta:.2f}")
          if warn_drop is not None:
              output_lines.append(f"warn_drop={warn_drop:.2f}")
          output_lines.append(f"status={status}")

          output_path = Path(os.environ.get("GITHUB_OUTPUT", ""))
          if output_path:
              with output_path.open("a", encoding="utf-8") as handle:
                  for line in output_lines:
                      handle.write(line + "\n")
                  if comment_text:
                      handle.write("comment<<EOF\n")
                      handle.write(comment_text + "\n")
                      handle.write("EOF\n")

          PY

      - name: Capture artifacts
        if: always()
        run: |
          mkdir -p artifacts
          cp -f pytest-junit.xml artifacts/pytest-junit.xml || true
          cp -f coverage.xml artifacts/coverage.xml || true
          cp -f coverage.json artifacts/coverage.json || true

      - name: Upload diagnostics
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ inputs['python-version'] }}
          path: artifacts
          retention-days: 14

      - name: Post soft coverage alert
        if: >
          always() &&
          github.event_name == 'pull_request' &&
          steps.coverage_trend.outputs.status == 'warn' &&
          steps.coverage_trend.outputs.comment != ''
        uses: actions/github-script@v7
        env:
          COVERAGE_COMMENT: ${{ steps.coverage_trend.outputs.comment }}
        with:
          script: |
            const body = process.env.COVERAGE_COMMENT || '';
            if (!body.trim()) {
              core.info('No coverage alert comment to post.');
              return;
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });

      - name: Enforce coverage minimum
        run: |
          python - <<'PY'
          import os
          import sys
          import xml.etree.ElementTree as ET

          minimum = float(os.environ.get('COVERAGE_MINIMUM', '0'))
          try:
              root = ET.parse('coverage.xml').getroot()
          except FileNotFoundError:
              print('coverage.xml not found; cannot enforce coverage minimum', file=sys.stderr)
              sys.exit(1)
          except ET.ParseError as exc:
              print(f'Failed to parse coverage.xml: {exc}', file=sys.stderr)
              sys.exit(1)
          rate = root.get('line-rate')
          if rate is None:
              print('Missing line-rate attribute in coverage.xml', file=sys.stderr)
              sys.exit(1)
          current = float(rate) * 100.0
          if current + 1e-9 < minimum:
              print(f'Coverage {current:.2f}% is below required minimum {minimum:.2f}%', file=sys.stderr)
              sys.exit(1)
          print(f'Coverage {current:.2f}% meets minimum {minimum:.2f}%')
          PY
