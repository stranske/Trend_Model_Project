name: Agents 70 Orchestrator

on:
  schedule:
    - cron: '*/20 * * * *'
  workflow_run:
    workflows: [Gate]
    types: [completed]
  repository_dispatch:
    types:
      - agents-orchestrator-ping
    # Expected payload:
    #   event_type: agents-orchestrator-ping
    #   client_payload:
    #     keepalive_enabled: true|false (optional)
    #     dry_run: true|false (optional)
    #     params: { ... }        # forwarded to params_json
    #     options: { ... }       # forwarded to options_json overrides
  workflow_dispatch:
    inputs:
      # Keepalive controls — toggle the sweep or combine with keepalive:paused label.
      keepalive_enabled:
        description: 'Enable Codex keepalive sweep for this run'
        required: false
        default: 'true'
        type: boolean
      params_json:
        description: 'JSON payload of orchestrator params'
        required: false
        default: '{}'
        type: string
      options_json:
        description: 'Optional JSON overrides forwarded to reusable agents workflow'
        required: false
        default: '{}'
        type: string
      dry_run:
        description: 'Preview orchestrator actions without writes'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

concurrency:
  group: agents-70-orchestrator-${{ inputs.options_json || github.run_id }}
  cancel-in-progress: false

jobs:
  idle-precheck:
    name: Idle precheck
    runs-on: ubuntu-latest
    outputs:
      has_work: ${{ steps.precheck.outputs.has_work || 'false' }}
    steps:
      - name: Detect manual dispatch origin
        if: github.event_name == 'repository_dispatch'
        uses: actions/github-script@v7
        with:
          script: |
            const sender = context.payload?.sender?.login || 'unknown';
            const type = context.payload?.action || context.payload?.event_type || 'agents-orchestrator-ping';
            core.info(`Repository dispatch received from @${sender} (type: ${type}).`);

      - name: Count agent issues
        id: precheck
        uses: actions/github-script@v7
        with:
          script: |
            const summary = core.summary;
            const { owner, repo } = context.repo;
            const started = Date.now();
            let count = 0;

            await github.paginate(
              github.rest.issues.listForRepo,
              {
                owner,
                repo,
                state: 'open',
                per_page: 100,
              },
              (response, done) => {
                for (const issue of response.data || []) {
                  if (issue.pull_request) {
                    continue;
                  }
                  const labels = Array.isArray(issue.labels) ? issue.labels : [];
                  if (
                    labels.some((label) => {
                      const name = typeof label === 'string' ? label : label?.name;
                      return typeof name === 'string' && name.startsWith('agent:');
                    })
                  ) {
                    count += 1;
                    if (count > 0) {
                      done();
                      break;
                    }
                  }
                }
                return [];
              }
            );

            const hasWork = count > 0;
            const elapsed = Math.round((Date.now() - started) / 100) / 10;
            core.setOutput('has_work', hasWork ? 'true' : 'false');

            summary.addHeading('Agents orchestrator idle precheck');
            summary.addRaw(`agent:* issues detected: ${count}`);
            summary.addEOL();
            summary.addRaw(`Duration: ${elapsed.toFixed(1)}s`);
            summary.addEOL();
            if (!hasWork) {
              summary.addRaw('Result: idle, skipping orchestrator dispatch.').addEOL();
            }
            await summary.write();

            if (!hasWork) {
              core.info('Idle, skipping orchestrator dispatch.');
            } else {
              core.info(`Detected ${count} agent-triage issues; proceeding.`);
            }

  resolve-params:
    name: Resolve Parameters
    needs: idle-precheck
    if: needs.idle-precheck.outputs.has_work == 'true'
    runs-on: ubuntu-latest
    outputs:
      enable_readiness: ${{ steps.resolve.outputs.enable_readiness }}
      readiness_agents: ${{ steps.resolve.outputs.readiness_agents }}
      readiness_custom_logins: ${{ steps.resolve.outputs.readiness_custom_logins }}
      require_all: ${{ steps.resolve.outputs.require_all }}
      enable_preflight: ${{ steps.resolve.outputs.enable_preflight }}
      codex_user: ${{ steps.resolve.outputs.codex_user }}
      codex_command_phrase: ${{ steps.resolve.outputs.codex_command_phrase }}
      enable_diagnostic: ${{ steps.resolve.outputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ steps.resolve.outputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ steps.resolve.outputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ steps.resolve.outputs.enable_verify_issue }}
      verify_issue_number: ${{ steps.resolve.outputs.verify_issue_number }}
      enable_watchdog: ${{ steps.resolve.outputs.enable_watchdog }}
      enable_keepalive: ${{ steps.resolve.outputs.enable_keepalive }}
      keepalive_pause_label: ${{ steps.resolve.outputs.keepalive_pause_label }}
      enable_bootstrap: ${{ steps.resolve.outputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ steps.resolve.outputs.bootstrap_issues_label }}
      draft_pr: ${{ steps.resolve.outputs.draft_pr }}
      verify_issue_valid_assignees: ${{ steps.resolve.outputs.verify_issue_valid_assignees }}
      dry_run: ${{ steps.resolve.outputs.dry_run }}
      options_json: ${{ steps.resolve.outputs.options_json }}
      dispatcher_force_issue: ${{ steps.resolve.outputs.dispatcher_force_issue }}
      worker_max_parallel: ${{ steps.resolve.outputs.worker_max_parallel }}
      conveyor_max_merges: ${{ steps.resolve.outputs.conveyor_max_merges }}
      keepalive_trace: ${{ steps.resolve.outputs.keepalive_trace }}
      keepalive_round: ${{ steps.resolve.outputs.keepalive_round }}
      keepalive_pr: ${{ steps.resolve.outputs.keepalive_pr }}
    steps:
      - name: Confirm default-branch execution context
        uses: actions/github-script@v7
        with:
          script: |
            const ref = context.ref || '';
            const defaultBranch = context.payload?.repository?.default_branch || 'main';
            const expectedRef = `refs/heads/${defaultBranch}`;
            core.info(`Workflow ref: ${ref}`);
            core.info(`Repository default branch: ${defaultBranch}`);
            if (context.eventName === 'schedule' && ref && ref !== expectedRef) {
              core.setFailed(`Scheduled orchestrator runs must execute from ${expectedRef}, but received ${ref}.`);
            }
      # Do not remove checkout; local helper is required.
      - name: Checkout orchestrator scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1
      - name: Resolve dispatch parameters
        id: resolve
        uses: actions/github-script@v7
        env:
          PARAMS_JSON: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.params_json ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.params && toJson(github.event.client_payload.params) ||
                github.event.client_payload && github.event.client_payload.params_json ||
                ''
              ) ||
              '{}'
            }}
          WORKFLOW_DRY_RUN: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.dry_run || ''
              ) ||
              ''
            }}
          WORKFLOW_OPTIONS_JSON: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.options_json ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.options && toJson(github.event.client_payload.options) ||
                github.event.client_payload && github.event.client_payload.options_json ||
                ''
              ) ||
              ''
            }}
          WORKFLOW_KEEPALIVE_ENABLED: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.keepalive_enabled ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.keepalive_enabled || ''
              ) ||
              ''
            }}
        with:
          script: |
            // Do not remove checkout; local helper is required.
            const { resolveOrchestratorParams } = require('./.github/scripts/agents_orchestrator_resolve.js');
            await resolveOrchestratorParams({ github, context, core, env: process.env });

  keepalive-guard:
    name: Evaluate keepalive gate
    needs: resolve-params
    if: needs.resolve-params.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      proceed: ${{ steps.guard.outputs.proceed || 'true' }}
      reason: ${{ steps.guard.outputs.reason || '' }}
    steps:
      - name: Evaluate keepalive prerequisites
        id: guard
        uses: actions/github-script@v7
        env:
          KEEPALIVE_ENABLED: ${{ needs.resolve-params.outputs.enable_keepalive }}
          KEEPALIVE_TRACE: ${{ needs.resolve-params.outputs.keepalive_trace }}
          KEEPALIVE_ROUND: ${{ needs.resolve-params.outputs.keepalive_round }}
          KEEPALIVE_PR: ${{ needs.resolve-params.outputs.keepalive_pr }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const normalise = (value) => String(value || '').trim();
            const toBool = (value) => {
              const norm = normalise(value).toLowerCase();
              return ['true', '1', 'yes', 'on'].includes(norm);
            };

            const isAssignable = (login) => {
              const raw = normalise(login);
              if (!raw) {
                return false;
              }
              if (/\[bot\]$/i.test(raw)) {
                return false;
              }
              const lowered = raw.toLowerCase();
              const blocked = new Set([
                'chatgpt-codex-connector',
                'stranske-automation-bot',
                'github-actions',
                'dependabot',
                'copilot'
              ]);
              return !blocked.has(lowered);
            };

            const keepaliveEnabled = toBool(process.env.KEEPALIVE_ENABLED);
            const trace = normalise(process.env.KEEPALIVE_TRACE);
            const round = normalise(process.env.KEEPALIVE_ROUND);
            const prRaw = normalise(process.env.KEEPALIVE_PR);
            const summary = core.summary;
            summary.addHeading('Keepalive gate evaluation');

            const renderLine = (reason) => `**Keepalive ${round || '?' }** \`${trace || 'unknown'}\` skipped: ${reason}`;

            const setOutputs = (proceed, reason) => {
              core.setOutput('proceed', proceed ? 'true' : 'false');
              core.setOutput('reason', reason || '');
            };

            if (!keepaliveEnabled || !trace) {
              setOutputs(true, '');
              summary
                .addRaw('Keepalive gating not required for this run.')
                .addEOL()
                .write();
              return;
            }

            const prNumber = Number(prRaw);
            if (!Number.isFinite(prNumber) || prNumber <= 0) {
              const reason = 'missing-pr-number';
              summary
                .addRaw(renderLine(reason))
                .addEOL()
                .write();
              setOutputs(false, reason);
              return;
            }

            const { owner, repo } = context.repo;
            let pr;
            try {
              const response = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              pr = response.data;
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Unable to load PR #${prNumber}: ${message}`);
              const reason = 'pr-fetch-failed';
              summary
                .addRaw(renderLine(reason))
                .addEOL();
              if (message) {
                summary.addRaw(`Details: ${message}`).addEOL();
              }
              summary.write();
              setOutputs(false, reason);
              return;
            }

            const reasons = [];
            if (!pr) {
              reasons.push('missing-pr');
            } else {
              if ((pr.state || '').toLowerCase() !== 'open') {
                reasons.push('pr-not-open');
              }
              if (pr.draft) {
                reasons.push('pr-draft');
              }
              const labelNames = new Set(
                (pr.labels || [])
                  .map((label) => (typeof label === 'string' ? label : label?.name || ''))
                  .map((name) => name.trim().toLowerCase())
                  .filter(Boolean)
              );
              if (!labelNames.has('agents:keepalive')) {
                reasons.push('missing-label:agents-keepalive');
              }
              if (!labelNames.has('agent:codex')) {
                reasons.push('missing-label:agent-codex');
              }

              const headSha = pr.head?.sha || '';
              if (!headSha) {
                reasons.push('missing-head-sha');
              } else {
                try {
                  const { data: combined } = await github.rest.repos.getCombinedStatusForRef({
                    owner,
                    repo,
                    ref: headSha,
                  });
                  const statuses = combined?.statuses || [];
                  const gateStatuses = statuses.filter((status) => {
                    const ctx = (status.context || '').toLowerCase();
                    return ctx === 'gate / gate' || ctx === 'gate' || ctx.endsWith('/ gate');
                  });
                  const gateHealthy = gateStatuses.length
                    ? gateStatuses.every((status) => (status.state || '').toLowerCase() === 'success')
                    : (combined.state || '').toLowerCase() === 'success';
                  if (!gateHealthy) {
                    reasons.push('gate-not-green');
                  }
                } catch (error) {
                  const message = error instanceof Error ? error.message : String(error);
                  core.warning(`Unable to evaluate gate status for ${headSha}: ${message}`);
                }
              }

              const currentAssignees = (pr.assignees || []).map((assignee) => assignee?.login).filter(Boolean);
              const humanAssignees = currentAssignees.filter(isAssignable);

              if (!humanAssignees.length) {
                const candidateLogins = [];
                const author = pr.user?.login;
                if (isAssignable(author)) {
                  candidateLogins.push(author);
                }
                for (const reviewer of pr.requested_reviewers || []) {
                  if (isAssignable(reviewer?.login)) {
                    candidateLogins.push(reviewer.login);
                  }
                }

                const uniqueCandidates = [];
                const seen = new Set();
                for (const login of candidateLogins) {
                  const normalised = login.toLowerCase();
                  if (!seen.has(normalised)) {
                    seen.add(normalised);
                    uniqueCandidates.push(login);
                  }
                }

                if (uniqueCandidates.length) {
                  try {
                    await github.rest.issues.addAssignees({
                      owner,
                      repo,
                      issue_number: prNumber,
                      assignees: uniqueCandidates,
                    });
                    summary.addRaw(`Assigned human owners to PR #${prNumber}: ${uniqueCandidates.join(', ')}`).addEOL();
                  } catch (assignmentError) {
                    const message = assignmentError instanceof Error ? assignmentError.message : String(assignmentError);
                    summary.addRaw(`Failed to assign humans to PR #${prNumber}: ${message}`).addEOL();
                  }
                } else {
                  summary.addRaw(`No human assignees available for PR #${prNumber}; continuing without assignment.`).addEOL();
                }
              }
            }

            if (reasons.length) {
              const reasonText = reasons.join(', ');
              const line = renderLine(reasonText);
              summary.addRaw(line).addEOL().write();
              try {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: line,
                });
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                core.warning(`Failed to post keepalive skip comment on PR #${prNumber}: ${message}`);
              }
              setOutputs(false, reasonText);
              return;
            }

            summary
              .addRaw(`Keepalive ${round || '?'} trace \`${trace}\`: proceed`)
              .addEOL()
              .write();

            setOutputs(true, '');

  orchestrate:
    name: Dispatch Agents Toolkit
    needs:
      - resolve-params
      - keepalive-guard
    uses: ./.github/workflows/reusable-16-agents.yml
    # Job timeouts live inside reusable-16-agents.yml to satisfy workflow_call constraints.
    with:
      enable_readiness: ${{ needs.resolve-params.outputs.enable_readiness }}
      readiness_agents: ${{ needs.resolve-params.outputs.readiness_agents }}
      readiness_custom_logins: ${{ needs.resolve-params.outputs.readiness_custom_logins }}
      require_all: ${{ needs.resolve-params.outputs.require_all }}
      enable_preflight: ${{ needs.resolve-params.outputs.enable_preflight }}
      codex_user: ${{ needs.resolve-params.outputs.codex_user }}
      codex_command_phrase: ${{ needs.resolve-params.outputs.codex_command_phrase }}
      enable_diagnostic: ${{ needs.resolve-params.outputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ needs.resolve-params.outputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ needs.resolve-params.outputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ needs.resolve-params.outputs.enable_verify_issue }}
      verify_issue_number: ${{ needs.resolve-params.outputs.verify_issue_number }}
      enable_watchdog: ${{ needs.resolve-params.outputs.enable_watchdog }}
      enable_keepalive: ${{ needs.resolve-params.outputs.enable_keepalive }}
      enable_bootstrap: ${{ needs.resolve-params.outputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ needs.resolve-params.outputs.bootstrap_issues_label }}
      draft_pr: ${{ needs.resolve-params.outputs.draft_pr }}
      verify_issue_valid_assignees: ${{ needs.resolve-params.outputs.verify_issue_valid_assignees }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run }}
      options_json: ${{ needs.resolve-params.outputs.options_json }}
    secrets:
      service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}

  verify-assignment:
    name: Verify Assignment
    needs:
      - resolve-params
      - keepalive-guard
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.enable_verify_issue == 'true' &&
      needs.resolve-params.outputs.verify_issue_number != ''
    uses: ./.github/workflows/agents-64-verify-agent-assignment.yml
    with:
      issue_number: ${{ needs.resolve-params.outputs.verify_issue_number }}
      valid_assignees: ${{ needs.resolve-params.outputs.verify_issue_valid_assignees }}

  verify-assignment-summary:
    name: Record Verification Outcome
    needs:
      - resolve-params
      - keepalive-guard
      - verify-assignment
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.enable_verify_issue == 'true' &&
      needs.resolve-params.outputs.verify_issue_number != '' &&
      needs.verify-assignment.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Append verification summary
        env:
          ISSUE_NUMBER: ${{ needs.resolve-params.outputs.verify_issue_number }}
          STATUS: ${{ needs.verify-assignment.outputs.status }}
          MESSAGE: ${{ needs.verify-assignment.outputs.message }}
          MATCHED: ${{ needs.verify-assignment.outputs.matched_assignee }}
          REPOSITORY: ${{ github.repository }}
        run: |
          cat <<-'EOF' >> "$GITHUB_STEP_SUMMARY"
          ## Agent issue verification
          * Issue: [#${ISSUE_NUMBER}](https://github.com/${REPOSITORY}/issues/${ISSUE_NUMBER})
          * Status: ${STATUS}
          * Matched assignee: ${MATCHED:-_none_}
          EOF

          if [ -n "${MESSAGE}" ]; then
            echo "${MESSAGE}"
          fi

  belt-dispatch:
    name: Codex Belt Dispatcher
    needs:
      - resolve-params
      - keepalive-guard
    uses: ./.github/workflows/agents-71-codex-belt-dispatcher.yml
    with:
      force_issue: ${{ needs.resolve-params.outputs.dispatcher_force_issue }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' }}
    secrets:
      actions_bot_pat: ${{ secrets.ACTIONS_BOT_PAT }}

  belt-check-existing-pr:
    name: Guard existing Codex PRs
    needs:
      - belt-dispatch
      - keepalive-guard
      - resolve-params
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.belt-dispatch.outputs.issue != '' &&
      needs.belt-dispatch.outputs.branch != ''
    runs-on: ubuntu-latest
    outputs:
      pr_exists: ${{ steps.lookup.outputs.pr_exists || 'false' }}
      pr_number: ${{ steps.lookup.outputs.pr_number || '' }}
      pr_url: ${{ steps.lookup.outputs.pr_url || '' }}
    steps:
      - name: Detect existing PR for issue branch
        id: lookup
        uses: actions/github-script@v7
        env:
          KEEPALIVE_ENABLED: ${{ needs.resolve-params.outputs.enable_keepalive }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const branch = '${{ needs.belt-dispatch.outputs.branch }}';
            const summary = core.summary;
            const keepaliveEnabled = (process.env.KEEPALIVE_ENABLED || '').trim().toLowerCase() === 'true';

            summary.addHeading('Codex belt PR guard');

            const { data: pulls } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              head: `${owner}:${branch}`,
              per_page: 1,
            });

            const existing = Array.isArray(pulls) && pulls.length > 0 ? pulls[0] : null;

            if (!existing) {
              summary.addRaw(`No open PR detected for branch \`${branch}\`.`).write();
              core.setOutput('pr_exists', 'false');
              core.setOutput('pr_number', '');
              core.setOutput('pr_url', '');
              return;
            }

            const prNumber = existing.number ? String(existing.number) : '';
            const prUrl = existing.html_url || (prNumber ? `https://github.com/${owner}/${repo}/pull/${prNumber}` : '');

            summary
              .addRaw(`Existing PR detected: <a href="${prUrl}">#${prNumber || '(unknown)'}</a>.`)
              .addEOL()
              .addRaw(keepaliveEnabled
                ? 'Result: keepalive override active – worker may resume existing branch.'
                : 'Result: skipped: PR exists.')
              .write();

            core.info(keepaliveEnabled
              ? 'PR already exists; keepalive override allows worker to continue.'
              : 'PR already exists.');
            core.setOutput('pr_exists', 'true');
            core.setOutput('pr_number', prNumber);
            core.setOutput('pr_url', prUrl);

  belt-worker:
    name: Codex Belt Worker
    needs:
      - resolve-params
      - belt-dispatch
      - belt-check-existing-pr
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.worker_max_parallel != '0' &&
      needs.belt-dispatch.outputs.issue != ''
      && (
        needs.belt-check-existing-pr.outputs.pr_exists != 'true' ||
        needs.resolve-params.outputs.enable_keepalive == 'true'
      )
    uses: ./.github/workflows/agents-72-codex-belt-worker.yml
    with:
      issue: ${{ needs.belt-dispatch.outputs.issue }}
      branch: ${{ needs.belt-dispatch.outputs.branch }}
      base: ${{ needs.belt-dispatch.outputs.base }}
      source: ${{ needs.belt-dispatch.outputs.reason }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' || needs.belt-dispatch.outputs.dry_run == 'true' }}
      max_parallel: ${{ fromJson(needs.resolve-params.outputs.worker_max_parallel || '1') }}
      keepalive: ${{ needs.resolve-params.outputs.enable_keepalive == 'true' }}
    secrets:
      actions_bot_pat: ${{ secrets.ACTIONS_BOT_PAT }}

  belt-dispatch-summary:
    name: Summarise Codex dispatch outcomes
    needs:
      - belt-dispatch
      - belt-worker
      - belt-check-existing-pr
      - keepalive-guard
      - resolve-params
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Record existing PR guard outcome
        if: needs.belt-check-existing-pr.outputs.pr_exists == 'true' && needs.resolve-params.outputs.enable_keepalive != 'true'
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          ## Codex belt worker guard
          * Status: skipped: PR exists.
          * Existing PR: [#${{ needs.belt-check-existing-pr.outputs.pr_number }}](${{ needs.belt-check-existing-pr.outputs.pr_url }})
          EOF

      - name: Highlight worker failure
        if: needs.belt-worker.result == 'failure'
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          ## Codex belt worker
          * Result: failure – see Agents 72 logs for details.
          EOF

      # Do not remove checkout; local helper is required.
      - name: Checkout orchestrator scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1

      - name: Append dispatch summary
        uses: actions/github-script@v7
        env:
          DISPATCH_RESULT: ${{ needs.belt-dispatch.result || '' }}
          DISPATCH_ISSUE: ${{ needs.belt-dispatch.outputs.issue || '' }}
          DISPATCH_REASON: ${{ needs.belt-dispatch.outputs.reason || '' }}
          WORKER_RESULT: "${{ (needs.belt-check-existing-pr.outputs.pr_exists == 'true' && needs.resolve-params.outputs.enable_keepalive != 'true') && 'skipped: PR exists.' || needs.belt-worker.result || '' }}"
          WORKER_ALLOWED: ${{ needs.belt-worker.outputs.allowed || '' }}
          WORKER_PR_NUMBER: "${{ (needs.belt-check-existing-pr.outputs.pr_exists == 'true' && needs.resolve-params.outputs.enable_keepalive != 'true') && needs.belt-check-existing-pr.outputs.pr_number || needs.belt-worker.outputs.pr_number || '' }}"
          WORKER_BRANCH: ${{ needs.belt-worker.outputs.branch || needs.belt-dispatch.outputs.branch || '' }}
          WORKER_DRY_RUN: ${{ needs.belt-worker.outputs.dry_run || '' }}
        with:
          script: |
            // Do not remove checkout; local helper is required.
            const { appendDispatchSummary } = require('./.github/scripts/agents_dispatch_summary.js');
            await appendDispatchSummary({ core, context, env: process.env });

      - name: Record keepalive worker outcome
        if: |
          needs.keepalive-guard.outputs.proceed != 'false' &&
          needs.resolve-params.outputs.keepalive_trace != ''
        uses: actions/github-script@v7
        env:
          KEEPALIVE_TRACE: ${{ needs.resolve-params.outputs.keepalive_trace }}
          KEEPALIVE_ROUND: ${{ needs.resolve-params.outputs.keepalive_round }}
          KEEPALIVE_PR: ${{ needs.resolve-params.outputs.keepalive_pr || needs.belt-worker.outputs.pr_number || '' }}
          WORKER_RESULT: ${{ needs.belt-worker.result || '' }}
          WORKER_BRANCH: ${{ needs.belt-worker.outputs.branch || needs.belt-dispatch.outputs.branch || '' }}
          WORKER_DRY_RUN: ${{ needs.belt-worker.outputs.dry_run || '' }}
        with:
          github-token: ${{ secrets.ACTIONS_BOT_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const normalise = (value) => String(value || '').trim();
            const trace = normalise(process.env.KEEPALIVE_TRACE);
            const round = normalise(process.env.KEEPALIVE_ROUND);
            const workerResult = normalise(process.env.WORKER_RESULT) || 'unknown';
            const branch = normalise(process.env.WORKER_BRANCH);
            const dryRun = normalise(process.env.WORKER_DRY_RUN).toLowerCase() === 'true';
            const prCandidate = normalise(process.env.KEEPALIVE_PR);
            const prNumber = Number(prCandidate);
            const { owner, repo } = context.repo;

            let headSha = '';
            if (branch) {
              try {
                const { data } = await github.rest.repos.getBranch({ owner, repo, branch });
                headSha = data?.commit?.sha || '';
              } catch (error) {
                const message = error instanceof Error ? error.message : String(error);
                core.warning(`Unable to determine head SHA for ${branch}: ${message}`);
              }
            }

            const summary = core.summary;
            summary
              .addHeading('Keepalive worker outcome')
              .addTable([
                [
                  { data: 'Round', header: true },
                  { data: 'Trace', header: true },
                  { data: 'Result', header: true },
                  { data: 'Head SHA', header: true }
                ],
                [
                  round || '—',
                  trace || '—',
                  workerResult,
                  headSha || '(unavailable)'
                ]
              ])
              .write();

            if (!trace) {
              core.info('No keepalive trace detected; skipping worker outcome comment.');
              return;
            }

            if (!prNumber || !Number.isFinite(prNumber)) {
              core.info('No PR number resolved for keepalive worker outcome; skipping comment.');
              return;
            }

            const loweredResult = workerResult.toLowerCase();
            const shouldComment = headSha || loweredResult !== 'skipped';

            if (!shouldComment) {
              core.info('Keepalive worker skipped; no outcome comment posted.');
              return;
            }

            const shortSha = headSha ? headSha.slice(0, 12) : 'unknown';
            let details = `worker ${workerResult}`;
            if (dryRun) {
              details += ' (dry run)';
            }
            if (headSha) {
              details += ` – head ${shortSha}`;
            }

            const body = `**Keepalive ${round || '?'}** \`${trace}\` worker: ${details}.`;

            try {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body,
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              core.warning(`Failed to post keepalive worker outcome for PR #${prNumber}: ${message}`);
            }
  belt-scan-ready-prs:
    name: Scan Codex promotion queue
    needs:
      - resolve-params
      - keepalive-guard
    runs-on: ubuntu-latest
    outputs:
      items: ${{ steps.scan.outputs.items || '[]' }}
    env:
      MAX_PROMOTIONS: ${{ needs.resolve-params.outputs.conveyor_max_merges }}
    steps:
      # Do not remove checkout; local helper is required.
      - name: Checkout orchestrator scripts
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/scripts
          sparse-checkout-cone-mode: false
          fetch-depth: 1
      - name: Identify ready Codex PRs
        id: scan
        uses: actions/github-script@v7
        with:
          script: |
            // Do not remove checkout; local helper is required.
            const { identifyReadyCodexPRs } = require('./.github/scripts/agents_belt_scan.js');
            await identifyReadyCodexPRs({ github, context, core, env: process.env });

  belt-conveyor:
    name: Promote Codex PRs
    needs:
      - resolve-params
      - belt-scan-ready-prs
      - keepalive-guard
    if: |
      needs.keepalive-guard.outputs.proceed != 'false' &&
      needs.resolve-params.outputs.conveyor_max_merges != '0' &&
      needs.belt-scan-ready-prs.outputs.items != '' &&
      needs.belt-scan-ready-prs.outputs.items != '[]'
    strategy:
      matrix:
        pr: ${{ fromJson(needs.belt-scan-ready-prs.outputs.items) }}
    uses: ./.github/workflows/agents-73-codex-belt-conveyor.yml
    with:
      issue: ${{ matrix.pr.issue || 0 }}
      branch: ${{ matrix.pr.branch }}
      pr_number: ${{ matrix.pr.pr }}
      head_sha: ${{ matrix.pr.head_sha }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' }}
    secrets:
      actions_bot_pat: ${{ secrets.ACTIONS_BOT_PAT }}

  automerge-agent-prs:
    name: Auto-merge labelled agent PRs
    needs:
      - resolve-params
      - belt-conveyor
      - keepalive-guard
    if: needs.keepalive-guard.outputs.proceed != 'false' && needs.resolve-params.outputs.dry_run != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Merge Codex PRs tagged for automerge
        id: automerge
        uses: actions/github-script@v7
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || '' }}
          AUTOMERGE_LABEL: automerge
          AUTOMATION_USERS: ${{ needs.resolve-params.outputs.codex_user }}
        with:
          github-token: ${{ secrets.OWNER_PR_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const label = (process.env.AUTOMERGE_LABEL || 'automerge').trim();
            const summary = core.summary;
            const { owner, repo } = context.repo;

            let defaultBranch = (process.env.DEFAULT_BRANCH || '').trim();
            if (!defaultBranch) {
              const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
              defaultBranch = repoInfo.default_branch || 'main';
            }

            const automationUsersRaw = process.env.AUTOMATION_USERS || '';
            const automationUsers = automationUsersRaw
              .split(',')
              .map((login) => login.trim())
              .filter(Boolean);
            if (!automationUsers.length) {
              automationUsers.push('stranske-automation-bot');
            }

            async function loadPullRequest(pull_number) {
              let attempt = 0;
              while (true) {
                const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number });
                if (!pr) {
                  return null;
                }
                const state = (pr.mergeable_state || '').toLowerCase();
                if (state && state !== 'unknown') {
                  return pr;
                }
                attempt += 1;
                if (attempt >= 2) {
                  return pr;
                }
                await new Promise((resolve) => setTimeout(resolve, 2000));
              }
            }

            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'open', labels: label, per_page: 100 }
            );

            const rows = [];
            const merged = [];

            summary.addHeading('Agent auto-merge scan');
            if (!issues.length) {
              summary.addRaw(`No open pull requests carry the "${label}" label.`).addEOL();
              await summary.write();
              core.setOutput('merged', JSON.stringify(merged));
              return;
            }

            for (const issue of issues) {
              if (!issue || !issue.pull_request) {
                continue;
              }

              const prNumber = Number(issue.number);
              let note = '';
              let status = 'skipped';

              try {
                const pr = await loadPullRequest(prNumber);
                if (!pr) {
                  note = 'Unable to load pull request data.';
                } else {
                  const author = pr.user && pr.user.login ? pr.user.login : '';
                  if (!automationUsers.includes(author)) {
                    note = `Author @${author || 'unknown'} is not an automation account.`;
                  } else if ((pr.base && pr.base.ref) !== defaultBranch) {
                    note = `Base branch ${pr.base && pr.base.ref ? pr.base.ref : '(unknown)'} does not match ${defaultBranch}.`;
                  } else if (pr.draft) {
                    note = 'Draft pull requests are not eligible for auto-merge.';
                  } else {
                    const mergeableState = (pr.mergeable_state || '').toLowerCase();
                    if (['blocked', 'dirty', 'draft'].includes(mergeableState)) {
                      if (mergeableState === 'blocked') {
                        note = 'Branch protection blocks the merge (mergeable_state=blocked).';
                      } else if (mergeableState === 'dirty') {
                        note = 'Merge conflicts detected (mergeable_state=dirty).';
                      } else {
                        note = `Mergeable state ${mergeableState} prevents auto-merge.`;
                      }
                    } else {
                      const headSha = pr.head && pr.head.sha ? pr.head.sha : '';
                      if (!headSha) {
                        note = 'Missing head SHA for pull request.';
                      } else {
                        const { data: combined } = await github.rest.repos.getCombinedStatusForRef({
                          owner,
                          repo,
                          ref: headSha
                        });
                        if (!combined || combined.state !== 'success') {
                          note = 'Required status checks have not all succeeded.';
                        } else {
                          let checksOk = true;
                          let failingCheck = '';
                          try {
                            const { data: checks } = await github.rest.checks.listForRef({
                              owner,
                              repo,
                              ref: headSha,
                              per_page: 100
                            });
                            const checkRuns = Array.isArray(checks.check_runs) ? checks.check_runs : [];
                            for (const run of checkRuns) {
                              const conclusion = (run.conclusion || '').toLowerCase();
                              const statusName = run.name || run.id || 'unknown check';
                              if (!conclusion && run.status !== 'completed') {
                                checksOk = false;
                                failingCheck = `${statusName} pending`;
                                break;
                              }
                              if (conclusion && !['success', 'neutral', 'skipped'].includes(conclusion)) {
                                checksOk = false;
                                failingCheck = `${statusName} concluded ${conclusion}`;
                                break;
                              }
                            }
                          } catch (error) {
                            checksOk = false;
                            failingCheck = `Unable to list check runs: ${error.message || error}`;
                          }

                          if (!checksOk) {
                            note = failingCheck || 'Checks have not completed successfully.';
                          } else {
                            const mergeParams = {
                              owner,
                              repo,
                              pull_number: prNumber,
                              merge_method: 'squash'
                            };
                            try {
                              const response = await github.rest.pulls.merge(mergeParams);
                              if (response && response.data && response.data.merged) {
                                status = 'merged';
                                note = `Merged via ${response.data.merge_method || mergeParams.merge_method}.`;
                                merged.push(prNumber);
                              } else {
                                status = 'error';
                                note = 'Merge API returned an unexpected response.';
                              }
                            } catch (error) {
                              status = 'error';

                              const message = error instanceof Error ? error.message : String(error);
                              const response = error && typeof error === 'object' ? error.response : undefined;
                              const responseData = response && typeof response === 'object' ? response.data : undefined;

                              let details = '';
                              if (responseData && typeof responseData.message === 'string' && responseData.message.trim()) {
                                details = responseData.message.trim();
                              }

                              if (
                                responseData &&
                                Array.isArray(responseData.errors) &&
                                responseData.errors.length
                              ) {
                                const extras = responseData.errors
                                  .map((entry) => {
                                    if (!entry) {
                                      return '';
                                    }
                                    if (typeof entry === 'string') {
                                      return entry;
                                    }
                                    if (typeof entry.message === 'string' && entry.message.trim()) {
                                      return entry.message.trim();
                                    }
                                    try {
                                      return JSON.stringify(entry);
                                    } catch (jsonError) {
                                      return '';
                                    }
                                  })
                                  .filter(Boolean)
                                  .join('; ');
                                if (extras) {
                                  details = details ? `${details} (${extras})` : extras;
                                }
                              }

                              if (!details) {
                                details = message;
                              }

                              const lowered = (details || '').toLowerCase();
                              if (lowered.includes('protected') || lowered.includes('required status check')) {
                                note = `Blocked by branch protection: ${details}`;
                              } else {
                                note = `Merge failed: ${details}`;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } catch (error) {
                status = 'error';
                const message = error instanceof Error ? error.message : String(error);
                note = `Failed to evaluate PR #${prNumber}: ${message}`;
              }

              if (status === 'skipped' && !note) {
                note = 'Auto-merge conditions not satisfied.';
              }

              rows.push([
                `#${prNumber}`,
                status,
                note
              ]);
            }

            if (rows.length) {
              summary.addTable([
                [
                  { data: 'PR', header: true },
                  { data: 'Result', header: true },
                  { data: 'Details', header: true }
                ],
                ...rows
              ]);
            }

            if (!merged.length) {
              summary
                .addRaw('No pull requests were merged automatically during this scan.')
                .addEOL();
            }

            await summary.write();
            core.setOutput('merged', JSON.stringify(merged));
