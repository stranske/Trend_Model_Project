name: Agents 70 Orchestrator

on:
  schedule:
    - cron: '*/20 * * * *'
  repository_dispatch:
    types:
      - agents-orchestrator-ping
    # Expected payload:
    #   event_type: agents-orchestrator-ping
    #   client_payload:
    #     keepalive_enabled: true|false (optional)
    #     dry_run: true|false (optional)
    #     params: { ... }        # forwarded to params_json
    #     options: { ... }       # forwarded to options_json overrides
  workflow_dispatch:
    inputs:
      # Keepalive controls â€” toggle the sweep or combine with keepalive:paused label.
      keepalive_enabled:
        description: 'Enable Codex keepalive sweep for this run'
        required: false
        default: 'true'
        type: boolean
      params_json:
        description: 'JSON payload of orchestrator params'
        required: false
        default: '{}'
        type: string
      options_json:
        description: 'Optional JSON overrides forwarded to reusable agents workflow'
        required: false
        default: '{}'
        type: string
      dry_run:
        description: 'Preview orchestrator actions without writes'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

concurrency:
  group: orchestrator-${{ github.ref }}
  cancel-in-progress: true

jobs:
  idle-precheck:
    name: Idle precheck
    runs-on: ubuntu-latest
    outputs:
      has_work: ${{ steps.precheck.outputs.has_work || 'false' }}
    steps:
      - name: Detect manual dispatch origin
        if: github.event_name == 'repository_dispatch'
        uses: actions/github-script@v7
        with:
          script: |
            const sender = context.payload?.sender?.login || 'unknown';
            const type = context.payload?.action || context.payload?.event_type || 'agents-orchestrator-ping';
            core.info(`Repository dispatch received from @${sender} (type: ${type}).`);

      - name: Count agent issues
        id: precheck
        uses: actions/github-script@v7
        with:
          script: |
            const summary = core.summary;
            const { owner, repo } = context.repo;
            const started = Date.now();
            let count = 0;

            await github.paginate(
              github.rest.issues.listForRepo,
              {
                owner,
                repo,
                state: 'open',
                per_page: 100,
              },
              (response, done) => {
                for (const issue of response.data || []) {
                  if (issue.pull_request) {
                    continue;
                  }
                  const labels = Array.isArray(issue.labels) ? issue.labels : [];
                  if (
                    labels.some((label) => {
                      const name = typeof label === 'string' ? label : label?.name;
                      return typeof name === 'string' && name.startsWith('agent:');
                    })
                  ) {
                    count += 1;
                    if (count > 0) {
                      done();
                      break;
                    }
                  }
                }
                return [];
              }
            );

            const hasWork = count > 0;
            const elapsed = Math.round((Date.now() - started) / 100) / 10;
            core.setOutput('has_work', hasWork ? 'true' : 'false');

            summary.addHeading('Agents orchestrator idle precheck');
            summary.addRaw(`agent:* issues detected: ${count}`);
            summary.addEOL();
            summary.addRaw(`Duration: ${elapsed.toFixed(1)}s`);
            summary.addEOL();
            if (!hasWork) {
              summary.addRaw('Result: idle, skipping orchestrator dispatch.').addEOL();
            }
            await summary.write();

            if (!hasWork) {
              core.info('Idle, skipping orchestrator dispatch.');
            } else {
              core.info(`Detected ${count} agent-triage issues; proceeding.`);
            }

  resolve-params:
    name: Resolve Parameters
    needs: idle-precheck
    if: needs.idle-precheck.outputs.has_work == 'true'
    runs-on: ubuntu-latest
    outputs:
      enable_readiness: ${{ steps.resolve.outputs.enable_readiness }}
      readiness_agents: ${{ steps.resolve.outputs.readiness_agents }}
      readiness_custom_logins: ${{ steps.resolve.outputs.readiness_custom_logins }}
      require_all: ${{ steps.resolve.outputs.require_all }}
      enable_preflight: ${{ steps.resolve.outputs.enable_preflight }}
      codex_user: ${{ steps.resolve.outputs.codex_user }}
      codex_command_phrase: ${{ steps.resolve.outputs.codex_command_phrase }}
      enable_diagnostic: ${{ steps.resolve.outputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ steps.resolve.outputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ steps.resolve.outputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ steps.resolve.outputs.enable_verify_issue }}
      verify_issue_number: ${{ steps.resolve.outputs.verify_issue_number }}
      enable_watchdog: ${{ steps.resolve.outputs.enable_watchdog }}
      enable_keepalive: ${{ steps.resolve.outputs.enable_keepalive }}
      keepalive_pause_label: ${{ steps.resolve.outputs.keepalive_pause_label }}
      enable_bootstrap: ${{ steps.resolve.outputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ steps.resolve.outputs.bootstrap_issues_label }}
      draft_pr: ${{ steps.resolve.outputs.draft_pr }}
      verify_issue_valid_assignees: ${{ steps.resolve.outputs.verify_issue_valid_assignees }}
      dry_run: ${{ steps.resolve.outputs.dry_run }}
      options_json: ${{ steps.resolve.outputs.options_json }}
      dispatcher_force_issue: ${{ steps.resolve.outputs.dispatcher_force_issue }}
      worker_max_parallel: ${{ steps.resolve.outputs.worker_max_parallel }}
      conveyor_max_merges: ${{ steps.resolve.outputs.conveyor_max_merges }}
    steps:
      - name: Confirm default-branch execution context
        uses: actions/github-script@v7
        with:
          script: |
            const ref = context.ref || '';
            const defaultBranch = context.payload?.repository?.default_branch || 'main';
            const expectedRef = `refs/heads/${defaultBranch}`;
            core.info(`Workflow ref: ${ref}`);
            core.info(`Repository default branch: ${defaultBranch}`);
            if (context.eventName === 'schedule' && ref && ref !== expectedRef) {
              core.setFailed(`Scheduled orchestrator runs must execute from ${expectedRef}, but received ${ref}.`);
            }
      - name: Resolve dispatch parameters
        id: resolve
        uses: actions/github-script@v7
        env:
          PARAMS_JSON: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.params_json ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.params && toJson(github.event.client_payload.params) ||
                github.event.client_payload && github.event.client_payload.params_json ||
                ''
              ) ||
              '{}'
            }}
          WORKFLOW_DRY_RUN: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.dry_run || ''
              ) ||
              ''
            }}
          WORKFLOW_OPTIONS_JSON: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.options_json ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.options && toJson(github.event.client_payload.options) ||
                github.event.client_payload && github.event.client_payload.options_json ||
                ''
              ) ||
              ''
            }}
          WORKFLOW_KEEPALIVE_ENABLED: >-
            ${{
              github.event_name == 'workflow_dispatch' && github.event.inputs.keepalive_enabled ||
              github.event_name == 'repository_dispatch' && (
                github.event.client_payload && github.event.client_payload.keepalive_enabled || ''
              ) ||
              ''
            }}
        with:
          script: |
            const { resolveOrchestratorParams } = require('./.github/scripts/agents_orchestrator_resolve.js');
            await resolveOrchestratorParams({ github, context, core, env: process.env });

  orchestrate:
    name: Dispatch Agents Toolkit
    needs: resolve-params
    uses: ./.github/workflows/reusable-16-agents.yml
    # Job timeouts live inside reusable-16-agents.yml to satisfy workflow_call constraints.
    with:
      enable_readiness: ${{ needs.resolve-params.outputs.enable_readiness }}
      readiness_agents: ${{ needs.resolve-params.outputs.readiness_agents }}
      readiness_custom_logins: ${{ needs.resolve-params.outputs.readiness_custom_logins }}
      require_all: ${{ needs.resolve-params.outputs.require_all }}
      enable_preflight: ${{ needs.resolve-params.outputs.enable_preflight }}
      codex_user: ${{ needs.resolve-params.outputs.codex_user }}
      codex_command_phrase: ${{ needs.resolve-params.outputs.codex_command_phrase }}
      enable_diagnostic: ${{ needs.resolve-params.outputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ needs.resolve-params.outputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ needs.resolve-params.outputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ needs.resolve-params.outputs.enable_verify_issue }}
      verify_issue_number: ${{ needs.resolve-params.outputs.verify_issue_number }}
      enable_watchdog: ${{ needs.resolve-params.outputs.enable_watchdog }}
      enable_keepalive: ${{ needs.resolve-params.outputs.enable_keepalive }}
      enable_bootstrap: ${{ needs.resolve-params.outputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ needs.resolve-params.outputs.bootstrap_issues_label }}
      draft_pr: ${{ needs.resolve-params.outputs.draft_pr }}
      verify_issue_valid_assignees: ${{ needs.resolve-params.outputs.verify_issue_valid_assignees }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run }}
      options_json: ${{ needs.resolve-params.outputs.options_json }}

  verify-assignment:
    name: Verify Assignment
    needs: resolve-params
    if: needs.resolve-params.outputs.enable_verify_issue == 'true' && needs.resolve-params.outputs.verify_issue_number != ''
    uses: ./.github/workflows/agents-64-verify-agent-assignment.yml
    with:
      issue_number: ${{ needs.resolve-params.outputs.verify_issue_number }}
      valid_assignees: ${{ needs.resolve-params.outputs.verify_issue_valid_assignees }}

  verify-assignment-summary:
    name: Record Verification Outcome
    needs:
      - resolve-params
      - verify-assignment
    if: |
      needs.resolve-params.outputs.enable_verify_issue == 'true' &&
      needs.resolve-params.outputs.verify_issue_number != '' &&
      needs.verify-assignment.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Append verification summary
        env:
          ISSUE_NUMBER: ${{ needs.resolve-params.outputs.verify_issue_number }}
          STATUS: ${{ needs.verify-assignment.outputs.status }}
          MESSAGE: ${{ needs.verify-assignment.outputs.message }}
          MATCHED: ${{ needs.verify-assignment.outputs.matched_assignee }}
          REPOSITORY: ${{ github.repository }}
        run: |
          cat <<-'EOF' >> "$GITHUB_STEP_SUMMARY"
          ## Agent issue verification
          * Issue: [#${ISSUE_NUMBER}](https://github.com/${REPOSITORY}/issues/${ISSUE_NUMBER})
          * Status: ${STATUS}
          * Matched assignee: ${MATCHED:-_none_}
          EOF

          if [ -n "${MESSAGE}" ]; then
            echo "${MESSAGE}"
          fi

  belt-dispatch:
    name: Codex Belt Dispatcher
    needs: resolve-params
    uses: ./.github/workflows/agents-71-codex-belt-dispatcher.yml
    with:
      force_issue: ${{ needs.resolve-params.outputs.dispatcher_force_issue }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' }}
    secrets:
      actions_bot_pat: ${{ secrets.ACTIONS_BOT_PAT }}

  belt-check-existing-pr:
    name: Guard existing Codex PRs
    needs:
      - belt-dispatch
    if: needs.belt-dispatch.outputs.issue != '' && needs.belt-dispatch.outputs.branch != ''
    runs-on: ubuntu-latest
    outputs:
      pr_exists: ${{ steps.lookup.outputs.pr_exists || 'false' }}
      pr_number: ${{ steps.lookup.outputs.pr_number || '' }}
      pr_url: ${{ steps.lookup.outputs.pr_url || '' }}
    steps:
      - name: Detect existing PR for issue branch
        id: lookup
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const branch = '${{ needs.belt-dispatch.outputs.branch }}';
            const summary = core.summary;

            summary.addHeading('Codex belt PR guard');

            const { data: pulls } = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              head: `${owner}:${branch}`,
              per_page: 1,
            });

            const existing = Array.isArray(pulls) && pulls.length > 0 ? pulls[0] : null;

            if (!existing) {
              summary.addRaw(`No open PR detected for branch \`${branch}\`.`).write();
              core.setOutput('pr_exists', 'false');
              core.setOutput('pr_number', '');
              core.setOutput('pr_url', '');
              return;
            }

            const prNumber = existing.number ? String(existing.number) : '';
            const prUrl = existing.html_url || (prNumber ? `https://github.com/${owner}/${repo}/pull/${prNumber}` : '');

            summary
              .addRaw(`Existing PR detected: <a href="${prUrl}">#${prNumber || '(unknown)'}</a>.`)
              .addEOL()
              .addRaw('Result: skipped: PR exists.')
              .write();

            core.info('PR already exists.');
            core.setOutput('pr_exists', 'true');
            core.setOutput('pr_number', prNumber);
            core.setOutput('pr_url', prUrl);

  belt-worker:
    name: Codex Belt Worker
    needs:
      - resolve-params
      - belt-dispatch
      - belt-check-existing-pr
    if: |
      needs.resolve-params.outputs.worker_max_parallel != '0' &&
      needs.belt-dispatch.outputs.issue != ''
      && needs.belt-check-existing-pr.outputs.pr_exists != 'true'
    uses: ./.github/workflows/agents-72-codex-belt-worker.yml
    with:
      issue: ${{ needs.belt-dispatch.outputs.issue }}
      branch: ${{ needs.belt-dispatch.outputs.branch }}
      base: ${{ needs.belt-dispatch.outputs.base }}
      source: ${{ needs.belt-dispatch.outputs.reason }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' || needs.belt-dispatch.outputs.dry_run == 'true' }}
      max_parallel: ${{ fromJson(needs.resolve-params.outputs.worker_max_parallel || '1') }}
    secrets:
      actions_bot_pat: ${{ secrets.ACTIONS_BOT_PAT }}

  belt-dispatch-summary:
    name: Summarise Codex dispatch outcomes
    needs:
      - belt-dispatch
      - belt-worker
      - belt-check-existing-pr
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Record existing PR guard outcome
        if: needs.belt-check-existing-pr.outputs.pr_exists == 'true'
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          ## Codex belt worker guard
          * Status: skipped: PR exists.
          * Existing PR: [#${{ needs.belt-check-existing-pr.outputs.pr_number }}](${{ needs.belt-check-existing-pr.outputs.pr_url }})
          EOF

      - name: Append dispatch summary
        uses: actions/github-script@v7
        env:
          DISPATCH_RESULT: ${{ needs.belt-dispatch.result || '' }}
          DISPATCH_ISSUE: ${{ needs.belt-dispatch.outputs.issue || '' }}
          DISPATCH_REASON: ${{ needs.belt-dispatch.outputs.reason || '' }}
          WORKER_RESULT: "${{ needs.belt-check-existing-pr.outputs.pr_exists == 'true' && 'skipped: PR exists.' || needs.belt-worker.result || '' }}"
          WORKER_ALLOWED: ${{ needs.belt-worker.outputs.allowed || '' }}
          WORKER_PR_NUMBER: "${{ needs.belt-check-existing-pr.outputs.pr_exists == 'true' && needs.belt-check-existing-pr.outputs.pr_number || needs.belt-worker.outputs.pr_number || '' }}"
          WORKER_BRANCH: ${{ needs.belt-worker.outputs.branch || needs.belt-dispatch.outputs.branch || '' }}
          WORKER_DRY_RUN: ${{ needs.belt-worker.outputs.dry_run || '' }}
        with:
          script: |
            const { appendDispatchSummary } = require('./.github/scripts/agents_dispatch_summary.js');
            await appendDispatchSummary({ core, context, env: process.env });
  belt-scan-ready-prs:
    name: Scan Codex promotion queue
    needs: resolve-params
    runs-on: ubuntu-latest
    outputs:
      items: ${{ steps.scan.outputs.items || '[]' }}
    env:
      MAX_PROMOTIONS: ${{ needs.resolve-params.outputs.conveyor_max_merges }}
    steps:
      - name: Identify ready Codex PRs
        id: scan
        uses: actions/github-script@v7
        with:
          script: |
            const { identifyReadyCodexPRs } = require('./.github/scripts/agents_belt_scan.js');
            await identifyReadyCodexPRs({ github, context, core, env: process.env });

  belt-conveyor:
    name: Promote Codex PRs
    needs:
      - resolve-params
      - belt-scan-ready-prs
    if: |
      needs.resolve-params.outputs.conveyor_max_merges != '0' &&
      needs.belt-scan-ready-prs.outputs.items != '' &&
      needs.belt-scan-ready-prs.outputs.items != '[]'
    strategy:
      matrix:
        pr: ${{ fromJson(needs.belt-scan-ready-prs.outputs.items) }}
    uses: ./.github/workflows/agents-73-codex-belt-conveyor.yml
    with:
      issue: ${{ matrix.pr.issue || 0 }}
      branch: ${{ matrix.pr.branch }}
      pr_number: ${{ matrix.pr.pr }}
      head_sha: ${{ matrix.pr.head_sha }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' }}
    secrets:
      actions_bot_pat: ${{ secrets.ACTIONS_BOT_PAT }}

  automerge-agent-prs:
    name: Auto-merge labelled agent PRs
    needs:
      - resolve-params
      - belt-conveyor
    if: needs.resolve-params.outputs.dry_run != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Merge Codex PRs tagged for automerge
        id: automerge
        uses: actions/github-script@v7
        env:
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch || '' }}
          AUTOMERGE_LABEL: automerge
          AUTOMATION_USERS: ${{ needs.resolve-params.outputs.codex_user }}
        with:
          github-token: ${{ secrets.OWNER_PR_PAT || secrets.SERVICE_BOT_PAT || github.token }}
          script: |
            const label = (process.env.AUTOMERGE_LABEL || 'automerge').trim();
            const summary = core.summary;
            const { owner, repo } = context.repo;

            let defaultBranch = (process.env.DEFAULT_BRANCH || '').trim();
            if (!defaultBranch) {
              const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
              defaultBranch = repoInfo.default_branch || 'main';
            }

            const automationUsersRaw = process.env.AUTOMATION_USERS || '';
            const automationUsers = automationUsersRaw
              .split(',')
              .map((login) => login.trim())
              .filter(Boolean);
            if (!automationUsers.length) {
              automationUsers.push('stranske-automation-bot');
            }

            async function loadPullRequest(pull_number) {
              let attempt = 0;
              while (true) {
                const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number });
                if (!pr) {
                  return null;
                }
                const state = (pr.mergeable_state || '').toLowerCase();
                if (state && state !== 'unknown') {
                  return pr;
                }
                attempt += 1;
                if (attempt >= 2) {
                  return pr;
                }
                await new Promise((resolve) => setTimeout(resolve, 2000));
              }
            }

            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'open', labels: label, per_page: 100 }
            );

            const rows = [];
            const merged = [];

            summary.addHeading('Agent auto-merge scan');
            if (!issues.length) {
              summary.addRaw(`No open pull requests carry the "${label}" label.`).addEOL();
              await summary.write();
              core.setOutput('merged', JSON.stringify(merged));
              return;
            }

            for (const issue of issues) {
              if (!issue || !issue.pull_request) {
                continue;
              }

              const prNumber = Number(issue.number);
              let note = '';
              let status = 'skipped';

              try {
                const pr = await loadPullRequest(prNumber);
                if (!pr) {
                  note = 'Unable to load pull request data.';
                } else {
                  const author = pr.user && pr.user.login ? pr.user.login : '';
                  if (!automationUsers.includes(author)) {
                    note = `Author @${author || 'unknown'} is not an automation account.`;
                  } else if ((pr.base && pr.base.ref) !== defaultBranch) {
                    note = `Base branch ${pr.base && pr.base.ref ? pr.base.ref : '(unknown)'} does not match ${defaultBranch}.`;
                  } else if (pr.draft) {
                    note = 'Draft pull requests are not eligible for auto-merge.';
                  } else {
                    const mergeableState = (pr.mergeable_state || '').toLowerCase();
                    if (['blocked', 'dirty', 'draft'].includes(mergeableState)) {
                      if (mergeableState === 'blocked') {
                        note = 'Branch protection blocks the merge (mergeable_state=blocked).';
                      } else if (mergeableState === 'dirty') {
                        note = 'Merge conflicts detected (mergeable_state=dirty).';
                      } else {
                        note = `Mergeable state ${mergeableState} prevents auto-merge.`;
                      }
                    } else {
                      const headSha = pr.head && pr.head.sha ? pr.head.sha : '';
                      if (!headSha) {
                        note = 'Missing head SHA for pull request.';
                      } else {
                        const { data: combined } = await github.rest.repos.getCombinedStatusForRef({
                          owner,
                          repo,
                          ref: headSha
                        });
                        if (!combined || combined.state !== 'success') {
                          note = 'Required status checks have not all succeeded.';
                        } else {
                          let checksOk = true;
                          let failingCheck = '';
                          try {
                            const { data: checks } = await github.rest.checks.listForRef({
                              owner,
                              repo,
                              ref: headSha,
                              per_page: 100
                            });
                            const checkRuns = Array.isArray(checks.check_runs) ? checks.check_runs : [];
                            for (const run of checkRuns) {
                              const conclusion = (run.conclusion || '').toLowerCase();
                              const statusName = run.name || run.id || 'unknown check';
                              if (!conclusion && run.status !== 'completed') {
                                checksOk = false;
                                failingCheck = `${statusName} pending`;
                                break;
                              }
                              if (conclusion && !['success', 'neutral', 'skipped'].includes(conclusion)) {
                                checksOk = false;
                                failingCheck = `${statusName} concluded ${conclusion}`;
                                break;
                              }
                            }
                          } catch (error) {
                            checksOk = false;
                            failingCheck = `Unable to list check runs: ${error.message || error}`;
                          }

                          if (!checksOk) {
                            note = failingCheck || 'Checks have not completed successfully.';
                          } else {
                            const mergeParams = {
                              owner,
                              repo,
                              pull_number: prNumber,
                              merge_method: 'squash'
                            };
                            try {
                              const response = await github.rest.pulls.merge(mergeParams);
                              if (response && response.data && response.data.merged) {
                                status = 'merged';
                                note = `Merged via ${response.data.merge_method || mergeParams.merge_method}.`;
                                merged.push(prNumber);
                              } else {
                                status = 'error';
                                note = 'Merge API returned an unexpected response.';
                              }
                            } catch (error) {
                              status = 'error';

                              const message = error instanceof Error ? error.message : String(error);
                              const response = error && typeof error === 'object' ? error.response : undefined;
                              const responseData = response && typeof response === 'object' ? response.data : undefined;

                              let details = '';
                              if (responseData && typeof responseData.message === 'string' && responseData.message.trim()) {
                                details = responseData.message.trim();
                              }

                              if (
                                responseData &&
                                Array.isArray(responseData.errors) &&
                                responseData.errors.length
                              ) {
                                const extras = responseData.errors
                                  .map((entry) => {
                                    if (!entry) {
                                      return '';
                                    }
                                    if (typeof entry === 'string') {
                                      return entry;
                                    }
                                    if (typeof entry.message === 'string' && entry.message.trim()) {
                                      return entry.message.trim();
                                    }
                                    try {
                                      return JSON.stringify(entry);
                                    } catch (jsonError) {
                                      return '';
                                    }
                                  })
                                  .filter(Boolean)
                                  .join('; ');
                                if (extras) {
                                  details = details ? `${details} (${extras})` : extras;
                                }
                              }

                              if (!details) {
                                details = message;
                              }

                              const lowered = (details || '').toLowerCase();
                              if (lowered.includes('protected') || lowered.includes('required status check')) {
                                note = `Blocked by branch protection: ${details}`;
                              } else {
                                note = `Merge failed: ${details}`;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } catch (error) {
                status = 'error';
                const message = error instanceof Error ? error.message : String(error);
                note = `Failed to evaluate PR #${prNumber}: ${message}`;
              }

              if (status === 'skipped' && !note) {
                note = 'Auto-merge conditions not satisfied.';
              }

              rows.push([
                `#${prNumber}`,
                status,
                note
              ]);
            }

            if (rows.length) {
              summary.addTable([
                [
                  { data: 'PR', header: true },
                  { data: 'Result', header: true },
                  { data: 'Details', header: true }
                ],
                ...rows
              ]);
            }

            if (!merged.length) {
              summary
                .addRaw('No pull requests were merged automatically during this scan.')
                .addEOL();
            }

            await summary.write();
            core.setOutput('merged', JSON.stringify(merged));
