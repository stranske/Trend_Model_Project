name: Agents 70 Orchestrator

on:
  schedule:
    - cron: '*/20 * * * *'
  workflow_dispatch:
    inputs:
      params_json:
        description: 'JSON payload of orchestrator params'
        required: false
        default: '{}'

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: agents-orchestrator-${{ github.ref }}
  cancel-in-progress: true

jobs:
  resolve-params:
    name: Resolve Parameters
    runs-on: ubuntu-latest
    outputs:
      enable_readiness: ${{ steps.resolve.outputs.enable_readiness }}
      readiness_agents: ${{ steps.resolve.outputs.readiness_agents }}
      readiness_custom_logins: ${{ steps.resolve.outputs.readiness_custom_logins }}
      require_all: ${{ steps.resolve.outputs.require_all }}
      enable_preflight: ${{ steps.resolve.outputs.enable_preflight }}
      codex_user: ${{ steps.resolve.outputs.codex_user }}
      codex_command_phrase: ${{ steps.resolve.outputs.codex_command_phrase }}
      enable_diagnostic: ${{ steps.resolve.outputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ steps.resolve.outputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ steps.resolve.outputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ steps.resolve.outputs.enable_verify_issue }}
      verify_issue_number: ${{ steps.resolve.outputs.verify_issue_number }}
      enable_watchdog: ${{ steps.resolve.outputs.enable_watchdog }}
      enable_keepalive: ${{ steps.resolve.outputs.enable_keepalive }}
      enable_bootstrap: ${{ steps.resolve.outputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ steps.resolve.outputs.bootstrap_issues_label }}
      draft_pr: ${{ steps.resolve.outputs.draft_pr }}
      verify_issue_valid_assignees: ${{ steps.resolve.outputs.verify_issue_valid_assignees }}
      options_json: ${{ steps.resolve.outputs.options_json }}
    steps:
      - name: Resolve dispatch parameters
        id: resolve
        uses: actions/github-script@v7
        env:
          PARAMS_JSON: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.params_json || '{}' }}
        with:
          script: |
            const DEFAULT_READINESS_AGENTS = 'copilot,codex';
            const DEFAULT_VERIFY_ISSUE_ASSIGNEES = 'copilot,chatgpt-codex-connector,stranske-automation-bot';
            const DEFAULT_OPTIONS_JSON = '{}';
            const DEFAULTS = {
              enable_readiness: 'false',
              readiness_agents: DEFAULT_READINESS_AGENTS,
              readiness_custom_logins: '',
              require_all: 'false',
              enable_preflight: 'false',
              codex_user: '',
              codex_command_phrase: '',
              enable_verify_issue: 'false',
              verify_issue_number: '',
              verify_issue_valid_assignees: DEFAULT_VERIFY_ISSUE_ASSIGNEES,
              enable_watchdog: 'true',
              enable_keepalive: 'true',
              enable_bootstrap: 'false',
              bootstrap_issues_label: 'agent:codex',
              draft_pr: 'false',
              diagnostic_mode: 'off',
              options_json: DEFAULT_OPTIONS_JSON
            };

            const toString = (value, fallback = '') => {
              if (value === undefined || value === null) {
                return fallback;
              }
              if (Array.isArray(value)) {
                return value.map((item) => String(item).trim()).filter(Boolean).join(',');
              }
              return String(value);
            };

            const toBoolString = (value, fallback) => {
              const candidate = value === undefined ? fallback : value;
              if (typeof candidate === 'boolean') {
                return candidate ? 'true' : 'false';
              }
              if (typeof candidate === 'number') {
                return candidate !== 0 ? 'true' : 'false';
              }
              if (typeof candidate === 'string') {
                const norm = candidate.trim().toLowerCase();
                if (['true', '1', 'yes', 'y', 'on'].includes(norm)) {
                  return 'true';
                }
                if (['false', '0', 'no', 'n', 'off', ''].includes(norm)) {
                  return 'false';
                }
              }
              return fallback === 'true' || fallback === true ? 'true' : 'false';
            };

            const toCsv = (value, fallback = '') => {
              if (value === undefined || value === null) {
                return fallback;
              }
              const raw = Array.isArray(value)
                ? value
                : typeof value === 'string'
                  ? value.split(',')
                  : [];
              const cleaned = raw
                .map((entry) => String(entry).trim())
                .filter(Boolean);
              if (!cleaned.length) {
                return fallback;
              }
              return cleaned.join(',');
            };

            const nested = (value) => (value && typeof value === 'object' ? value : {});

            let user = {};
            try {
              const parsed = JSON.parse(process.env.PARAMS_JSON || '{}');
              if (parsed && typeof parsed === 'object') {
                user = parsed;
              }
            } catch (error) {
              core.warning(`Bad params_json; using defaults. Parse error: ${error.message}`);
            }

            const merged = { ...DEFAULTS, ...user };

            const readinessAgents = toCsv(merged.readiness_agents, DEFAULTS.readiness_agents);
            const readinessCustom = toCsv(
              merged.readiness_custom_logins ?? merged.readiness_custom ?? merged.custom_logins,
              DEFAULTS.readiness_custom_logins
            );
            const codexUser = toString(merged.codex_user, DEFAULTS.codex_user);
            const codexCommand = toString(merged.codex_command_phrase, DEFAULTS.codex_command_phrase);
            const verifyIssueNumber = toString(merged.verify_issue_number, DEFAULTS.verify_issue_number).trim();
            const verifyIssueAssignees = toCsv(
              merged.verify_issue_valid_assignees ?? merged.valid_assignees,
              DEFAULT_VERIFY_ISSUE_ASSIGNEES
            );

            const bootstrap = nested(merged.bootstrap);
            const keepalive = nested(merged.keepalive);

            const bootstrapRaw = toString(
              merged.bootstrap_issues_label ?? bootstrap.label,
              DEFAULTS.bootstrap_issues_label
            );
            const bootstrapTrimmed = bootstrapRaw.trim();
            const bootstrapLabel = bootstrapTrimmed || DEFAULTS.bootstrap_issues_label;
            const bootstrapFallbackUsed = bootstrapTrimmed === '' && bootstrapLabel !== bootstrapRaw;
            const bootstrapLabelFallbackNotice =
              'bootstrap_issues_label empty; defaulting to agent:codex.';

            const diagnosticModeRaw = toString(merged.diagnostic_mode, DEFAULTS.diagnostic_mode).trim().toLowerCase();
            const diagnosticMode = ['full', 'dry-run'].includes(diagnosticModeRaw) ? diagnosticModeRaw : 'off';

            const enableVerifyIssue = toBoolString(
              merged.enable_verify_issue,
              verifyIssueNumber !== '' ? 'true' : DEFAULTS.enable_verify_issue
            );

            const sanitiseOptions = (value) => {
              if (value === undefined || value === null || value === '') {
                return DEFAULT_OPTIONS_JSON;
              }
              if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed) {
                  return DEFAULT_OPTIONS_JSON;
                }
                try {
                  const parsed = JSON.parse(trimmed);
                  return JSON.stringify(parsed);
                } catch (error) {
                  core.warning(`options_json is not valid JSON (${error.message}); using default.`);
                  return DEFAULT_OPTIONS_JSON;
                }
              }
              if (typeof value === 'object') {
                try {
                  return JSON.stringify(value);
                } catch (error) {
                  core.warning(`options_json could not be serialised (${error.message}); using default.`);
                  return DEFAULT_OPTIONS_JSON;
                }
              }
              return DEFAULT_OPTIONS_JSON;
            };

            const optionsSource = merged.options_json ?? merged.options ?? DEFAULT_OPTIONS_JSON;

            const outputs = {
              enable_readiness: toBoolString(merged.enable_readiness, DEFAULTS.enable_readiness),
              readiness_agents: readinessAgents,
              readiness_custom_logins: readinessCustom,
              require_all: toBoolString(merged.require_all, DEFAULTS.require_all),
              enable_preflight: toBoolString(merged.enable_preflight, DEFAULTS.enable_preflight),
              codex_user: codexUser,
              codex_command_phrase: codexCommand,
              enable_diagnostic: diagnosticMode === 'off' ? 'false' : 'true',
              diagnostic_attempt_branch: diagnosticMode === 'full' ? 'true' : 'false',
              diagnostic_dry_run: diagnosticMode === 'full' ? 'false' : 'true',
              enable_verify_issue: enableVerifyIssue,
              verify_issue_number: verifyIssueNumber,
              verify_issue_valid_assignees: verifyIssueAssignees,
              enable_watchdog: toBoolString(merged.enable_watchdog, DEFAULTS.enable_watchdog),
              enable_keepalive: toBoolString(merged.enable_keepalive ?? keepalive.enabled, DEFAULTS.enable_keepalive),
              enable_bootstrap: toBoolString(merged.enable_bootstrap ?? bootstrap.enable, DEFAULTS.enable_bootstrap),
              bootstrap_issues_label: bootstrapLabel,
              draft_pr: toBoolString(merged.draft_pr, DEFAULTS.draft_pr),
              options_json: sanitiseOptions(optionsSource)
            };

            const orderedKeys = [
              'enable_readiness',
              'readiness_agents',
              'readiness_custom_logins',
              'require_all',
              'enable_preflight',
              'codex_user',
              'codex_command_phrase',
              'enable_diagnostic',
              'diagnostic_attempt_branch',
              'diagnostic_dry_run',
              'enable_verify_issue',
              'verify_issue_number',
              'verify_issue_valid_assignees',
              'enable_watchdog',
              'enable_keepalive',
              'enable_bootstrap',
              'bootstrap_issues_label',
              'draft_pr',
              'options_json'
            ];

            const summarise = (value) => {
              const text = String(value ?? '');
              const limit = 120;
              const separator = ' â€¦ ';
              if (text.length <= limit) {
                return text;
              }
              const available = limit - separator.length;
              const headLen = Math.ceil(available / 2);
              const tailLen = Math.floor(available / 2);
              const head = text.slice(0, headLen).trimEnd();
              const tail = text.slice(-tailLen).trimStart();
              return `${head}${separator}${tail}`;
            };

            for (const key of orderedKeys) {
              if (Object.prototype.hasOwnProperty.call(outputs, key)) {
                core.setOutput(key, outputs[key]);
              }
            }

            const summary = core.summary;
            summary.addHeading('Agents orchestrator parameters');
            summary.addTable([
              [{ data: 'Parameter', header: true }, { data: 'Value', header: true }],
              ...orderedKeys.map((key) => [key, summarise(outputs[key])])
            ]);
            if (bootstrapFallbackUsed) {
              summary.addRaw(bootstrapLabelFallbackNotice).addEOL();
              core.notice(bootstrapLabelFallbackNotice);
            }
            await summary.write();

  orchestrate:
    name: Dispatch Agents Toolkit
    needs: resolve-params
    uses: ./.github/workflows/reusable-16-agents.yml
    # Job timeouts live inside reusable-16-agents.yml to satisfy workflow_call constraints.
    with:
      enable_readiness: ${{ needs.resolve-params.outputs.enable_readiness }}
      readiness_agents: ${{ needs.resolve-params.outputs.readiness_agents }}
      readiness_custom_logins: ${{ needs.resolve-params.outputs.readiness_custom_logins }}
      require_all: ${{ needs.resolve-params.outputs.require_all }}
      enable_preflight: ${{ needs.resolve-params.outputs.enable_preflight }}
      codex_user: ${{ needs.resolve-params.outputs.codex_user }}
      codex_command_phrase: ${{ needs.resolve-params.outputs.codex_command_phrase }}
      enable_diagnostic: ${{ needs.resolve-params.outputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ needs.resolve-params.outputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ needs.resolve-params.outputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ needs.resolve-params.outputs.enable_verify_issue }}
      verify_issue_number: ${{ needs.resolve-params.outputs.verify_issue_number }}
      enable_watchdog: ${{ needs.resolve-params.outputs.enable_watchdog }}
      enable_keepalive: ${{ needs.resolve-params.outputs.enable_keepalive }}
      enable_bootstrap: ${{ needs.resolve-params.outputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ needs.resolve-params.outputs.bootstrap_issues_label }}
      draft_pr: ${{ needs.resolve-params.outputs.draft_pr }}
      verify_issue_valid_assignees: ${{ needs.resolve-params.outputs.verify_issue_valid_assignees }}
      options_json: ${{ needs.resolve-params.outputs.options_json }}

  verify-assignment:
    name: Verify Assignment
    needs: resolve-params
    if: needs.resolve-params.outputs.enable_verify_issue == 'true' && needs.resolve-params.outputs.verify_issue_number != ''
    uses: ./.github/workflows/agents-64-verify-agent-assignment.yml
    with:
      issue_number: ${{ needs.resolve-params.outputs.verify_issue_number }}
      valid_assignees: ${{ needs.resolve-params.outputs.verify_issue_valid_assignees }}

  verify-assignment-summary:
    name: Record Verification Outcome
    needs:
      - resolve-params
      - verify-assignment
    if: |
      needs.resolve-params.outputs.enable_verify_issue == 'true' &&
      needs.resolve-params.outputs.verify_issue_number != '' &&
      needs.verify-assignment.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Append verification summary
        env:
          ISSUE_NUMBER: ${{ needs.resolve-params.outputs.verify_issue_number }}
          STATUS: ${{ needs.verify-assignment.outputs.status }}
          MESSAGE: ${{ needs.verify-assignment.outputs.message }}
          MATCHED: ${{ needs.verify-assignment.outputs.matched_assignee }}
          REPOSITORY: ${{ github.repository }}
        run: |
          cat <<EOF >> "$GITHUB_STEP_SUMMARY"
          ## Agent issue verification
          * Issue: [#${ISSUE_NUMBER}](https://github.com/${REPOSITORY}/issues/${ISSUE_NUMBER})
          * Status: ${STATUS}
          * Matched assignee: ${MATCHED:-_none_}
          EOF

          if [ -n "${MESSAGE}" ]; then
            echo "${MESSAGE}"
          fi
