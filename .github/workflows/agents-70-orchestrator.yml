name: Agents 70 Orchestrator

on:
  schedule:
    - cron: '*/20 * * * *'
  workflow_dispatch:
    inputs:
      # Keepalive controls — toggle the sweep or combine with keepalive:paused label.
      keepalive_enabled:
        description: 'Enable Codex keepalive sweep for this run'
        required: false
        default: 'true'
        type: boolean
      params_json:
        description: 'JSON payload of orchestrator params'
        required: false
        default: '{}'
        type: string
      options_json:
        description: 'Optional JSON overrides forwarded to reusable agents workflow'
        required: false
        default: '{}'
        type: string
      dry_run:
        description: 'Preview orchestrator actions without writes'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: write

concurrency:
  group: orchestrator-${{ github.ref }}
  cancel-in-progress: true

jobs:
  resolve-params:
    name: Resolve Parameters
    runs-on: ubuntu-latest
    outputs:
      enable_readiness: ${{ steps.resolve.outputs.enable_readiness }}
      readiness_agents: ${{ steps.resolve.outputs.readiness_agents }}
      readiness_custom_logins: ${{ steps.resolve.outputs.readiness_custom_logins }}
      require_all: ${{ steps.resolve.outputs.require_all }}
      enable_preflight: ${{ steps.resolve.outputs.enable_preflight }}
      codex_user: ${{ steps.resolve.outputs.codex_user }}
      codex_command_phrase: ${{ steps.resolve.outputs.codex_command_phrase }}
      enable_diagnostic: ${{ steps.resolve.outputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ steps.resolve.outputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ steps.resolve.outputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ steps.resolve.outputs.enable_verify_issue }}
      verify_issue_number: ${{ steps.resolve.outputs.verify_issue_number }}
      enable_watchdog: ${{ steps.resolve.outputs.enable_watchdog }}
      enable_keepalive: ${{ steps.resolve.outputs.enable_keepalive }}
      keepalive_pause_label: ${{ steps.resolve.outputs.keepalive_pause_label }}
      enable_bootstrap: ${{ steps.resolve.outputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ steps.resolve.outputs.bootstrap_issues_label }}
      draft_pr: ${{ steps.resolve.outputs.draft_pr }}
      verify_issue_valid_assignees: ${{ steps.resolve.outputs.verify_issue_valid_assignees }}
      dry_run: ${{ steps.resolve.outputs.dry_run }}
      options_json: ${{ steps.resolve.outputs.options_json }}
      dispatcher_force_issue: ${{ steps.resolve.outputs.dispatcher_force_issue }}
      worker_max_parallel: ${{ steps.resolve.outputs.worker_max_parallel }}
      conveyor_max_merges: ${{ steps.resolve.outputs.conveyor_max_merges }}
    steps:
      - name: Confirm default-branch execution context
        uses: actions/github-script@v7
        with:
          script: |
            const ref = context.ref || '';
            const defaultBranch = context.payload?.repository?.default_branch || 'main';
            const expectedRef = `refs/heads/${defaultBranch}`;
            core.info(`Workflow ref: ${ref}`);
            core.info(`Repository default branch: ${defaultBranch}`);
            if (context.eventName === 'schedule' && ref && ref !== expectedRef) {
              core.setFailed(`Scheduled orchestrator runs must execute from ${expectedRef}, but received ${ref}.`);
            }
      - name: Resolve dispatch parameters
        id: resolve
        uses: actions/github-script@v7
        env:
          PARAMS_JSON: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.params_json || '{}' }}
          WORKFLOW_DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run || '' }}
          WORKFLOW_OPTIONS_JSON: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.options_json || '' }}
          WORKFLOW_KEEPALIVE_ENABLED: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.keepalive_enabled || '' }}
        with:
          script: |
            const DEFAULT_READINESS_AGENTS = 'copilot,codex';
            const DEFAULT_VERIFY_ISSUE_ASSIGNEES = 'copilot,chatgpt-codex-connector,stranske-automation-bot';
            const DEFAULT_OPTIONS_JSON = '{}';
            // Repository label that pauses keepalive sweeps when present.
            // Delete the label (or rename it) to resume keepalive automation without code changes.
            const KEEPALIVE_PAUSE_LABEL = 'keepalive:paused';
            const DEFAULTS = {
              enable_readiness: 'false',
              readiness_agents: DEFAULT_READINESS_AGENTS,
              readiness_custom_logins: '',
              require_all: 'false',
              enable_preflight: 'false',
              codex_user: '',
              codex_command_phrase: '',
              enable_verify_issue: 'false',
              verify_issue_number: '',
              verify_issue_valid_assignees: DEFAULT_VERIFY_ISSUE_ASSIGNEES,
              enable_watchdog: 'true',
              enable_keepalive: 'true',
              enable_bootstrap: 'false',
              bootstrap_issues_label: 'agent:codex',
              draft_pr: 'false',
              diagnostic_mode: 'off',
              options_json: DEFAULT_OPTIONS_JSON,
              dry_run: 'false',
              dispatcher_force_issue: '',
              worker_max_parallel: '1',
              conveyor_max_merges: '2'
            };

            const toString = (value, fallback = '') => {
              if (value === undefined || value === null) {
                return fallback;
              }
              if (Array.isArray(value)) {
                return value.map((item) => String(item).trim()).filter(Boolean).join(',');
              }
              return String(value);
            };

            const toBoolString = (value, fallback) => {
              const candidate = value === undefined ? fallback : value;
              if (typeof candidate === 'boolean') {
                return candidate ? 'true' : 'false';
              }
              if (typeof candidate === 'number') {
                return candidate !== 0 ? 'true' : 'false';
              }
              if (typeof candidate === 'string') {
                const norm = candidate.trim().toLowerCase();
                if (['true', '1', 'yes', 'y', 'on'].includes(norm)) {
                  return 'true';
                }
                if (['false', '0', 'no', 'n', 'off', ''].includes(norm)) {
                  return 'false';
                }
              }
              return fallback === 'true' || fallback === true ? 'true' : 'false';
            };

            const toCsv = (value, fallback = '') => {
              if (value === undefined || value === null) {
                return fallback;
              }
              const raw = Array.isArray(value)
                ? value
                : typeof value === 'string'
                  ? value.split(',')
                  : [];
              const cleaned = raw
                .map((entry) => String(entry).trim())
                .filter(Boolean);
              if (!cleaned.length) {
                return fallback;
              }
              return cleaned.join(',');
            };

            const nested = (value) => (value && typeof value === 'object' ? value : {});

            const toBoundedIntegerString = (value, fallback, bounds = {}) => {
              const { min, max } = bounds;
              const fallbackNumber = Number(fallback);
              let candidate = Number(value);
              if (!Number.isFinite(candidate)) {
                candidate = Number.isFinite(fallbackNumber) ? fallbackNumber : 0;
              }
              if (Number.isFinite(min) && candidate < min) {
                candidate = min;
              }
              if (Number.isFinite(max) && candidate > max) {
                candidate = max;
              }
              if (!Number.isFinite(candidate)) {
                candidate = 0;
              }
              return String(Math.max(0, Math.floor(candidate)));
            };

            let user = {};
            try {
              const parsed = JSON.parse(process.env.PARAMS_JSON || '{}');
              if (parsed && typeof parsed === 'object') {
                user = parsed;
              }
            } catch (error) {
              core.warning(`Bad params_json; using defaults. Parse error: ${error.message}`);
            }

            const merged = { ...DEFAULTS, ...user };
            const workflowDryRun = process.env.WORKFLOW_DRY_RUN;
            if (workflowDryRun !== undefined && workflowDryRun !== null && workflowDryRun !== '') {
              merged.dry_run = workflowDryRun;
            }

            const workflowOptionsJson = process.env.WORKFLOW_OPTIONS_JSON;
            if (workflowOptionsJson !== undefined && workflowOptionsJson !== null && workflowOptionsJson.trim() !== '') {
              merged.options_json = workflowOptionsJson;
            }

            const workflowKeepaliveEnabled = process.env.WORKFLOW_KEEPALIVE_ENABLED;
            if (
              workflowKeepaliveEnabled !== undefined &&
              workflowKeepaliveEnabled !== null &&
              workflowKeepaliveEnabled !== ''
            ) {
              merged.enable_keepalive = workflowKeepaliveEnabled;
            }

            const readinessAgents = toCsv(merged.readiness_agents, DEFAULTS.readiness_agents);
            const readinessCustom = toCsv(
              merged.readiness_custom_logins ?? merged.readiness_custom ?? merged.custom_logins,
              DEFAULTS.readiness_custom_logins
            );
            const codexUser = toString(merged.codex_user, DEFAULTS.codex_user);
            const codexCommand = toString(merged.codex_command_phrase, DEFAULTS.codex_command_phrase);
            const verifyIssueNumber = toString(merged.verify_issue_number, DEFAULTS.verify_issue_number).trim();
            const verifyIssueAssignees = toCsv(
              merged.verify_issue_valid_assignees ?? merged.valid_assignees,
              DEFAULT_VERIFY_ISSUE_ASSIGNEES
            );

            const bootstrap = nested(merged.bootstrap);
            const keepalive = nested(merged.keepalive);

            const dryRun = toBoolString(merged.dry_run, DEFAULTS.dry_run);

            const diagnosticModeRaw = toString(merged.diagnostic_mode, DEFAULTS.diagnostic_mode).trim().toLowerCase();
            const diagnosticMode = ['full', 'dry-run'].includes(diagnosticModeRaw) ? diagnosticModeRaw : 'off';

            const enableVerifyIssue = toBoolString(
              merged.enable_verify_issue,
              verifyIssueNumber !== '' ? 'true' : DEFAULTS.enable_verify_issue
            );

            const sanitiseOptions = (value) => {
              if (value === undefined || value === null || value === '') {
                return DEFAULT_OPTIONS_JSON;
              }
              if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed) {
                  return DEFAULT_OPTIONS_JSON;
                }
                try {
                  const parsed = JSON.parse(trimmed);
                  return JSON.stringify(parsed);
                } catch (error) {
                  core.warning(`options_json is not valid JSON (${error.message}); using default.`);
                  return DEFAULT_OPTIONS_JSON;
                }
              }
              if (typeof value === 'object') {
                try {
                  return JSON.stringify(value);
                } catch (error) {
                  core.warning(`options_json could not be serialised (${error.message}); using default.`);
                  return DEFAULT_OPTIONS_JSON;
                }
              }
              return DEFAULT_OPTIONS_JSON;
            };

            const optionsSource = merged.options_json ?? merged.options ?? DEFAULT_OPTIONS_JSON;
            const sanitisedOptions = sanitiseOptions(optionsSource);

            let parsedOptions = {};
            try {
              parsedOptions = JSON.parse(sanitisedOptions);
            } catch (error) {
              core.warning(`options_json could not be parsed (${error.message}); using defaults.`);
            }

            const beltOptions = nested(parsedOptions.belt ?? parsedOptions.codex_belt);
            const dispatcherOptions = nested(beltOptions.dispatcher ?? parsedOptions.dispatcher);
            const workerOptions = nested(beltOptions.worker ?? parsedOptions.worker);
            const conveyorOptions = nested(beltOptions.conveyor ?? parsedOptions.conveyor);

            const dispatcherForceIssue = toString(
              dispatcherOptions.force_issue ?? merged.dispatcher_force_issue,
              DEFAULTS.dispatcher_force_issue
            );

            const workerMaxParallel = toBoundedIntegerString(
              workerOptions.max_parallel ?? workerOptions.parallel ?? merged.worker_max_parallel,
              DEFAULTS.worker_max_parallel,
              { min: 0, max: 5 }
            );

            const conveyorMaxMerges = toBoundedIntegerString(
              conveyorOptions.max_merges ?? conveyorOptions.limit ?? merged.conveyor_max_merges,
              DEFAULTS.conveyor_max_merges,
              { min: 0, max: 5 }
            );

            const keepaliveRequested = toBoolString(
              merged.enable_keepalive ?? keepalive.enabled,
              DEFAULTS.enable_keepalive
            );

            const { owner, repo } = context.repo;
            let keepalivePaused = false;

            if (keepaliveRequested === 'true') {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: KEEPALIVE_PAUSE_LABEL });
                keepalivePaused = true;
                core.info(`keepalive skipped: repository label "${KEEPALIVE_PAUSE_LABEL}" is present.`);
              } catch (error) {
                if (error && error.status === 404) {
                  core.info(`Keepalive pause label "${KEEPALIVE_PAUSE_LABEL}" not present; keepalive remains enabled.`);
                } else {
                  const message = error instanceof Error ? error.message : String(error);
                  core.warning(`Unable to resolve keepalive pause label (${message}); proceeding with keepalive.`);
                }
              }
            } else {
              core.info('Keepalive disabled via configuration; skipping pause label check.');
            }

            const keepaliveEffective = keepalivePaused ? 'false' : keepaliveRequested;

            const outputs = {
              enable_readiness: toBoolString(merged.enable_readiness, DEFAULTS.enable_readiness),
              readiness_agents: readinessAgents,
              readiness_custom_logins: readinessCustom,
              require_all: toBoolString(merged.require_all, DEFAULTS.require_all),
              enable_preflight: toBoolString(merged.enable_preflight, DEFAULTS.enable_preflight),
              codex_user: codexUser,
              codex_command_phrase: codexCommand,
              enable_diagnostic: diagnosticMode === 'off' ? 'false' : 'true',
              diagnostic_attempt_branch: diagnosticMode === 'full' ? 'true' : 'false',
              diagnostic_dry_run: diagnosticMode === 'full' ? 'false' : 'true',
              enable_verify_issue: enableVerifyIssue,
              verify_issue_number: verifyIssueNumber,
              verify_issue_valid_assignees: verifyIssueAssignees,
              enable_watchdog: toBoolString(merged.enable_watchdog, DEFAULTS.enable_watchdog),
              enable_keepalive: keepaliveEffective,
              keepalive_requested: keepaliveRequested,
              keepalive_paused_label: keepalivePaused ? 'true' : 'false',
              keepalive_pause_label: KEEPALIVE_PAUSE_LABEL,
              enable_bootstrap: toBoolString(merged.enable_bootstrap ?? bootstrap.enable, DEFAULTS.enable_bootstrap),
              bootstrap_issues_label: toString(
                merged.bootstrap_issues_label ?? bootstrap.label,
                DEFAULTS.bootstrap_issues_label
              ),
              draft_pr: toBoolString(merged.draft_pr, DEFAULTS.draft_pr),
              dry_run: dryRun,
              options_json: sanitisedOptions,
              dispatcher_force_issue: dispatcherForceIssue,
              worker_max_parallel: workerMaxParallel,
              conveyor_max_merges: conveyorMaxMerges
            };

            const orderedKeys = [
              'enable_readiness',
              'readiness_agents',
              'readiness_custom_logins',
              'require_all',
              'enable_preflight',
              'codex_user',
              'codex_command_phrase',
              'enable_diagnostic',
              'diagnostic_attempt_branch',
              'diagnostic_dry_run',
              'enable_verify_issue',
              'verify_issue_number',
              'verify_issue_valid_assignees',
              'enable_watchdog',
              'enable_keepalive',
              'keepalive_requested',
              'keepalive_paused_label',
              'keepalive_pause_label',
              'enable_bootstrap',
              'bootstrap_issues_label',
              'draft_pr',
              'dry_run',
              'options_json',
              'dispatcher_force_issue',
              'worker_max_parallel',
              'conveyor_max_merges'
            ];

            const summarise = (value) => {
              const text = String(value ?? '');
              const limit = 120;
              const separator = ' … ';
              if (text.length <= limit) {
                return text;
              }
              const available = limit - separator.length;
              const headLen = Math.ceil(available / 2);
              const tailLen = Math.floor(available / 2);
              const head = text.slice(0, headLen).trimEnd();
              const tail = text.slice(-tailLen).trimStart();
              return `${head}${separator}${tail}`;
            };

            for (const key of orderedKeys) {
              if (Object.prototype.hasOwnProperty.call(outputs, key)) {
                core.setOutput(key, outputs[key]);
              }
            }

            const summary = core.summary;
            summary.addHeading('Agents orchestrator parameters');
            summary.addTable([
              [{ data: 'Parameter', header: true }, { data: 'Value', header: true }],
              ...orderedKeys.map((key) => [key, summarise(outputs[key])])
            ]);
            if (keepalivePaused) {
              summary.addRaw(`keepalive skipped because the ${KEEPALIVE_PAUSE_LABEL} label is present.`).addEOL();
            } else if (keepaliveRequested !== keepaliveEffective) {
              summary
                .addRaw('keepalive disabled via configuration overrides (input or params).')
                .addEOL();
            }
            await summary.write();

  orchestrate:
    name: Dispatch Agents Toolkit
    needs: resolve-params
    uses: ./.github/workflows/reusable-16-agents.yml
    # Job timeouts live inside reusable-16-agents.yml to satisfy workflow_call constraints.
    with:
      enable_readiness: ${{ needs.resolve-params.outputs.enable_readiness }}
      readiness_agents: ${{ needs.resolve-params.outputs.readiness_agents }}
      readiness_custom_logins: ${{ needs.resolve-params.outputs.readiness_custom_logins }}
      require_all: ${{ needs.resolve-params.outputs.require_all }}
      enable_preflight: ${{ needs.resolve-params.outputs.enable_preflight }}
      codex_user: ${{ needs.resolve-params.outputs.codex_user }}
      codex_command_phrase: ${{ needs.resolve-params.outputs.codex_command_phrase }}
      enable_diagnostic: ${{ needs.resolve-params.outputs.enable_diagnostic }}
      diagnostic_attempt_branch: ${{ needs.resolve-params.outputs.diagnostic_attempt_branch }}
      diagnostic_dry_run: ${{ needs.resolve-params.outputs.diagnostic_dry_run }}
      enable_verify_issue: ${{ needs.resolve-params.outputs.enable_verify_issue }}
      verify_issue_number: ${{ needs.resolve-params.outputs.verify_issue_number }}
      enable_watchdog: ${{ needs.resolve-params.outputs.enable_watchdog }}
      enable_keepalive: ${{ needs.resolve-params.outputs.enable_keepalive }}
      enable_bootstrap: ${{ needs.resolve-params.outputs.enable_bootstrap }}
      bootstrap_issues_label: ${{ needs.resolve-params.outputs.bootstrap_issues_label }}
      draft_pr: ${{ needs.resolve-params.outputs.draft_pr }}
      verify_issue_valid_assignees: ${{ needs.resolve-params.outputs.verify_issue_valid_assignees }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run }}
      options_json: ${{ needs.resolve-params.outputs.options_json }}

  verify-assignment:
    name: Verify Assignment
    needs: resolve-params
    if: needs.resolve-params.outputs.enable_verify_issue == 'true' && needs.resolve-params.outputs.verify_issue_number != ''
    uses: ./.github/workflows/agents-64-verify-agent-assignment.yml
    with:
      issue_number: ${{ needs.resolve-params.outputs.verify_issue_number }}
      valid_assignees: ${{ needs.resolve-params.outputs.verify_issue_valid_assignees }}

  verify-assignment-summary:
    name: Record Verification Outcome
    needs:
      - resolve-params
      - verify-assignment
    if: |
      needs.resolve-params.outputs.enable_verify_issue == 'true' &&
      needs.resolve-params.outputs.verify_issue_number != '' &&
      needs.verify-assignment.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Append verification summary
        env:
          ISSUE_NUMBER: ${{ needs.resolve-params.outputs.verify_issue_number }}
          STATUS: ${{ needs.verify-assignment.outputs.status }}
          MESSAGE: ${{ needs.verify-assignment.outputs.message }}
          MATCHED: ${{ needs.verify-assignment.outputs.matched_assignee }}
          REPOSITORY: ${{ github.repository }}
        run: |
          cat <<-'EOF' >> "$GITHUB_STEP_SUMMARY"
          ## Agent issue verification
          * Issue: [#${ISSUE_NUMBER}](https://github.com/${REPOSITORY}/issues/${ISSUE_NUMBER})
          * Status: ${STATUS}
          * Matched assignee: ${MATCHED:-_none_}
          EOF

          if [ -n "${MESSAGE}" ]; then
            echo "${MESSAGE}"
          fi

  belt-dispatch:
    name: Codex Belt Dispatcher
    needs: resolve-params
    uses: ./.github/workflows/agents-71-codex-belt-dispatcher.yml
    with:
      force_issue: ${{ needs.resolve-params.outputs.dispatcher_force_issue }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' }}
    secrets:
      actions_bot_pat: ${{ secrets.ACTIONS_BOT_PAT }}

  belt-worker:
    name: Codex Belt Worker
    needs:
      - resolve-params
      - belt-dispatch
    if: |
      needs.resolve-params.outputs.worker_max_parallel != '0' &&
      needs.belt-dispatch.outputs.issue != ''
    uses: ./.github/workflows/agents-72-codex-belt-worker.yml
    with:
      issue: ${{ needs.belt-dispatch.outputs.issue }}
      branch: ${{ needs.belt-dispatch.outputs.branch }}
      base: ${{ needs.belt-dispatch.outputs.base }}
      source: ${{ needs.belt-dispatch.outputs.reason }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' || needs.belt-dispatch.outputs.dry_run == 'true' }}
      max_parallel: ${{ fromJson(needs.resolve-params.outputs.worker_max_parallel || '1') }}
    secrets:
      actions_bot_pat: ${{ secrets.ACTIONS_BOT_PAT }}

  belt-dispatch-summary:
    name: Summarise Codex dispatch outcomes
    needs:
      - belt-dispatch
      - belt-worker
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Append dispatch summary
        uses: actions/github-script@v7
        env:
          DISPATCH_RESULT: ${{ needs.belt-dispatch.result || '' }}
          DISPATCH_ISSUE: ${{ needs.belt-dispatch.outputs.issue || '' }}
          DISPATCH_REASON: ${{ needs.belt-dispatch.outputs.reason || '' }}
          WORKER_RESULT: ${{ needs.belt-worker.result || '' }}
          WORKER_ALLOWED: ${{ needs.belt-worker.outputs.allowed || '' }}
          WORKER_PR_NUMBER: ${{ needs.belt-worker.outputs.pr_number || '' }}
          WORKER_BRANCH: ${{ needs.belt-worker.outputs.branch || '' }}
          WORKER_DRY_RUN: ${{ needs.belt-worker.outputs.dry_run || '' }}
        with:
          script: |
            const dispatchResult = (process.env.DISPATCH_RESULT || '').trim().toLowerCase();
            const workerResult = (process.env.WORKER_RESULT || '').trim().toLowerCase();
            const workerAllowed = (process.env.WORKER_ALLOWED || '').trim().toLowerCase();
            const dispatchedIssue = (process.env.DISPATCH_ISSUE || '').trim();
            const dispatchReason = (process.env.DISPATCH_REASON || '').trim() || 'unknown';
            const workerDryRun = (process.env.WORKER_DRY_RUN || '').trim().toLowerCase();
            const prNumber = (process.env.WORKER_PR_NUMBER || '').trim();
            const workerBranch = (process.env.WORKER_BRANCH || '').trim();

            let success = 0;
            let skipped = 0;
            let failures = 0;

            const normalise = (value) => {
              if (!value) {
                return 'unknown';
              }
              return value.toLowerCase();
            };

            const dispatchState = normalise(dispatchResult);
            const workerState = normalise(workerResult);

            if (dispatchState === 'success' && dispatchedIssue) {
              if (workerState === 'success') {
                success += 1;
              } else if (['failure', 'cancelled'].includes(workerState)) {
                failures += 1;
              } else if (workerState === 'skipped' || workerAllowed === 'false') {
                skipped += 1;
              } else {
                skipped += 1;
              }
            } else if (dispatchState === 'success') {
              skipped += 1;
            } else if (dispatchState === 'skipped' || dispatchState === 'cancelled') {
              skipped += 1;
            } else if (dispatchState === 'failure') {
              failures += 1;
            } else {
              skipped += 1;
            }

            const summary = core.summary;
            summary
              .addRaw(`Dispatch succeeded for ${success} PRs; ${skipped} skipped; ${failures} failures.`)
              .addEOL();

            const rows = [
              [
                { data: 'PR', header: true },
                { data: 'Issue', header: true },
                { data: 'Reason', header: true },
                { data: 'Worker Result', header: true },
                { data: 'Branch', header: true }
              ]
            ];

            const prLink = () => {
              if (!prNumber) {
                return workerDryRun === 'true' || workerAllowed === 'false' ? '— (preview)' : '—';
              }
              const { owner, repo } = context.repo;
              const url = `https://github.com/${owner}/${repo}/pull/${prNumber}`;
              return `<a href="${url}">#${prNumber}</a>`;
            };

            const issueLink = () => {
              if (!dispatchedIssue) {
                return '—';
              }
              const { owner, repo } = context.repo;
              const url = `https://github.com/${owner}/${repo}/issues/${dispatchedIssue}`;
              return `<a href="${url}">#${dispatchedIssue}</a>`;
            };

            const branchInfo = workerBranch ? `\`${workerBranch}\`` : '—';
            const workerLabel = workerAllowed === 'false' ? 'blocked' : workerState;

            rows.push([
              prLink(),
              issueLink(),
              dispatchReason || 'unknown',
              workerDryRun === 'true' ? 'preview' : workerLabel,
              branchInfo,
            ]);

            summary.addTable(rows);
            await summary.write();

  belt-scan-ready-prs:
    name: Scan Codex promotion queue
    needs: resolve-params
    runs-on: ubuntu-latest
    outputs:
      items: ${{ steps.scan.outputs.items || '[]' }}
    env:
      MAX_PROMOTIONS: ${{ needs.resolve-params.outputs.conveyor_max_merges }}
    steps:
      - name: Identify ready Codex PRs
        id: scan
        uses: actions/github-script@v7
        with:
          script: |
            const maxPromotionsRaw = process.env.MAX_PROMOTIONS || '0';
            const maxPromotions = Math.max(0, Math.floor(Number(maxPromotionsRaw || '0')));
            const { owner, repo } = context.repo;
            const { data: pulls } = await github.rest.pulls.list({ owner, repo, state: 'open', per_page: 50 });
            const candidates = [];

            for (const pr of pulls) {
              if (!pr || typeof pr !== 'object') {
                continue;
              }
              const branch = pr.head && pr.head.ref ? pr.head.ref : '';
              if (!/^codex\/issue-\d+$/.test(branch)) {
                continue;
              }
              if (pr.draft) {
                continue;
              }
              const headSha = pr.head && pr.head.sha ? pr.head.sha : '';
              if (!headSha) {
                continue;
              }
              const { data: status } = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: headSha });
              if (!status || status.state !== 'success') {
                continue;
              }
              const issueMatch = branch.match(/^codex\/issue-(\d+)$/);
              const issue = issueMatch ? Number(issueMatch[1]) : null;
              candidates.push({
                pr: pr.number,
                issue,
                branch,
                head_sha: headSha,
              });
              if (maxPromotions && candidates.length >= maxPromotions) {
                break;
              }
            }

            const summary = core.summary;
            summary
              .addHeading('Codex belt conveyor scan')
              .addRaw(`Ready pull requests: ${candidates.length}`)
              .addEOL();
            if (candidates.length) {
              summary.addTable([
                [{ data: 'PR', header: true }, { data: 'Issue', header: true }, { data: 'Branch', header: true }],
                ...candidates.map((entry) => [
                  `#${entry.pr}`,
                  entry.issue ? `#${entry.issue}` : '(unknown)',
                  entry.branch,
                ])
              ]);
            }
            await summary.write();

            core.setOutput('items', JSON.stringify(candidates));

  belt-conveyor:
    name: Promote Codex PRs
    needs:
      - resolve-params
      - belt-scan-ready-prs
    if: |
      needs.resolve-params.outputs.conveyor_max_merges != '0' &&
      needs.belt-scan-ready-prs.outputs.items != '' &&
      needs.belt-scan-ready-prs.outputs.items != '[]'
    strategy:
      matrix:
        pr: ${{ fromJson(needs.belt-scan-ready-prs.outputs.items) }}
    uses: ./.github/workflows/agents-73-codex-belt-conveyor.yml
    with:
      issue: ${{ matrix.pr.issue || 0 }}
      branch: ${{ matrix.pr.branch }}
      pr_number: ${{ matrix.pr.pr }}
      head_sha: ${{ matrix.pr.head_sha }}
      dry_run: ${{ needs.resolve-params.outputs.dry_run == 'true' }}
    secrets:
      actions_bot_pat: ${{ secrets.ACTIONS_BOT_PAT }}
