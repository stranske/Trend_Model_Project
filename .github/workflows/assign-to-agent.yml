name: Assign to Agent (Issues + PRs)

'on':
  issues:
    types: [opened, labeled, reopened]
  workflow_dispatch:
    inputs:
      codex_command:
        description: "Command to kick Codex after assignment / bootstrap"
        required: false
        default: "codex: start"
      codex_pr_mode:
        description: "Codex PR creation mode: auto | manual"
        required: false
        default: "auto"

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  assign:
    name: Detect Codex Issue
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      contents: read
    outputs:
      needs_codex_bootstrap: ${{ steps.detect.outputs.needs_codex_bootstrap }}
      codex_issue: ${{ steps.detect.outputs.codex_issue }}
    steps:
      - name: Detect label
        id: detect
        uses: actions/github-script@v7
        with:
          script: |
            try {
              if (context.eventName !== 'issues') {
                core.setOutput('needs_codex_bootstrap', 'false');
                core.setOutput('codex_issue', '');
                return;
              }
              const labels = (context.payload.issue?.labels || []).map(l => (l.name || '').toLowerCase());
              const has = labels.includes('agent:codex');
              core.setOutput('needs_codex_bootstrap', has ? 'true' : 'false');
              core.setOutput('codex_issue', has ? String(context.payload.issue.number) : '');
            } catch (e) {
              core.warning('detection failed: ' + e.message);
              core.setOutput('needs_codex_bootstrap', 'false');
              core.setOutput('codex_issue', '');
            }
      - name: Summary comment (non-fatal)
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            if (context.eventName !== 'issues') return;
            const marker = '<!-- codex-agent-summary -->';
            const { owner, repo } = context.repo;
            const issue_number = context.payload.issue.number;
            const needs = '${{ steps.detect.outputs.needs_codex_bootstrap }}' === 'true';
            const summary = { issue: issue_number, needs_codex_bootstrap: needs, ts: new Date().toISOString() };
            const body = `${marker}\n\n\`\`\`json\n${JSON.stringify(summary, null, 2)}\n\`\`\``;
            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number, per_page: 100 });
            const existing = comments.find(c => c.body && c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }

  codex_bootstrap:
    name: Codex Bootstrap
    needs: assign
    if: needs.assign.outputs.needs_codex_bootstrap == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
      - name: Codex bootstrap
        id: bootstrap
        uses: ./.github/actions/codex-bootstrap
        with:
          issue: ${{ needs.assign.outputs.codex_issue }}
          service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
          codex_command: ${{ github.event.inputs.codex_command }}
          pr_mode: ${{ github.event.inputs.codex_pr_mode || 'auto' }}
          allow_fallback: 'true'
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: codex-bootstrap-${{ github.run_id }}
          path: codex-artifacts

        permissions:
          contents: read
          issues: write
          pull-requests: write

        jobs:
          assign:
            name: Detect Codex Issue
            runs-on: ubuntu-latest
            outputs:
              needs_codex_bootstrap: ${{ steps.detect.outputs.needs_codex_bootstrap }}
              codex_issue: ${{ steps.detect.outputs.codex_issue }}
            steps:
              - name: Detect label
                id: detect
                uses: actions/github-script@v7
                with:
                  script: |
                    try {
                      if (context.eventName !== 'issues') { core.setOutput('needs_codex_bootstrap','false'); core.setOutput('codex_issue',''); return; }
                      const labels = (context.payload.issue?.labels||[]).map(l=> (l.name||'').toLowerCase());
                      const has = labels.includes('agent:codex');
                      core.setOutput('needs_codex_bootstrap', has ? 'true':'false');
                      core.setOutput('codex_issue', has ? String(context.payload.issue.number):'');
                    } catch(e){ core.warning('detection failed: '+e.message); core.setOutput('needs_codex_bootstrap','false'); core.setOutput('codex_issue',''); }
              - name: Summary comment (non-fatal)
                if: always()
                uses: actions/github-script@v7
                with:
                  github-token: ${{ github.token }}
                  script: |
                    const marker='<!-- codex-agent-summary -->';
                    if (context.eventName!=='issues') return;
                    const { owner, repo } = context.repo;
                    const issue_number = context.payload.issue.number;
                    const needs = '${{ steps.detect.outputs.needs_codex_bootstrap }}'==='true';
                    const body = `${marker}\n\n\`\`\`json\n${JSON.stringify({ issue: issue_number, needs_codex_bootstrap: needs, ts:new Date().toISOString() },null,2)}\n\`\`\``;
                    const comments = await github.paginate(github.rest.issues.listComments,{owner,repo,issue_number,per_page:100});
                    const existing = comments.find(c=>c.body&&c.body.includes(marker));
                    if (existing) await github.rest.issues.updateComment({owner,repo,comment_id:existing.id,body}); else await github.rest.issues.createComment({owner,repo,issue_number,body});

          codex_bootstrap:
            needs: assign
            if: needs.assign.outputs.needs_codex_bootstrap == 'true'
            runs-on: ubuntu-latest
            permissions:
              contents: write
              issues: write
              pull-requests: write
            steps:
              - uses: actions/checkout@v4
              - name: Codex bootstrap
                id: bootstrap
                uses: ./.github/actions/codex-bootstrap
                with:
                  issue: ${{ needs.assign.outputs.codex_issue }}
                  service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
                  codex_command: ${{ github.event.inputs.codex_command }}
                  pr_mode: ${{ github.event.inputs.codex_pr_mode || 'auto' }}
                  allow_fallback: 'true'
              - name: Upload artifacts
                if: always()
                uses: actions/upload-artifact@v4
                with:
                  name: codex-bootstrap-${{ github.run_id }}
                  path: codex-artifacts
          
      - name: Debug Codex artifact directory
        if: always()
        run: |
          echo "Listing codex-artifacts directory (if present)";
          if [ -d codex-artifacts ]; then ls -l codex-artifacts; else echo "codex-artifacts directory missing"; fi

            // Marker detection
            const branch = `agents/codex-issue-${issue_number}`;
            const markerPath = `agents/.codex-bootstrap-${issue_number}.json`;
            async function exists(path, ref){
              try { await github.rest.repos.getContent({owner, repo, path, ref}); return true; } catch { return false; }
            }
            let baseSha; let baseBranch;
            try {
              const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
              baseBranch = repoInfo.default_branch || 'main';
              const { data: ref } = await github.rest.git.getRef({ owner, repo, ref: `heads/${baseBranch}` });
              baseSha = ref.object.sha;
            } catch (e) {
              core.setFailed(`Unable to resolve base branch SHA: ${e.message}`);
              return;
            }
            let branchExists = true;
            try { await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` }); } catch { branchExists = false; }
            if (!branchExists) {
              try {
                await github.rest.git.createRef({ owner, repo, ref: `refs/heads/${branch}`, sha: baseSha });
                core.info(`Created branch ${branch}`);
              } catch (e) {
                const msg = `Codex bootstrap blocked: unable to create branch ${branch} (permissions). ${e.status || ''} ${e.message}`;
                core.warning(msg);
                try { await github.rest.issues.createComment({ owner, repo, issue_number, body: msg + '\n\nEnsure GITHUB_TOKEN has contents:write and repo settings allow Actions to write branches. Optionally configure SERVICE_BOT_PAT with repo access.' }); } catch {}
                return;
              }
            }
            (async () => {
              const issue_number =
                getValidNumber(process.env.SUMMARY_ISSUE) ||
                getValidNumber(process.env.SUMMARY_PR);
              if (issue_number == null) { core.info('No issue/PR number available for summary comment'); return; }
              const summary = {
                event: process.env.SUMMARY_EVENT,
                issue: process.env.SUMMARY_ISSUE || null,
                pr: process.env.SUMMARY_PR || null,
                needs_codex_bootstrap: process.env.SUMMARY_NEEDS === 'true',
                codex_issue: process.env.SUMMARY_CODEX_ISSUE || null,
                copilot_assigned: process.env.SUMMARY_COPILOT === 'true',
                generic_agents: (process.env.SUMMARY_GENERIC || '').split(',').filter(Boolean),
                ts: new Date().toISOString()
              };
              const body = `${marker}\n\n\`\`\`json\n${JSON.stringify(summary, null, 2)}\n\`\`\`\n\n_Do not edit above block; updated automatically._`;
              const primaryResult = { ok: false, status: null };
              try {
                await upsert(github, issue_number, body);
                primaryResult.ok = true;
                core.info('JSON summary comment upserted with primary token.');
              } catch (e) {
                primaryResult.status = e.status || 'unknown';
                core.warning(`Primary token failed to upsert summary (status=${e.status || '?'} message=${e.message}).`);
              }
              if (!primaryResult.ok && process.env.SERVICE_BOT_PAT && process.env.GH_FALLBACK_TOKEN) {
                // PAT attempted and failed; retry once with fallback GITHUB_TOKEN
                try {
                  const { Octokit } = require('@octokit/rest');
                  const octo = new Octokit({ auth: process.env.GH_FALLBACK_TOKEN, request: { fetch: global.fetch } });
                  await upsert(octo, issue_number, body);
                  core.info('JSON summary comment upserted with fallback GITHUB_TOKEN.');
                } catch (e2) {
                  core.warning(`Fallback token also failed to upsert summary (status=${e2.status || '?'} message=${e2.message}). Proceeding without summary comment.`);
                }
              }
            })().catch(err => {
              core.warning('Non-fatal error in JSON summary step: ' + err.message);
            });

