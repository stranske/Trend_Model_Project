name: Assign to Agent (Issues + PRs)

on:
  issues:
    types: [opened, labeled, reopened]
  workflow_dispatch:
    inputs:
      codex_command:
        description: "Command to kick Codex after assignment / bootstrap"
        required: false
        default: "codex: start"
      codex_pr_mode:
        description: "Codex PR creation mode: auto | manual"
        required: false
        default: "auto"

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  assign:
    name: Detect Codex Issue
    runs-on: ubuntu-latest
    outputs:
      needs_codex_bootstrap: ${{ steps.detect.outputs.needs_codex_bootstrap }}
      codex_issue: ${{ steps.detect.outputs.codex_issue }}
    steps:
      - name: Detect label
        id: detect
        uses: actions/github-script@v7
        with:
          script: |
            try {
              if (context.eventName !== 'issues') {
                core.setOutput('needs_codex_bootstrap', 'false');
                core.setOutput('codex_issue', '');
                return;
              }
              const labels = (context.payload.issue?.labels || []).map(l => (l.name || '').toLowerCase());
              const has = labels.includes('agent:codex');
              core.setOutput('needs_codex_bootstrap', has ? 'true' : 'false');
              core.setOutput('codex_issue', has ? String(context.payload.issue.number) : '');
            } catch (e) {
              core.warning('detection failed: ' + e.message);
              core.setOutput('needs_codex_bootstrap', 'false');
              core.setOutput('codex_issue', '');
            }
      - name: Summary comment (non-fatal)
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            if (context.eventName !== 'issues') return;
            const marker = '<!-- codex-agent-summary -->';
            const { owner, repo } = context.repo;
            const issue_number = context.payload.issue.number;
            const needs = '${{ steps.detect.outputs.needs_codex_bootstrap }}' === 'true';
            const summary = { issue: issue_number, needs_codex_bootstrap: needs, ts: new Date().toISOString() };
            const body = `${marker}\n\n\`\`\`json\n${JSON.stringify(summary, null, 2)}\n\`\`\``;
            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number, per_page: 100 });
            const existing = comments.find(c => c.body && c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }

  codex_bootstrap:
    name: Codex Bootstrap
    needs: assign
    if: needs.assign.outputs.needs_codex_bootstrap == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
      - name: Codex bootstrap
        id: bootstrap
        uses: ./.github/actions/codex-bootstrap
        with:
          issue: ${{ needs.assign.outputs.codex_issue }}
          service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
          codex_command: ${{ github.event.inputs.codex_command }}
          pr_mode: ${{ github.event.inputs.codex_pr_mode || 'auto' }}
          allow_fallback: 'true'
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: codex-bootstrap-${{ github.run_id }}
          path: codex-artifacts

        permissions:
          contents: read
          issues: write
          pull-requests: write

        jobs:
          assign:
            name: Detect Codex Issue
            runs-on: ubuntu-latest
            outputs:
              needs_codex_bootstrap: ${{ steps.detect.outputs.needs_codex_bootstrap }}
              codex_issue: ${{ steps.detect.outputs.codex_issue }}
            steps:
              - name: Detect label
                id: detect
                uses: actions/github-script@v7
                with:
                  script: |
                    try {
                      if (context.eventName !== 'issues') { core.setOutput('needs_codex_bootstrap','false'); core.setOutput('codex_issue',''); return; }
                      const labels = (context.payload.issue?.labels||[]).map(l=> (l.name||'').toLowerCase());
                      const has = labels.includes('agent:codex');
                      core.setOutput('needs_codex_bootstrap', has ? 'true':'false');
                      core.setOutput('codex_issue', has ? String(context.payload.issue.number):'');
                    } catch(e){ core.warning('detection failed: '+e.message); core.setOutput('needs_codex_bootstrap','false'); core.setOutput('codex_issue',''); }
              - name: Summary comment (non-fatal)
                if: always()
                uses: actions/github-script@v7
                with:
                  github-token: ${{ github.token }}
                  script: |
                    const marker='<!-- codex-agent-summary -->';
                    if (context.eventName!=='issues') return;
                    const { owner, repo } = context.repo;
                    const issue_number = context.payload.issue.number;
                    const needs = '${{ steps.detect.outputs.needs_codex_bootstrap }}'==='true';
                    const body = `${marker}\n\n\`\`\`json\n${JSON.stringify({ issue: issue_number, needs_codex_bootstrap: needs, ts:new Date().toISOString() },null,2)}\n\`\`\``;
                    const comments = await github.paginate(github.rest.issues.listComments,{owner,repo,issue_number,per_page:100});
                    const existing = comments.find(c=>c.body&&c.body.includes(marker));
                    if (existing) await github.rest.issues.updateComment({owner,repo,comment_id:existing.id,body}); else await github.rest.issues.createComment({owner,repo,issue_number,body});

          codex_bootstrap:
            needs: assign
            if: needs.assign.outputs.needs_codex_bootstrap == 'true'
            runs-on: ubuntu-latest
            permissions:
              contents: write
              issues: write
              pull-requests: write
            steps:
              - uses: actions/checkout@v4
              - name: Codex bootstrap
                id: bootstrap
                uses: ./.github/actions/codex-bootstrap
                with:
                  issue: ${{ needs.assign.outputs.codex_issue }}
                  service_bot_pat: ${{ secrets.SERVICE_BOT_PAT }}
                  codex_command: ${{ github.event.inputs.codex_command }}
                  pr_mode: ${{ github.event.inputs.codex_pr_mode || 'auto' }}
                  allow_fallback: 'true'
              - name: Upload artifacts
                if: always()
                uses: actions/upload-artifact@v4
                with:
                  name: codex-bootstrap-${{ github.run_id }}
                  path: codex-artifacts
          
          name: codex-bootstrap-${{ github.run_id }}
          path: codex-artifacts
      - name: Debug Codex artifact directory
        if: always()
        run: |
          echo "Listing codex-artifacts directory (if present)";
          if [ -d codex-artifacts ]; then ls -l codex-artifacts; else echo "codex-artifacts directory missing"; fi

            // Marker detection
            const branch = `agents/codex-issue-${issue_number}`;
            const markerPath = `agents/.codex-bootstrap-${issue_number}.json`;
            async function exists(path, ref){
              try { await github.rest.repos.getContent({owner, repo, path, ref}); return true; } catch { return false; }
            }
            let baseSha; let baseBranch;
            try {
              const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
              baseBranch = repoInfo.default_branch || 'main';
              const { data: ref } = await github.rest.git.getRef({ owner, repo, ref: `heads/${baseBranch}` });
              baseSha = ref.object.sha;
            } catch (e) {
              core.setFailed(`Unable to resolve base branch SHA: ${e.message}`);
              return;
            }
            let branchExists = true;
            try { await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` }); } catch { branchExists = false; }
            if (!branchExists) {
              try {
                await github.rest.git.createRef({ owner, repo, ref: `refs/heads/${branch}`, sha: baseSha });
                core.info(`Created branch ${branch}`);
              } catch (e) {
                const msg = `Codex bootstrap blocked: unable to create branch ${branch} (permissions). ${e.status || ''} ${e.message}`;
                core.warning(msg);
                try { await github.rest.issues.createComment({ owner, repo, issue_number, body: msg + '\n\nEnsure GITHUB_TOKEN has contents:write and repo settings allow Actions to write branches. Optionally configure SERVICE_BOT_PAT with repo access.' }); } catch {}
                return;
              }
            } else {
              core.info(`Branch ${branch} already exists`);
            }
            if (await exists(markerPath, branch)) {
              core.info('Marker exists – bootstrap already performed. Emitting summary (idempotent).');
              let decoded; let issueBodyCached = '';
              try {
                const { data: markerFile } = await github.rest.repos.getContent({ owner, repo, path: markerPath, ref: branch });
                if (!Array.isArray(markerFile)) {
                  decoded = Buffer.from(markerFile.content, markerFile.encoding || 'base64').toString('utf8');
                  core.summary.addHeading('Codex Bootstrap (Previously Completed)').addCodeBlock(decoded, 'json').write();
                }
              } catch (e) { core.warning('Could not read marker for summary: ' + e.message); }
              // Fetch issue to allow suppression detection for parity (not strictly needed but keeps fields consistent)
              try { const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number }); issueBodyCached = issue.body || ''; } catch {}
              const suppressFromToken = (issueBodyCached || '').includes('[codex-suppress-activate]');
              const suppressFromInput = /true/i.test(String(process.env.CODEX_SUPPRESS_ACTIVATE_INPUT||''));
              const suppressFromEnv   = !!process.env.CODEX_SUPPRESS_ACTIVATE;
              const activationSuppressed = suppressFromEnv || suppressFromInput || suppressFromToken;
              // Parse marker for PR number and propagate outputs + artifact
              const parsed = (()=>{ try { return JSON.parse(decoded||'{}'); } catch { return {}; } })();
              if (parsed.pr) core.setOutput('codex_pr', String(parsed.pr));
              core.setOutput('codex_reused', 'true');
              const prAuthor = parsed.pr_author || null;
              try {
                const fs = require('fs');
                fs.mkdirSync('codex-artifacts', { recursive: true });
                fs.writeFileSync('codex-artifacts/codex_bootstrap_result.json', JSON.stringify({
                  reused: true,
                  issue: issue_number,
                  pr: parsed.pr || null,
                  branch,
                  base: baseBranch,
                  suppression: activationSuppressed,
                  token_source: tokenSource,
                  pr_author: prAuthor,
                  ts: new Date().toISOString()
                }, null, 2));
                // Copy marker snapshot for convenience
                if (decoded) fs.writeFileSync('codex-artifacts/marker_snapshot.json', decoded);
                fs.writeFileSync('codex-artifacts/README.txt', 'Codex bootstrap artifacts. Fields:\n- codex_bootstrap_result.json: structured summary\n- marker_snapshot.json: on-branch marker file copy (if available)\n');
              } catch (e) { core.warning('Failed to write codex_bootstrap_result.json: ' + e.message); }
              console.log('CODEX_BOOTSTRAP_RESULT:' + JSON.stringify({ reused: true, issue: issue_number, pr: parsed.pr || null, branch, base: baseBranch, suppression: activationSuppressed, token_source: tokenSource, pr_author: prAuthor }));
              return;
            }
            const path = `agents/codex-${issue_number}.md`;
            const content = Buffer.from(`<!-- bootstrap for codex on issue #${issue_number} -->\n`).toString('base64');
            let sha;
            try { const probe = await github.rest.repos.getContent({ owner, repo, path, ref: branch }); if (!Array.isArray(probe.data)) sha = probe.data.sha; } catch {}
            await github.rest.repos.createOrUpdateFileContents({ owner, repo, path, branch, message: `chore(codex): bootstrap PR for issue #${issue_number}`, content, sha });
            // Pull issue details to replicate content into PR body
            let issueTitle = '(no title)';
            let issueBody  = '(no body provided)';
            try {
              const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number });
              issueTitle = issue.title || issueTitle;
              issueBody  = issue.body  || issueBody;
            } catch (e) {
              core.warning(`Failed to fetch issue #${issue_number} for body replication: ${e.message}`);
            }
            // Determine PR mode (auto | manual)
            const prMode = (process.env.CODEX_PR_MODE || 'auto').toLowerCase();
            const manual = prMode === 'manual';
            if (manual) {
              // Write marker (no PR yet) so reruns stay idempotent
              const markerContent = Buffer.from(JSON.stringify({ issue: issue_number, pr: null, ts: new Date().toISOString(), mode: 'manual', token_source: tokenSource }, null, 2)).toString('base64');
              await github.rest.repos.createOrUpdateFileContents({ owner, repo, path: markerPath, branch, message: `chore(codex): mark manual bootstrap for #${issue_number}`, content: markerContent });
              await github.rest.issues.createComment({ owner, repo, issue_number, body: `Branch **${branch}** created. Manual mode is enabled (CODEX_PR_MODE=manual). Please open a draft PR from this branch targeting **${baseBranch}** so Codex can engage. Once open, label the PR with \`agent:codex\` or re-label this issue.` });
              core.summary.addHeading('Codex Bootstrap (Manual Mode)').addTable([[{data:'Issue',header:true},{data:'Branch',header:true},{data:'PR Created',header:true},{data:'Mode',header:true},{data:'TokenSource',header:true}], [String(issue_number), branch, 'false', 'manual', tokenSource]]).write();
              try {
                const fs = require('fs');
                fs.mkdirSync('codex-artifacts', { recursive: true });
                fs.writeFileSync('codex-artifacts/codex_bootstrap_result.json', JSON.stringify({ reused:false, issue:issue_number, pr:null, branch, base:baseBranch, manual:true, token_source: tokenSource, pr_author: null, ts:new Date().toISOString() }, null, 2));
              } catch (e) { core.warning('Failed to write codex_bootstrap_result.json (manual mode): ' + e.message); }
              console.log('CODEX_BOOTSTRAP_RESULT:' + JSON.stringify({ reused:false, issue:issue_number, pr:null, branch, base:baseBranch, manual:true, token_source: tokenSource, pr_author: null }));
              core.setOutput('codex_pr', '');
              core.setOutput('codex_reused', 'false');
              return;
            }
            // Suppression detection (inputs/env/token)
            const suppressFromToken = (issueBody || '').includes('[codex-suppress-activate]');
            const suppressFromInput = /true/i.test(String(process.env.CODEX_SUPPRESS_ACTIVATE_INPUT||''));
            const suppressFromEnv   = !!process.env.CODEX_SUPPRESS_ACTIVATE;
            const activationSuppressed = suppressFromEnv || suppressFromInput || suppressFromToken;
            const replicatedHeader = `### Source Issue #${issue_number}: ${issueTitle}`;
            const replicatedBody = `${replicatedHeader}\n\n---\n${issueBody}\n\n---\n\nThis draft PR was auto-created to engage Codex on the task above. All edits should occur on this branch.\n`;
            // Discover existing PR (open, head = branch) before attempting creation
            const { data: open } = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${branch}` });
            let prNumber; let prBodyNeedsUpdate = false; let existingPR; let prAuthorLogin = null;
            if (open.length) {
              existingPR = open[0];
              prNumber = existingPR.number;
              prAuthorLogin = existingPR.user && existingPR.user.login || null;
              if (!existingPR.body || !existingPR.body.includes(replicatedHeader)) prBodyNeedsUpdate = true;
            } else {
              const { data: pr } = await github.rest.pulls.create({ owner, repo, head: branch, base: baseBranch, draft: true, title: `Codex bootstrap for #${issue_number}`, body: replicatedBody });
              prNumber = pr.number;
              prAuthorLogin = pr.user && pr.user.login || null;
            }
            if (prBodyNeedsUpdate) {
              try {
                await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body: replicatedBody });
                core.info(`Updated existing PR #${prNumber} body to replicate issue content.`);
              } catch (e) {
                core.warning(`Unable to update PR #${prNumber} body: ${e.message}`);
              }
            }
            // --- Assignment phase with granular diagnostics (after PR exists) ---
            const human = 'stranske-automation-bot';
            async function assignPair(targetIssueOrPR) {
              try {
                await github.rest.issues.addAssignees({ owner, repo, issue_number: targetIssueOrPR, assignees: ['chatgpt-codex-connector', human] });
                core.info(`Assigned chatgpt-codex-connector + ${human} to #${targetIssueOrPR}`);
                return true;
              } catch (e) {
                core.warning(`Codex assignment failed on #${targetIssueOrPR}: status=${e.status || '?'} message="${e.message}"`);
                try {
                  await github.rest.issues.createComment({ owner, repo, issue_number: targetIssueOrPR, body: `:warning: Unable to assign chatgpt-codex-connector automatically (status ${e.status || '?'}). Ensure the bot has access or add it manually.\n\nError: ${e.message}` });
                } catch (c2) { core.warning('Secondary comment failed: ' + c2.message); }
                return false;
              }
            }
            const issueAssignOk = await assignPair(issue_number);
            const prAssignOk = await assignPair(prNumber);
            if (!issueAssignOk || !prAssignOk) {
              core.summary.addHeading('Codex Assignment Issues').addList([
                `Issue assignment ok: ${issueAssignOk}`,
                `PR assignment ok: ${prAssignOk}`
              ]).write();
            }
            // Explicit activation instructions comment (only once per bootstrap unless suppressed by CODEX_SUPPRESS_ACTIVATE)
            if (!activationSuppressed) {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `@chatgpt-codex-connector Please begin work on this task. Focus first on establishing a passing baseline, then implement required changes as described in the source issue #${issue_number}. Provide incremental commits and keep descriptions concise.` });
            } else {
              core.info('Activation comment suppressed (env/input/token).');
            }
            // Label and Codex command kickoff
            await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: ['agent:codex'] });
            let cmd = String(process.env.CODEX_COMMAND || 'codex: start').replace(/[\r\n`]/g,'').trim();
            if (!/^[a-zA-Z0-9 :\-]+$/.test(cmd)) { core.warning('Unsafe Codex command; defaulting.'); cmd = 'codex: start'; }
            if (!/^codex:/i.test(cmd)) cmd = 'codex: ' + cmd;
            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `${cmd}\n\nPlease create commits on this branch, run tests, and keep the PR updated.` });
            await github.rest.issues.createComment({ owner, repo, issue_number, body: `Opened draft PR #${prNumber} to engage Codex. Track work there.` });
            // Marker file to ensure idempotency on reruns
            const markerContent = Buffer.from(JSON.stringify({ issue: issue_number, pr: prNumber, ts: new Date().toISOString() }, null, 2)).toString('base64');
            await github.rest.repos.createOrUpdateFileContents({ owner, repo, path: markerPath, branch, message: `chore(codex): mark bootstrap for #${issue_number}`, content: markerContent });
            // Summary + outputs
            core.summary.addHeading('Codex Bootstrap').addTable([[
              {data:'Issue',header:true},{data:'PR',header:true},{data:'Branch',header:true},{data:'Reused',header:true},{data:'Suppressed',header:true},{data:'TokenSource',header:true},{data:'Author',header:true}
            ], [String(issue_number), String(prNumber), branch, 'false', String(activationSuppressed), tokenSource, prAuthorLogin || '(unknown)'] ]).write();
            core.setOutput('codex_pr', String(prNumber));
            core.setOutput('codex_reused', 'false');
            // Write structured artifact file (non-reused path)
            try {
              const fs = require('fs');
              fs.mkdirSync('codex-artifacts', { recursive: true });
              fs.writeFileSync('codex-artifacts/codex_bootstrap_result.json', JSON.stringify({
                reused: false,
                issue: issue_number,
                pr: prNumber,
                branch,
                base: baseBranch,
                assigned_issue: issueAssignOk,
                assigned_pr: prAssignOk,
                suppression: activationSuppressed,
                token_source: tokenSource,
                pr_author: prAuthorLogin,
                ts: new Date().toISOString()
              }, null, 2));
              fs.writeFileSync('codex-artifacts/README.txt', 'Codex bootstrap artifacts. Fields:\n- codex_bootstrap_result.json: structured summary\n- marker_snapshot.json: on-branch marker file copy (added on reuse)\n');
            } catch (e) { core.warning('Failed to write codex_bootstrap_result.json: ' + e.message); }
            // Structured console artifact line
            console.log('CODEX_BOOTSTRAP_RESULT:' + JSON.stringify({ reused: false, issue: issue_number, pr: prNumber, branch, base: baseBranch, assigned_issue: issueAssignOk, assigned_pr: prAssignOk, suppression: activationSuppressed, token_source: tokenSource, pr_author: prAuthorLogin }));

            // Token mismatch detection (PAT set but author still github-actions[bot])
            const mismatch = usingPAT && prAuthorLogin === 'github-actions[bot]';
            if (mismatch) {
              const msg = `:warning: Token mismatch – SERVICE_BOT_PAT was provided but PR author is github-actions[bot]. Check PAT permissions or organization policies.`;
              try { await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: msg }); } catch (e) { core.warning('Comment failed: ' + e.message); }
              core.warning('SERVICE_BOT_PAT present but PR author is github-actions[bot].');
              if (process.env.CODEX_FAIL_ON_TOKEN_MISMATCH) {
                core.setFailed('Failing due to CODEX_FAIL_ON_TOKEN_MISMATCH and author mismatch.');
              }
            }

      - name: Update JSON summary with bootstrap data
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.SERVICE_BOT_PAT != '' && env.SERVICE_BOT_PAT || github.token }}
          script: |
            const marker = '<!-- codex-agent-summary -->';
            const codexIssueRaw = '${{ needs.assign_or_backfill.outputs.codex_issue }}'.trim();
            if (!codexIssueRaw || !/^\d+$/.test(codexIssueRaw)) { core.info('No valid codex issue number; skip JSON bootstrap update'); return; }
            const issue_number = Number(codexIssueRaw);
            const { owner, repo } = context.repo;
            // Read bootstrap result json if present
            const fs = require('fs');
            let bootstrap = null;
            try {
              const raw = fs.readFileSync('codex-artifacts/codex_bootstrap_result.json','utf8');
              bootstrap = JSON.parse(raw);
            } catch (e) { core.warning('Failed to load bootstrap data: ' + e.message); }
            // Fetch existing summary comment
            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number, per_page: 100 });
            const existing = comments.find(c => c.body && c.body.includes(marker));
            if (!existing) { core.info('No existing summary comment to update (assignment job may have failed).'); return; }
            // Extract prior JSON
            const rx = /```json\n([\s\S]*?)\n```/m;
            const m = existing.body.match(rx);
            let prior = {};
            if (m) { try { prior = JSON.parse(m[1]); } catch (e) { core.warning('Failed to parse prior JSON: ' + e.message); } }
            const merged = { ...prior, bootstrap };
            merged.ts_bootstrap_update = new Date().toISOString();
            const newBody = `${marker}\n\n\`\`\`json\n${JSON.stringify(merged, null, 2)}\n\`\`\`\n\n_Do not edit above block; updated automatically._`;
            await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body: newBody });
            core.info('Updated JSON summary comment with bootstrap data.');
