name: Assign to Agent (Issues + PRs)

on:
  issues:
    types: [opened, labeled, reopened]
  pull_request_target:
    types: [opened, labeled, reopened]
  workflow_dispatch:
    inputs:
      scope:
        description: "Backfill scope: issues | prs | both"
        required: false
        default: "both"
      agents:
        description: "Comma-separated agent names for backfill (default: all known)"
        required: false
        default: ""
      codex_command:
        description: "Command to kick Codex after assignment (for PRs and bootstrap PRs)"
        required: false
        default: "codex: start"

permissions:
  issues: write
  pull-requests: write
  contents: read          # Base permission level; codex_bootstrap job sets contents: write in its own elevated permissions section

concurrency:
  group: assign-agent-${{ github.event_name }}-${{ github.event.issue.number || github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  assign_or_backfill:
    runs-on: ubuntu-latest
    outputs:
      needs_codex_bootstrap: ${{ steps.decide.outputs.needs_codex_bootstrap }}
      codex_issue: ${{ steps.decide.outputs.codex_issue }}
      copilot_assigned: ${{ steps.assign_or_backfill.outputs.copilot_assigned }}
      generic_agents: ${{ steps.assign_or_backfill.outputs.generic_agents }}
    env:
      CODEX_COMMAND: ${{ github.event.inputs.codex_command }}
      ALLOWED_FALLBACKS: ${{ vars.ALLOWED_FALLBACKS || '' }}
      SERVICE_BOT_PAT: ${{ secrets.SERVICE_BOT_PAT }}
    steps:
      # Optional registry override file
      - uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/agents.json
          sparse-checkout-cone-mode: false

      - name: Debug event snapshot
        uses: actions/github-script@v7
        with:
          script: |
            const e = context;
            const payload = {
              event: e.eventName,
              action: e.payload.action,
              issue_number: e.payload.issue?.number,
              pr_number: e.payload.pull_request?.number,
              event_label: (e.payload.label?.name || '').toLowerCase(),
              issue_labels: (e.payload.issue?.labels || []).map(l => (l.name || '').toLowerCase()),
              pr_labels: (e.payload.pull_request?.labels || []).map(l => (l.name || '').toLowerCase()),
            };
            core.info('EVENT DEBUG:\n' + JSON.stringify(payload, null, 2));

      - name: Assign or backfill
        id: assign_or_backfill
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ env.SERVICE_BOT_PAT }}
        with:
          github-token: ${{ env.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const number = (context.payload.issue?.number ?? context.payload.pull_request?.number);
            const eventName = context.eventName;
            const labelPayload = (context.payload.issue?.labels || context.payload.pull_request?.labels || []).map(l => (l.name||'').toLowerCase());
            let codexLabelPresent = labelPayload.includes('agent:codex');
            let copilotAssigned = false;
            const genericAssigned = [];

            // ---- Agent registry (defaults + optional .github/agents.json override) ----
            const DEFAULTS = {
              copilot: { assignee: 'copilot', mention: '@copilot', aliases: ['copilot'] },
              codex:   { assignee: 'chatgpt-codex-connector', mention: '@chatgpt-codex-connector', aliases: ['codex','chatgpt-codex-connector'] }
            };
            const fs = require('fs');
            let REGISTRY = JSON.parse(JSON.stringify(DEFAULTS));
            try {
              if (fs.existsSync('.github/agents.json')) {
                const extra = JSON.parse(fs.readFileSync('.github/agents.json','utf8'));
                for (const [k,v] of Object.entries(extra || {})) {
                  const key = k.toLowerCase();
                  REGISTRY[key] = {
                    assignee: (v.assignee || v.username || v.login || key),
                    mention:  (v.mention  || '@'+(v.assignee || v.username || v.login || key)),
                    aliases:  (v.aliases || []).map(a => String(a).toLowerCase()).concat([key])
                  };
                }
              }
            } catch (err) {
              core.warning('agents.json present but could not be parsed: ' + err.message);
            }

            function parseList(str) {
              return String(str || '')
                .split(',')
                .map(s => s.trim().toLowerCase())
                .filter(Boolean);
            }

            const ALLOWED_FALLBACKS = parseList(process.env.ALLOWED_FALLBACKS);

            function resolveAgent(name) {
              if (!name) return null;
              const key = String(name).toLowerCase();
              if (REGISTRY[key]) return { key, ...REGISTRY[key] };
              for (const [k,rec] of Object.entries(REGISTRY)) {
                if ((rec.aliases || []).map(a => a.toLowerCase()).includes(key)) return { key: k, ...rec };
              }
              if (ALLOWED_FALLBACKS.includes(key)) {
                return { key, assignee: key, mention: '@'+key, aliases: [key] };
              }
              core.warning(`Unknown agent "${name}" not in ALLOWED_FALLBACKS; skip`);
              return null;
            }

            function agentsFromLabels(labels) {
              const names = (labels || []).map(l => (l.name || '').toLowerCase());
              const wanted = names.filter(n => n.startsWith('agent:')).map(n => n.slice('agent:'.length));
              return [...new Set(wanted)].map(resolveAgent).filter(Boolean);
            }

            async function breadcrumb(body, issueOrPR = number) {
              await github.rest.issues.createComment({ owner, repo, issue_number: issueOrPR, body });
            }

            // ---- Utility: post as service user when we need a "human" author ----
            async function postAsService(body, issueOrPR = number) {
              const pat = process.env.SERVICE_BOT_PAT || '';
              if (!pat) {
                core.warning('SERVICE_BOT_PAT not set; posting as github-actions[bot]. Some apps may ignore this.');
                await github.rest.issues.createComment({ owner, repo, issue_number: issueOrPR, body });
                return;
              }
              const { Octokit } = require('@octokit/rest');
              const oc = new Octokit({ auth: pat, request: { fetch: global.fetch } });
              await oc.issues.createComment({ owner, repo, issue_number: issueOrPR, body });
              core.info(`Posted comment as service user on #${issueOrPR}`);
            }

            // ---- Copilot via GraphQL on ISSUES (official path) ----
            async function assignCopilotIssueGraphQL(issue_number) {
              const q = `
                query($owner:String!,$repo:String!,$num:Int!) {
                  repository(owner:$owner, name:$repo) {
                    issue(number:$num) {
                      id
                      assignees(first:100){ nodes { id login } }
                    }
                    suggestedActors(capabilities:[CAN_BE_ASSIGNED], first:100){
                      nodes {
                        login
                        __typename
                        ... on Bot { id }
                        ... on User { id }
                      }
                    }
                  }
                }`;
              const data = await github.graphql(q, { owner, repo, num: issue_number });

              const actors = (data.repository.suggestedActors?.nodes || [])
                .map(n => ({ login: (n.login || '').toLowerCase(), id: n.id }));
              const cop = actors.find(a => a.login === 'copilot-swe-agent');

              if (!cop?.id) {
                await breadcrumb(
                  "Tried to assign **Copilot**, but this repo’s GraphQL `suggestedActors` does not include `copilot-swe-agent`. " +
                  "Enable the Copilot coding agent for this repo/org, then try again."
                , issue_number);
                core.setFailed("Copilot not enabled for this repo (no `copilot-swe-agent` in suggestedActors).");
                return false;
              }

              const issueId = data.repository.issue.id;
              const existing = (data.repository.issue.assignees?.nodes || []).map(n => n.id);
              const uniq = Array.from(new Set([...existing, cop.id]));

              const m = `
                mutation($assignableId:ID!,$actorIds:[ID!]!) {
                  replaceActorsForAssignable(input:{ assignableId:$assignableId, actorIds:$actorIds }) {
                    clientMutationId
                  }
                }`;
              await github.graphql(m, { assignableId: issueId, actorIds: uniq });
              await breadcrumb("Assigning/pinging @copilot for this task.", issue_number);
              return true;
            }

            // Codex bootstrap removed to dedicated job

            // ---- Codex on PRs: label + human-authored command ----
            async function assignCodexPR(pr_number) {
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr_number, labels: ['agent:codex'] });
              try {
                const human = 'stranske-automation-bot';
                await github.rest.issues.addAssignees({ owner, repo, issue_number: pr_number, assignees: ['chatgpt-codex-connector', human] });
              } catch (err) {
                core.warning('Failed to assign Codex/human: ' + err.message);
              }

              let cmd = String(process.env.CODEX_COMMAND || 'codex: start')
                .replace(/[\r\n`]/g, '')
                .trim();
              if (!/^[a-zA-Z0-9 :\-]+$/.test(cmd)) { core.warning('Unsafe Codex command; defaulting.'); cmd = 'codex: start'; }
              if (!/^codex:/i.test(cmd)) cmd = 'codex: ' + cmd;

              await postAsService(`${cmd}\n\nPlease create commits on this branch, run tests, and keep the PR updated.`, pr_number);
              return true;
            }

            // ---- Generic REST assignment (fallback agents) ----
            async function assignGenericREST(issue_number, agent) {
              const { data:item } = await github.rest.issues.get({ owner, repo, issue_number });
              const current = (item.assignees || []).map(a => (a.login || '').toLowerCase());
              const already = current.includes(agent.assignee.toLowerCase());
              if (already) {
                core.info(`#${issue_number}: ${agent.assignee} already assigned`);
                // Breadcrumb not needed when agent is already assigned
                return true;
              }
              try {
                const res = await github.rest.issues.addAssignees({
                  owner, repo, issue_number, assignees: [agent.assignee]
                });
                const ok = res.status >= 200 && res.status < 300;
                await breadcrumb(`Assigning/pinging ${agent.mention} for this task.`, issue_number);
                if (!ok) core.setFailed(`#${issue_number}: ${agent.assignee} could not be assigned.`);
                return ok;
              } catch (e) {
                core.error(`#${issue_number}: addAssignees(${agent.assignee}) failed: ${e.status || '?'} ${e.message}`);
                core.setFailed(`#${issue_number}: ${agent.assignee} is not assigned. See logs.`);
                return false;
              }
            }

            // ---- Entrypoints ----
            async function handleIssues() {
              const issue = context.payload.issue;
              const eventLabel = (context.payload.label?.name || '').toLowerCase();
              let agents = agentsFromLabels(issue.labels);
              if (eventLabel.startsWith('agent:')) {
                const extra = resolveAgent(eventLabel.slice(6));
                if (extra) agents.push(extra);
              }
              if (!agents.length) { core.info('No agent:* label on issue; skip'); return; }

              const seen = new Set();
              for (const ag of agents) {
                const key = ag.key + '#' + ag.assignee;
                if (seen.has(key)) continue; seen.add(key);

                if (ag.key === 'copilot') {
                  const res = await assignCopilotIssueGraphQL(issue.number);
                  copilotAssigned = copilotAssigned || !!res;
                } else if (ag.key === 'codex') {
                  codexLabelPresent = true; // mark for second job
                } else {
                  await assignGenericREST(issue.number, ag);
                  genericAssigned.push(ag.key);
                }
              }
            }

            async function handlePRs() {
              const pr = context.payload.pull_request;
              const eventLabel = (context.payload.label?.name || '').toLowerCase();
              let agents = agentsFromLabels(pr.labels);
              if (eventLabel.startsWith('agent:')) {
                const extra = resolveAgent(eventLabel.slice(6));
                if (extra) agents.push(extra);
              }
              if (!agents.length) { core.info('No agent:* label on PR; skip'); return; }

              const seen = new Set();
              for (const ag of agents) {
                const key = ag.key + '#' + ag.assignee;
                if (seen.has(key)) continue; seen.add(key);

                if (ag.key === 'copilot') {
                  await breadcrumb("Heads up: Copilot coding agent starts from **issues**, not PRs. Label the linked issue `agent:copilot`.", pr.number);
                } else if (ag.key === 'codex') {
                  // For PR label, we still just label & command here (no branch needed)
                  await assignCodexPR(pr.number);
                } else {
                  await assignGenericREST(pr.number, ag);
                  genericAssigned.push(ag.key);
                }
              }
            }

            async function backfill(scope, agentKeys) {
              const keys = agentKeys.length ? agentKeys : Object.keys(REGISTRY);

              for (const raw of keys) {
                const ag = resolveAgent(raw);
                if (!ag) continue;

                // Issues
                if (scope === 'issues' || scope === 'both') {
                  const qI = `repo:${owner}/${repo} is:issue is:open label:"agent:${ag.key}"`;
                  let page = 1;
                  while (true) {
                    const res = await github.rest.search.issuesAndPullRequests({ q: qI, per_page: 100, page });
                    if (!res.data.items.length) break;
                    for (const it of res.data.items) {
                      if (ag.key === 'copilot') {
                        await assignCopilotIssueGraphQL(it.number);
                      } else if (ag.key === 'codex') {
                        await codexBootstrapFromIssue(it.number);
                      } else {
                        await assignGenericREST(it.number, ag);
                      }
                    }
                    if (res.data.items.length < 100) break;
                    page += 1;
                  }
                }

                // PRs
                if (scope === 'prs' || scope === 'both') {
                  const qP = `repo:${owner}/${repo} is:pr is:open label:"agent:${ag.key}"`;
                  let page = 1;
                  while (true) {
                    const res = await github.rest.search.issuesAndPullRequests({ q: qP, per_page: 100, page });
                    if (!res.data.items.length) break;
                    for (const it of res.data.items) {
                      if (ag.key === 'copilot') {
                        await breadcrumb("Copilot coding agent starts from **issues**, not PRs. Label the linked issue `agent:copilot`.", it.number);
                      } else if (ag.key === 'codex') {
                        await assignCodexPR(it.number);
                      } else {
                        await assignGenericREST(it.number, ag);
                      }
                    }
                    if (res.data.items.length < 100) break;
                    page += 1;
                  }
                }
              }
            }

            // Dispatch
            if (context.eventName === 'workflow_dispatch') {
              const scope  = (context.payload.inputs?.scope || 'both').toLowerCase();
              const agents = parseList(context.payload.inputs?.agents || '');
              await backfill(scope, agents);
              return;
            }
            if (context.eventName === 'issues')  { await handleIssues(); }
            if (context.eventName === 'pull_request_target') { await handlePRs(); }

            core.setOutput('needs_codex_bootstrap', codexLabelPresent && eventName === 'issues' ? 'true' : 'false');
            core.setOutput('codex_issue', codexLabelPresent && eventName === 'issues' ? String(number) : '');
            core.setOutput('copilot_assigned', copilotAssigned ? 'true' : 'false');
            core.setOutput('generic_agents', genericAssigned.join(','));

      - name: Decide summary
        id: decide
        run: |
          echo "needs_codex_bootstrap=${{ steps.assign_or_backfill.outputs.needs_codex_bootstrap }}" >> $GITHUB_OUTPUT
          echo "codex_issue=${{ steps.assign_or_backfill.outputs.codex_issue }}" >> $GITHUB_OUTPUT
      - name: Write assignment artifact
        if: always()
        run: |
          mkdir -p agent-artifacts
          cat > agent-artifacts/agent_assignment.json <<'EOF'
          {
            "event": "${{ github.event_name }}",
            "issue": "${{ github.event.issue.number || '' }}",
            "pr": "${{ github.event.pull_request.number || '' }}",
            "needs_codex_bootstrap": "${{ steps.assign_or_backfill.outputs.needs_codex_bootstrap }}",
            "codex_issue": "${{ steps.assign_or_backfill.outputs.codex_issue }}",
            "copilot_assigned": "${{ steps.assign_or_backfill.outputs.copilot_assigned }}",
            "generic_agents": "${{ steps.assign_or_backfill.outputs.generic_agents }}"
          }
          EOF
          echo '### Agent Assignment Summary' >> $GITHUB_STEP_SUMMARY
          cat agent-artifacts/agent_assignment.json >> $GITHUB_STEP_SUMMARY
      - name: Upload assignment artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: agent-assignment-${{ github.run_id }}
          path: agent-artifacts/agent_assignment.json

  codex_bootstrap:
    needs: assign_or_backfill
    if: needs.assign_or_backfill.outputs.needs_codex_bootstrap == 'true'
    permissions:
      issues: write
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest
    env:
      SERVICE_BOT_PAT: ${{ secrets.SERVICE_BOT_PAT }}
      CODEX_COMMAND: ${{ github.event.inputs.codex_command }}
    steps:
      - uses: actions/checkout@v4
      - name: Debug needs
        run: |
          echo "needs_codex_bootstrap=${{ needs.assign_or_backfill.outputs.needs_codex_bootstrap }}"
          echo "codex_issue=${{ needs.assign_or_backfill.outputs.codex_issue }}"
      - name: Abort if PAT missing
        if: env.SERVICE_BOT_PAT == ''
        uses: actions/github-script@v7
        with:
          script: |
            core.setFailed('SERVICE_BOT_PAT missing – cannot perform Codex bootstrap (branch/PR creation). Label remains; retry after configuring secret.');
            const {owner, repo} = context.repo;
            const issue_number = Number('${{ needs.assign_or_backfill.outputs.codex_issue }}');
            if (issue_number) {
              await github.rest.issues.createComment({ owner, repo, issue_number, body: 'Codex bootstrap skipped: missing SERVICE_BOT_PAT. Configure secret then re-add label `agent:codex`.' });
            }
            return;
      - name: Bootstrap Codex branch/PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.SERVICE_BOT_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const issue_number = Number('${{ needs.assign_or_backfill.outputs.codex_issue }}');
            if (!issue_number) { core.setFailed('No issue number passed to bootstrap'); return; }
            if (!process.env.SERVICE_BOT_PAT) { core.setFailed('SERVICE_BOT_PAT missing – cannot bootstrap'); return; }

            // Marker detection
            const branch = `agents/codex-issue-${issue_number}`;
            const markerPath = `agents/.codex-bootstrap-${issue_number}.json`;
            async function exists(path, ref){
              try { await github.rest.repos.getContent({owner, repo, path, ref}); return true; } catch { return false; }
            }
            const { data: repoInfo } = await github.rest.repos.get({ owner, repo });
            const base = repoInfo.default_branch || 'main';
            const { data: ref } = await github.rest.git.getRef({ owner, repo, ref: `heads/${base}` });
            const baseSha = ref.object.sha;
            let branchExists = true;
            try { await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` }); } catch { branchExists = false; }
            if (!branchExists) {
              await github.rest.git.createRef({ owner, repo, ref: `refs/heads/${branch}`, sha: baseSha });
              core.info(`Created branch ${branch}`);
            } else {
              core.info(`Branch ${branch} already exists`);
            }
            if (await exists(markerPath, branch)) {
              core.info('Marker exists – bootstrap already performed.');
              return;
            }
            const path = `agents/codex-${issue_number}.md`;
            const content = Buffer.from(`<!-- bootstrap for codex on issue #${issue_number} -->\n`).toString('base64');
            let sha;
            try { const probe = await github.rest.repos.getContent({ owner, repo, path, ref: branch }); if (!Array.isArray(probe.data)) sha = probe.data.sha; } catch {}
            await github.rest.repos.createOrUpdateFileContents({ owner, repo, path, branch, message: `chore(codex): bootstrap PR for issue #${issue_number}`, content, sha });
            // Pull issue details to replicate content into PR body
            let issueTitle = '(no title)';
            let issueBody  = '(no body provided)';
            try {
              const { data: issue } = await github.rest.issues.get({ owner, repo, issue_number });
              issueTitle = issue.title || issueTitle;
              issueBody  = issue.body  || issueBody;
            } catch (e) {
              core.warning(`Failed to fetch issue #${issue_number} for body replication: ${e.message}`);
            }
            const replicatedHeader = `### Source Issue #${issue_number}: ${issueTitle}`;
            const replicatedBody = `${replicatedHeader}\n\n---\n${issueBody}\n\n---\n\nThis draft PR was auto-created to engage Codex on the task above. All edits should occur on this branch.\n`;

            const { data: open } = await github.rest.pulls.list({ owner, repo, state: 'open', head: `${owner}:${branch}` });
            let prNumber; let prBodyNeedsUpdate = false; let existingPR;
            if (open.length) {
              existingPR = open[0];
              prNumber = existingPR.number;
              if (!existingPR.body || !existingPR.body.includes(replicatedHeader)) {
                prBodyNeedsUpdate = true;
              }
            } else {
              const { data: pr } = await github.rest.pulls.create({ owner, repo, head: branch, base, draft: true, title: `Codex bootstrap for #${issue_number}`, body: replicatedBody });
              prNumber = pr.number;
            }
            if (prBodyNeedsUpdate) {
              try {
                await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body: replicatedBody });
                core.info(`Updated existing PR #${prNumber} body to replicate issue content.`);
              } catch (e) {
                core.warning(`Unable to update PR #${prNumber} body: ${e.message}`);
              }
            }
            try {
              const human = 'stranske-automation-bot';
              await github.rest.issues.addAssignees({ owner, repo, issue_number, assignees: ['chatgpt-codex-connector', human] });
              await github.rest.issues.addAssignees({ owner, repo, issue_number: prNumber, assignees: ['chatgpt-codex-connector', human] });
            } catch (err) { core.warning('Assign failed: ' + err.message); }
            await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: ['agent:codex'] });
            let cmd = String(process.env.CODEX_COMMAND || 'codex: start').replace(/[\r\n`]/g,'').trim();
            if (!/^[a-zA-Z0-9 :\-]+$/.test(cmd)) { core.warning('Unsafe Codex command; defaulting.'); cmd = 'codex: start'; }
            if (!/^codex:/i.test(cmd)) cmd = 'codex: ' + cmd;
            await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `${cmd}\n\nPlease create commits on this branch, run tests, and keep the PR updated.` });
            await github.rest.issues.createComment({ owner, repo, issue_number, body: `Opened draft PR #${prNumber} to engage Codex. Track work there.` });
            const markerContent = Buffer.from(JSON.stringify({ issue: issue_number, pr: prNumber, ts: new Date().toISOString() }, null, 2)).toString('base64');
            await github.rest.repos.createOrUpdateFileContents({ owner, repo, path: markerPath, branch, message: `chore(codex): mark bootstrap for #${issue_number}`, content: markerContent });
            core.summary.addHeading('Codex Bootstrap').addTable([[{data:'Issue',header:true},{data:'PR',header:true},{data:'Branch',header:true}], [String(issue_number), String(prNumber), branch]]).write();
            core.setOutput('codex_pr', String(prNumber));
