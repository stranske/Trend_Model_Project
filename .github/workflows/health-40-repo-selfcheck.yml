name: Health 40 Repo Selfcheck

on:
  schedule:
    - cron: '20 6 * * 1'
  workflow_dispatch:
    inputs:
      pull_request_number:
        description: 'Optional PR to receive the repo health checklist comment'
        required: false
        type: string

permissions:
  contents: read
  issues: write

jobs:
  repo-health:
    name: Repository health summary
    runs-on: ubuntu-latest
    steps:
      - name: Prepare privileged token
        id: privileged-token
        env:
          SERVICE_BOT_PAT: ${{ secrets.SERVICE_BOT_PAT }}
        run: |
          python - <<'PY'
          import os

          token = (os.environ.get('SERVICE_BOT_PAT') or '').strip()

          if token:
              print(f"::add-mask::{token}")

          output_path = os.environ['GITHUB_OUTPUT']
          with open(output_path, 'a', encoding='utf-8') as handle:
              handle.write(f"token={token}\n")
              handle.write(f"has_token={'true' if token else 'false'}\n")
          PY

      - name: Collect repository signals
        id: collect
        uses: actions/github-script@v7
        env:
          REQUIRED_LABELS: agent:codex,agent:copilot,automerge,risk:low,codex-ready
          SERVICE_BOT_PAT: ${{ steps.privileged-token.outputs.token }}
        with:
          github-token: ${{ steps.privileged-token.outputs.token || github.token }}
          script: |
            const core = require('@actions/core');

            const { owner, repo } = context.repo;
            const requiredLabels = (process.env.REQUIRED_LABELS || '')
              .split(',')
              .map((label) => label.trim())
              .filter(Boolean);

            const timestamp = new Date().toISOString();
            let defaultBranch = context.payload?.repository?.default_branch || '';
            try {
              const repoInfo = await github.rest.repos.get({ owner, repo });
              defaultBranch = repoInfo.data.default_branch || defaultBranch;
            } catch (error) {
              const message = `Failed to resolve default branch via GitHub API: ${error?.message || error}`;
              core.warning(message);
              if (!defaultBranch) {
                defaultBranch = 'main';
              }
            }

            const missingLabels = [];
            const labelErrors = [];
            for (const label of requiredLabels) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: label });
              } catch (error) {
                if (error.status === 404) {
                  missingLabels.push(label);
                } else {
                  const detail = error?.message || String(error);
                  const message = `Label lookup failed for ${label}: ${detail}`;
                  core.warning(message);
                  labelErrors.push({ label, detail: message });
                }
              }
            }

            let branchStatus = 'unknown';
            let branchNote = 'Branch protection not checked.';
            const serviceBotPat = (process.env.SERVICE_BOT_PAT || '').trim();
            let privilegedChecksUsed = false;
            let privilegedChecksSkipped = false;
            let branchFetchError = null;

            const runPrivilegedCheck = async () => {
              // Use the authenticated `github` client made available by actions/github-script
              // This avoids requiring external modules (e.g. @octokit/rest) which may not be
              // available in the action runtime and would cause an unhandled exception.
              try {
                const resp = await github.rest.repos.getBranchProtection({ owner, repo, branch: defaultBranch });
                // resp.status is not always present on the returned object; treat success as configured
                branchStatus = 'enabled';
                branchNote = `Branch protection is configured for ${defaultBranch}.`;
                return;
              } catch (error) {
                // Normalize different failure modes into statuses the rest of the workflow understands.
                const status = error.status || '';
                if (status === 404) {
                  branchStatus = 'missing';
                  branchNote = `Branch protection is not configured for ${defaultBranch}.`;
                } else if (status === 401) {
                  branchStatus = 'forbidden';
                  branchNote = 'The supplied token was rejected (401 Unauthorized) when reading branch protection settings.';
                  core.warning(branchNote);
                } else if (status === 403) {
                  branchStatus = 'forbidden';
                  branchNote = 'The supplied token lacks permission to read branch protection settings.';
                  core.warning(branchNote);
                } else {
                  branchStatus = 'error';
                  branchNote = `Branch protection check failed: ${error && (error.message || String(error))}`;
                  core.warning(branchNote);
                }
                // Preserve a textual fetch/error note for downstream reporting
                branchFetchError = branchNote;
                return;
              }
            };

            if (serviceBotPat) {
              privilegedChecksUsed = true;
              await runPrivilegedCheck();
            } else {
              privilegedChecksSkipped = true;
              branchStatus = 'skipped';
              branchNote = 'SERVICE_BOT_PAT not configured; skipped branch protection check.';
              core.notice('Skipped privileged checks because SERVICE_BOT_PAT is not configured.');
            }

            const checks = [
              {
                key: 'labels',
                title: 'Label inventory',
                status: missingLabels.length === 0 && labelErrors.length === 0 ? 'pass' : 'warn',
                detail:
                  missingLabels.length === 0 && labelErrors.length === 0
                    ? 'All required labels are present.'
                    : [
                        missingLabels.length ? `Missing labels: ${missingLabels.join(', ')}` : null,
                        labelErrors.length
                          ? `Additional lookup warnings: ${labelErrors.map((entry) => `${entry.label}`).join(', ')}`
                          : null,
                      ]
                        .filter(Boolean)
                        .join(' | '),
                missingLabels,
                labelErrors,
              },
              {
                key: 'branch',
                title: 'Default branch protection',
                status:
                  branchStatus === 'enabled'
                    ? 'pass'
                    : branchStatus === 'missing'
                    ? 'error'
                    : branchStatus === 'skipped'
                    ? 'warn'
                    : branchStatus === 'error' || branchStatus === 'forbidden'
                    ? 'warn'
                    : 'info',
                detail: branchNote,
                branchStatus,
                branchFetchError,
              },
              {
                key: 'default-branch',
                title: 'Default branch',
                status: 'info',
                detail: defaultBranch,
              },
            ];

            core.info(
              [
                `Repo health summary @ ${timestamp}`,
                `• Required labels present: ${missingLabels.length === 0 ? 'yes' : 'no'}`,
                `• Branch protection status: ${branchStatus}`,
                privilegedChecksUsed
                  ? '• Privileged checks: executed with SERVICE_BOT_PAT'
                  : '• Privileged checks: skipped (SERVICE_BOT_PAT not configured)',
              ].join('\n')
            );

            core.setOutput('checks', JSON.stringify(checks));
            core.setOutput('timestamp', timestamp);
            core.setOutput('default_branch', defaultBranch);
            core.setOutput('privileged_checks_skipped', privilegedChecksSkipped ? 'true' : 'false');
            core.setOutput('privileged_checks_used', privilegedChecksUsed ? 'true' : 'false');
            core.setOutput('branch_protection_status', branchStatus);
            core.setOutput('branch_protection_note', branchNote);
            core.setOutput('missing_labels', JSON.stringify(missingLabels));
            core.setOutput('label_errors', JSON.stringify(labelErrors));
            core.setOutput('branch_fetch_error', branchFetchError || '');

      - name: Aggregate & Summarize
        id: aggregate
        env:
          CHECKS_JSON: ${{ steps.collect.outputs.checks }}
          TIMESTAMP: ${{ steps.collect.outputs.timestamp }}
          DEFAULT_BRANCH: ${{ steps.collect.outputs.default_branch }}
          PRIVILEGED_SKIPPED: ${{ steps.collect.outputs.privileged_checks_skipped }}
          PRIVILEGED_USED: ${{ steps.collect.outputs.privileged_checks_used }}
          BRANCH_STATUS: ${{ steps.collect.outputs.branch_protection_status }}
          BRANCH_NOTE: ${{ steps.collect.outputs.branch_protection_note }}
          MISSING_LABELS: ${{ steps.collect.outputs.missing_labels }}
          LABEL_ERRORS: ${{ steps.collect.outputs.label_errors }}
          BRANCH_FETCH_ERROR: ${{ steps.collect.outputs.branch_fetch_error }}
        run: |
          python - <<'PY'
          import json
          import os

          checks = json.loads(os.environ.get('CHECKS_JSON') or '[]')
          timestamp = os.environ.get('TIMESTAMP') or ''
          default_branch = os.environ.get('DEFAULT_BRANCH') or ''
          privileged_skipped = (os.environ.get('PRIVILEGED_SKIPPED') or '').lower() == 'true'
          privileged_used = (os.environ.get('PRIVILEGED_USED') or '').lower() == 'true'
          branch_status = (os.environ.get('BRANCH_STATUS') or '').strip()
          branch_note = os.environ.get('BRANCH_NOTE') or ''
          missing_labels = json.loads(os.environ.get('MISSING_LABELS') or '[]')
          label_errors = json.loads(os.environ.get('LABEL_ERRORS') or '[]')
          branch_fetch_error = os.environ.get('BRANCH_FETCH_ERROR') or ''

          status_labels = {
              'pass': '✅ Pass',
              'warn': '⚠️ Warning',
              'info': 'ℹ️ Info',
              'skipped': '⏭️ Skipped',
              'error': '❌ Error',
          }

          lines = ['# Repo health summary']
          if timestamp:
              lines.append('')
              lines.append(f'*Run timestamp:* `{timestamp}`')
          if default_branch:
              lines.append('')
              lines.append(f'*Default branch:* `{default_branch}`')

          if checks:
              lines.append('')
              lines.append('| Check | Status | Details |')
              lines.append('| --- | --- | --- |')
              for check in checks:
                  title = check.get('title', 'Unknown')
                  status = status_labels.get(check.get('status', 'info'), check.get('status', 'info'))
                  detail = (check.get('detail') or '').replace('\n', '<br>').replace('|', '\\|')
                  lines.append(f'| {title} | {status} | {detail} |')

          if privileged_skipped:
              lines.append('')
              lines.append('> ⚠️ Privileged checks were skipped because `SERVICE_BOT_PAT` is not configured.')
          elif privileged_used and branch_status in {'enabled', 'missing'}:
              lines.append('')
              lines.append('> ✅ Privileged checks executed with the configured credentials.')
          elif privileged_used:
              lines.append('')
              detail = branch_note.replace('\n', ' ').strip()
              if detail:
                  lines.append('> ⚠️ Privileged checks ran but reported access issues: ' + detail)
              else:
                  lines.append('> ⚠️ Privileged checks ran but reported access issues. Review the branch protection result above for details.')
          else:
              lines.append('')
              lines.append('> ℹ️ No privileged checks were requested in this run.')

          output = '\n'.join(lines) + '\n'
          print(output)

          summary_path = os.environ['GITHUB_STEP_SUMMARY']
          with open(summary_path, 'a', encoding='utf-8') as handle:
              handle.write(output)

          report = {
              'timestamp': timestamp,
              'default_branch': default_branch,
              'checks': checks,
              'privileged_checks': {
                  'skipped': privileged_skipped,
                  'used': privileged_used,
                  'status': branch_status,
                  'note': branch_note,
                  'fetch_error': branch_fetch_error,
              },
          }

          with open('repo-health-summary.json', 'w', encoding='utf-8') as handle:
              json.dump(report, handle, indent=2)

          warning_statuses = {'warn'}
          error_statuses = {'error'}
          findings = [check for check in checks if check.get('status') in warning_statuses | error_statuses]
          error_findings = [check for check in checks if check.get('status') in error_statuses]

          fix_items = []
          if any(check.get('key') == 'labels' for check in findings):
              if missing_labels:
                  fix_items.append(f"- [ ] Create the missing labels: {', '.join(sorted(missing_labels))}.")
              if label_errors:
                  fix_items.append('- [ ] Re-run after resolving label API warnings (check token permissions).')
          if any(check.get('key') == 'branch' for check in findings):
              if branch_status == 'missing':
                  fix_items.append(f"- [ ] Enable branch protection on `{default_branch}`.")
              elif branch_status in {'error', 'forbidden', 'skipped'}:
                  fix_items.append('- [ ] Restore branch protection visibility (configure SERVICE_BOT_PAT or retry later).')

          if not fix_items:
              fix_items.append('- [x] No action required — repo health checks are green.')

          comment_sections = [
              '## Repo health self-check',
              f'*Run timestamp:* `{timestamp}`' if timestamp else None,
              f'*Default branch:* `{default_branch}`' if default_branch else None,
              '',
              '### Checks',
              '| Check | Status | Details |',
              '| --- | --- | --- |',
          ]

          for check in checks:
              title = check.get('title', 'Unknown')
              status = status_labels.get(check.get('status', 'info'), check.get('status', 'info'))
              detail = (
                  check.get('detail', '')
                  .replace('|', '\\|')
                  .replace('\n', '<br>')
              )
              comment_sections.append(f'| {title} | {status} | {detail or ""} |')

          comment_sections.extend([
              '',
              '### How to fix',
              *fix_items,
          ])

          comment_body = '\n'.join(filter(lambda block: block is not None, comment_sections))

          output_path = os.environ['GITHUB_OUTPUT']
          with open(output_path, 'a', encoding='utf-8') as handle:
              handle.write('comment_body<<COMMENT\n')
              handle.write(comment_body)
              handle.write('\nCOMMENT\n')
              handle.write(f"has_errors={'true' if error_findings else 'false'}\n")
              handle.write(f"has_warnings={'true' if findings and not error_findings else 'false'}\n")

          PY

      - name: Upload JSON summary
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: repo-health-selfcheck-${{ github.run_id }}
          path: repo-health-summary.json
          if-no-files-found: warn

      - name: Publish PR checklist comment
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.pull_request_number != '' && steps.aggregate.outputs.comment_body != '' }}
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.inputs.pull_request_number }}
          COMMENT_BODY: ${{ steps.aggregate.outputs.comment_body }}
        with:
          github-token: ${{ github.token }}
          script: |
            const marker = '<!-- repo-health-selfcheck -->';
            const prNumber = parseInt(process.env.PR_NUMBER || '', 10);
            if (!prNumber) {
              core.info('No PR number supplied; skipping comment.');
              return;
            }
            const body = `${marker}\n${process.env.COMMENT_BODY.trim()}\n`;

            const { data: existingComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const match = existingComments.find((comment) => comment.body && comment.body.includes(marker));

            if (match) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: match.id,
                body,
              });
              core.info(`Updated existing repo health comment (${match.id}).`);
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body,
              });
              core.info(`Posted new repo health comment on PR #${prNumber}.`);
            }

      - name: Fail on blocking issues
        if: ${{ steps.aggregate.outputs.has_errors == 'true' }}
        run: |
          echo "Blocking repo health findings detected; marking the run as failed."
          exit 1
