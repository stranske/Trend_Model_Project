name: Health 40 Repo Selfcheck

on:
  schedule:
    - cron: '20 6 * * 1'
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: read
  actions: read

jobs:
  repo-health:
    name: Repository health summary
    runs-on: ubuntu-latest
    steps:
      - name: Prepare privileged token
        id: privileged-token
        env:
          SERVICE_BOT_PAT: ${{ secrets.SERVICE_BOT_PAT }}
        run: |
          python - <<'PY'
          import os

          token = (os.environ.get('SERVICE_BOT_PAT') or '').strip()

          output_path = os.environ['GITHUB_OUTPUT']
          with open(output_path, 'a', encoding='utf-8') as handle:
            handle.write(f"token={token}\n")
            handle.write(f"has_token={'true' if token else 'false'}\n")
          PY

      - name: Collect repository signals
        id: collect
        uses: actions/github-script@v7
        env:
          REQUIRED_LABELS: agent:codex,agent:copilot,automerge,risk:low,codex-ready
          SERVICE_BOT_PAT: ${{ steps.privileged-token.outputs.token }}
        with:
          github-token: ${{ steps.privileged-token.outputs.has_token == 'true' && steps.privileged-token.outputs.token || github.token }}
          script: |
            const { owner, repo } = context.repo;
            const requiredLabels = (process.env.REQUIRED_LABELS || '')
              .split(',')
              .map((label) => label.trim())
              .filter(Boolean);

            const timestamp = new Date().toISOString();
            let defaultBranch = context.payload?.repository?.default_branch || '';
            try {
              const repoInfo = await github.rest.repos.get({ owner, repo });
              defaultBranch = repoInfo.data.default_branch || defaultBranch;
            } catch (error) {
              const message = `Failed to resolve default branch via GitHub API: ${error?.message || error}`;
              core.warning(message);
              if (!defaultBranch) {
                defaultBranch = 'main';
              }
            }

            const missingLabels = [];
            for (const label of requiredLabels) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: label });
              } catch (error) {
                if (error.status === 404) {
                  missingLabels.push(label);
                } else {
                  throw error;
                }
              }
            }

            let branchStatus = 'unknown';
            let branchNote = 'Branch protection not checked.';
            const serviceBotPat = (process.env.SERVICE_BOT_PAT || '').trim();
            let privilegedChecksUsed = false;
            let privilegedChecksSkipped = false;

            const runPrivilegedCheck = async () => {
              const endpoint = `https://api.github.com/repos/${owner}/${repo}/branches/${defaultBranch}/protection`;
              const headers = {
                'Accept': 'application/vnd.github+json',
                'User-Agent': 'repo-health-selfcheck',
                'Authorization': `token ${serviceBotPat}`,
              };

              let response;
              try {
                response = await fetch(endpoint, { headers });
              } catch (error) {
                branchStatus = 'error';
                branchNote = `Branch protection check encountered a network error: ${error?.message || error}`;
                core.warning(branchNote);
                return;
              }

              if (response.status === 200) {
                branchStatus = 'enabled';
                branchNote = `Branch protection is configured for ${defaultBranch}.`;
                return;
              }

              if (response.status === 404) {
                branchStatus = 'missing';
                branchNote = `Branch protection is not configured for ${defaultBranch}.`;
                return;
              }

              if (response.status === 401) {
                branchStatus = 'forbidden';
                branchNote = 'The supplied token was rejected (401 Unauthorized) when reading branch protection settings.';
                core.warning(branchNote);
                return;
              }

              if (response.status === 403) {
                branchStatus = 'forbidden';
                branchNote = 'The supplied token lacks permission to read branch protection settings.';
                core.warning(branchNote);
                return;
              }

              branchStatus = 'error';
              const detail = await response.text();
              branchNote = `Branch protection check failed with status ${response.status}: ${detail}`;
              core.warning(branchNote);
            };

            if (serviceBotPat) {
              privilegedChecksUsed = true;
              await runPrivilegedCheck();
            } else {
              privilegedChecksSkipped = true;
              branchStatus = 'skipped';
              branchNote = 'SERVICE_BOT_PAT not configured; skipped branch protection check.';
              core.notice('Skipped privileged checks because SERVICE_BOT_PAT is not configured.');
            }

            const checks = [
              {
                key: 'labels',
                title: 'Label inventory',
                status: missingLabels.length === 0 ? 'pass' : 'attention',
                detail:
                  missingLabels.length === 0
                    ? 'All required labels are present.'
                    : `Missing labels: ${missingLabels.join(', ')}`,
              },
              {
                key: 'branch',
                title: 'Default branch protection',
                status:
                  branchStatus === 'enabled'
                    ? 'pass'
                    : branchStatus === 'missing'
                    ? 'attention'
                    : branchStatus === 'skipped'
                    ? 'skipped'
                    : branchStatus === 'error'
                    ? 'error'
                    : 'warn',
                detail: branchNote,
              },
              {
                key: 'default-branch',
                title: 'Default branch',
                status: 'info',
                detail: defaultBranch,
              },
            ];

            core.info(
              [
                `Repo health summary @ ${timestamp}`,
                `• Required labels present: ${missingLabels.length === 0 ? 'yes' : 'no'}`,
                `• Branch protection status: ${branchStatus}`,
                privilegedChecksUsed
                  ? '• Privileged checks: executed with SERVICE_BOT_PAT'
                  : '• Privileged checks: skipped (SERVICE_BOT_PAT not configured)',
              ].join('\n')
            );

            core.setOutput('checks', JSON.stringify(checks));
            core.setOutput('timestamp', timestamp);
            core.setOutput('default_branch', defaultBranch);
            core.setOutput('privileged_checks_skipped', privilegedChecksSkipped ? 'true' : 'false');
            core.setOutput('privileged_checks_used', privilegedChecksUsed ? 'true' : 'false');
            core.setOutput('branch_protection_status', branchStatus);
            core.setOutput('branch_protection_note', branchNote);

      - name: Aggregate & Summarize
        env:
          CHECKS_JSON: ${{ steps.collect.outputs.checks }}
          TIMESTAMP: ${{ steps.collect.outputs.timestamp }}
          DEFAULT_BRANCH: ${{ steps.collect.outputs.default_branch }}
          PRIVILEGED_SKIPPED: ${{ steps.collect.outputs.privileged_checks_skipped }}
          PRIVILEGED_USED: ${{ steps.collect.outputs.privileged_checks_used }}
        run: |
          python - <<'PY'
          import json
          import os

          checks = json.loads(os.environ.get('CHECKS_JSON') or '[]')
          timestamp = os.environ.get('TIMESTAMP') or ''
          default_branch = os.environ.get('DEFAULT_BRANCH') or ''
          privileged_skipped = (os.environ.get('PRIVILEGED_SKIPPED') or '').lower() == 'true'
          privileged_used = (os.environ.get('PRIVILEGED_USED') or '').lower() == 'true'

          status_labels = {
              'pass': '✅ Pass',
              'attention': '⚠️ Needs attention',
              'warn': '⚠️ Warning',
              'info': 'ℹ️ Info',
              'skipped': '⏭️ Skipped',
              'error': '❌ Error',
          }

          lines = ['# Repo health summary']
          if timestamp:
              lines.append('')
              lines.append(f'*Run timestamp:* `{timestamp}`')
          if default_branch:
              lines.append('')
              lines.append(f'*Default branch:* `{default_branch}`')

          if checks:
              lines.append('')
              lines.append('| Check | Status | Details |')
              lines.append('| --- | --- | --- |')
              for check in checks:
                  title = check.get('title', 'Unknown')
                  status = status_labels.get(check.get('status', 'info'), check.get('status', 'info'))
                  detail = (check.get('detail') or '').replace('\n', '<br>')
                  lines.append(f'| {title} | {status} | {detail} |')

          if privileged_skipped:
              lines.append('')
              lines.append('> ⚠️ Privileged checks were skipped because `SERVICE_BOT_PAT` is not configured.')
          elif privileged_used:
              lines.append('')
              lines.append('> ✅ Privileged checks executed with the configured credentials.')
          else:
              lines.append('')
              lines.append('> ℹ️ No privileged checks were requested in this run.')

          output = '\n'.join(lines) + '\n'
          print(output)

          summary_path = os.environ['GITHUB_STEP_SUMMARY']
          with open(summary_path, 'a', encoding='utf-8') as handle:
              handle.write(output)
          PY
