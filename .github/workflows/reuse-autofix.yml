name: Reusable Autofix

on:
  workflow_call:
    inputs:
      opt_in_label:
        description: 'Label to opt-in when PR is draft'
        required: false
        default: 'autofix'
        type: string
      commit_prefix:
        description: 'Commit message prefix'
        required: false
        default: 'ci: autofix'
        type: string

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: autofix-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: false

jobs:
  autofix:
    runs-on: ubuntu-latest
    if: >-
      ${{ github.event_name == 'pull_request' &&
          github.actor != 'github-actions' &&
          github.actor != 'github-actions[bot]' &&
          !startsWith(github.event.pull_request.title, inputs.commit_prefix) &&
          ( !github.event.pull_request.draft || contains(github.event.pull_request.labels.*.name, inputs.opt_in_label) ) }}
    steps:
      - name: Guard against loops (Issue #1347)
        shell: bash
        run: |
          msg=$(git log -1 --pretty=%s || true)
          if [ "${{ github.actor }}" = "github-actions" ] && echo "$msg" | grep -qiF "^${{ inputs.commit_prefix }}"; then
            echo "[autofix] Skipping: detected prior autofix commit (${msg})"
            exit 0
          fi
      - name: Checkout PR HEAD
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          fetch-depth: 0
          persist-credentials: true

      - name: Detect same-repo PR
        id: same_repo
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const same = pr.head.repo.full_name === `${context.repo.owner}/${context.repo.repo}`;
            core.setOutput('same', String(same));

      - name: Autofix
        id: autofix
        uses: ./.github/actions/autofix

      - name: Commit changes (same-repo)
        if: steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "${{ inputs.commit_prefix }} formatting/lint"

      - name: Push changes (same-repo with rebase+retry)
        if: steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same == 'true'
        shell: bash
        run: |
          set -euo pipefail
          branch="${{ github.event.pull_request.head.ref }}"
          for attempt in 1 2 3; do
            echo "[autofix] Push attempt $attempt"
            if git push origin HEAD:"$branch"; then
              echo "[autofix] Push succeeded"
              exit 0
            fi
            echo "[autofix] Push failed - attempting rebase (attempt $attempt)"
            git fetch origin "$branch" --prune
            if git rebase --autostash --strategy-option theirs origin/"$branch"; then
              echo "[autofix] Rebase completed"
            else
              echo "[autofix] Rebase conflict; aborting rebase"; git rebase --abort || true
            fi
          done
          echo "[autofix] Failed to push after 3 attempts" >&2
          exit 1

      - name: Create patch artifact (fork PR)
        if: steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same != 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A
          git commit -m "${{ inputs.commit_prefix }} formatting/lint (patch)" || true
          git format-patch -1 --stdout > autofix.patch

      - name: Upload patch artifact
        if: steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: autofix-patch-pr-${{ github.event.pull_request.number }}
          path: autofix.patch


      - name: Manage clean/debt labels (same-repo)
        if: steps.same_repo.outputs.same == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const remaining = parseInt('${{ steps.autofix.outputs.remaining_issues }}', 10) || 0;
            const cleanLabel = 'autofix:clean';
            const debtLabel = 'autofix:debt';
            const want = remaining === 0 ? cleanLabel : debtLabel;
            const drop = remaining === 0 ? debtLabel : cleanLabel;
            try {
              await github.rest.issues.removeLabel({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, name: drop }).catch(()=>{});
              await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, labels: [want] });
            } catch(e) {
              core.warning('Label management warning: ' + e.message);
            }

      - name: Update residual history (same-repo)
        if: steps.same_repo.outputs.same == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f autofix_report_enriched.json ]; then echo "[history] missing enriched report"; exit 0; fi
          python scripts/update_residual_history.py || echo "[history] update failed"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ci/autofix/history.json
          if git diff --cached --quiet; then echo "[history] No updates to commit"; exit 0; fi
          branch="${{ github.event.pull_request.head.ref }}"
          git commit -m "${{ inputs.commit_prefix }} update residual history"
          for attempt in 1 2 3; do
            if git push origin HEAD:"$branch"; then echo "[history] Push succeeded"; exit 0; fi
            echo "[history] Push failed attempt $attempt; rebasing";
            git fetch origin "$branch" --prune || true
            git rebase --autostash origin/"$branch" || git rebase --abort || true
          done
          echo "[history] Failed to push history after retries" >&2
          exit 1

      - name: Generate trend sparkline (same-repo)
        if: steps.same_repo.outputs.same == 'true'
        shell: bash
        run: |
          if [ -f scripts/generate_residual_trend.py ]; then python scripts/generate_residual_trend.py || true; fi
          if [ -f ci/autofix/trend.json ]; then echo "Trend:"; cat ci/autofix/trend.json; fi

      - name: Build consolidated PR comment (same-repo)
        if: steps.same_repo.outputs.same == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python scripts/build_autofix_pr_comment.py --out autofix_pr_comment.md
          echo 'Built unified comment:'
          sed -n '1,40p' autofix_pr_comment.md

      - name: Upsert consolidated PR comment (same-repo)
        if: steps.same_repo.outputs.same == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const marker = '<!-- autofix-status: DO NOT EDIT -->';
            const body = fs.readFileSync('autofix_pr_comment.md', 'utf8');
            const pr = context.payload.pull_request;
            // Fetch existing comments once (first 100 is ample for typical PRs)
            const comments = await github.paginate(github.rest.issues.listComments, { owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, per_page: 100 });
            const existing = comments.find(c => c.body && c.body.includes(marker));
            if (existing) {
              await github.rest.issues.updateComment({ owner: context.repo.owner, repo: context.repo.repo, comment_id: existing.id, body });
              console.log('Updated existing autofix status comment.');
            } else {
              await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body });
              console.log('Created new autofix status comment.');
            }

      - name: Regression detector (same-repo)
        if: steps.same_repo.outputs.same == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let hist=[]; try { hist = JSON.parse(fs.readFileSync('ci/autofix/history.json','utf8')); } catch(e) {}
            if (!Array.isArray(hist) || hist.length < 5) { return; }
            const last = hist.slice(-1)[0];
            const prev = hist.slice(-6,-1); // previous 5 points
            const avgPrev = prev.reduce((a,b)=>a+(b.remaining||0),0)/prev.length;
            const spike = avgPrev > 0 ? (last.remaining - avgPrev)/avgPrev : 0;
            const THRESH = 0.35; // 35% jump threshold
            if (spike <= THRESH) return;
            const issueTitle = 'lint regression: residual spike';
            // Check for existing open issue
            const issues = await github.rest.issues.listForRepo({ owner: context.repo.owner, repo: context.repo.repo, state:'open', labels:'autofix:regression' });
            if (issues.data.some(i => i.title === issueTitle)) return;
            const body = [
              'Detected residual lint spike exceeding threshold.',
              `Latest remaining: ${last.remaining}`,
              `Previous avg (5 runs): ${avgPrev.toFixed(2)}`,
              `Relative increase: ${(spike*100).toFixed(1)}%`,
              '',
              'Action items:',
              '- Investigate new codes in last run classification',
              '- Consider targeted fixes or allowlist pruning',
              '',
              'This issue was auto-generated.'
            ].join('\n');
            await github.rest.issues.create({ owner: context.repo.owner, repo: context.repo.repo, title: issueTitle, body, labels:['autofix:regression'] });

      - name: Emit JSON report
        shell: bash
        run: |
          set -euo pipefail
          ts=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          if [ -f autofix_report_enriched.json ]; then
            python -c "import json,os;from datetime import datetime,timezone as TZ;meta={'pull_request':os.environ.get('PR_NUMBER'),'timestamp_utc':datetime.now(TZ.utc).strftime('%Y-%m-%dT%H:%M:%SZ')};\nimport pathlib;\ntry: data=json.load(open('autofix_report_enriched.json'));\nexcept Exception: data={};data.update(meta);json.dump(data, open('autofix_report.json','w'), indent=2, sort_keys=True)" || echo '{"error":"merge_failed"}' > autofix_report.json
          else
            printf '{\n  "changed": "%s",\n  "remaining_issues": "%s",\n  "new_issues": "%s",\n  "pull_request": "%s",\n  "timestamp_utc": "%s"\n}\n' \
              "${{ steps.autofix.outputs.changed }}" \
              "${{ steps.autofix.outputs.remaining_issues }}" \
              "${{ steps.autofix.outputs.new_issues }}" \
              "${{ github.event.pull_request.number }}" \
              "$ts" > autofix_report.json
          fi
          echo "Enriched report ready.";
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}

      - name: Upload JSON report
        uses: actions/upload-artifact@v4
        with:
          name: autofix-report-pr-${{ github.event.pull_request.number }}
          path: autofix_report.json

      - name: Comment with patch instructions
        if: steps.autofix.outputs.changed == 'true' && steps.same_repo.outputs.same != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = [
              'I generated an autofix patch for this fork PR.',
              '',
              'How to apply locally:',
              '1. Download the artifact "autofix-patch-pr-' + pr.number + '" from the Actions run.',
              '2. In your repo root, run:',
              '   git am < autofix.patch',
              '3. Push the changes to your PR branch:',
              '   git push origin HEAD:' + pr.head.ref,
            ].join('\n');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body
            });

      - name: Summary
        if: always()
        run: |
          echo "### Reusable Autofix Summary" >> $GITHUB_STEP_SUMMARY
          echo "Applied changes: ${{ steps.autofix.outputs.changed }}" >> $GITHUB_STEP_SUMMARY
          echo "Same repo: ${{ steps.same_repo.outputs.same }}" >> $GITHUB_STEP_SUMMARY
          echo "Remaining ruff issues: ${{ steps.autofix.outputs.remaining_issues }}" >> $GITHUB_STEP_SUMMARY
          echo "New (non-allowlisted) ruff issues: ${{ steps.autofix.outputs.new_issues }}" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.autofix.outputs.changed }}" = "true" ] && [ "${{ steps.same_repo.outputs.same }}" != "true" ]; then
            echo "Patch artifact: autofix-patch-pr-${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
          fi
