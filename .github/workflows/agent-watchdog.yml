name: agent watchdog (issue -> PR)
# DEPRECATION: Replaced largely by reuse-agents.yml (enable_watchdog). Retain until full parity implemented.
on:
  issues:
    types: [assigned, labeled, reopened]
permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  watch:
    if: >
      (github.event.action == 'assigned'  && (
          (github.event.assignee.login == 'copilot') ||
          (github.event.assignee.login == 'chatgpt-codex-connector')
      )) ||
      (github.event.action == 'labeled' && startsWith(github.event.label.name, 'agent:')) ||
      (github.event.action == 'reopened')
    runs-on: ubuntu-latest
    env:
      WATCH_TIMEOUT_MINUTES: 10
      POLL_INTERVAL_SECONDS: 15
    steps:
      - name: Wait for agent PR (poll timeline)
        id: poll
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.SERVICE_BOT_PAT }}
          script: |
            const {owner, repo} = context.repo;
            const issue_number = context.payload.issue.number;

            // Early exit: detect codex bootstrap skip comment
            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number, per_page: 100 });
            if (comments.some(c => /Codex bootstrap skipped: missing SERVICE_BOT_PAT/i.test(c.body || ''))) {
              core.notice('Detected bootstrap skip comment; aborting watchdog.');
              return;
            }

            // If marker file already exists, reduce timeout to fast poll
            let fastMode = false;
            try {
              const marker = `agents/.codex-bootstrap-${issue_number}.json`;
              await github.rest.repos.getContent({ owner, repo, path: marker });
              core.info('Bootstrap marker present â€“ switching to fast 2-minute window.');
              fastMode = true;
            } catch {}

            // Helper: fetch cross-referenced PRs from issue timeline
            async function findLinkedPR() {
              // Timeline can contain cross-referenced events with a source.issue that is a PR
              let page = 1;
              while (true) {
                const { data: events } = await github.rest.issues.listEventsForTimeline({
                  owner, repo, issue_number, per_page: 100, page
                });
                if (!events.length) break;
                for (const ev of events) {
                  if (ev.event === 'cross-referenced' && ev.source && ev.source.issue && ev.source.issue.pull_request) {
                    const prNum = ev.source.issue.number;
                    // ensure the PR still exists and is open
                    try {
                      const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNum });
                      if (pr.state === 'open') return prNum;
                    } catch (e) { /* ignore */ }
                  }
                }
                if (events.length < 100) break;
                page += 1;
              }
              return null;
            }

            const timeoutMinutesRaw = process.env.WATCH_TIMEOUT_MINUTES;
            const pollIntervalSecondsRaw = process.env.POLL_INTERVAL_SECONDS;
            let timeoutMinutes = Number(timeoutMinutesRaw);
            const pollIntervalMs = Number(pollIntervalSecondsRaw) * 1000;
            if (fastMode && timeoutMinutes > 2) timeoutMinutes = 2;

            if (
              !timeoutMinutesRaw ||
              isNaN(timeoutMinutes) ||
              timeoutMinutes <= 0
            ) {
              core.setFailed(`WATCH_TIMEOUT_MINUTES is missing or invalid: "${timeoutMinutesRaw}"`);
              return;
            }
            if (
              !pollIntervalSecondsRaw ||
              isNaN(Number(pollIntervalSecondsRaw)) ||
              Number(pollIntervalSecondsRaw) <= 0
            ) {
              core.setFailed(`POLL_INTERVAL_SECONDS is missing or invalid: "${pollIntervalSecondsRaw}"`);
              return;
            }
            const started = Date.now();
            const deadlineMs = timeoutMinutes * 60 * 1000;
            let prFound = null;

            while ((Date.now() - started) < deadlineMs) {
              const prNum = await findLinkedPR();
              if (prNum) { prFound = prNum; break; }
              await new Promise(r => setTimeout(r, pollIntervalMs));
            }

            core.setOutput('pr', prFound ? String(prFound) : '');
            if (prFound) {
              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body: `Agent linked PR #${prFound}. Tracking begins here.`
              });
              core.info(`Found PR #${prFound} linked to issue #${issue_number}.`);
              core.setOutput('state', 'FOUND');
            } else {
              const timeoutMessage = [
                'No agent PR detected within the watch window.',
                'If this issue is assigned to @copilot, check the Agents panel or reassign.',
                'For Codex ensure the connector is authorized and use its command (e.g., "codex: start").'
              ].join(' ');

              await github.rest.issues.createComment({
                owner, repo, issue_number,
                body: timeoutMessage
              });
              core.setFailed(`No PR linked to issue #${issue_number} within ${timeoutMinutes} minutes.`);
              core.setOutput('state', 'TIMEOUT');
            }
      - name: Summary
        if: always()
        run: |
          echo "### Watchdog Summary" >> $GITHUB_STEP_SUMMARY
          echo "Issue: ${{ github.event.issue.number }}" >> $GITHUB_STEP_SUMMARY
          echo "State: ${{ steps.poll.outputs.state || 'SKIPPED' }}" >> $GITHUB_STEP_SUMMARY
          echo "PR: ${{ steps.poll.outputs.pr || '(none)' }}" >> $GITHUB_STEP_SUMMARY
