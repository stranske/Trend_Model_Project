name: Post CI Summary

on:
  workflow_run:
    workflows: ["CI", "Docker"]
    types: [completed]

concurrency:
  group: post-ci-summary-${{ github.event.workflow_run.head_sha }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: read
  actions: read

jobs:
  summarize:
    if: >
      github.event.workflow_run.event == 'pull_request' &&
      github.event.workflow_run.pull_requests[0].number
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Discover workflow runs for head SHA
        id: runs
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const headSha = run.head_sha;

            const parseJsonInput = (raw, fallback) => {
              if (!raw) {
                return fallback;
              }
              try {
                return JSON.parse(raw);
              } catch (error) {
                core.warning(`Failed to parse JSON input: ${error}`);
                return fallback;
              }
            };

            const defaultWorkflowTargets = [
              { key: 'ci', display_name: 'CI', workflow_path: '.github/workflows/pr-10-ci-python.yml' },
              { key: 'docker', display_name: 'Docker', workflow_path: '.github/workflows/pr-12-docker-smoke.yml' },
            ];

            const workflowTargetsRaw = process.env.WORKFLOW_TARGETS_JSON;
            const workflowTargetsInput = parseJsonInput(workflowTargetsRaw, defaultWorkflowTargets);
            const workflowTargetsSource = Array.isArray(workflowTargetsInput) ? workflowTargetsInput : defaultWorkflowTargets;
            // Helper to normalize target properties
            function normalizeTargetProps(target) {
              return {
                key: target.key,
                displayName: target.display_name || target.displayName || target.key || 'workflow',
                workflowPath: target.workflow_path || target.workflowPath || '',
                workflowFile: target.workflow_file || target.workflowFile || target.workflow_id || target.workflowId || '',
                workflowName: target.workflow_name || target.workflowName || '',
                workflowIds: Array.isArray(target.workflow_ids) ? target.workflow_ids : (target.workflowIds && Array.isArray(target.workflowIds) ? target.workflowIds : []),
              };
            }

            const workflowTargets = workflowTargetsSource
              .map(normalizeTargetProps)
              .filter(target => target && target.key);

            const normalizePath = (value) => {
              if (!value) return '';
              return String(value).replace(/^\.\//, '').replace(/^\/+/, '');
            };

            async function latestRun(workflowFile) {
              const response = await github.rest.actions.listWorkflowRuns({
                owner,
                repo,
                workflow_id: workflowFile,
                head_sha: headSha,
                event: 'pull_request',
                per_page: 1,
              });
              return response.data.workflow_runs?.[0]?.id ?? '';
            }

            const ciRunId = await latestRun('pr-10-ci-python.yml');
            const dockerRunId = await latestRun('pr-12-docker-smoke.yml');

            const ciRun = runs.find(r => r.key === 'ci' && r.present);
            const dockerRun = runs.find(r => r.key === 'docker' && r.present);
            core.setOutput('ci_run_id', ciRun ? String(ciRun.id) : '');
            core.setOutput('docker_run_id', dockerRun ? String(dockerRun.id) : '');
      - name: Check out repository
        uses: actions/checkout@v4
      - name: Download coverage summary
        if: ${{ steps.gather.outputs.ci_run_id }}
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: coverage-summary
          run-id: ${{ steps.gather.outputs.ci_run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          path: artifacts/coverage-summary
      - name: Download coverage trend
        if: ${{ steps.gather.outputs.ci_run_id }}
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ steps.runs.outputs.ci }}
          pattern: '*'
          merge-multiple: true
          path: summary_artifacts
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download Docker artifacts
        if: steps.runs.outputs.docker && steps.runs.outputs.docker != steps.runs.outputs.ci
        uses: actions/download-artifact@v4
        with:
          run-id: ${{ steps.runs.outputs.docker }}
          pattern: '*'
          merge-multiple: true
          path: summary_artifacts
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute coverage stats
        id: coverage_stats
        run: |
          set -euo pipefail
          python <<'PY'
          import json
          from pathlib import Path

          root = Path('summary_artifacts')

          def find_one(pattern: str) -> Path | None:
              if not root.exists():
                  return None
              for candidate in root.rglob(pattern):
                  if candidate.is_file():
                      return candidate
              return None

          record_path = find_one('coverage-trend.json')
          history_path = find_one('coverage-trend-history.ndjson')

          def load_record(path: Path | None) -> dict[str, object] | None:
              if not path:
                  return None
              try:
                  data = json.loads(path.read_text(encoding='utf-8'))
              except Exception:
                  return None
              return data if isinstance(data, dict) else None

          latest_record = load_record(record_path)

          history: list[dict[str, object]] = []
          if history_path and history_path.exists():
              for raw in history_path.read_text(encoding='utf-8').splitlines():
                  line = raw.strip()
                  if not line:
                      continue
                  try:
                      parsed = json.loads(line)
                  except json.JSONDecodeError:
                      continue
                  if isinstance(parsed, dict):
                      history.append(parsed)

          def run_identifier(record: dict[str, object] | None) -> tuple[object | None, object | None]:
              if not isinstance(record, dict):
                  return (None, None)
              return (record.get('run_id'), record.get('run_number'))

          latest_id = run_identifier(latest_record)

          if latest_record is None and history:
              latest_record = history[-1]
              latest_id = run_identifier(latest_record)

          previous_record: dict[str, object] | None = None
          if history:
              for candidate in reversed(history):
                  if run_identifier(candidate) == latest_id:
                      continue
                  previous_record = candidate
                  break
              if previous_record is None and len(history) > 1:
                  previous_record = history[-2]

          def extract(record: dict[str, object] | None, key: str) -> float | None:
              if not isinstance(record, dict):
                  return None
              value = record.get(key)
              try:
                  return float(value) if value is not None else None
              except (TypeError, ValueError):
                  return None

          avg_latest = extract(latest_record, 'avg_coverage')
          worst_latest = extract(latest_record, 'worst_job_coverage')
          avg_prev = extract(previous_record, 'avg_coverage')
          worst_prev = extract(previous_record, 'worst_job_coverage')

          def delta(latest: float | None, prev: float | None) -> float | None:
              try:
                  if latest is None or prev is None:
                      return None
                  return round(float(latest) - float(prev), 2)
              except Exception:
                  return None

          stats = {
              'avg_latest': avg_latest,
              'avg_previous': avg_prev,
              'avg_delta': delta(avg_latest, avg_prev),
              'worst_latest': worst_latest,
              'worst_previous': worst_prev,
              'worst_delta': delta(worst_latest, worst_prev),
              'history_len': len(history),
          }

          print(json.dumps(stats))
          Path('coverage-stats.json').write_text(json.dumps(stats), encoding='utf-8')
          PY
          if [ -f coverage-stats.json ]; then
            printf 'stats_json=%s\n' "$(cat coverage-stats.json)" >> "$GITHUB_OUTPUT"
          fi
      - name: Prepare summary body
        id: prep
        run: |
          python tools/post_ci_summary.py
        env:
          RUNS_JSON: ${{ steps.gather.outputs.runs }}
          HEAD_SHA: ${{ steps.gather.outputs.head_sha }}
          COVERAGE_SECTION: ${{ steps.coverage_summary.outputs.body }}
          COVERAGE_STATS: ${{ steps.coverage_stats.outputs.stats_json }}
          REQUIRED_JOB_GROUPS_JSON: ${{ env.REQUIRED_JOB_GROUPS_JSON }}
      - name: Upsert summary comment
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.gather.outputs.pr_number }}
          BODY: ${{ steps.prep.outputs.body }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER);
            const body = process.env.BODY || '';
            const { owner, repo } = context.repo;
            if (!prNumber || !body) {
              core.info('No PR number or body computed; skipping comment update.');
              return;
            }

            const marker = 'Automated Status Summary';
            const { data: comments } = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100,
            });

            const existing = comments.find(comment => comment.body && comment.body.includes(marker));

      - name: Append comment preview to job summary
        if: always()
        run: |
          if [ -f summary_artifacts/comment_preview.md ]; then
            cat summary_artifacts/comment_preview.md >> "$GITHUB_STEP_SUMMARY"
          fi
