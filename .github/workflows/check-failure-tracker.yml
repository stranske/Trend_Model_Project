name: Check Failure Tracker

"on":
  workflow_run:
    workflows: ["CI", "Docker", "CI Selftest"]
    types: [completed]

permissions:
  issues: write
  contents: read
  actions: read

jobs:
  failure:
    name: track failures
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    runs-on: ubuntu-latest
    env:
      RATE_LIMIT_MINUTES: 15                # Minutes between comments for same issue
      STACK_TOKENS_ENABLED: 'true'          # 'true' to enable stack token hashing
      STACK_TOKEN_MAX_LEN: 160              # Max characters kept from extracted stack/error line
      AUTO_HEAL_INACTIVITY_HOURS: 24        # Used by success job for auto-heal closure
      FAILURE_INACTIVITY_HEAL_HOURS: 0      # (Reserved) would auto-close during failure path if >0
      NEW_ISSUE_COOLDOWN_HOURS: 24          # If >0, cooldown window for *new* failure issues (append instead)
      DISABLE_FAILURE_ISSUES: 'false'       # If 'true', skip issue create/update (still summary)
    steps:
      - name: Derive failure signature & update tracking issue
        id: tracker
        uses: actions/github-script@v7
        with:
          script: |
            const run = context.payload.workflow_run;
            const { owner, repo } = context.repo;
            const runId = run.id;

            // Config via env with sensible fallbacks
            const RATE_LIMIT_MINUTES = parseInt(process.env.RATE_LIMIT_MINUTES || '15', 10);
            const STACK_TOKENS_ENABLED = /^true$/i.test(process.env.STACK_TOKENS_ENABLED || 'true');
            const STACK_TOKEN_MAX_LEN = parseInt(process.env.STACK_TOKEN_MAX_LEN || '160', 10);
            const FAILURE_INACTIVITY_HEAL_HOURS = parseFloat(process.env.FAILURE_INACTIVITY_HEAL_HOURS || '0');
            const HEAL_THRESHOLD_DESC = `Auto-heal after ${process.env.AUTO_HEAL_INACTIVITY_HOURS || '24'}h stability (success path)`;

            // Fetch jobs for this run
            const jobsResp = await github.rest.actions.listJobsForWorkflowRun({ owner, repo, run_id: runId, per_page: 100 });
            const failedJobs = jobsResp.data.jobs.filter(j => (j.conclusion || '').toLowerCase() !== 'success');
            if (!failedJobs.length) {
              core.info('No failed jobs found despite run-level failure – aborting.');
              return;
            }

            // Phase‑2 enhancement: include a stable token from the first error / stack line in logs (if obtainable)
            let stackTokenNote = 'Stack tokens disabled';
            if (STACK_TOKENS_ENABLED) {
              const zlib = require('zlib');
              async function extractStackToken(job) {
                try {
                  const logResp = await github.request('GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs', {
                    owner, repo, job_id: job.id,
                    request: { decompress: false }
                  });
                  const gz = Buffer.from(logResp.data);
                  let text;
                  try { text = zlib.gunzipSync(gz).toString('utf8'); }
                  catch { text = gz.toString('utf8'); }
                  const lines = text.split(/\r?\n/);
                  const idxTraceback = lines.findIndex(l => /Traceback (most recent call last)/i.test(l));
                  if (idxTraceback !== -1) {
                    for (let k = idxTraceback + 1; k < Math.min(lines.length, idxTraceback + 15); k++) {
                      if (/^[A-Za-z_][A-Za-z0-9_\.]*: /.test(lines[k])) {
                        return lines[k].trim().slice(0, STACK_TOKEN_MAX_LEN);
                      }
                    }
                  }
                  const errLine = lines.find(l => /error/i.test(l));
                  if (errLine) return errLine.trim().slice(0, STACK_TOKEN_MAX_LEN);
                } catch (e) {
                  core.info(`Log parse skipped for job ${job.name}: ${e.message}`);
                }
                return 'no-stack';
              }
              for (const job of failedJobs) {
                job.__stackToken = await extractStackToken(job);
              }
              stackTokenNote = 'Stack token = first exception or error line (fallback no-stack).';
            } else {
              for (const job of failedJobs) job.__stackToken = 'stacks-off';
            }

            const sigParts = failedJobs.map(j => {
              const failingStep = (j.steps || []).find(s => (s.conclusion || '').toLowerCase() !== 'success');
              return `${j.name}::${failingStep ? failingStep.name : 'no-step'}::${j.__stackToken}`;
            }).sort();
            const crypto = require('crypto');
            const sigHash = crypto.createHash('sha256').update(sigParts.join('|')).digest('hex').slice(0, 12);
            const workflowName = run.name;
            const signature = `${workflowName}|${sigHash}`;
            const title = `Workflow Failure (${signature})`;
            const labels = ['ci-failure', 'workflows', 'devops', 'priority: medium'];

            // Ensure labels exist (best effort; ignore races)
            for (const lb of labels) {
              try { await github.rest.issues.getLabel({ owner, repo, name: lb }); }
              catch { try { await github.rest.issues.createLabel({ owner, repo, name: lb, color: 'BFDADC' }); } catch {} }
            }

            // Build markdown job table
            const rows = failedJobs.map(j => `| ${j.name} | ${(j.conclusion || j.status)} | [logs](${j.html_url}) |`);
            const table = ['| Job | Result | Logs |', '|---|---|---|', ...rows].join('\n');
            const runUrl = run.html_url;
            // Build stack token table for diagnostics
            const stackRows = failedJobs.map(j => `| ${j.name} | ${j.__stackToken.replace(/\|/g,'\\|')} |`).join('\n');
            const stackTable = ['| Job | Stack Token |','|---|---|', stackRows].join('\n');

            const bodyBlock = [
              `Workflow: **${workflowName}**`,
              `Run: ${runUrl}`,
              '',
              `**Failure signature:** \`${signature}\` (hash over failed job + first failing step names + first stack line token)`,
              '',
              '### Failed Jobs',
              table,
              '',
              '### Stack Tokens (Phase‑2)',
              stackTable,
              '',
              `> NOTE: ${stackTokenNote}`
            ].join('\n');

            // Optional global disable
            if (/^true$/i.test(process.env.DISABLE_FAILURE_ISSUES || 'false')) {
              core.info('Failure issue tracking disabled via DISABLE_FAILURE_ISSUES.');
              core.summary.addHeading('Failure (tracking disabled)');
              core.summary.addRaw('Issue creation disabled; diagnostics available in logs.');
              await core.summary.write();
              return;
            }

            // Query for existing signature issue
            const q = `repo:${owner}/${repo} is:issue is:open in:title "${signature}" label:ci-failure`;
            const search = await github.rest.search.issuesAndPullRequests({ q, per_page: 1 });
            if (search.data.items.length) {
              const issue_number = search.data.items[0].number;
              // Fetch existing issue body for occurrence tracking
              const existing = await github.rest.issues.get({ owner, repo, issue_number });
              let body = existing.data.body || '';
              const nowIso = new Date().toISOString();
              // Occurrences
              const occMatch = body.match(/Occurrences:\s*(\d+)/i);
              let occ = occMatch ? parseInt(occMatch[1], 10) : 0;
              occ += 1;
              if (/Occurrences:/i.test(body)) {
                body = body.replace(/Occurrences:\s*\d+/i, `Occurrences: ${occ}`);
              } else {
                body = `Occurrences: ${occ}\n${body}`;
              }
              if (/Last seen:/i.test(body)) {
                body = body.replace(/Last seen:.*/i, `Last seen: ${nowIso}`);
              } else {
                body = `Last seen: ${nowIso}\n${body}`;
              }
              if (!/Healing threshold:/i.test(body)) {
                body = `Healing threshold: ${HEAL_THRESHOLD_DESC}\n${body}`;
              }

              // Maintain occurrence history table inside body (bounded)
              const HISTORY_START = '<!-- occurrence-history-start -->';
              const HISTORY_END = '<!-- occurrence-history-end -->';
              const MAX_HISTORY = 10;
              const runUrlHist = run.html_url;
              const newRow = `| ${nowIso} | [run](${runUrlHist}) | ${sigHash} | ${failedJobs.length} |`;
              let historySection = `${HISTORY_START}\n| Timestamp | Run | Sig Hash | Failed Jobs |\n|---|---|---|---|\n${newRow}\n${HISTORY_END}`;
              if (body.includes(HISTORY_START) && body.includes(HISTORY_END)) {
                const pre = body.split(HISTORY_START)[0];
                const midPlus = body.split(HISTORY_START)[1];
                const after = midPlus.split(HISTORY_END)[1];
                const existingBlock = midPlus.split(HISTORY_END)[0];
                const lines = existingBlock.split(/\n/).filter(l => l.trim() && !l.startsWith('| Timestamp')); // remove header later rebuild
                // first line might be table header; keep only rows starting with '|'
                const rows = lines.filter(l => l.startsWith('|')).map(l => l.trim());
                const filtered = [newRow, ...rows.filter(r => r !== newRow)].slice(0, MAX_HISTORY);
                historySection = `${HISTORY_START}\n| Timestamp | Run | Sig Hash | Failed Jobs |\n|---|---|---|---|\n${filtered.join('\n')}\n${HISTORY_END}`;
                body = pre + historySection + after;
              } else {
                body = historySection + '\n' + body;
              }
              await github.rest.issues.update({ owner, repo, issue_number, title, body });

              // Rate limiting duplicate or too-frequent comments
              const comments = await github.rest.issues.listComments({ owner, repo, issue_number, per_page: 50 });
              const runUrl = run.html_url;
              const alreadyCommented = comments.data.some(c => c.body && c.body.includes(runUrl));
              let postComment = !alreadyCommented;
              if (postComment && comments.data.length) {
                const last = comments.data[comments.data.length - 1];
                const lastTs = Date.parse(last.created_at);
                if (!isNaN(lastTs)) {
                  const minutesAgo = (Date.now() - lastTs) / 60000;
                  if (minutesAgo < RATE_LIMIT_MINUTES) {
                    postComment = false;
                    core.info(`Skipping comment due to rate limit (${minutesAgo.toFixed(1)} < ${RATE_LIMIT_MINUTES}m).`);
                  }
                }
              }
              if (postComment) {
                await github.rest.issues.createComment({ owner, repo, issue_number, body: bodyBlock });
                core.info(`Appended failure instance comment to #${issue_number}`);
              }
              core.info(`Updated existing failure issue #${issue_number} (occurrence ${occ}).`);
            } else {
              // Cooldown path for new issues
              const cooldownHours = parseFloat(process.env.NEW_ISSUE_COOLDOWN_HOURS || '0');
              if (cooldownHours > 0) {
                const recent = await github.rest.search.issuesAndPullRequests({
                  q: `repo:${owner}/${repo} is:issue label:ci-failure`,
                  sort: 'created', order: 'desc', per_page: 1
                });
                if (recent.data.items.length) {
                  const latest = recent.data.items[0];
                  const createdAt = Date.parse(latest.created_at);
                  if (!isNaN(createdAt)) {
                    const age = (Date.now() - createdAt) / 3_600_000;
                    if (age < cooldownHours) {
                      await github.rest.issues.createComment({ owner, repo, issue_number: latest.number, body: `Additional failure during cooldown (no new issue).\n\n${bodyBlock}` });
                      core.info(`Cooldown active (${age.toFixed(2)}h < ${cooldownHours}h). Appended to #${latest.number}`);
                      return;
                    }
                  }
                }
              }
              const nowIso = new Date().toISOString();
              const headerMeta = [
                'Occurrences: 1',
                `Last seen: ${nowIso}`,
                `Healing threshold: ${HEAL_THRESHOLD_DESC}`,
                ''
              ].join('\n');
              const created = await github.rest.issues.create({ owner, repo, title, body: headerMeta + bodyBlock, labels });
              core.info(`Created new failure issue #${created.data.number}`);
            }
      - name: Emit summary
        run: echo "Failure tracking step completed." >> $GITHUB_STEP_SUMMARY

  success:
    name: success summary
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    env:
      AUTO_HEAL_INACTIVITY_HOURS: 24   # Hours without recurrence before auto-heal closes issue
    steps:
      - name: Auto-heal stale failure issues & note success
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const INACTIVITY_HOURS = parseFloat(process.env.AUTO_HEAL_INACTIVITY_HOURS || '24');
            const now = Date.now();
            const perPage = 50;
            // Search open ci-failure issues
            const q = `repo:${owner}/${repo} is:issue is:open label:ci-failure`;
            const search = await github.rest.search.issuesAndPullRequests({ q, per_page: 100 });
            for (const item of search.data.items) {
              const issue_number = item.number;
              const issue = await github.rest.issues.get({ owner, repo, issue_number });
              const body = issue.data.body || '';
              const m = body.match(/Last seen:\s*(.+)/i);
              if (!m) continue;
              const lastSeenTs = Date.parse(m[1].trim());
              if (isNaN(lastSeenTs)) continue;
              const hours = (now - lastSeenTs) / 3_600_000;
              if (hours >= INACTIVITY_HOURS) {
                const comment = `Auto-heal: no reoccurrence for ${hours.toFixed(1)}h (>= ${INACTIVITY_HOURS}h). Closing.`;
                await github.rest.issues.createComment({ owner, repo, issue_number, body: comment });
                await github.rest.issues.update({ owner, repo, issue_number, state: 'closed' });
                core.info(`Closed healed failure issue #${issue_number}`);
              }
            }
            core.summary.addHeading('Success Run Summary');
            core.summary.addRaw('Checked for stale failure issues and applied auto-heal where applicable.');
            await core.summary.write();
      - name: Snapshot open failure issues (JSON)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const q = `repo:${owner}/${repo} is:issue is:open label:ci-failure`;
            const search = await github.rest.search.issuesAndPullRequests({ q, per_page: 100 });
            const issues = [];
            for (const item of search.data.items) {
              const issue = await github.rest.issues.get({ owner, repo, issue_number: item.number });
              const body = issue.data.body || '';
              const occ = (body.match(/Occurrences:\s*(\d+)/i)||[])[1] || null;
              const lastSeen = (body.match(/Last seen:\s*(.*)/i)||[])[1] || null;
              issues.push({
                number: issue.data.number,
                title: issue.data.title,
                occurrences: occ ? parseInt(occ,10) : null,
                last_seen: lastSeen,
                url: issue.data.html_url,
                created_at: issue.data.created_at,
                updated_at: issue.data.updated_at
              });
            }
            const fs = require('fs');
            fs.mkdirSync('artifacts', { recursive: true });
            fs.writeFileSync('artifacts/ci_failures_snapshot.json', JSON.stringify({ generated_at: new Date().toISOString(), issues }, null, 2));
            core.info(`Snapshot written with ${issues.length} open failure issues.`);
      - name: Upload snapshot artifact
        uses: actions/upload-artifact@v4
        with:
            name: ci-failures-snapshot
            path: artifacts/ci_failures_snapshot.json
      - name: Emit success summary
        run: echo "Run succeeded – failure issues scanned for auto-heal." >> $GITHUB_STEP_SUMMARY
