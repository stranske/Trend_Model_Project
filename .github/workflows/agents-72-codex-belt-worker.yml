# Executes the Codex belt worker: validates the queued issue, ensures the
# codex/issue-<n> branch exists, and opens or refreshes the automation PR.
name: Agents 72 Codex Belt Worker

on:
  workflow_call:
    inputs:
      issue:
        description: 'Issue number'
        required: true
        type: string
      branch:
        description: 'Branch to prepare (codex/issue-<n>)'
        required: true
        type: string
      base:
        description: 'Base branch (defaults to repository default)'
        required: false
        default: ''
        type: string
      source:
        description: 'Source of the worker invocation'
        required: false
        default: 'orchestrator'
        type: string
      dry_run:
        description: 'Preview worker actions without writes'
        required: false
        default: false
        type: boolean
      max_parallel:
        description: 'Maximum concurrent worker runs permitted'
        required: false
        default: 1
        type: number
    secrets:
      actions_bot_pat:
        required: true

  repository_dispatch:
    types: [codex-belt.work]

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

concurrency:
  group: codex-belt-${{ github.event.client_payload.issue || github.event.client_payload.issue_number || github.event.inputs.issue || github.run_id }}
  cancel-in-progress: false

jobs:
  bootstrap:
    name: Prepare Codex automation PR
    runs-on: ubuntu-latest
    outputs:
      issue: ${{ steps.ctx.outputs.issue || '' }}
      branch: ${{ steps.ctx.outputs.branch || '' }}
      base: ${{ steps.base.outputs.branch || '' }}
      pr_number: ${{ steps.pr.outputs.number || '' }}
      dry_run: ${{ steps.mode.outputs.dry_run || 'false' }}
      allowed: ${{ steps.parallel.outputs.allowed || 'true' }}
      concurrency_group: ${{ steps.ctx.outputs.concurrency_group || '' }}
    env:
      ACTIONS_BOT_PAT: ${{ secrets.actions_bot_pat != '' && secrets.actions_bot_pat || secrets.ACTIONS_BOT_PAT }}
    steps:
      - name: Ensure ACTIONS_BOT_PAT is configured
        run: |
          if [ -z "$ACTIONS_BOT_PAT" ]; then
            echo '::error::ACTIONS_BOT_PAT secret is required for worker actions.'
            exit 1
          fi

      - name: Determine worker mode
        id: mode
        uses: actions/github-script@v7
        with:
          script: |
            const eventName = context.eventName;
            const coerce = (value) => {
              if (typeof value === 'boolean') {
                return value;
              }
              if (typeof value === 'number') {
                return value !== 0;
              }
              if (typeof value === 'string') {
                const norm = value.trim().toLowerCase();
                if (['true', '1', 'yes', 'y', 'on'].includes(norm)) {
                  return true;
                }
                if (['false', '0', 'no', 'n', 'off', ''].includes(norm)) {
                  return false;
                }
              }
              return false;
            };

            const payload = eventName === 'repository_dispatch'
              ? (context.payload && context.payload.client_payload) || {}
              : {};

            const dryRunInput = '${{ inputs.dry_run }}';
            const dryRunValue = dryRunInput !== '' ? dryRunInput : payload.dry_run;
            const dryRun = coerce(dryRunValue);

            core.setOutput('dry_run', dryRun ? 'true' : 'false');

      - name: Resolve worker context
        id: ctx
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const eventName = context.eventName;
            const payload = eventName === 'repository_dispatch'
              ? (context.payload && context.payload.client_payload) || {}
              : {};

            const issueInput = '${{ inputs.issue }}'.trim();
            const branchInput = '${{ inputs.branch }}'.trim();
            const baseInput = '${{ inputs.base }}'.trim();
            const sourceInput = '${{ inputs.source }}'.trim();

            const coerceNumber = (value) => {
              const parsed = Number(value);
              return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
            };

            let issue = coerceNumber(issueInput);
            if (!issue) {
              issue = coerceNumber(payload.issue ?? payload.issue_number);
            }

            let branch = branchInput;
            if (!branch && payload.branch) {
              branch = String(payload.branch).trim();
            }
            if (!branch && issue) {
              branch = `codex/issue-${issue}`;
            }

            let base = baseInput;
            if (!base && payload.base) {
              base = String(payload.base).trim();
            }

            let source = sourceInput;
            if (!source && payload.source) {
              source = String(payload.source).trim();
            }
            if (!source) {
              source = eventName === 'repository_dispatch' ? 'dispatcher' : 'orchestrator';
            }

            if (!issue) {
              core.setFailed('Worker missing issue number.');
              return;
            }
            if (!branch) {
              core.setFailed('Worker missing branch name.');
              return;
            }
            if (!branch.startsWith('codex/issue-')) {
              core.warning(`Unexpected branch naming: ${branch}`);
            }

            const runId = context.runId;
            const concurrencyKey = issue || payload.issue || payload.issue_number || runId;
            const concurrencyGroup = concurrencyKey ? `codex-belt-${concurrencyKey}` : '';
            if (!concurrencyGroup) {
              core.setFailed('Unable to determine concurrency group.');
              return;
            }

            core.setOutput('issue', String(issue));
            core.setOutput('branch', branch);
            core.setOutput('base', base);
            core.setOutput('source', source);
            core.setOutput('concurrency_group', concurrencyGroup);
            core.summary
              .addHeading('Codex Belt Worker')
              .addTable([[{ data: 'Issue', header: true }, { data: 'Branch', header: true }, { data: 'Source', header: true }], [`#${issue}`, branch, source]])
              .addTable([[{ data: 'Concurrency Group', header: true }, { data: 'Issue', header: true }, { data: 'Branch', header: true }], [concurrencyGroup, `#${issue}`, branch]])
              .write();

      - name: Determine default branch
        id: base
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const supplied = '${{ steps.ctx.outputs.base }}'.trim();
            if (supplied) {
              core.setOutput('branch', supplied);
              return;
            }
            const { owner, repo } = context.repo;
            const { data } = await github.rest.repos.get({ owner, repo });
            core.setOutput('branch', data.default_branch || 'main');

      - name: Check parallel allowance
        id: parallel
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const eventName = context.eventName;
            const payload = eventName === 'repository_dispatch'
              ? (context.payload && context.payload.client_payload) || {}
              : {};

            const rawMaxInput = '${{ inputs.max_parallel }}';
            const rawMax = rawMaxInput !== '' ? Number(rawMaxInput) : Number(payload.max_parallel);
            const maxParallel = Number.isFinite(rawMax) && rawMax > 0 ? rawMax : 1;
            if (maxParallel <= 1) {
              core.setOutput('allowed', 'true');
              return;
            }

            const { owner, repo } = context.repo;
            const workflowId = 'agents-72-codex-belt-worker.yml';
            const { data } = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: workflowId,
              status: 'in_progress',
              per_page: 100,
            });

            const currentRunId = context.runId;
            const others = (data.workflow_runs || []).filter((run) => run.id !== currentRunId);
            if (others.length >= maxParallel) {
              core.info(`Skipping worker execution – ${others.length} concurrent runs >= max_parallel ${maxParallel}.`);
              core.setOutput('allowed', 'false');
              return;
            }

            core.setOutput('allowed', 'true');

      - name: Re-verify issue labels
        if: ${{ steps.parallel.outputs.allowed == 'true' }}
        id: verify
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const { owner, repo } = context.repo;
            const { data } = await github.rest.issues.get({ owner, repo, issue_number: issue });

            const labelNames = Array.isArray(data.labels) ? data.labels.map((l) => String(l.name || '')) : [];
            const hasCodex = labelNames.some((name) => name === 'agent:codex');
            if (!hasCodex) {
              core.setFailed(`Issue #${issue} no longer carries the agent:codex label.`);
              return;
            }
            const hasReady = labelNames.some((name) => name === 'status:ready');
            const hasInProgress = labelNames.some((name) => name === 'status:in-progress');
            core.setOutput('has_ready', hasReady ? 'true' : 'false');
            core.setOutput('has_in_progress', hasInProgress ? 'true' : 'false');

      - name: Checkout branch
        if: ${{ steps.parallel.outputs.allowed == 'true' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.ctx.outputs.branch }}
          token: ${{ env.ACTIONS_BOT_PAT }}
          fetch-depth: 0

      - name: Prepare ledger task
        if: ${{ steps.parallel.outputs.allowed == 'true' }}
        id: ledger_start
        env:
          ISSUE: ${{ steps.ctx.outputs.issue }}
          BRANCH: ${{ steps.ctx.outputs.branch }}
          BASE_BRANCH: ${{ steps.base.outputs.branch }}
          GITHUB_TOKEN: ${{ env.ACTIONS_BOT_PAT }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          python <<'PY'
          import datetime as dt
          import json
          import os
          import re
          import sys
          import urllib.request
          from pathlib import Path

          import yaml

          def iso_now() -> str:
              return dt.datetime.utcnow().replace(microsecond=0).isoformat() + 'Z'

          issue = os.environ["ISSUE"].strip()
          branch = os.environ["BRANCH"].strip()
          base = os.environ["BASE_BRANCH"].strip()
          repo = os.environ["GITHUB_REPOSITORY"].strip()
          token = os.environ.get("GITHUB_TOKEN", "").strip()

          agents_dir = Path('.agents')
          agents_dir.mkdir(parents=True, exist_ok=True)
          ledger_path = agents_dir / f'issue-{issue}-ledger.yml'
          start_path = agents_dir / '.ledger-start.json'

          original_text = None
          data = None
          if ledger_path.exists():
              original_text = ledger_path.read_text(encoding='utf-8')
              loaded = yaml.safe_load(original_text) or {}
              if not isinstance(loaded, dict):
                  raise SystemExit(f"Ledger {ledger_path} must contain a mapping")
              data = loaded
          else:
              owner, _, name = repo.partition('/')
              url = f"https://api.github.com/repos/{owner}/{name}/issues/{issue}"
              headers = {"Accept": "application/vnd.github+json"}
              if token:
                  headers["Authorization"] = f"token {token}"
              request = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(request, timeout=30) as response:
                  payload = json.load(response)
              body = payload.get('body') or ''
              pattern = re.compile(r'^\s*[-*]\s+\[(?: |x|X)\]\s+(.*)$', re.MULTILINE)
              tasks = []
              for index, match in enumerate(pattern.finditer(body), start=1):
                  title = match.group(1).strip()
                  if not title:
                      continue
                  tasks.append({
                      'id': f'task-{index:02d}',
                      'title': title,
                      'status': 'todo',
                      'started_at': None,
                      'finished_at': None,
                      'commit': '',
                      'notes': [],
                  })
              if not tasks:
                  tasks = [{
                      'id': 'task-01',
                      'title': 'Initialise durable progress ledger from issue tasks',
                      'status': 'todo',
                      'started_at': None,
                      'finished_at': None,
                      'commit': '',
                      'notes': [],
                  }]
              data = {
                  'version': 1,
                  'issue': int(issue),
                  'base': base,
                  'branch': branch,
                  'tasks': tasks,
              }

          data.setdefault('version', 1)
          data.setdefault('issue', int(issue))
          data['issue'] = int(data['issue'])
          data['base'] = base
          data['branch'] = branch
          tasks = data.setdefault('tasks', [])
          if not isinstance(tasks, list):
              raise SystemExit('Ledger tasks must be a list')

          selected = None
          previous_status = None
          for task in tasks:
              if not isinstance(task, dict):
                  continue
              task.setdefault('notes', [])
              task.setdefault('commit', '')
              if task.get('status') == 'doing':
                  selected = task
                  previous_status = 'doing'
                  break
          if selected is None:
              for task in tasks:
                  if not isinstance(task, dict):
                      continue
                  if task.get('status') == 'todo':
                      selected = task
                      previous_status = 'todo'
                      break

          now = iso_now()
          if selected is not None:
              if selected.get('status') == 'todo':
                  selected['status'] = 'doing'
                  selected['started_at'] = now
                  selected['finished_at'] = None
                  selected['commit'] = ''
              elif selected.get('status') == 'doing' and not selected.get('started_at'):
                  selected['started_at'] = now

          new_text = yaml.safe_dump(data, sort_keys=False)
          changed = new_text != (original_text or '')
          if changed:
              ledger_path.write_text(new_text, encoding='utf-8')

          start_info = {
              'issue': issue,
              'ledger_path': str(ledger_path),
              'created': original_text is None,
              'ledger_changed': changed,
              'task': None,
          }
          if selected is not None:
              start_info['task'] = {
                  'id': selected.get('id'),
                  'title': selected.get('title'),
                  'previous_status': previous_status,
                  'current_status': selected.get('status'),
              }
          start_path.write_text(json.dumps(start_info), encoding='utf-8')

          gh_output = os.environ.get('GITHUB_OUTPUT')
          if gh_output:
              with open(gh_output, 'a', encoding='utf-8') as handle:
                  handle.write(f"task_id={start_info['task']['id'] if start_info['task'] else ''}\n")
                  handle.write(f"task_status={start_info['task']['current_status'] if start_info['task'] else ''}\n")
                  handle.write(f"ledger_changed={'true' if changed else 'false'}\n")
                  handle.write(f"ledger_created={'true' if start_info['created'] else 'false'}\n")
          PY

      - name: Validate ledger schema (pre-flight)
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.ledger_start.outputs.ledger_changed == 'true' }}
        run: |
          python scripts/ledger_validate.py .agents/issue-${{ steps.ctx.outputs.issue }}-ledger.yml

      - name: Commit ledger in-progress state
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.ledger_start.outputs.ledger_changed == 'true' }}
        env:
          ISSUE: ${{ steps.ctx.outputs.issue }}
          BRANCH: ${{ steps.ctx.outputs.branch }}
          TASK_ID: ${{ steps.ledger_start.outputs.task_id }}
        run: |
          set -euo pipefail
          git config user.name "stranske-automation-bot"
          git config user.email "stranske-automation-bot@users.noreply.github.com"
          git add .agents/issue-${ISSUE}-ledger.yml
          if git diff --cached --quiet; then
            exit 0
          fi
          task_id=${TASK_ID:-n/a}
          git commit -m "chore(ledger): start task ${task_id} for issue #${ISSUE}"
          git push origin "${BRANCH}"

      - name: Ensure branch exists remotely
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' }}
        run: |
          set -euo pipefail
          branch="${{ steps.ctx.outputs.branch }}"
          if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
            echo "Confirmed origin/$branch exists."
          else
            echo "::error::Expected branch $branch on origin." >&2
            exit 1
          fi

      - name: Create placeholder commit when branch matches base
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' }}
        env:
          BASE_BRANCH: ${{ steps.base.outputs.branch }}
        run: |
          set -euo pipefail
          branch="${{ steps.ctx.outputs.branch }}"
          base="${BASE_BRANCH}"
          git fetch origin "$base"
          upstream_sha=$(git rev-parse "origin/$base")
          head_sha=$(git rev-parse HEAD)
          if [ "$upstream_sha" = "$head_sha" ]; then
            git config user.name "stranske-automation-bot"
            git config user.email "stranske-automation-bot@users.noreply.github.com"
            git commit --allow-empty -m "chore(codex): initialize belt run for issue #${{ steps.ctx.outputs.issue }}"
            git push origin "$branch"
          else
            echo "Branch already diverged from $base; skipping placeholder commit."
          fi

      - name: Ensure issue labels reflect in-progress state
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.verify.outputs.has_in_progress != 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: issue, labels: ['status:in-progress'] });
            } catch (error) {
              core.warning(`Failed to set status:in-progress: ${error.message}`);
            }

      - name: Remove residual status:ready label
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.verify.outputs.has_ready == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: issue, name: 'status:ready' });
            } catch (error) {
              if (error.status !== 404) {
                core.warning(`Failed to remove status:ready: ${error.message}`);
              }
            }

      - name: Open or refresh Codex PR
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' }}
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const branch = '${{ steps.ctx.outputs.branch }}';
            const base = '${{ steps.base.outputs.branch }}';
            const { owner, repo } = context.repo;

            const issueUrl = `https://github.com/${owner}/${repo}/issues/${issue}`;
            let issueTitle = '';
            let issueBody = '';
            try {
              const { data: issueData } = await github.rest.issues.get({ owner, repo, issue_number: issue });
              issueTitle = issueData.title || '';
              issueBody = issueData.body || '';
            } catch (error) {
              core.warning(`Unable to read issue #${issue}: ${error.message}`);
            }

            const header = `### Source Issue #${issue}: ${issueTitle}`;
            const quoted = (issueBody || '').split('\n').map((line) => `> ${line}`).join('\n');
            const body = `${header}\n\nSource: ${issueUrl}\n\n${quoted}\n\n—\nPR created automatically to engage Codex.`;

            // Attempt to reuse an existing PR first
            let prNumber = null;
            try {
              const { data: prs } = await github.rest.pulls.list({ owner, repo, head: `${owner}:${branch}`, state: 'open' });
              const existing = prs.find((p) => p.head && p.head.ref === branch);
              if (existing) {
                prNumber = existing.number;
                await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body });
              }
            } catch (error) {
              core.warning(`Failed to search for existing PR: ${error.message}`);
            }

            if (!prNumber) {
              try {
                const { data: pr } = await github.rest.pulls.create({ owner, repo, head: branch, base, title: `Codex belt for #${issue}`, body });
                prNumber = pr.number;
              } catch (error) {
                core.setFailed(`Failed to open pull request: ${error.status || '?'} ${error.message}`);
                return;
              }
            }

            core.setOutput('number', String(prNumber));
            core.summary.addRaw(`Prepared PR #${prNumber} targeting \`${base}\`.`).write();

      - name: Apply automation labels
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.pr.outputs.number }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            const { owner, repo } = context.repo;
            const labels = ['agent:codex', 'autofix', 'from:codex'];
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels });
            } catch (error) {
              core.warning(`Failed to label PR #${prNumber}: ${error.message}`);
            }

      - name: Ensure PR assignees include automation
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.pr.outputs.number }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const { owner, repo } = context.repo;
            const assignees = ['chatgpt-codex-connector', 'stranske-automation-bot'];
            for (const target of [prNumber, issue]) {
              try {
                await github.rest.issues.addAssignees({ owner, repo, issue_number: target, assignees });
              } catch (error) {
                core.warning(`Failed to assign #${target}: ${error.message}`);
              }
            }

      - name: Post activation comment
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.pr.outputs.number }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            const { owner, repo } = context.repo;
            const message = '@codex start\n\nAutomated belt worker prepared this PR. Please continue implementing the requested changes.';
            try {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: message });
            } catch (error) {
              core.warning(`Failed to post Codex command on PR #${prNumber}: ${error.message}`);
            }

      - name: Sync issue comment with PR link
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.pr.outputs.number }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.createComment({ owner, repo, issue_number: issue, body: `Opened PR #${prNumber} via Codex belt worker.` });
            } catch (error) {
              core.warning(`Failed to comment on issue #${issue}: ${error.message}`);
            }

      - name: Finalise ledger task
        if: ${{ always() && steps.parallel.outputs.allowed == 'true' }}
        id: ledger_finalize
        env:
          ISSUE: ${{ steps.ctx.outputs.issue }}
          BRANCH: ${{ steps.ctx.outputs.branch }}
          BASE_BRANCH: ${{ steps.base.outputs.branch }}
          TASK_ID: ${{ steps.ledger_start.outputs.task_id }}
          JOB_STATUS: ${{ job.status }}
          DRY_RUN: ${{ steps.mode.outputs.dry_run }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          set -euo pipefail
          python <<'PY'
          import datetime as dt
          import json
          import os
          import subprocess
          from pathlib import Path

          import yaml

          def iso_now() -> str:
              return dt.datetime.utcnow().replace(microsecond=0).isoformat() + 'Z'

          issue = os.environ.get('ISSUE', '').strip()
          branch = os.environ.get('BRANCH', '').strip()
          base = os.environ.get('BASE_BRANCH', '').strip()
          task_id_env = (os.environ.get('TASK_ID') or '').strip()
          job_status = (os.environ.get('JOB_STATUS') or '').lower()
          dry_run = (os.environ.get('DRY_RUN') or '').lower() == 'true'
          run_id = os.environ.get('GITHUB_RUN_ID', '')

          agents_dir = Path('.agents')
          ledger_path = agents_dir / f'issue-{issue}-ledger.yml'
          start_path = agents_dir / '.ledger-start.json'
          summary_path = agents_dir / '.ledger-summary.md'

          original_text = ledger_path.read_text(encoding='utf-8') if ledger_path.exists() else ''
          data = yaml.safe_load(original_text) if original_text else None
          if data is None:
              data = {}
          if not isinstance(data, dict):
              raise SystemExit(f'Ledger {ledger_path} must contain a mapping')
          tasks = data.get('tasks') or []
          if not isinstance(tasks, list):
              raise SystemExit('Ledger tasks must be a list')

          start_info = {}
          if start_path.exists():
              try:
                  start_info = json.loads(start_path.read_text(encoding='utf-8'))
              except json.JSONDecodeError:
                  start_info = {}
          task_info = start_info.get('task') if isinstance(start_info.get('task'), dict) else None
          task_id = task_id_env or (task_info.get('id') if task_info else '')

          summary_lines = []
          if start_info.get('created'):
              summary_lines.append(f"Created ledger for issue #{issue} targeting {branch} -> {base}.")

          target_task = None
          for task in tasks:
              if isinstance(task, dict) and task.get('id') == task_id:
                  target_task = task
                  break

          changed = False
          final_status = ''
          commit_sha = ''

          if not task_id:
              summary_lines.append('No ledger task selected for this run.')
          elif target_task is None:
              summary_lines.append(f"Ledger task {task_id} not found; no updates applied.")
          elif dry_run:
              summary_lines.append(f"Dry run – task {task_id} remains {target_task.get('status','todo')}.")
              final_status = str(target_task.get('status', ''))
          else:
              status_before = str(target_task.get('status', ''))
              notes = target_task.setdefault('notes', [])
              if not isinstance(notes, list):
                  notes = []
                  target_task['notes'] = notes
              if job_status == 'success':
                  commit_sha = subprocess.check_output(['git', 'rev-parse', 'HEAD'], text=True).strip()
                  target_task['status'] = 'done'
                  target_task['finished_at'] = iso_now()
                  if not target_task.get('started_at'):
                      target_task['started_at'] = target_task['finished_at']
                  target_task['commit'] = commit_sha
                  final_status = 'done'
                  summary_lines.append(f"Task {task_id} advanced {status_before} → done @ {commit_sha[:7]}.")
              else:
                  note = f"{iso_now()} failure (run {run_id}): status={job_status or 'failure'}"
                  notes.append(note)
                  target_task['status'] = 'todo'
                  target_task['commit'] = ''
                  target_task['finished_at'] = None
                  target_task['started_at'] = None
                  final_status = 'todo'
                  summary_lines.append(f"Task {task_id} reset to todo after {job_status or 'failure'}.")

              new_text = yaml.safe_dump(data, sort_keys=False)
              if new_text != original_text:
                  ledger_path.write_text(new_text, encoding='utf-8')
                  changed = True

          if not summary_lines:
              summary_lines.append('Ledger unchanged during this run.')

          summary_path.write_text('\n'.join(summary_lines) + '\n', encoding='utf-8')

          if start_path.exists():
              start_path.unlink()

          gh_output = os.environ.get('GITHUB_OUTPUT')
          if gh_output:
              with open(gh_output, 'a', encoding='utf-8') as handle:
                  handle.write(f"ledger_changed={'true' if changed else 'false'}\n")
                  handle.write(f"task_id={task_id}\n")
                  handle.write(f"task_status={final_status}\n")
                  handle.write(f"ledger_path={ledger_path if ledger_path.exists() else ''}\n")
                  handle.write(f"commit_sha={commit_sha}\n")
          PY

      - name: Validate ledger schema (final)
        if: ${{ always() && steps.parallel.outputs.allowed == 'true' && steps.ledger_finalize.outputs.ledger_path != '' }}
        run: |
          python scripts/ledger_validate.py ${{ steps.ledger_finalize.outputs.ledger_path }}

      - name: Commit ledger completion state
        if: ${{ always() && steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.ledger_finalize.outputs.ledger_changed == 'true' }}
        env:
          ISSUE: ${{ steps.ctx.outputs.issue }}
          BRANCH: ${{ steps.ctx.outputs.branch }}
          TASK_ID: ${{ steps.ledger_finalize.outputs.task_id }}
        run: |
          set -euo pipefail
          git config user.name "stranske-automation-bot"
          git config user.email "stranske-automation-bot@users.noreply.github.com"
          git add .agents/issue-${ISSUE}-ledger.yml
          if git diff --cached --quiet; then
            exit 0
          fi
          task_id=${TASK_ID:-n/a}
          git commit -m "chore(ledger): finish task ${task_id} for issue #${ISSUE}"
          git push origin "${BRANCH}"

      - name: Append ledger delta to summary
        if: ${{ always() && steps.parallel.outputs.allowed == 'true' }}
        run: |
          if [ -f .agents/.ledger-summary.md ]; then
            cat .agents/.ledger-summary.md >>"$GITHUB_STEP_SUMMARY"
          fi

      - name: Summarise worker preview
        if: ${{ steps.parallel.outputs.allowed != 'true' || steps.mode.outputs.dry_run == 'true' }}
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          Worker executed in preview mode. No branches, issues, or pull requests were modified.
          EOF
