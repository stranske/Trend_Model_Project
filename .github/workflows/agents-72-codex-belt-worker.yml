# Executes the Codex belt worker: validates the queued issue, ensures the
# codex/issue-<n> branch exists, and opens or refreshes the automation PR.
name: Agents 72 Codex Belt Worker

on:
  workflow_call:
    inputs:
      issue:
        description: 'Issue number'
        required: true
        type: string
      branch:
        description: 'Branch to prepare (codex/issue-<n>)'
        required: true
        type: string
      base:
        description: 'Base branch (defaults to repository default)'
        required: false
        default: ''
        type: string
      source:
        description: 'Source of the worker invocation'
        required: false
        default: 'orchestrator'
        type: string
      dry_run:
        description: 'Preview worker actions without writes'
        required: false
        default: false
        type: boolean
      use_step_branch:
        description: 'Allow fallback step branch when issue branch is stale'
        required: false
        default: false
        type: boolean
      max_parallel:
        description: 'Maximum concurrent worker runs permitted'
        required: false
        default: 1
        type: number
    secrets:
      actions_bot_pat:
        required: true

  repository_dispatch:
    types: [codex-belt.work]

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

concurrency:
  group: codex-belt-${{ github.event.client_payload.issue || github.event.client_payload.issue_number || github.event.inputs.issue || github.run_id }}
  cancel-in-progress: false

jobs:
  bootstrap:
    name: Prepare Codex automation PR
    runs-on: ubuntu-latest
    outputs:
      issue: ${{ steps.ctx.outputs.issue || '' }}
      branch: ${{ steps.ctx.outputs.branch || '' }}
      base: ${{ steps.base.outputs.branch || '' }}
      pr_number: ${{ steps.pr.outputs.number || '' }}
      dry_run: ${{ steps.mode.outputs.dry_run || 'false' }}
      allowed: ${{ steps.parallel.outputs.allowed || 'true' }}
      use_step_branch: ${{ steps.mode.outputs.use_step_branch || 'false' }}
      freshness: ${{ steps.freshness.outputs.status || '' }}
      fallback_branch: ${{ steps.fallback.outputs.branch || '' }}
    env:
      ACTIONS_BOT_PAT: ${{ secrets.actions_bot_pat != '' && secrets.actions_bot_pat || secrets.ACTIONS_BOT_PAT }}
    steps:
      - name: Ensure ACTIONS_BOT_PAT is configured
        run: |
          if [ -z "$ACTIONS_BOT_PAT" ]; then
            echo '::error::ACTIONS_BOT_PAT secret is required for worker actions.'
            exit 1
          fi

      - name: Determine worker mode
        id: mode
        uses: actions/github-script@v7
        with:
          script: |
            const eventName = context.eventName;
            const coerce = (value) => {
              if (typeof value === 'boolean') {
                return value;
              }
              if (typeof value === 'number') {
                return value !== 0;
              }
              if (typeof value === 'string') {
                const norm = value.trim().toLowerCase();
                if (['true', '1', 'yes', 'y', 'on'].includes(norm)) {
                  return true;
                }
                if (['false', '0', 'no', 'n', 'off', ''].includes(norm)) {
                  return false;
                }
              }
              return false;
            };

            const payload = eventName === 'repository_dispatch'
              ? (context.payload && context.payload.client_payload) || {}
              : {};

            const dryRunInput = '${{ inputs.dry_run }}';
            const dryRunValue = dryRunInput !== '' ? dryRunInput : payload.dry_run;
            const dryRun = coerce(dryRunValue);

            const stepBranchInput = '${{ inputs.use_step_branch }}';
            const stepBranchValue = stepBranchInput !== '' ? stepBranchInput : payload.use_step_branch;
            const useStepBranch = coerce(stepBranchValue);

            core.setOutput('dry_run', dryRun ? 'true' : 'false');
            core.setOutput('use_step_branch', useStepBranch ? 'true' : 'false');

      - name: Resolve worker context
        id: ctx
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const eventName = context.eventName;
            const payload = eventName === 'repository_dispatch'
              ? (context.payload && context.payload.client_payload) || {}
              : {};

            const issueInput = '${{ inputs.issue }}'.trim();
            const branchInput = '${{ inputs.branch }}'.trim();
            const baseInput = '${{ inputs.base }}'.trim();
            const sourceInput = '${{ inputs.source }}'.trim();

            const coerceNumber = (value) => {
              const parsed = Number(value);
              return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
            };

            let issue = coerceNumber(issueInput);
            if (!issue) {
              issue = coerceNumber(payload.issue ?? payload.issue_number);
            }

            let branch = branchInput;
            if (!branch && payload.branch) {
              branch = String(payload.branch).trim();
            }
            if (!branch && issue) {
              branch = `codex/issue-${issue}`;
            }

            let base = baseInput;
            if (!base && payload.base) {
              base = String(payload.base).trim();
            }

            let source = sourceInput;
            if (!source && payload.source) {
              source = String(payload.source).trim();
            }
            if (!source) {
              source = eventName === 'repository_dispatch' ? 'dispatcher' : 'orchestrator';
            }

            if (!issue) {
              core.setFailed('Worker missing issue number.');
              return;
            }
            if (!branch) {
              core.setFailed('Worker missing branch name.');
              return;
            }
            if (!branch.startsWith('codex/issue-')) {
              core.warning(`Unexpected branch naming: ${branch}`);
            }

            const runId = context.runId;
            const concurrencyKey = issue || payload.issue || payload.issue_number || runId;
            const concurrencyGroup = concurrencyKey ? `codex-belt-${concurrencyKey}` : '';
            if (!concurrencyGroup) {
              core.setFailed('Unable to determine concurrency group.');
              return;
            }

            core.setOutput('issue', String(issue));
            core.setOutput('branch', branch);
            core.setOutput('base', base);
            core.setOutput('source', source);
            core.setOutput('concurrency_group', concurrencyGroup);
            core.summary
              .addHeading('Codex Belt Worker')
              .addTable([[{ data: 'Issue', header: true }, { data: 'Branch', header: true }, { data: 'Source', header: true }], [`#${issue}`, branch, source]])
              .addTable([[{ data: 'Concurrency Group', header: true }, { data: 'Issue', header: true }, { data: 'Branch', header: true }], [concurrencyGroup, `#${issue}`, branch]])
              .write();

      - name: Determine default branch
        id: base
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const supplied = '${{ steps.ctx.outputs.base }}'.trim();
            if (supplied) {
              core.setOutput('branch', supplied);
              return;
            }
            const { owner, repo } = context.repo;
            const { data } = await github.rest.repos.get({ owner, repo });
            core.setOutput('branch', data.default_branch || 'main');

      - name: Check parallel allowance
        id: parallel
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const eventName = context.eventName;
            const payload = eventName === 'repository_dispatch'
              ? (context.payload && context.payload.client_payload) || {}
              : {};

            const rawMaxInput = '${{ inputs.max_parallel }}';
            const rawMax = rawMaxInput !== '' ? Number(rawMaxInput) : Number(payload.max_parallel);
            const maxParallel = Number.isFinite(rawMax) && rawMax > 0 ? rawMax : 1;
            if (maxParallel <= 1) {
              core.setOutput('allowed', 'true');
              return;
            }

            const { owner, repo } = context.repo;
            const workflowId = 'agents-72-codex-belt-worker.yml';
            const { data } = await github.rest.actions.listWorkflowRuns({
              owner,
              repo,
              workflow_id: workflowId,
              status: 'in_progress',
              per_page: 100,
            });

            const currentRunId = context.runId;
            const others = (data.workflow_runs || []).filter((run) => run.id !== currentRunId);
            if (others.length >= maxParallel) {
              core.info(`Skipping worker execution – ${others.length} concurrent runs >= max_parallel ${maxParallel}.`);
              core.setOutput('allowed', 'false');
              return;
            }

            core.setOutput('allowed', 'true');

      - name: Re-verify issue labels
        if: ${{ steps.parallel.outputs.allowed == 'true' }}
        id: verify
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const { owner, repo } = context.repo;
            const { data } = await github.rest.issues.get({ owner, repo, issue_number: issue });

            const labelNames = Array.isArray(data.labels) ? data.labels.map((l) => String(l.name || '')) : [];
            const hasCodex = labelNames.some((name) => name === 'agent:codex');
            if (!hasCodex) {
              core.setFailed(`Issue #${issue} no longer carries the agent:codex label.`);
              return;
            }
            const hasReady = labelNames.some((name) => name === 'status:ready');
            const hasInProgress = labelNames.some((name) => name === 'status:in-progress');
            core.setOutput('has_ready', hasReady ? 'true' : 'false');
            core.setOutput('has_in_progress', hasInProgress ? 'true' : 'false');

      - name: Checkout branch
        if: ${{ steps.parallel.outputs.allowed == 'true' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.ctx.outputs.branch }}
          token: ${{ env.ACTIONS_BOT_PAT }}
          fetch-depth: 0

      - name: Check branch freshness
        if: ${{ steps.parallel.outputs.allowed == 'true' }}
        id: freshness
        env:
          BASE_BRANCH: ${{ steps.base.outputs.branch }}
        run: |
          set -euo pipefail
          branch="${{ steps.ctx.outputs.branch }}"
          base="$BASE_BRANCH"
          if [ -n "$base" ]; then
            git fetch --no-tags origin "$base" "$branch"
          else
            git fetch --no-tags origin "$branch"
          fi
          local_sha=$(git rev-parse HEAD)
          remote_sha=$(git rev-parse "origin/$branch")
          if [ "$local_sha" = "$remote_sha" ]; then
            verdict=fresh
          else
            verdict=stale
          fi
          {
            echo "status=$verdict"
            echo "local_sha=$local_sha"
            echo "remote_sha=$remote_sha"
          } >>"$GITHUB_OUTPUT"

      - name: Fail on stale branch without fallback
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.freshness.outputs.status == 'stale' && steps.mode.outputs.use_step_branch != 'true' }}
        run: |
          echo "::error::Origin/${{ steps.ctx.outputs.branch }} has advanced; enable use_step_branch to proceed." >&2
          exit 1

      - name: Prepare step branch fallback
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.freshness.outputs.status == 'stale' && steps.mode.outputs.use_step_branch == 'true' }}
        id: fallback
        env:
          ISSUE: ${{ steps.ctx.outputs.issue }}
        run: |
          set -euo pipefail
          branch="${{ steps.ctx.outputs.branch }}"
          remote_sha="${{ steps.freshness.outputs.remote_sha }}"
          short_id=$(python - <<'PY'
          import secrets
          alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789'
          token = ''.join(secrets.choice(alphabet) for _ in range(8))
          print(token)
          PY
          )
          step_branch="codex/issue-${ISSUE}/step/$short_id"
          git checkout -B "$step_branch" "$remote_sha"
          git push origin "$step_branch"
          {
            echo "branch=$step_branch"
          } >>"$GITHUB_OUTPUT"

      - name: Ensure branch exists remotely
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' }}
        run: |
          set -euo pipefail
          branch="${{ steps.fallback.outputs.branch || steps.ctx.outputs.branch }}"
          if git ls-remote --exit-code --heads origin "$branch" >/dev/null 2>&1; then
            echo "Confirmed origin/$branch exists."
          else
            echo "::error::Expected branch $branch on origin." >&2
            exit 1
          fi

      - name: Create placeholder commit when branch matches base
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' }}
        env:
          BASE_BRANCH: ${{ steps.base.outputs.branch }}
        run: |
          set -euo pipefail
          branch="${{ steps.fallback.outputs.branch || steps.ctx.outputs.branch }}"
          base="${BASE_BRANCH}"
          git fetch origin "$base"
          upstream_sha=$(git rev-parse "origin/$base")
          head_sha=$(git rev-parse HEAD)
          if [ "$upstream_sha" = "$head_sha" ]; then
            git config user.name "stranske-automation-bot"
            git config user.email "stranske-automation-bot@users.noreply.github.com"
            git commit --allow-empty -m "chore(codex): initialize belt run for issue #${{ steps.ctx.outputs.issue }}"
            git push origin "$branch"
          else
            echo "Branch already diverged from $base; skipping placeholder commit."
          fi

      - name: Ensure issue labels reflect in-progress state
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.verify.outputs.has_in_progress != 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: issue, labels: ['status:in-progress'] });
            } catch (error) {
              core.warning(`Failed to set status:in-progress: ${error.message}`);
            }

      - name: Remove residual status:ready label
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.verify.outputs.has_ready == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.removeLabel({ owner, repo, issue_number: issue, name: 'status:ready' });
            } catch (error) {
              if (error.status !== 404) {
                core.warning(`Failed to remove status:ready: ${error.message}`);
              }
            }

      - name: Open or refresh Codex PR
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' }}
        id: pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const fallbackBranch = '${{ steps.fallback.outputs.branch || '' }}';
            const branch = fallbackBranch || '${{ steps.ctx.outputs.branch }}';
            const base = fallbackBranch ? '${{ steps.ctx.outputs.branch }}' : '${{ steps.base.outputs.branch }}';
            const { owner, repo } = context.repo;

            const issueUrl = `https://github.com/${owner}/${repo}/issues/${issue}`;
            let issueTitle = '';
            let issueBody = '';
            try {
              const { data: issueData } = await github.rest.issues.get({ owner, repo, issue_number: issue });
              issueTitle = issueData.title || '';
              issueBody = issueData.body || '';
            } catch (error) {
              core.warning(`Unable to read issue #${issue}: ${error.message}`);
            }

            const header = `### Source Issue #${issue}: ${issueTitle}`;
            const quoted = (issueBody || '').split('\n').map((line) => `> ${line}`).join('\n');
            const body = `${header}\n\nSource: ${issueUrl}\n\n${quoted}\n\n—\nPR created automatically to engage Codex.`;

            // Attempt to reuse an existing PR first
            let prNumber = null;
            try {
              const { data: prs } = await github.rest.pulls.list({ owner, repo, head: `${owner}:${branch}`, state: 'open' });
              const existing = prs.find((p) => p.head && p.head.ref === branch);
              if (existing) {
                prNumber = existing.number;
                await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body });
              }
            } catch (error) {
              core.warning(`Failed to search for existing PR: ${error.message}`);
            }

            if (!prNumber) {
              try {
                const { data: pr } = await github.rest.pulls.create({ owner, repo, head: branch, base, title: `Codex belt for #${issue}`, body });
                prNumber = pr.number;
              } catch (error) {
                core.setFailed(`Failed to open pull request: ${error.status || '?'} ${error.message}`);
                return;
              }
            }

            core.setOutput('number', String(prNumber));
            core.setOutput('summary', `Prepared PR #${prNumber} targeting \`${base}\`.`);

      - name: Apply automation labels
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.pr.outputs.number }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            const { owner, repo } = context.repo;
            const labels = ['agent:codex', 'autofix', 'from:codex'];
            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels });
            } catch (error) {
              core.warning(`Failed to label PR #${prNumber}: ${error.message}`);
            }

      - name: Ensure PR assignees include automation
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.pr.outputs.number }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const { owner, repo } = context.repo;
            const assignees = ['chatgpt-codex-connector', 'stranske-automation-bot'];
            for (const target of [prNumber, issue]) {
              try {
                await github.rest.issues.addAssignees({ owner, repo, issue_number: target, assignees });
              } catch (error) {
                core.warning(`Failed to assign #${target}: ${error.message}`);
              }
            }

      - name: Post activation comment
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.pr.outputs.number }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            const { owner, repo } = context.repo;
            const message = '@codex start\n\nAutomated belt worker prepared this PR. Please continue implementing the requested changes.';
            try {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: message });
            } catch (error) {
              core.warning(`Failed to post Codex command on PR #${prNumber}: ${error.message}`);
            }

      - name: Sync issue comment with PR link
        if: ${{ steps.parallel.outputs.allowed == 'true' && steps.mode.outputs.dry_run != 'true' && steps.pr.outputs.number }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.ACTIONS_BOT_PAT }}
          script: |
            const issue = Number('${{ steps.ctx.outputs.issue }}');
            const prNumber = Number('${{ steps.pr.outputs.number }}');
            const { owner, repo } = context.repo;
            try {
              await github.rest.issues.createComment({ owner, repo, issue_number: issue, body: `Opened PR #${prNumber} via Codex belt worker.` });
            } catch (error) {
              core.warning(`Failed to comment on issue #${issue}: ${error.message}`);
            }

      - name: Summarise worker outcome
        if: ${{ always() }}
        id: summary
        uses: actions/github-script@v7
        with:
          script: |
            const issue = '${{ steps.ctx.outputs.issue || '' }}';
            const branch = '${{ steps.fallback.outputs.branch || steps.ctx.outputs.branch || '' }}';
            const status = '${{ steps.freshness.outputs.status || '' }}';
            const fallbackBranch = '${{ steps.fallback.outputs.branch || '' }}';
            const prSummary = '${{ steps.pr.outputs.summary || '' }}';

            let verdict = status || 'unknown';
            if (status === 'stale' && fallbackBranch) {
              verdict = 'stale (step branch)';
            } else if (!status) {
              const allowed = '${{ steps.parallel.outputs.allowed || '' }}';
              verdict = allowed === 'false' ? 'skipped' : 'unknown';
            }

            const table = [
              [
                { data: 'Issue', header: true },
                { data: 'Branch', header: true },
                { data: 'Freshness verdict', header: true },
                { data: 'Fallback branch', header: true }
              ],
              [
                issue ? `#${issue}` : '—',
                branch || '—',
                verdict,
                fallbackBranch || '—'
              ]
            ];

            const summary = core.summary;
            summary.addHeading('Codex Belt Worker');
            if (prSummary) {
              summary.addRaw(`${prSummary}\n\n`);
            }
            summary.addTable(table).write();

      - name: Summarise worker preview
        if: ${{ steps.parallel.outputs.allowed != 'true' || steps.mode.outputs.dry_run == 'true' }}
        run: |
          cat <<'EOF' >>"$GITHUB_STEP_SUMMARY"
          Worker executed in preview mode. No branches, issues, or pull requests were modified.
          EOF
