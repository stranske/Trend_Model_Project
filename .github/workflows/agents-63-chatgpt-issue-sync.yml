# See docs/ci/AGENTS_POLICY.md for guardrails and override process.
name: Agents 63 ChatGPT Issue Sync

on:
  workflow_dispatch:
    inputs:
      repo_file:
        description: "Primary: path (in repo) to topics file (preferred for large lists)"
        required: false
        type: string
      raw_input:
        description: "Secondary: small pasted topic list (may truncate around 1KB)"
        required: false
        type: string
      source_url:
        description: "Fallback: raw text URL (raw.githubusercontent.com / Gist raw)"
        required: false
        type: string
      debug:
        description: Enable verbose debug diagnostics
        required: false
        type: boolean
        default: false

jobs:
  sync:
    name: Normalize ChatGPT topics into GitHub issues
    runs-on: ubuntu-latest
    concurrency:
      # Queue overlapping runs on the same ref so a prior sync can finish cleanly.
      group: agent-sync-${{ github.ref }}
      cancel-in-progress: false
    permissions:
      contents: read
      issues: write # Only elevated when a sync actually mutates issues; early exits remain read-only.
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Echo received inputs
        run: |
          echo "Inputs JSON:" '${{ toJson(github.event.inputs) }}'
          echo "Selected ref: ${GITHUB_REF}"

      - name: Prepare topic source
        env:
          RAW_INPUT_JSON: ${{ toJson(github.event.inputs.raw_input) }}
          SOURCE_URL: ${{ github.event.inputs.source_url }}
          REPO_FILE: ${{ github.event.inputs.repo_file }}
          DEBUG_FLAG: ${{ github.event.inputs.debug }}
        run: |
          set -euo pipefail
          echo "Ref: ${GITHUB_REF} Commit: ${GITHUB_SHA}" >&2
          echo "Debug input (raw): '${DEBUG_FLAG}'" >&2
          # Precedence: repo_file > raw_input > source_url
          if [ -n "${REPO_FILE}" ]; then
            if [ -f "${REPO_FILE}" ]; then
              python .github/scripts/decode_raw_input.py --passthrough --in "${REPO_FILE}" --source repo_file
            else
              echo "::error::repo_file '${REPO_FILE}' not found in repository." >&2; exit 1
            fi
          elif [ -n "${RAW_INPUT_JSON}" ] && [ "${RAW_INPUT_JSON}" != "null" ]; then
            printf '%s' "${RAW_INPUT_JSON}" > raw_input.json
            python .github/scripts/decode_raw_input.py --source raw_input || python .github/scripts/decode_raw_input.py
          elif [ -n "${SOURCE_URL}" ]; then
            tmp_dl=$(mktemp)
            if ! curl -fsSL "${SOURCE_URL}" -o "$tmp_dl"; then
              echo "::error::Failed to download content from ${SOURCE_URL}" >&2; exit 1
            fi
            python .github/scripts/decode_raw_input.py --passthrough --in "$tmp_dl" --source source_url
          else
            echo "::error::Provide one of repo_file, raw_input, or source_url when dispatching this workflow." >&2; exit 1
          fi
          if ! [ -s input.txt ]; then
            echo "::error::The provided input was empty." >&2
            exit 1
          fi
          if [ -f raw_input.json ]; then
            size=$(wc -c < raw_input.json || echo 0)
            if [ "$size" -ge 1024 ]; then
              echo "::warning::raw_input size is $size bytes (possible truncation). Prefer repo_file or source_url." >&2
            fi
          fi

      - name: Debug artifacts (raw/decoded)
        if: ${{ github.event.inputs.debug == 'true' }}
        run: |
          echo '--- DEBUG: file inventory ---'
          # shellcheck disable=SC2012
          ls -al . | sed 's/^/  /'
          if [ -f raw_input.json ]; then
            echo "--- DEBUG: raw_input.json (size) ---"; wc -c raw_input.json
            echo '--- DEBUG: raw_input.json (first 240 chars) ---'
            head -c 240 raw_input.json | sed 's/[[:cntrl:]]/./g'; echo
            echo '--- DEBUG: raw_input.json (hexdump first 256 bytes) ---'
            head -c 256 raw_input.json | hexdump -C || true
          else
            echo 'raw_input.json missing'
          fi
          if [ -f input.txt ]; then
            echo "--- DEBUG: input.txt (size + line count) ---"; wc -cl input.txt
            echo '--- DEBUG: input.txt (first 240 chars) ---'
            head -c 240 input.txt | sed 's/[[:cntrl:]]/./g'; echo
          else
            echo 'input.txt missing'
          fi

      - name: Upload debug artifacts
        if: ${{ always() && github.event.inputs.debug == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: chatgpt-sync-debug
          path: |
            raw_input.json
            input.txt
            topics.json
            decode_debug.json
          if-no-files-found: ignore

      - name: Parse topics
        env:
          ALLOW_SINGLE_TOPIC: '1'
        run: |
          set -euo pipefail
          echo '--- INPUT PREVIEW (first 200 chars) ---'
          head -c 200 input.txt 2>/dev/null | sed 's/[[:cntrl:]]/./g' || true
          printf '\n--------------------------------------\n'
          if python .github/scripts/parse_chatgpt_topics.py; then
            echo 'Parser succeeded.'
          else
            ec=$?
            case "$ec" in
              2) echo '::error::Exit 2 (empty after trimming). Ensure raw_input or source_url contains non-whitespace content.' ;;
              3) echo '::error::Exit 3 (no enumerated topics). Provide numbered lines.' ;;
              4) echo '::error::Exit 4 (parsed zero topics unexpectedly).' ;;
              *) echo "::error::Parser failed with exit code $ec." ;;
            esac
            # Fallback: if enumerators detected by decoder (decode_debug.json) and code==3, attempt naive split
            if [ "$ec" -eq 3 ] && [ -f decode_debug.json ]; then
              enum_count=$(jq '.rebuilt_enum_count // 0' decode_debug.json 2>/dev/null || echo 0)
              if [ "$enum_count" -gt 0 ]; then
                echo '::warning::Structured parser failed; invoking fallback enumerator splitter.'
                python .github/scripts/fallback_split.py || true
                if [ -f topics.json ]; then
                  tmp=$(mktemp)
                  if jq '. + {fallback_used: true}' decode_debug.json > "$tmp"; then
                    mv "$tmp" decode_debug.json
                  else
                    rm -f "$tmp"
                  fi
                  echo 'Fallback succeeded.'
                  ec=0
                fi
              fi
            fi
            if [ "$ec" -ne 0 ]; then
              exit $ec
            fi
          fi
          echo 'Topics length:'
          if [ -f topics.json ]; then jq 'length' topics.json || true; fi
          if [ -f decode_debug.json ] && [ -f topics.json ]; then
            topics_count=$(jq 'length' topics.json 2>/dev/null || echo 0)
            first_title=$(jq -r '.[0].title // ""' topics.json 2>/dev/null || echo "")
            tmp=$(mktemp)
            if jq --arg tc "$topics_count" --arg ft "$first_title" '. + {parsed_topics: ($tc|tonumber), first_title: $ft}' decode_debug.json > "$tmp"; then
              mv "$tmp" decode_debug.json
            else
              rm -f "$tmp"
            fi
          fi

      - name: Sync issues
        uses: actions/github-script@v7
        env:
          RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          script: |
            const fs = require('fs');
            const crypto = require('crypto');
            const defaultOutputs = {
              created_issues: 0,
              updated_issues: 0,
              reopened_issues: 0,
              skipped_issues: 0,
              duplicate_topics: 0,
              invalid_topics: 0,
              mutations_performed: 0,
              topics_total: 0,
              topics_with_agent_labels: 0,
              topics_after_dedup: 0,
              topics_processed: 0,
              topics_skipped_for_other_agents: 0,
              assigned_elsewhere: 0,
            };
            const metrics = {
              topics_total: 0,
              topics_with_agent_labels: 0,
              topics_after_dedup: 0,
              topics_processed: 0,
              topics_skipped_for_other_agents: 0,
              duplicate_topics: 0,
              invalid_topics: 0,
              assigned_elsewhere: 0,
              mutations_performed: 0,
            };
            const setOutputs = (overrides = {}) => {
              const values = { ...defaultOutputs, ...metrics, ...overrides };
              for (const [key, value] of Object.entries(values)) {
                core.setOutput(key, String(value));
              }
            };
            const setZeroOutputs = () => {
              setOutputs();
            };
            const publishSummary = async ({
              createdCount = 0,
              updatedCount = 0,
              reopenedCount = 0,
              skippedCount = 0,
              duplicateCount = 0,
              invalidTopicCount = 0,
              assignedElsewhereCount = 0,
              mutationCount,
              notice,
            } = {}) => {
              const mutationsPerformed =
                typeof mutationCount === 'number' ? mutationCount : createdCount + updatedCount;
              const summaryLines = [
                `Topics provided: ${metrics.topics_total}`,
                `Agent-labeled topics: ${metrics.topics_with_agent_labels}`,
                `Deduplicated topics: ${metrics.topics_after_dedup}`,
                `Topics processed: ${metrics.topics_processed}`,
                `Topics skipped for other agents: ${metrics.topics_skipped_for_other_agents}`,
                `Created issues: ${createdCount}`,
                `Updated issues: ${updatedCount}`,
                `Reopened issues: ${reopenedCount}`,
                `Skipped (no changes): ${skippedCount}`,
                `Skipped (assigned to other agents): ${assignedElsewhereCount}`,
                `Duplicate topics skipped: ${duplicateCount}`,
                `Invalid topics skipped: ${invalidTopicCount}`,
                `Mutations performed: ${mutationsPerformed}`,
              ];
              const summaryText = summaryLines.join('\n');
              if (notice) core.notice(notice);
              core.notice(summaryText);
              core.summary.clear();
              core.summary.addHeading('Agents issue sync results');
              for (const line of summaryLines) {
                core.summary.addRaw(`- ${line}\n`);
              }
              await core.summary.write();
            };
            if (!fs.existsSync('topics.json')) {
              setZeroOutputs();
              await publishSummary({
                notice: 'topics.json not found â€“ assuming parser short-circuited. Exiting without mutations.',
              });
              return;
            }
            const rawTopics = JSON.parse(fs.readFileSync('topics.json', 'utf8'));
            metrics.topics_total = Array.isArray(rawTopics) ? rawTopics.length : 0;
            if (!Array.isArray(rawTopics) || rawTopics.length === 0) {
              setZeroOutputs();
              await publishSummary({ notice: 'No topics provided. Exiting without mutations.' });
              return;
            }
            const normalizeLabel = (label) => label.trim().toLowerCase();
            const isAgentLabel = (label) => {
              if (typeof label !== 'string') return false;
              return label.trim().toLowerCase().startsWith('agent:');
            };
            const isCodexAgentLabel = (label) => {
              if (typeof label !== 'string') return false;
              return label.trim().toLowerCase() === 'agent:codex';
            };
            let topicsWithAgentLabels = 0;
            const topics = rawTopics.filter((topic) => {
              const labels = Array.isArray(topic.labels) ? topic.labels : [];
              const agentLabels = labels.filter((label) => isAgentLabel(label));
              if (agentLabels.length) {
                topicsWithAgentLabels += 1;
                const codexLabelTargets = agentLabels.filter((label) => isCodexAgentLabel(label));
                if (!codexLabelTargets.length) {
                  const preview = topic?.title ? ` (${topic.title.slice(0, 80)})` : '';
                  core.info(
                    `Skipping topic targeted at other agents${preview}. Labels: ${agentLabels.join(', ')}`,
                  );
                  metrics.topics_skipped_for_other_agents += 1;
                  return false;
                }
              }
              return true;
            });
            metrics.topics_with_agent_labels = topicsWithAgentLabels;
            if (!topics.length) {
              setZeroOutputs();
              const otherAgentSkipCount = metrics.topics_skipped_for_other_agents;
              const notice = otherAgentSkipCount
                ? `All topics were skipped because they request other agent assignments (${otherAgentSkipCount}). Exiting without changes.`
                : 'No topics were eligible after filtering. Exiting without changes.';
              await publishSummary({
                notice,
              });
              return;
            }
            const seenTopics = new Set();
            const deduped = [];
            let duplicateCount = 0;
            for (const topic of topics) {
              const guidKey = topic.guid ? `guid:${topic.guid.trim().toLowerCase()}` : null;
              const titleKey = topic.title ? `title:${topic.title.trim().toLowerCase()}` : null;
              const key = guidKey || titleKey;
              if (key && seenTopics.has(key)) {
                const preview = topic?.title ? ` (${topic.title.slice(0, 80)})` : '';
                core.info(`Skipping duplicate topic${preview}.`);
                duplicateCount += 1;
                metrics.duplicate_topics = duplicateCount;
                continue;
              }
              if (key) {
                seenTopics.add(key);
              }
              deduped.push(topic);
            }
            metrics.topics_after_dedup = deduped.length;
            metrics.duplicate_topics = duplicateCount;
            if (!deduped.length) {
              setOutputs();
              await publishSummary({
                notice: `All topics were filtered as duplicates (${duplicateCount}). Exiting without changes.`,
                duplicateCount,
              });
              return;
            }
            const { owner, repo } = context.repo;
            const normalize = (name) => name.toLowerCase().replace(/[^a-z0-9]+/g, '');
            const escapeSearch = (value) => value.replace(/["\\]/g, (char) => `\\${char}`);
            const canonicalizeNewLabel = (name) => {
              let cleaned = name.trim().toLowerCase();
              cleaned = cleaned.replace(/[_\u2013\u2014]/g, ' ');
              cleaned = cleaned.replace(/[^a-z0-9: ]+/g, ' ').replace(/\s+/g, ' ').trim();
              if (!cleaned) return name.trim();
              if (cleaned.includes(':')) {
                return cleaned
                  .split(':')
                  .map((s) => s.trim().replace(/\s+/g, '-'))
                  .join(':');
              }
              const parts = cleaned.split(' ');
              if (parts.length > 1) return `${parts[0]}:${parts.slice(1).join('-')}`;
              return cleaned.replace(/\s+/g, '-');
            };
            const levenshtein = (a, b) => {
              const dp = Array.from({ length: a.length + 1 }, () => new Array(b.length + 1).fill(0));
              for (let i = 0; i <= a.length; i++) dp[i][0] = i;
              for (let j = 0; j <= b.length; j++) dp[0][j] = j;
              for (let i = 1; i <= a.length; i++)
                for (let j = 1; j <= b.length; j++) {
                  const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                  dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
                }
              return dp[a.length][b.length];
            };
            const labelsCache = await github.paginate(
              github.rest.issues.listLabelsForRepo,
              { owner, repo, per_page: 100 },
            );
            const usedColors = new Set(labelsCache.map((l) => l.color.toLowerCase()));
            const findMatchingLabel = (input) => {
              const candidates = [input];
              if (!input.includes(':')) candidates.push(canonicalizeNewLabel(input));
              for (const cand of candidates) {
                const norm = normalize(cand);
                if (!norm) continue;
                for (const label of labelsCache) {
                  if (normalize(label.name) === norm) return label.name;
                }
                const partial = labelsCache
                  .map((label) => ({ label, norm: normalize(label.name) }))
                  .filter((o) => o.norm && (o.norm.includes(norm) || norm.includes(o.norm)));
                if (partial.length === 1) return partial[0].label.name;
                if (partial.length > 1) {
                  let best = null;
                  let bestScore = Infinity;
                  for (const m of partial) {
                    const d = levenshtein(m.norm, norm);
                    const r = d / Math.max(m.norm.length, norm.length);
                    if (r < bestScore) {
                      best = m.label.name;
                      bestScore = r;
                    }
                  }
                  if (best !== null && bestScore <= 0.35) return best;
                }
              }
              return null;
            };
            const generateColor = (name) => {
              const base = crypto.createHash('md5').update(name.toLowerCase()).digest('hex').slice(0, 6);
              if (!usedColors.has(base)) {
                usedColors.add(base);
                return base;
              }
              let c = 1;
              while (c < 4096) {
                const val = (parseInt(base, 16) + c * 0x111111) % 0xffffff;
                const cand = val.toString(16).padStart(6, '0');
                if (!usedColors.has(cand)) {
                  usedColors.add(cand);
                  return cand;
                }
                c++;
              }
              usedColors.add('777777');
              return '777777';
            };
            const labelResolutionCache = new Map();
            const memoizeLabelResolution = (keys, value) => {
              for (const key of keys) {
                if (!key) continue;
                labelResolutionCache.set(key.toLowerCase(), value);
              }
            };
            const classifyTopicLabels = (rawLabels) => {
              const details = [];
              const pendingCreates = new Map();
              const skipped = [];
              for (const raw of rawLabels || []) {
                if (typeof raw !== 'string') continue;
                const trimmed = raw.trim();
                if (!trimmed) continue;
                const cacheKey = trimmed.toLowerCase();
                if (labelResolutionCache.has(cacheKey)) {
                  const cached = labelResolutionCache.get(cacheKey);
                  if (cached) {
                    details.push({ name: cached, requiresCreation: false });
                  } else {
                    skipped.push(trimmed);
                  }
                  continue;
                }
                const existing = findMatchingLabel(trimmed);
                if (existing) {
                  memoizeLabelResolution([trimmed, existing], existing);
                  details.push({ name: existing, requiresCreation: false });
                  continue;
                }
                const newName = canonicalizeNewLabel(trimmed);
                const canonicalKey = newName.toLowerCase();
                if (labelResolutionCache.has(canonicalKey)) {
                  const cached = labelResolutionCache.get(canonicalKey);
                  if (cached) {
                    memoizeLabelResolution([trimmed, newName, cached], cached);
                    details.push({ name: cached, requiresCreation: false });
                  } else {
                    skipped.push(trimmed);
                  }
                  continue;
                }
                const already = findMatchingLabel(newName);
                if (already) {
                  memoizeLabelResolution([trimmed, newName, already], already);
                  details.push({ name: already, requiresCreation: false });
                  continue;
                }
                if (!pendingCreates.has(canonicalKey)) {
                  pendingCreates.set(canonicalKey, {
                    name: newName,
                    source: trimmed,
                    keys: [trimmed, newName],
                  });
                } else {
                  pendingCreates.get(canonicalKey).keys.push(trimmed);
                }
                details.push({ name: newName, requiresCreation: true, pendingKey: canonicalKey });
              }
              return { details, pendingCreates, skipped };
            };
            const ensurePendingLabelCreates = async (pendingCreates) => {
              const successful = new Set();
              for (const pending of pendingCreates.values()) {
                const existing = findMatchingLabel(pending.name);
                if (existing) {
                  memoizeLabelResolution([...pending.keys, existing], existing);
                  successful.add(existing.toLowerCase());
                  continue;
                }
                const color = generateColor(pending.name);
                try {
                  const created = await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: pending.name,
                    color,
                    description: `Synthesized from ChatGPT import for ${pending.source}`,
                  });
                  labelsCache.push(created.data);
                  const resolvedName = created.data.name || pending.name;
                  memoizeLabelResolution([...pending.keys, resolvedName], resolvedName);
                  successful.add(resolvedName.toLowerCase());
                } catch (e) {
                  core.warning(`Failed to create label for "${pending.source}": ${e.message}`);
                  memoizeLabelResolution(pending.keys, null);
                }
              }
              return successful;
            };
            const formatTasks = (text) => {
              if (!text || !text.trim()) return '_Not provided._';
              const lines = text.split('\n');
              const out = [];
              let inFence = false;
              for (const raw of lines) {
                const tr = raw.trim();
                if (tr.startsWith('```')) {
                  inFence = !inFence;
                  out.push(raw);
                  continue;
                }
                if (!inFence && /^[-*]\s+/.test(tr)) {
                  out.push(raw.replace(/^\s*[-*]\s+/, '- [ ] '));
                } else {
                  out.push(raw);
                }
              }
              return out.join('\n').trim() || '_Not provided._';
            };
            const ensureContent = (t) => (t && t.trim() ? t.trim() : '_Not provided._');
            const buildBody = (topic) => {
              const lines = [];
              const guidText = topic.guid && String(topic.guid).trim() ? String(topic.guid).trim() : '_Not provided._';
              lines.push(`Topic GUID: ${guidText}`, '', '## Why');
              const why =
                (topic.sections?.why && topic.sections.why.trim()) ||
                topic.extras?.trim() ||
                '_Not provided._';
              lines.push(why, '', '## Tasks', formatTasks(topic.sections?.tasks || ''));
              lines.push('', '## Acceptance criteria', ensureContent(topic.sections?.acceptance_criteria || ''));
              lines.push('', '## Implementation notes', ensureContent(topic.sections?.implementation_notes || ''));
              lines.push('', '---', `Synced by [workflow run](${process.env.RUN_URL}).`);
              return lines.join('\n');
            };
            const normalizeSyncFooter = (text) => {
              if (!text) return '';
              return text
                .trim()
                .replace(
                  /Synced by \[workflow run\]\([^)]+\)\./gi,
                  'Synced by [workflow run](RUN_URL_PLACEHOLDER).',
                );
            };
            const labelsEqual = (a, b) => {
              const clean = (list) =>
                Array.from(new Set((list || []).map((l) => l.trim()).filter(Boolean))).sort((x, y) =>
                  x.localeCompare(y, undefined, { sensitivity: 'accent' }),
                );
              const left = clean(a);
              const right = clean(b);
              if (left.length !== right.length) return false;
              for (let i = 0; i < left.length; i += 1) {
                if (left[i].toLowerCase() !== right[i].toLowerCase()) {
                  return false;
                }
              }
              return true;
            };
            let createdCount = 0;
            let updatedCount = 0;
            let reopenedCount = 0;
            let skippedCount = 0;
            let invalidTopicCount = 0;
            let assignedElsewhereCount = 0;
            for (const topic of deduped) {
              try {
                const rawTitle = typeof topic.title === 'string' ? topic.title : '';
                const title = rawTitle.trim();
                if (!title) {
                  invalidTopicCount += 1;
                  metrics.invalid_topics = invalidTopicCount;
                  core.warning('Skipping topic without a valid title.');
                  continue;
                }
                metrics.topics_processed += 1;
                const { details: labelDetails, pendingCreates, skipped } = classifyTopicLabels(topic.labels || []);
                for (const skippedLabel of skipped) {
                  core.warning(`Skipped label "${skippedLabel}" for ${title}.`);
                }
                const uniqueDesired = Array.from(
                  new Set(labelDetails.map((detail) => detail.name).filter((name) => typeof name === 'string' && name)),
                );
                const body = buildBody(topic);
                const guid = topic.guid && String(topic.guid).trim() ? String(topic.guid).trim() : '';
                let issueNumber = null;
                if (guid) {
                  const escapedGuid = escapeSearch(guid);
                  const searchOpen = await github.rest.search.issuesAndPullRequests({
                    q: `repo:${owner}/${repo} "${escapedGuid}" in:body is:issue is:open`,
                    per_page: 1,
                  });
                  if (searchOpen.data.items.length) {
                    issueNumber = searchOpen.data.items[0].number;
                  } else {
                    const searchAny = await github.rest.search.issuesAndPullRequests({
                      q: `repo:${owner}/${repo} "${escapedGuid}" in:body is:issue`,
                      per_page: 1,
                    });
                    if (searchAny.data.items.length) {
                      issueNumber = searchAny.data.items[0].number;
                    }
                  }
                }
                if (!issueNumber && title && title.trim()) {
                  const quotedTitle = escapeSearch(title.trim());
                  const searchTitleOpen = await github.rest.search.issuesAndPullRequests({
                    q: `repo:${owner}/${repo} "${quotedTitle}" in:title is:issue is:open`,
                    per_page: 1,
                  });
                  if (searchTitleOpen.data.items.length) {
                    issueNumber = searchTitleOpen.data.items[0].number;
                  } else {
                    const searchTitleAny = await github.rest.search.issuesAndPullRequests({
                      q: `repo:${owner}/${repo} "${quotedTitle}" in:title is:issue`,
                      per_page: 1,
                    });
                    if (searchTitleAny.data.items.length) {
                      issueNumber = searchTitleAny.data.items[0].number;
                    }
                  }
                }
                if (issueNumber) {
                  const issueData = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
                  const current = (issueData.data.labels || [])
                    .map((l) => l.name)
                    .filter(Boolean);
                  let final = Array.from(new Set([...current, ...uniqueDesired]));
                  const needsStateChange = issueData.data.state === 'closed';
                  const existingTitle = (issueData.data.title || '').trim();
                  const needsTitle = existingTitle !== title;
                  const existingBody = (issueData.data.body || '').trim();
                  const normalizedExistingBody = normalizeSyncFooter(existingBody);
                  const normalizedDesiredBody = normalizeSyncFooter(body);
                  const needsBody = normalizedExistingBody !== normalizedDesiredBody;
                  if (!needsBody && existingBody !== body.trim()) {
                    core.info(
                      `Preserving existing sync footer for issue #${issueNumber} to avoid unnecessary run URL churn.`,
                    );
                  }
                  const normalizeAgentLabel = (labelName) => {
                    if (!labelName) return null;
                    const trimmed = labelName.trim();
                    if (!trimmed.toLowerCase().startsWith('agent:')) return null;
                    return trimmed.toLowerCase();
                  };
                  const currentAgentLabels = current
                    .map((label) => normalizeAgentLabel(label))
                    .filter((label) => label !== null);
                  const hasNonCodexAssignment = currentAgentLabels.some(
                    (label) => label !== 'agent:codex',
                  );
                  if (hasNonCodexAssignment) {
                    core.info(
                      `Skipping issue #${issueNumber} because it already has an agent assignment (${currentAgentLabels.join(
                        ', ',
                      )}).`,
                    );
                    skippedCount += 1;
                    assignedElsewhereCount += 1;
                    metrics.assigned_elsewhere = assignedElsewhereCount;
                    continue;
                  }
                  const needsLabels = !labelsEqual(current, final);
                  if (!(needsStateChange || needsTitle || needsBody || needsLabels)) {
                    core.info(`No changes detected for issue #${issueNumber}; skipping update.`);
                    skippedCount += 1;
                    continue;
                  }
                  let ensuredLabels = uniqueDesired;
                  if (pendingCreates.size && (needsLabels || !labelsEqual(current, uniqueDesired))) {
                    const createdLabels = await ensurePendingLabelCreates(pendingCreates);
                    ensuredLabels = Array.from(
                      new Set(
                        labelDetails
                          .filter((detail) => {
                            if (!detail.name) return false;
                            if (!detail.requiresCreation) return true;
                            return createdLabels.has(detail.name.toLowerCase());
                          })
                          .map((detail) => detail.name),
                      ),
                    );
                    final = Array.from(new Set([...current, ...ensuredLabels]));
                  }
                  const finalNeedsLabels = !labelsEqual(current, final);
                  if (!(needsStateChange || needsTitle || needsBody || finalNeedsLabels)) {
                    core.info(
                      `No changes detected for issue #${issueNumber} after label reconciliation; skipping update.`,
                    );
                    skippedCount += 1;
                    continue;
                  }
                  const bodyForUpdate = needsBody ? body : issueData.data.body;
                  const payload = {
                    owner,
                    repo,
                    issue_number: issueNumber,
                    title,
                    labels: final,
                  };
                  if (bodyForUpdate !== undefined && bodyForUpdate !== null) {
                    payload.body = bodyForUpdate;
                  }
                  if (needsStateChange) payload.state = 'open';
                  await github.rest.issues.update(payload);
                  updatedCount += 1;
                  if (needsStateChange) {
                    reopenedCount += 1;
                  }
                  if (needsTitle || needsBody || needsLabels || needsStateChange) {
                    try {
                      await github.rest.issues.createComment({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        body: `Updated by [workflow run](${process.env.RUN_URL}).`,
                      });
                    } catch (e) {
                      core.warning(`Failed to comment on issue #${issueNumber}: ${e.message}`);
                    }
                  }
                } else {
                  let labelsForCreation = uniqueDesired;
                  if (pendingCreates.size) {
                    const createdLabels = await ensurePendingLabelCreates(pendingCreates);
                    labelsForCreation = Array.from(
                      new Set(
                        labelDetails
                          .filter((detail) => {
                            if (!detail.name) return false;
                            if (!detail.requiresCreation) {
                              return true;
                            }
                            return createdLabels.has(detail.name.toLowerCase());
                          })
                          .map((detail) => detail.name),
                      ),
                    );
                  }
                  const created = await github.rest.issues.create({
                    owner,
                    repo,
                    title,
                    body,
                    labels: labelsForCreation,
                  });
                  core.info(`Created issue #${created.data.number} for ${title}.`);
                  createdCount += 1;
                }
              } catch (e) {
                core.warning(`Failed to process topic "${topic.title}": ${e.message}`);
              }
            }
            let summaryNotice;
            if (!metrics.topics_processed && invalidTopicCount) {
              const invalidSummary =
                metrics.topics_after_dedup > 0
                  ? `All ${metrics.topics_after_dedup} topics were skipped because they lacked valid titles.`
                  : 'All topics were skipped because they lacked valid titles.';
              summaryNotice = invalidSummary;
            }
            if (
              !summaryNotice &&
              assignedElsewhereCount &&
              metrics.topics_processed > 0 &&
              assignedElsewhereCount === metrics.topics_processed &&
              !createdCount &&
              !updatedCount
            ) {
              const plural = assignedElsewhereCount === 1 ? 'topic was' : 'topics were';
              summaryNotice = `All ${assignedElsewhereCount} processed ${plural} already assigned to other agents. No mutations performed.`;
            }
            const mutationCount = createdCount + updatedCount;
            metrics.duplicate_topics = duplicateCount;
            metrics.invalid_topics = invalidTopicCount;
            metrics.assigned_elsewhere = assignedElsewhereCount;
            metrics.mutations_performed = mutationCount;
            setOutputs({
              created_issues: createdCount,
              updated_issues: updatedCount,
              reopened_issues: reopenedCount,
              skipped_issues: skippedCount,
            });
            await publishSummary({
              createdCount,
              updatedCount,
              reopenedCount,
              skippedCount,
              duplicateCount,
              invalidTopicCount,
              assignedElsewhereCount,
              mutationCount,
              notice: summaryNotice,
            });
            if (!createdCount && !updatedCount && !reopenedCount) {
              if (!summaryNotice) {
                core.notice('No issues required modifications; run completed without mutations.');
              }
            }

