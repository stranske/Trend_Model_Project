 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/tests/test_analysis.py b/tests/test_analysis.py
index 22a692738008d5da439885129b24fcd6abbcb685..8ac6d08be177ccf0af13cf575c784dcd31be4984 100644
--- a/tests/test_analysis.py
+++ b/tests/test_analysis.py
@@ -1,17 +1,28 @@
 import importlib.util
 import pathlib
-import pytest
+import sys
 
-# Dynamically load the cleanup module from its file path
-module_path = pathlib.Path(__file__).resolve().parents[1] / 'Old' / 'Vol_Adj_Trend_Analysis_Cleanup.py'
-spec = importlib.util.spec_from_file_location('cleanup', module_path)
+if "ipyfilechooser" not in sys.modules:
+    stub = type(sys)("ipyfilechooser")
+    stub.FileChooser = object
+    sys.modules["ipyfilechooser"] = stub
+
+module_path = (
+    pathlib.Path(__file__).resolve().parents[1]
+    / "Old"
+    / "Vol_Adj_Trend_Analysis_Cleanup.py"
+)
+spec = importlib.util.spec_from_file_location("cleanup", module_path)
 cleanup = importlib.util.module_from_spec(spec)
+assert spec.loader is not None
 spec.loader.exec_module(cleanup)
 
 
 def test_run_analysis_returns_none():
-    assert cleanup.run_analysis(None, None, None, None, None, None, None) is None
+    assert (
+        cleanup.run_analysis(None, None, None, None, None, None, None) is None
+    )
 
 
 def test_prepare_weights_missing():
-    assert not hasattr(cleanup, 'prepare_weights')
+    assert not hasattr(cleanup, "prepare_weights")
diff --git a/tests/test_metrics.py b/tests/test_metrics.py
new file mode 100644
index 0000000000000000000000000000000000000000..7d425d6fa90854be0907bf8e64356e96fdfe717a
--- /dev/null
+++ b/tests/test_metrics.py
@@ -0,0 +1,45 @@
+import sys
+import pathlib
+
+sys.path.insert(0, str(pathlib.Path(__file__).resolve().parents[1]))
+from trend_analysis import metrics
+
+import pandas as pd
+import numpy as np
+
+
+def test_annualize_return_series():
+    s = pd.Series([0.02, -0.01, 0.03])
+    result = metrics.annualize_return(s)
+    expected = (1 + s).prod() ** (12 / len(s)) - 1
+    assert np.isclose(result, expected)
+
+
+def test_annualize_volatility_dataframe():
+    df = pd.DataFrame({"a": [0.01, 0.02, 0.03, -0.01]})
+    res = metrics.annualize_volatility(df)
+    expected = df.std(ddof=1) * np.sqrt(12)
+    assert np.allclose(res.values, expected.values)
+
+
+def test_sharpe_ratio_simple():
+    r = pd.Series([0.02, 0.03, -0.01])
+    rf = pd.Series([0.01, 0.01, 0.01])
+    res = metrics.sharpe_ratio(r, rf)
+    ex = r - rf
+    expected = metrics.annualize_return(ex) / metrics.annualize_volatility(ex)
+    assert np.isclose(res, expected, equal_nan=True)
+
+
+def test_sortino_ratio_no_downside():
+    r = pd.Series([0.05, 0.04])
+    rf = pd.Series([0.01, 0.01])
+    assert np.isnan(metrics.sortino_ratio(r, rf))
+
+
+def test_max_drawdown_dataframe():
+    df = pd.DataFrame({"a": [0.1, -0.05, 0.02, -0.02]})
+    result = metrics.max_drawdown(df)
+    wealth = (1 + df["a"]).cumprod()
+    expected = (1 - wealth / wealth.cummax()).max()
+    assert np.isclose(result["a"], expected)
diff --git a/trend_analysis/__init__.py b/trend_analysis/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e64edd8bce631f04e0f24881b6987264c2552946
--- /dev/null
+++ b/trend_analysis/__init__.py
@@ -0,0 +1,5 @@
+"""Trend analysis package."""
+
+from . import metrics
+
+__all__ = ["metrics"]
diff --git a/trend_analysis/metrics.py b/trend_analysis/metrics.py
new file mode 100644
index 0000000000000000000000000000000000000000..31beefe4cf22006c2f1bf5c6921e13bf3884931a
--- /dev/null
+++ b/trend_analysis/metrics.py
@@ -0,0 +1,176 @@
+"""Core performance metrics used across the project."""
+
+from __future__ import annotations
+
+import numpy as np
+import pandas as pd
+from pandas import DataFrame, Series
+
+
+def _validate_input(obj: Series | DataFrame) -> None:
+    if not isinstance(obj, (Series, DataFrame)):
+        raise TypeError("Input must be pandas Series or DataFrame")
+
+
+def _apply(  # helper to handle Series/DataFrame uniformly
+    obj: Series | DataFrame, func, axis: int
+) -> Series | float:
+    if isinstance(obj, Series):
+        return func(obj.dropna())
+    return obj.apply(lambda col: func(col.dropna()), axis=axis)
+
+
+def annualize_return(
+    returns: Series | DataFrame, periods_per_year: int = 12, axis: int = 0
+) -> Series | float:
+    """Geometric annualised return.
+
+    Parameters
+    ----------
+    returns : pandas.Series or pandas.DataFrame
+        Periodic returns in decimal form.
+    periods_per_year : int, default 12
+        Number of compounding periods per year.
+    axis : int, default 0
+        Axis along which to calculate for DataFrames.
+
+    Returns
+    -------
+    pandas.Series or float
+        Annualised return(s).
+
+    Example
+    -------
+    >>> import pandas as pd
+    >>> s = pd.Series([0.02, -0.01, 0.03])
+    >>> annualize_return(s)
+    0.236090...  # doctest: +ELLIPSIS
+    """
+    _validate_input(returns)
+
+    def _calc(x: Series) -> float:
+        if x.empty:
+            return np.nan
+        growth = (1 + x).prod()
+        n = len(x)
+        if growth <= 0:
+            return -1.0
+        return growth ** (periods_per_year / n) - 1
+
+    return _apply(returns, _calc, axis)
+
+
+def annualize_volatility(
+    returns: Series | DataFrame, periods_per_year: int = 12, axis: int = 0
+) -> Series | float:
+    """Annualised volatility of returns."""
+    _validate_input(returns)
+
+    def _calc(x: Series) -> float:
+        if len(x) <= 1:
+            return np.nan
+        return x.std(ddof=1) * np.sqrt(periods_per_year)
+
+    return _apply(returns, _calc, axis)
+
+
+def sharpe_ratio(
+    returns: Series | DataFrame,
+    rf: Series | DataFrame,
+    periods_per_year: int = 12,
+    axis: int = 0,
+) -> Series | float:
+    """Annualised Sharpe ratio."""
+    _validate_input(returns)
+    _validate_input(rf)
+
+    def _calc(r: Series, rf_s: Series) -> float:
+        df = pd.DataFrame({"r": r, "rf": rf_s}).dropna()
+        if len(df) < 2:
+            return np.nan
+        excess = df["r"] - df["rf"]
+        ann_excess_ret = annualize_return(excess, periods_per_year)
+        ann_excess_vol = annualize_volatility(excess, periods_per_year)
+        if ann_excess_vol == 0 or np.isnan(ann_excess_vol):
+            return np.nan
+        return ann_excess_ret / ann_excess_vol
+
+    if isinstance(returns, Series) and isinstance(rf, Series):
+        return _calc(returns, rf)
+
+    if isinstance(returns, DataFrame) and isinstance(rf, Series):
+        rf = DataFrame({c: rf for c in returns.columns})
+
+    if isinstance(returns, Series) and isinstance(rf, DataFrame):
+        returns = DataFrame({c: returns for c in rf.columns})
+
+    if isinstance(returns, DataFrame) and isinstance(rf, DataFrame):
+        return DataFrame(
+            {col: _calc(returns[col], rf[col]) for col in returns.columns}
+        ).squeeze(axis=1)
+
+    raise TypeError(
+        "returns and rf must be Series or DataFrame of compatible shape"
+    )
+
+
+def sortino_ratio(
+    returns: Series | DataFrame,
+    rf: Series | DataFrame,
+    periods_per_year: int = 12,
+    axis: int = 0,
+) -> Series | float:
+    """Annualised Sortino ratio."""
+    _validate_input(returns)
+    _validate_input(rf)
+
+    def _calc(r: Series, rf_s: Series) -> float:
+        df = pd.DataFrame({"r": r, "rf": rf_s}).dropna()
+        if len(df) < 2:
+            return np.nan
+        excess = df["r"] - df["rf"]
+        growth = (1 + excess).prod()
+        ann_ret = (
+            growth ** (periods_per_year / len(excess)) - 1
+            if growth > 0
+            else np.nan
+        )
+        downside = excess[excess < 0]
+        if downside.empty:
+            return np.nan
+        down_vol = downside.std(ddof=1) * np.sqrt(periods_per_year)
+        if down_vol == 0 or np.isnan(down_vol):
+            return np.nan
+        return ann_ret / down_vol
+
+    if isinstance(returns, Series) and isinstance(rf, Series):
+        return _calc(returns, rf)
+
+    if isinstance(returns, DataFrame) and isinstance(rf, Series):
+        rf = DataFrame({c: rf for c in returns.columns})
+
+    if isinstance(returns, Series) and isinstance(rf, DataFrame):
+        returns = DataFrame({c: returns for c in rf.columns})
+
+    if isinstance(returns, DataFrame) and isinstance(rf, DataFrame):
+        return DataFrame(
+            {col: _calc(returns[col], rf[col]) for col in returns.columns}
+        ).squeeze(axis=1)
+
+    raise TypeError(
+        "returns and rf must be Series or DataFrame of compatible shape"
+    )
+
+
+def max_drawdown(returns: Series | DataFrame, axis: int = 0) -> Series | float:
+    """Maximum drawdown of cumulative returns."""
+    _validate_input(returns)
+
+    def _calc(x: Series) -> float:
+        if x.empty:
+            return np.nan
+        wealth = (1 + x).cumprod()
+        dd = 1 - wealth / wealth.cummax()
+        return dd.max()
+
+    return _apply(returns, _calc, axis)
 
EOF
)