 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/Vol_Adj_Trend_Analysis1.3.TrEx.ipynb b/Vol_Adj_Trend_Analysis1.3.TrEx.ipynb
index e131eb70486477d4aa38bc111ae8a09c7a7aa494..87e43ec04040ca4795894c80966c27ec7bace3a2 100644
--- a/Vol_Adj_Trend_Analysis1.3.TrEx.ipynb
+++ b/Vol_Adj_Trend_Analysis1.3.TrEx.ipynb
@@ -196,51 +196,51 @@
     "\n",
     "        # spacer\n",
     "        row += 1\n",
     "\n",
     "        # 3. Index rows\n",
     "        for idx, pair in res.get(\"index_stats\", {}).items():\n",
     "            in_idx = pair[\"in_sample\"]\n",
     "            out_idx= pair[\"out_sample\"]\n",
     "            ws.write(row, 0, idx, bold)\n",
     "            ws.write(row, 1, safe(\"\") if True else int0)\n",
     "            vals = pct(tuple(in_idx)) + pct(tuple(out_idx))\n",
     "            fmts = ([num2]*4 + [red]) * 2\n",
     "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
     "                ws.write(row, col, safe(v), fmt)\n",
     "            row += 1\n",
     "\n",
     "    return fmt_summary\n",
     "\n",
     "# ───────────────────────────────────────────────────────────────\n",
     "#  2 · CSV LOADER + RF DETECTOR\n",
     "# ───────────────────────────────────────────────────────────────\n",
     "logger = logging.getLogger(__name__)\n",
     "\n",
     "def load_csv(path: str) -> pd.DataFrame | None:\n",
     "    try:\n",
-    "        df = pd.read_csv(path)\n",
+    "        df = pd.read_csv(path, parse_dates=['Date'])\n",
     "    except FileNotFoundError as e:\n",
     "        logger.error(f\"File not found: {path}\")\n",
     "        return None\n",
     "    except pd.errors.EmptyDataError:\n",
     "        logger.error(f\"No data in file: {path}\")\n",
     "        return None\n",
     "    except pd.errors.ParserError as e:\n",
     "        logger.error(f\"Parsing error in {path}: {e}\")\n",
     "        return None\n",
     "\n",
     "    if \"Date\" not in df.columns:\n",
     "        logger.error(f\"Validation failed ({path}): missing 'Date' column\")\n",
     "        return None\n",
     "\n",
     "    # Optionally check for NaNs in 'Date' column\n",
     "    if df[\"Date\"].isnull().any():\n",
     "        logger.warning(f\"Null values found in 'Date' column of {path}\")\n",
     "\n",
     "    return df\n",
     "\n",
     "def identify_risk_free_fund(df: pd.DataFrame) -> str:\n",
     "    returns = df.drop(columns=\"Date\", errors=\"ignore\")\n",
     "    stdevs  = returns.std(skipna=True, ddof=0)\n",
     "    return stdevs.idxmin()"
    ]
@@ -276,55 +276,51 @@
     "    min_volatility               = 0.05,\n",
     "    max_volatility               = 1.0,\n",
     "    min_avg_return               = 0.0,\n",
     "    max_skewness                 = 3.0,\n",
     "    max_kurtosis                 = 10.0,\n",
     "    expected_freq                = \"B\",\n",
     "    max_gap_days                 = 3,\n",
     "    min_aum_usd                  = 1e7,\n",
     ")\n",
     "\n",
     "def select_funds(\n",
     "    df: pd.DataFrame,\n",
     "    rf_col: str,\n",
     "    fund_columns: list[str],\n",
     "    in_sdate: str,\n",
     "    in_edate: str,\n",
     "    out_sdate: str,\n",
     "    out_edate: str,\n",
     "    cfg: FundSelectionConfig,\n",
     "    selection_mode: str = \"all\",\n",
     "    random_n: int | None = None\n",
     ") -> list[str]:\n",
     "    \"\"\"\n",
     "    Select eligible funds with additional data-validity and coverage checks driven by FundSelectionConfig.\n",
     "    \"\"\"\n",
-    "    # Ensure Date is datetime and sorted\n",
-    "    if not pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        df = df.copy()\n",
-    "        df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "        df.dropna(subset=[\"Date\"], inplace=True)\n",
+    "    # Ensure Date is sorted\n",
     "    df = df.sort_values(\"Date\")  # guarantee monotonic index\n",
     "\n",
     "    # Prepare monthly periods within analysis window\n",
     "    df[\"Month\"] = df[\"Date\"].dt.to_period(\"M\")\n",
     "    span = pd.period_range(\n",
     "        pd.Period(in_sdate, \"M\"), pd.Period(out_edate, \"M\"), freq=\"M\"\n",
     "    )\n",
     "\n",
     "    eligible_funds: list[str] = []\n",
     "    for f in fund_columns:\n",
     "        try:\n",
     "            ser = df.set_index(\"Date\")[f]\n",
     "            clean = ser.dropna()\n",
     "\n",
     "            # 1. Implausible value limits\n",
     "            if not clean.between(-cfg.implausible_value_limit, cfg.implausible_value_limit).all():\n",
     "                raise ValueError(f\"Values outside ±{cfg.implausible_value_limit}\")\n",
     "\n",
     "            # 2. Extreme outlier threshold\n",
     "            if (clean.abs() > cfg.outlier_threshold).any():\n",
     "                raise ValueError(f\"Outliers beyond ±{cfg.outlier_threshold}\")\n",
     "\n",
     "            # 3. Excessive zero-return rate\n",
     "            if (clean == 0).mean() > cfg.zero_return_threshold:\n",
     "                raise ValueError(f\"Zero-return proportion > {cfg.zero_return_threshold}\")\n",
@@ -812,51 +808,50 @@
     "# ---------- 1 · DATA LOAD ----------\n",
     "src = widgets.ToggleButtons(\n",
     "    options=[(\"Local\", \"local\"), (\"URL\", \"url\")],\n",
     "    description=\"Source:\"\n",
     ")\n",
     "\n",
     "chooser = FileChooser()\n",
     "url_box = widgets.Text(placeholder=\"https://…/file.csv\", layout={\"width\":\"70%\"})\n",
     "load_btn = widgets.Button(description=\"Load CSV\", button_style=\"success\")\n",
     "load_out = widgets.Output()\n",
     "\n",
     "def _toggle_src(c):\n",
     "    chooser.layout.display = \"block\" if c[\"new\"]==\"local\" else \"none\"\n",
     "    url_box.layout.display  = \"block\" if c[\"new\"]==\"url\"   else \"none\"\n",
     "src.observe(_toggle_src, names=\"value\"); _toggle_src({\"new\":src.value})\n",
     "\n",
     "def _load(_):\n",
     "    with load_out:\n",
     "        clear_output()\n",
     "        try:\n",
     "            path = chooser.selected if src.value==\"local\" else url_box.value.strip()\n",
     "            if not path: raise ValueError(\"choose file / URL\")\n",
     "            if src.value==\"url\" and not path.lower().endswith(\".csv\"):\n",
     "                raise ValueError(\"URL must end with .csv\")\n",
     "            df = load_csv(path)\n",
-    "            df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")  # single coercion\n",
     "            rf = identify_risk_free_fund(df)\n",
     "            session.update(df=df, rf=rf, sel=None, cweights=None)\n",
     "            print(f\"✅ Loaded {len(df):,} rows × {df.shape[1]} cols | RF → {rf}\")\n",
     "        except Exception as e:\n",
     "            print(\"❌\", e); session[\"df\"]=None\n",
     "load_btn.on_click(_load)\n",
     "\n",
     "# ---------- 2 · PARAMS ------------\n",
     "index_cnt = widgets.BoundedIntText(0, min=0, max=10, description=\"# Indices:\")\n",
     "in_start,in_end  = widgets.Text(\"2005-07\"), widgets.Text(\"2008-06\")\n",
     "out_start,out_end= widgets.Text(\"2008-07\"), widgets.Text(\"2009-06\")\n",
     "for w,lbl in [(in_start,\"In Start:\"),(in_end,\"In End:\"),\n",
     "              (out_start,\"Out Start:\"),(out_end,\"Out End:\")]:\n",
     "    w.description = lbl\n",
     "target_vol   = widgets.FloatText(0.25,  description=\"Target Vol:\")\n",
     "monthly_cost = widgets.FloatText(0.0033, description=\"Monthly Cost:\")\n",
     "\n",
     "# ---------- 3 · SELECTION ----------\n",
     "mode_dd = widgets.Dropdown(\n",
     "    options=[(\"All\", \"all\"), (\"Random\", \"random\"), (\"Manual\", \"manual\")],\n",
     "    value=\"all\",\n",
     "    description=\"Mode:\"\n",
     ")\n",
     "rand_n   = widgets.BoundedIntText(5, min=2, max=100, description=\"Sample N:\")\n",
     "fund_table, total_lbl = widgets.VBox([]), widgets.Label(\"Total = 0 %\")\n",
 
EOF
)