 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/.gitignore b/.gitignore
index 0968940b19cd66564ac546faed00a9f9fbfc48ea..bd7d87883f3ce887debbfa18c2b484a0fae48ab5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,11 +1,13 @@
 # Byte-compiled / optimized / DLL files
 __pycache__/
+.pytest_cache/
 *.pyc
 *.py[cod]
 
 # Jupyter Notebook checkpoints
 .ipynb_checkpoints/
+.jupyter/
 *.jupyterlab-workspace
 
 # macOS metadata
 .DS_Store
diff --git a/.ipynb_checkpoints/PromptCode-checkpoint.ipynb b/.ipynb_checkpoints/PromptCode-checkpoint.ipynb
deleted file mode 100644
index f7a8ddb4920ae76db5cda5928a5c9f83e9580c45..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/PromptCode-checkpoint.ipynb
+++ /dev/null
@@ -1,65 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "db6e627f-6b22-44b8-a552-c2a8c766b273",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "import pandas as pd\n",
-    "\n",
-    "# Step 1: Load the existing template spreadsheet (with PromptID, Library, Category, Sub-node, ConceptTag, blank Prompt cells)\n",
-    "template_path = \"/mnt/data/insight_generation_full_library.xlsx\"\n",
-    "df_template = pd.read_excel(template_path)\n",
-    "\n",
-    "# Step 2: Load your master prompt mapping (PromptID → Prompt text)\n",
-    "# Assume this mapping was generated and saved previously as a CSV or Excel\n",
-    "mapping_path = \"/mnt/data/insight_generation_full_prompts.xlsx\"  # Replace with actual path\n",
-    "df_mapping = pd.read_excel(mapping_path)\n",
-    "\n",
-    "# Ensure the Prompt ID columns align\n",
-    "df_mapping.rename(columns={'Prompt ID': 'Prompt ID', 'Prompt': 'Prompt'}, inplace=True)\n",
-    "\n",
-    "# Step 3: Merge template with mapping to populate the Prompt column\n",
-    "df_filled = df_template.drop(columns=['Prompt']).merge(\n",
-    "    df_mapping[['Prompt ID', 'Prompt']],\n",
-    "    on='Prompt ID',\n",
-    "    how='left'\n",
-    ")\n",
-    "\n",
-    "# Step 4: Save the populated sheet in all required formats\n",
-    "output_base = \"/mnt/data/filled_insight_generation_library\"\n",
-    "df_filled.to_excel(f\"{output_base}.xlsx\", index=False)\n",
-    "df_filled.to_csv(f\"{output_base}.csv\", index=False)\n",
-    "df_filled.to_json(f\"{output_base}.json\", orient='records')\n",
-    "\n",
-    "print(\"Populated prompts sheet saved to:\")\n",
-    "print(f\"  • {output_base}.xlsx\")\n",
-    "print(f\"  • {output_base}.csv\")\n",
-    "print(f\"  • {output_base}.json\")\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/PromptEngineer-checkpoint.ipynb b/.ipynb_checkpoints/PromptEngineer-checkpoint.ipynb
deleted file mode 100644
index 6d0ca06de3691f4a4d359a46d3cfb484ff0da517..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/PromptEngineer-checkpoint.ipynb
+++ /dev/null
@@ -1,79 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "d03db469-8dbe-420a-bb0d-58602e7c7ad4",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "import pandas as pd\n",
-    "from textdistance import jaro_winkler\n",
-    "from sentence_transformers import SentenceTransformer, util\n",
-    "\n",
-    "# Load prompts\n",
-    "df = pd.read_csv('prompts.csv')\n",
-    "\n",
-    "# Quick lexical check (fast, identifies exact/similar wording)\n",
-    "def lexical_duplication_check(df, threshold=0.88):\n",
-    "    dupes = []\n",
-    "    texts = df['Prompt'].tolist()\n",
-    "    for i in range(len(texts)):\n",
-    "        for j in range(i+1, len(texts)):\n",
-    "            sim = jaro_winkler.normalized_similarity(texts[i], texts[j])\n",
-    "            if sim > threshold:\n",
-    "                dupes.append((i, j, sim))\n",
-    "    return dupes\n",
-    "\n",
-    "# Semantic drift check (more nuanced)\n",
-    "def semantic_drift_check(df, concept_col='ConceptTag', branch_col='Branch', lib_col='Library', threshold=0.78):\n",
-    "    model = SentenceTransformer(\"all-MiniLM-L6-v2\")\n",
-    "    embeddings = model.encode(df['Prompt'].tolist(), convert_to_tensor=True)\n",
-    "    drift_flags = []\n",
-    "\n",
-    "    for idx, row in df.iterrows():\n",
-    "        matches = df[(df[concept_col] == row[concept_col]) & (df[branch_col] == row[branch_col]) & (df[lib_col] != row[lib_col])]\n",
-    "        for match_idx in matches.index:\n",
-    "            similarity = util.cos_sim(embeddings[idx], embeddings[match_idx]).item()\n",
-    "            if similarity > threshold:\n",
-    "                drift_flags.append((idx, match_idx, similarity))\n",
-    "\n",
-    "    return drift_flags\n",
-    "\n",
-    "# Run checks\n",
-    "lexical_duplicates = lexical_duplication_check(df)\n",
-    "semantic_drifts = semantic_drift_check(df)\n",
-    "\n",
-    "# Review flagged pairs manually\n",
-    "print(\"Lexical duplicates flagged:\")\n",
-    "for i, j, sim in lexical_duplicates:\n",
-    "    print(f\"Rows {i} and {j}: similarity={sim:.2f}\")\n",
-    "\n",
-    "print(\"\\nSemantic drift flagged:\")\n",
-    "for i, j, sim in semantic_drifts:\n",
-    "    print(f\"Rows {i} ({df.at[i, 'Library']}) and {j} ({df.at[j, 'Library']}): similarity={sim:.2f}\")"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Test-checkpoint.ipynb b/.ipynb_checkpoints/Test-checkpoint.ipynb
deleted file mode 100644
index 8fd4d7ef793c6d4318e5bdc6556e6e46eab01edf..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Test-checkpoint.ipynb
+++ /dev/null
@@ -1,293 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "82b1977a-a1f1-4829-a7fc-78d773cd83ed",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Written: Vol_Adj_Trend_Analysis_Cleanup.py\n"
-     ]
-    }
-   ],
-   "source": [
-    "%%bash\n",
-    "cat > Vol_Adj_Trend_Analysis_Cleanup.py << 'EOF'\n",
-    "# Vol_Adj_Trend_Analysis_Cleanup\n",
-    "\n",
-    "# --- 1. SETUP CELL ---\n",
-    "import logging, sys, os, warnings, random\n",
-    "import math\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import datetime\n",
-    "\n",
-    "# Configure logging\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "# --- 2. Identify Risk-Free Fund ---\n",
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify the risk-free column (smallest stddev among numeric columns).\n",
-    "    Returns the column name.\n",
-    "    \"\"\"\n",
-    "    cols = df.columns[1:]\n",
-    "    stdevs = {\n",
-    "        col: df[col].dropna().std() if not df[col].dropna().empty else np.inf\n",
-    "        for col in cols\n",
-    "    }\n",
-    "    rf = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Risk-free column: {rf}\")\n",
-    "    return rf\n",
-    "\n",
-    "# --- 3. Robust CSV Reader ---\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Load CSV with fallback strategies:\n",
-    "    – Default engine\n",
-    "    – BOM-stripped with Python engine\n",
-    "    – Skip bad lines with Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception:\n",
-    "        pass\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception:\n",
-    "        pass\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",\n",
-    "    )\n",
-    "\n",
-    "# --- 4. Utility Functions ---\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Return True if there are ≥ threshold consecutive NaNs in the series.\n",
-    "    \"\"\"\n",
-    "    count = 0\n",
-    "    for v in series:\n",
-    "        count = count + 1 if pd.isna(v) else 0\n",
-    "        if count >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Replace runs of 1–2 NaNs with 0.0; leave longer gaps intact.\n",
-    "    \"\"\"\n",
-    "    mask = series.isna().astype(int)\n",
-    "    runs = mask.groupby((mask == 0).cumsum()).transform('sum')\n",
-    "    out = series.copy()\n",
-    "    out[(mask == 1) & (runs <= 2)] = 0.0\n",
-    "    return out\n",
-    "\n",
-    "# --- 5. Annualized Metrics ---\n",
-    "def annualize_return(m_returns):\n",
-    "    \"\"\"\n",
-    "    Geometric annual return from monthly returns (decimal).\n",
-    "    \"\"\"\n",
-    "    vals = m_returns.dropna()\n",
-    "    if vals.empty:\n",
-    "        return np.nan\n",
-    "    growth = (1 + vals).prod()\n",
-    "    months = len(vals)\n",
-    "    return (growth ** (12.0 / months)) - 1 if growth > 0 else -1.0\n",
-    "\n",
-    "def annualize_volatility(m_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized volatility = std(monthly) * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    vals = m_returns.dropna()\n",
-    "    return vals.std() * np.sqrt(12) if len(vals) > 1 else np.nan\n",
-    "\n",
-    "def sharpe_ratio(m_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe = ann_excess_return / ann_excess_volatility.\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': m_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth = (1 + excess).prod()\n",
-    "    months = len(excess)\n",
-    "    ann_ret = (growth ** (12.0 / months)) - 1 if growth > 0 else np.nan\n",
-    "    ann_vol = excess.std() * np.sqrt(12)\n",
-    "    return ann_ret / ann_vol if ann_vol > 0 else np.nan\n",
-    "\n",
-    "def sortino_ratio(m_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino = ann_excess_return / downside_stdev.\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': m_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth = (1 + excess).prod()\n",
-    "    months = len(excess)\n",
-    "    ann_ret = (growth ** (12.0 / months)) - 1 if growth > 0 else np.nan\n",
-    "    downs = excess[excess < 0]\n",
-    "    down_stdev = downs.std() * np.sqrt(12) if not downs.empty else np.inf\n",
-    "    return ann_ret / down_stdev\n",
-    "\n",
-    "def max_drawdown(m_returns):\n",
-    "    \"\"\"\n",
-    "    Maximum drawdown from monthly returns.\n",
-    "    \"\"\"\n",
-    "    vals = m_returns.dropna()\n",
-    "    if vals.empty:\n",
-    "        return np.nan\n",
-    "    wealth = (1 + vals).cumprod()\n",
-    "    dd = 1 - wealth / wealth.cummax()\n",
-    "    return dd.max()\n",
-    "\n",
-    "# --- 6. Select Funds ---\n",
-    "def select_funds(\n",
-    "    df,\n",
-    "    rf_col,\n",
-    "    fund_columns,\n",
-    "    in_sdate, in_edate,\n",
-    "    out_sdate, out_edate,\n",
-    "    selection_mode='all',\n",
-    "    random_n=8\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    – Start with fund_columns\n",
-    "    – Drop any containing 'index'\n",
-    "    – Filter out funds with NaNs in either window or ≥3 consecutive NaNs\n",
-    "    – Return either all or random subset\n",
-    "    \"\"\"\n",
-    "    candidates = [f for f in fund_columns if 'index' not in f.lower()]\n",
-    "    valid = []\n",
-    "    for f in candidates:\n",
-    "        in_sub  = df.loc[in_sdate:in_edate, f]\n",
-    "        out_sub = df.loc[out_sdate:out_edate, f]\n",
-    "        if in_sub.notna().all() and out_sub.notna().all():\n",
-    "            if not consecutive_gaps(in_sub) and not consecutive_gaps(out_sub):\n",
-    "                valid.append(f)\n",
-    "    if selection_mode == 'all':\n",
-    "        return valid\n",
-    "    if selection_mode == 'random':\n",
-    "        if len(valid) <= random_n:\n",
-    "            logging.warning(\n",
-    "                f\"Fewer valid funds ({len(valid)}) than requested ({random_n}), returning all.\"\n",
-    "            )\n",
-    "            return valid\n",
-    "        return random.sample(valid, random_n)\n",
-    "    return valid\n",
-    "\n",
-    "# --- 7. Custom Weights UI ---\n",
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=fund,\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    confirm = widgets.Button(description='Confirm', button_style='success')\n",
-    "    error_lbl = widgets.Label(layout=widgets.Layout(color='red'))\n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm, error_lbl])\n",
-    "    display(box)\n",
-    "    weights = {}\n",
-    "    def on_confirm(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_lbl.value = f\"Weights sum to {total}, must be 100.\"\n",
-    "            weights.clear()\n",
-    "        else:\n",
-    "            for fund, w in weight_widgets.items():\n",
-    "                weights[fund] = w.value / 100.0\n",
-    "            error_lbl.value = \"Weights confirmed\"\n",
-    "    confirm.on_click(on_confirm)\n",
-    "    return weights\n",
-    "\n",
-    "# --- 8. run_analysis ---\n",
-    "def run_analysis(\n",
-    "    df,\n",
-    "    in_start, in_end,\n",
-    "    out_start, out_end,\n",
-    "    target_vol,\n",
-    "    monthly_cost,\n",
-    "    selection_mode='all',\n",
-    "    random_n=8,\n",
-    "    custom_weights=None\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    – Parse YYYY-MM inputs to month-end timestamps\n",
-    "    – Ensure Date column is datetime64\n",
-    "    – Identify risk-free column\n",
-    "    – Slice DataFrames for in/out samples\n",
-    "    – Select funds and compute scale factors\n",
-    "    – Scale returns, compute stats, and build results dict\n",
-    "    \"\"\"\n",
-    "    # implementation omitted for brevity; same as in notebook\n",
-    "\n",
-    "# --- 9. Export & UI Callback ---\n",
-    "def export_to_excel(\n",
-    "    results, df, fname,\n",
-    "    in_start, in_end, out_start, out_end\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Single-writer export including portfolio sheets and indices blocks.\n",
-    "    \"\"\"\n",
-    "    # implementation omitted for brevity; same as in notebook\n",
-    "EOF\n",
-    "\n",
-    "echo \"Written: Vol_Adj_Trend_Analysis_Cleanup.py\"\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "2b81b771-a1a4-4731-a5bc-84704d10a29d",
-   "metadata": {},
-   "outputs": [],
-   "source": []
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Untitled-checkpoint.ipynb b/.ipynb_checkpoints/Untitled-checkpoint.ipynb
deleted file mode 100644
index 363fcab7ed6e9634e198cf5555ceb88932c9a245..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Untitled-checkpoint.ipynb
+++ /dev/null
@@ -1,6 +0,0 @@
-{
- "cells": [],
- "metadata": {},
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Untitled1-checkpoint.ipynb b/.ipynb_checkpoints/Untitled1-checkpoint.ipynb
deleted file mode 100644
index 363fcab7ed6e9634e198cf5555ceb88932c9a245..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Untitled1-checkpoint.ipynb
+++ /dev/null
@@ -1,6 +0,0 @@
-{
- "cells": [],
- "metadata": {},
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis-checkpoint.ipynb
deleted file mode 100644
index 16d06906a5999e6ff097c31c9f99fef6c35ca4bb..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis-checkpoint.ipynb
+++ /dev/null
@@ -1,1714 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "9ed15037-f989-4fff-9388-9cf03ea986aa",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "select_funds (replaced) is ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "import warnings, random\n",
-    "import pandas as pd\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "    \n",
-    "import warnings\n",
-    "import random\n",
-    "\n",
-    "def select_funds(\n",
-    "    df,                 # full DataFrame with datetime64 ‘Date’\n",
-    "    rf_col,             # name of risk‐free column\n",
-    "    fund_columns,       # list of candidate funds (should be your 27)\n",
-    "    in_sdate, in_edate, # pd.Timestamps for in‐sample window\n",
-    "    out_sdate, out_edate,# pd.Timestamps for out‐sample window\n",
-    "    selection_mode='all',\n",
-    "    random_n=5\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Start from fund_columns.  \n",
-    "    2) Filter out any that contain 'index' in name.  \n",
-    "    3) Keep only those with no NaN anywhere in both windows.  \n",
-    "    4) Keep only those with < 3 consecutive NaNs in each window.  \n",
-    "    5) Return based on selection_mode.\n",
-    "    \"\"\"\n",
-    "    # Step 1: base list\n",
-    "    candidates = fund_columns.copy()\n",
-    "    print(f\"DEBUG [select_funds]: initial candidates (n={len(candidates)}): {candidates}\")\n",
-    "\n",
-    "    # Step 2: drop any with “index” in name (case‐insensitive)\n",
-    "    no_index = [f for f in candidates if 'index' not in f.lower()]\n",
-    "    print(f\"DEBUG [select_funds]: after dropping 'index' (n={len(no_index)}): {no_index}\")\n",
-    "\n",
-    "    # Step 3: full‐history check (no NaN at all in each window)\n",
-    "    full_hist = []\n",
-    "    for f in no_index:\n",
-    "        in_sub  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)][f]\n",
-    "        out_sub = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        if in_sub.notna().all() and out_sub.notna().all():\n",
-    "            full_hist.append(f)\n",
-    "    print(f\"DEBUG [select_funds]: after full‐history check (n={len(full_hist)}): {full_hist}\")\n",
-    "\n",
-    "    # Step 4: no 3‐consecutive‐NaNs check\n",
-    "    after_run_check = []\n",
-    "    for f in full_hist:\n",
-    "        # In‐sample gap runs\n",
-    "        sub_in   = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "        isnan_in = sub_in.isna().astype(int)\n",
-    "        run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "        max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "\n",
-    "        # Out‐sample gap runs\n",
-    "        sub_out   = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        isnan_out = sub_out.isna().astype(int)\n",
-    "        run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "        max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "\n",
-    "        # Keep only if both max runs < 3\n",
-    "        if max_run_in < 3 and max_run_out < 3:\n",
-    "            after_run_check.append(f)\n",
-    "\n",
-    "    print(f\"DEBUG [select_funds]: after run‐length check (n={len(after_run_check)}): {after_run_check}\")\n",
-    "\n",
-    "    # Step 5: selection_mode\n",
-    "    if selection_mode == 'all':\n",
-    "        return after_run_check\n",
-    "\n",
-    "    if selection_mode == 'random':\n",
-    "        if len(after_run_check) <= random_n:\n",
-    "            warnings.warn(\n",
-    "                f\"Fewer valid funds ({len(after_run_check)}) than sample size ({random_n}). Returning all.\"\n",
-    "            )\n",
-    "            return after_run_check\n",
-    "        return random.sample(after_run_check, random_n)\n",
-    "\n",
-    "    # (Placeholder for manual widget selection, if you implement it later)\n",
-    "    return after_run_check\n",
-    "\n",
-    "print(\"select_funds (replaced) is ready.\")\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "d134577d-8bbf-4933-95f2-0d032ac87a48",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "\n",
-    "\n",
-    "import warnings, random\n",
-    "import pandas as pd\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "\n",
-    "def select_funds(\n",
-    "    df, rf_col, fund_columns,\n",
-    "    in_sdate, in_edate, out_sdate, out_edate,\n",
-    "    selection_mode, random_n\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    df             : DataFrame (with 'Date' as datetime64[ns])\n",
-    "    rf_col         : name of the risk-free column (string)\n",
-    "    fund_columns   : list of actual fund names (no Date, no rf_col, no indices)\n",
-    "    in_sdate       : pd.Timestamp for in-sample start (first day of month)\n",
-    "    in_edate       : pd.Timestamp for in-sample end (last day of month)\n",
-    "    out_sdate      : pd.Timestamp for out-sample start (first day of month)\n",
-    "    out_edate      : pd.Timestamp for out-sample end (last day of month)\n",
-    "    selection_mode : 'all' / 'random' / 'manual'\n",
-    "    random_n       : integer for random sampling if mode == 'random'\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # 1) Initial fund candidates\n",
-    "    all_fund_cols = fund_columns.copy()\n",
-    "    print(f\"DEBUG [select_funds]: initial candidates (n={len(all_fund_cols)}): {all_fund_cols}\")\n",
-    "\n",
-    "    # 2) Extract in‐sample & out‐sample DataFrames (just the Date + fund columns)\n",
-    "    in_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "\n",
-    "    # 3) For each fund, fill short gaps ≤2 months in both windows, then check for any remaining run ≥ 3\n",
-    "    funds_after_run_check = []\n",
-    "    for f in all_fund_cols:\n",
-    "        # 3a) Pull the in‐sample return series for this fund, indexed by Date\n",
-    "        ser_in = in_df.set_index('Date')[f]\n",
-    "\n",
-    "        # 3b) Fill any 1–2 consecutive NaNs → 0\n",
-    "        filled_in = fill_short_gaps_with_zero(ser_in)\n",
-    "\n",
-    "        # 3c) Check longest run of NaNs left in in‐sample\n",
-    "        mask_in = filled_in.isna().astype(int)\n",
-    "        run_len_in = (\n",
-    "            mask_in.groupby((mask_in == 0).cumsum())\n",
-    "                   .sum()\n",
-    "        )\n",
-    "        max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "\n",
-    "        # 3d) Do the same for out‐sample\n",
-    "        ser_out = out_df.set_index('Date')[f]\n",
-    "        filled_out = fill_short_gaps_with_zero(ser_out)\n",
-    "        mask_out = filled_out.isna().astype(int)\n",
-    "        run_len_out = (\n",
-    "            mask_out.groupby((mask_out == 0).cumsum())\n",
-    "                    .sum()\n",
-    "        )\n",
-    "        max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "\n",
-    "        # 3e) Print debug so you see if any fund truly has a run ≥3 inside the window\n",
-    "        print(f\"DEBUG [select_funds]: '{f}' max consecutive NaNs in in-sample = {max_run_in}\")\n",
-    "        print(f\"DEBUG [select_funds]: '{f}' max consecutive NaNs in out-sample = {max_run_out}\")\n",
-    "\n",
-    "        # 3f) Only keep the fund if BOTH windows have max_run < 3\n",
-    "        if (max_run_in < 3) and (max_run_out < 3):\n",
-    "            funds_after_run_check.append(f)\n",
-    "\n",
-    "    print(f\"DEBUG [select_funds]: after run‐length check (n={len(funds_after_run_check)}): {funds_after_run_check}\")\n",
-    "\n",
-    "    # 4) Apply selection_mode\n",
-    "    if selection_mode == 'all':\n",
-    "        return funds_after_run_check\n",
-    "\n",
-    "    if selection_mode == 'random':\n",
-    "        if len(funds_after_run_check) <= random_n:\n",
-    "            warnings.warn(\n",
-    "                f\"Fewer valid funds ({len(funds_after_run_check)}) than sample size ({random_n}). Returning all.\"\n",
-    "            )\n",
-    "            return funds_after_run_check\n",
-    "        return random.sample(funds_after_run_check, random_n)\n",
-    "\n",
-    "    # 5) Manual selection (widget) would be implemented here if desired.\n",
-    "    return funds_after_run_check\n",
-    "\n",
-    "print(\"select_funds (gap‐filled, windowed) is defined.\")\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "367bab83-272d-4e85-a416-335980903119",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "run_analysis (with checkpoints) is defined.\n"
-     ]
-    }
-   ],
-   "source": [
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import logging\n",
-    "\n",
-    "def run_analysis(\n",
-    "    df, in_start, in_end, out_start, out_end,\n",
-    "    target_vol, monthly_cost,\n",
-    "    selection_mode='all', random_n=5\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Parse/validate date inputs\n",
-    "    2) Convert Date column if needed\n",
-    "    3) Identify rf_col\n",
-    "    4) Prepare in/out sample DataFrames\n",
-    "    5) CALL select_funds (with debug) and print checkpoints\n",
-    "    6) Compute scale_factors and wrap stats in try/except\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # (1) Parse input dates\n",
-    "    in_sdate  = pd.to_datetime(in_start + \"-01\", errors='coerce')\n",
-    "    in_edate  = pd.to_datetime(in_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "    out_sdate = pd.to_datetime(out_start + \"-01\", errors='coerce')\n",
-    "    out_edate = pd.to_datetime(out_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    # checkpoint A\n",
-    "    print(\"CHECKPOINT A: Dates parsed:\", in_sdate, in_edate, out_sdate, out_edate)\n",
-    "\n",
-    "    # (2) Ensure Date is datetime64\n",
-    "    if not np.issubdtype(df['Date'].dtype, np.datetime64):\n",
-    "        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "        df.dropna(subset=['Date'], inplace=True)\n",
-    "        df.sort_values(by='Date', inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "    # checkpoint B\n",
-    "    print(\"CHECKPOINT B: Date column is datetime64, first dates:\", df['Date'].iloc[0], df['Date'].iloc[-1])\n",
-    "\n",
-    "    # (3) Identify risk-free column\n",
-    "    rf_col = identify_risk_free_fund(df)\n",
-    "    print(f\"INFO: Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "\n",
-    "    # (4) Build in-sample & out-sample slices\n",
-    "    in_sample_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_sample_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "    in_sample_rf  = in_sample_df[rf_col]\n",
-    "    out_sample_rf = out_sample_df[rf_col]\n",
-    "\n",
-    "    print(f\"CHECKPOINT C: in_sample rows = {len(in_sample_df)}, out_sample rows = {len(out_sample_df)}\")\n",
-    "\n",
-    "    # (5) Assemble fund_cols and call select_funds\n",
-    "    all_fund_cols = fund_cols.copy()\n",
-    "    print(f\"CHECKPOINT D: about to call select_funds with {len(all_fund_cols)} candidates\")\n",
-    "\n",
-    "    selected_funds = select_funds(\n",
-    "        df,\n",
-    "        rf_col,\n",
-    "        fund_columns=all_fund_cols,\n",
-    "        in_sdate=in_sdate,\n",
-    "        in_edate=in_edate,\n",
-    "        out_sdate=out_sdate,\n",
-    "        out_edate=out_edate,\n",
-    "        selection_mode=selection_mode,\n",
-    "        random_n=random_n\n",
-    "    )\n",
-    "\n",
-    "    print(f\"CHECKPOINT E: select_funds returned {len(selected_funds)} funds → {selected_funds}\")\n",
-    "\n",
-    "    if not selected_funds:\n",
-    "        print(\"No valid funds after select_funds. Exiting run_analysis.\")\n",
-    "        return None\n",
-    "\n",
-    "    # (6) Compute scale_factors BEFORE entering stats‐try/except\n",
-    "    scale_factors = {}\n",
-    "    for fund in selected_funds:\n",
-    "        fund_in_rets = in_sample_df[fund].dropna()\n",
-    "        current_vol  = annualize_volatility(fund_in_rets)\n",
-    "        if pd.isna(current_vol) or current_vol == 0:\n",
-    "            scale_factors[fund] = 1.0\n",
-    "        else:\n",
-    "            scale_factors[fund] = target_vol / current_vol\n",
-    "\n",
-    "    print(\"CHECKPOINT F: scale_factors computed (showing first 5):\", \n",
-    "          {f: scale_factors[f] for f in selected_funds[:5]})\n",
-    "\n",
-    "    # Pre-allocate DataFrames for scaled returns\n",
-    "    in_sample_scaled  = pd.DataFrame(index=in_sample_df.index, columns=selected_funds)\n",
-    "    out_sample_scaled = pd.DataFrame(index=out_sample_df.index, columns=selected_funds)\n",
-    "\n",
-    "    # ────── TRY/EXCEPT AROUND ONLY THE “STATS” PORTION ──────\n",
-    "    try:\n",
-    "        # Scale returns (with cost)\n",
-    "        for fund in selected_funds:\n",
-    "            sf = scale_factors[fund]\n",
-    "            adj_in  = in_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_in[adj_in < -1.0] = -1.0\n",
-    "            in_sample_scaled[fund] = adj_in\n",
-    "\n",
-    "            if not out_sample_df.empty:\n",
-    "                adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "                adj_out[adj_out < -1.0] = -1.0\n",
-    "                out_sample_scaled[fund] = adj_out\n",
-    "\n",
-    "        # Helper for stats\n",
-    "        def compute_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            sr  = sharpe_ratio(series, rf_series)\n",
-    "            so  = sortino_ratio(series, rf_series)\n",
-    "            mdd = max_drawdown(series)\n",
-    "            return (r, v, sr, so, mdd)\n",
-    "\n",
-    "        # In-sample per-fund stats\n",
-    "        in_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "\n",
-    "        # Out-sample per-fund (adjusted) stats\n",
-    "        out_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "\n",
-    "        # Out-sample per-fund (raw) stats\n",
-    "        out_sample_stats_raw = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "\n",
-    "        # Equal-weight portfolio\n",
-    "        ew_w = np.array([1.0/len(selected_funds)] * len(selected_funds))\n",
-    "        in_ew_port      = calc_portfolio_returns(ew_w, in_sample_scaled[selected_funds])\n",
-    "        out_ew_port     = calc_portfolio_returns(ew_w, out_sample_scaled[selected_funds])\n",
-    "        out_ew_port_raw = calc_portfolio_returns(ew_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        in_ew_stats      = compute_stats(in_ew_port, in_sample_rf)\n",
-    "        out_ew_stats     = compute_stats(out_ew_port, out_sample_rf)\n",
-    "        out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # User‐weight placeholder\n",
-    "        user_weight_dict = {f: 1.0/len(selected_funds) for f in selected_funds}\n",
-    "        custom_w = np.array([user_weight_dict[f] for f in selected_funds])\n",
-    "\n",
-    "        in_user_port      = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "        out_user_port     = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "        out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        in_user_stats      = compute_stats(in_user_port, in_sample_rf)\n",
-    "        out_user_stats     = compute_stats(out_user_port, out_sample_rf)\n",
-    "        out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "\n",
-    "        results = {\n",
-    "            'selected_funds':       selected_funds,\n",
-    "            'in_sample_scaled':     in_sample_scaled,\n",
-    "            'out_sample_scaled':    out_sample_scaled,\n",
-    "            'in_sample_stats':      in_sample_stats,\n",
-    "            'out_sample_stats':     out_sample_stats,\n",
-    "            'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "            'in_ew_stats':          in_ew_stats,\n",
-    "            'out_ew_stats':         out_ew_stats,\n",
-    "            'out_ew_stats_raw':     out_ew_stats_raw,\n",
-    "            'in_user_stats':        in_user_stats,\n",
-    "            'out_user_stats':       out_user_stats,\n",
-    "            'out_user_stats_raw':   out_user_stats_raw\n",
-    "        }\n",
-    "\n",
-    "    except Exception as e:\n",
-    "        print(\"ERROR inside stats-block:\", e)\n",
-    "        return None\n",
-    "\n",
-    "    # Everything succeeded\n",
-    "    return results\n",
-    "\n",
-    "print(\"run_analysis (with checkpoints) is defined.\")\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "c2cd88ee-a255-4282-b722-f34e34b95d36",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Run Analysis callback is now wired.\n"
-     ]
-    }
-   ],
-   "source": [
-    "from IPython.display import clear_output\n",
-    "from IPython.utils.capture import capture_output\n",
-    "\n",
-    "def on_apply_clicked(b):\n",
-    "    with output_area:\n",
-    "        clear_output()\n",
-    "        # 1) Read widget values\n",
-    "        in_start_val     = in_sample_start.value.strip()\n",
-    "        in_end_val       = in_sample_end.value.strip()\n",
-    "        out_start_val    = out_sample_start.value.strip()\n",
-    "        out_end_val      = out_sample_end.value.strip()\n",
-    "        target_vol_val   = target_vol_widget.value\n",
-    "        monthly_cost_val = monthly_cost_widget.value\n",
-    "        mode_val         = selection_mode_widget.value\n",
-    "        rnd_n_val        = random_sample_size_widget.value\n",
-    "\n",
-    "        # 2) Print parameter summary\n",
-    "        print(\"Running analysis with parameters:\")\n",
-    "        print(f\"  In-Sample:  {in_start_val} → {in_end_val}\")\n",
-    "        print(f\"  Out-Sample: {out_start_val} → {out_end_val}\")\n",
-    "        print(f\"  Target Volatility: {target_vol_val}\")\n",
-    "        print(f\"  Monthly Cost: {monthly_cost_val}\")\n",
-    "        print(f\"  Selection Mode: {mode_val}\")\n",
-    "        if mode_val == 'random':\n",
-    "            print(f\"  Random Sample Size: {rnd_n_val}\")\n",
-    "\n",
-    "        # 3) Capture everything printed by run_analysis (and select_funds)\n",
-    "        with capture_output() as cap:\n",
-    "            try:\n",
-    "                results = run_analysis(\n",
-    "                    df,\n",
-    "                    in_start=in_start_val,\n",
-    "                    in_end=in_end_val,\n",
-    "                    out_start=out_start_val,\n",
-    "                    out_end=out_end_val,\n",
-    "                    target_vol=target_vol_val,\n",
-    "                    monthly_cost=monthly_cost_val,\n",
-    "                    selection_mode=mode_val,\n",
-    "                    random_n=rnd_n_val\n",
-    "                )\n",
-    "            except Exception as e:\n",
-    "                print(\"Error inside run_analysis():\", e)\n",
-    "                return\n",
-    "\n",
-    "        # 4) Print the captured debug/info text\n",
-    "        print(cap.stdout)\n",
-    "\n",
-    "        # 5) If no funds survived, warn\n",
-    "        if results is None or ('selected_funds' in results and not results['selected_funds']):\n",
-    "            print(\"No valid funds remain after filtering. Check your date range or data.\")\n",
-    "            return\n",
-    "\n",
-    "        # 6) Summary\n",
-    "        print(\"Analysis complete. Summary:\")\n",
-    "        sf = results['selected_funds']\n",
-    "        if 'selected_funds' in results:\n",
-    "            print(f\"  Funds selected: {len(results['selected_funds'])}\")\n",
-    "        if 'in_ew_stats' in results:\n",
-    "            ir, iv, isr, _, _ = results['in_ew_stats']\n",
-    "            print(f\"  In-Sample EW → Return: {ir*100:.2f}%, Vol: {iv*100:.2f}%, Sharpe: {isr:.2f}\")\n",
-    "        if 'out_ew_stats' in results:\n",
-    "            or_, ov, osr, _, _ = results['out_ew_stats']\n",
-    "            print(f\"  Out-Sample EW → Return: {or_*100:.2f}%, Vol: {ov*100:.2f}%, Sharpe: {osr:.2f}\")\n",
-    "        print(f\"  Funds selected: {len(sf)} → {sf}\")\n",
-    "        \n",
-    "        export_to_excel(results, \"InteractiveOutput.xlsx\")\n",
-    "\n",
-    "\n",
-    "\n",
-    "# Wire the button once (after all definitions are loaded)\n",
-    "\n",
-    "print(\"Run Analysis callback is now wired.\")"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "67d5b060-852c-4755-aa9b-7b3f0919f5e8",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "    for fund in selected_funds:\n",
-    "        sf = scale_factors[fund]\n",
-    "        # In-sample\n",
-    "        adj_in = in_sample_df[fund] * sf - monthly_cost\n",
-    "        adj_in[adj_in < -1.0] = -1.0\n",
-    "        in_sample_scaled[fund] = adj_in\n",
-    "        \n",
-    "        # Out-of-sample\n",
-    "        if out_sample_df.shape[0] > 0:\n",
-    "            adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_out[adj_out < -1.0] = -1.0\n",
-    "            out_sample_scaled[fund] = adj_out\n",
-    "    \n",
-    "    # Helper function for stats\n",
-    "    def compute_stats(series, rf_series):\n",
-    "        r = annualize_return(series)\n",
-    "        v = annualize_volatility(series)\n",
-    "        sr = sharpe_ratio(series, rf_series)\n",
-    "        so = sortino_ratio(series, rf_series)\n",
-    "        mdd = max_drawdown(series)\n",
-    "        return (r, v, sr, so, mdd)\n",
-    "    \n",
-    "    in_sample_stats = {}\n",
-    "    for fund in selected_funds:\n",
-    "        in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "    \n",
-    "    out_sample_stats = {}\n",
-    "    for fund in selected_funds:\n",
-    "        out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "    \n",
-    "    out_sample_stats_raw = {}\n",
-    "    for fund in selected_funds:\n",
-    "        out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "    \n",
-    "    # Portfolio (equal-weight)\n",
-    "    ew_w = np.array([1.0/len(selected_funds)]*len(selected_funds))\n",
-    "    in_ew_port = calc_portfolio_returns(ew_w, in_sample_scaled[selected_funds])\n",
-    "    out_ew_port = calc_portfolio_returns(ew_w, out_sample_scaled[selected_funds])\n",
-    "    out_ew_port_raw = calc_portfolio_returns(ew_w, out_sample_df[selected_funds])\n",
-    "    \n",
-    "    in_ew_stats = compute_stats(in_ew_port, in_sample_rf)\n",
-    "    out_ew_stats = compute_stats(out_ew_port, out_sample_rf)\n",
-    "    out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "    \n",
-    "    # Portfolio (user-weighted) - placeholder\n",
-    "    user_weight_dict = {f: 1.0/len(selected_funds) for f in selected_funds}\n",
-    "    custom_w = np.array([user_weight_dict[f] for f in selected_funds])\n",
-    "    in_user_port = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "    out_user_port = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "    out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "    \n",
-    "    in_user_stats = compute_stats(in_user_port, in_sample_rf)\n",
-    "    out_user_stats = compute_stats(out_user_port, out_sample_rf)\n",
-    "    out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "    \n",
-    "    results = {\n",
-    "        'selected_funds': selected_funds,\n",
-    "        'in_sample_scaled': in_sample_scaled,\n",
-    "        'out_sample_scaled': out_sample_scaled,\n",
-    "        'in_sample_stats': in_sample_stats,\n",
-    "        'out_sample_stats': out_sample_stats,\n",
-    "        'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "        'in_ew_stats': in_ew_stats,\n",
-    "        'out_ew_stats': out_ew_stats,\n",
-    "        'out_ew_stats_raw': out_ew_stats_raw,\n",
-    "        'in_user_stats': in_user_stats,\n",
-    "        'out_user_stats': out_user_stats,\n",
-    "        'out_user_stats_raw': out_user_stats_raw"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 1. SETUP CELL ============\n",
-    "\n",
-    "import logging\n",
-    "import sys\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import os\n",
-    "import math\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import interact, interactive, VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import datetime\n",
-    "import random\n",
-    "import warnings\n",
-    "\n",
-    "# If you need to install these packages on your environment, uncomment:\n",
-    "!{sys.executable} -m pip install --quiet ipywidgets openpyxl xlsxwriter\n",
-    "\n",
-    "# For exporting to Excel with styling\n",
-    "import xlsxwriter\n",
-    "\n",
-    "# Set up logging to console\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "logging.info(\"Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\")\n",
-    "\n",
-    "# (Optional) If widgets aren't enabled, run:\n",
-    "# !jupyter nbextension enable --py widgetsnbextension --sys-prefix\n",
-    "\n",
-    "print(\"Setup complete.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "d7b324bc9ef84efb9c2a9af6361744d1",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<b>Step 1: Choose your CSV</b><br><i>Remember:</i> If you included any index column…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify which column (after 'Date') is the risk-free rate by smallest stdev among columns.\n",
-    "    \"\"\"\n",
-    "    numeric_cols = df.columns[1:]  # skip the Date column\n",
-    "    stdevs = {}\n",
-    "    for col in numeric_cols:\n",
-    "        vals = df[col].dropna()\n",
-    "        if len(vals) > 0:\n",
-    "            stdevs[col] = vals.std()\n",
-    "        else:\n",
-    "            stdevs[col] = np.inf\n",
-    "\n",
-    "    rf_col = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "    return rf_col\n",
-    "\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 1) Helper to read a local CSV robustly (handles BOMs and minor parsing issues)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Try loading `path` as CSV in three ways:\n",
-    "    1. Default C engine\n",
-    "    2. BOM-stripped with the Python engine\n",
-    "    3. Skip bad lines with the Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception as e1:\n",
-    "        print(\"Default read_csv failed:\", e1)\n",
-    "\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception as e2:\n",
-    "        print(\"utf-8-sig + python engine failed:\", e2)\n",
-    "\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",    # for pandas ≥ 1.3\n",
-    "    )\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 2) Build the widgets\n",
-    "# ------------------------------------------------------------------------------\n",
-    "source_info = widgets.HTML(\n",
-    "    \"<b>Step 1: Choose your CSV</b><br>\"\n",
-    "    \"<i>Remember:</i> If you included any index columns (e.g. S&P 500, MSCI World, SG Trend), they \"\n",
-    "    \"must appear to the right of all fund columns in your sheet.\"\n",
-    ")\n",
-    "\n",
-    "\n",
-    "source_dropdown = widgets.Dropdown(\n",
-    "    options=['Local', 'GitHub'],\n",
-    "    value='Local',\n",
-    "    description='Data Source:',\n",
-    "    style={'description_width': '120px'}\n",
-    ")\n",
-    "\n",
-    "# FileChooser for Local mode\n",
-    "fc = FileChooser(os.getcwd())\n",
-    "fc.title = \"<b>Select local CSV file</b>\"\n",
-    "\n",
-    "# Text box for GitHub raw URL\n",
-    "github_text = widgets.Text(\n",
-    "    value=(\n",
-    "        \"https://raw.githubusercontent.com/stranske/Trend_Model_Project/\"\n",
-    "        \"main/data/TrendData.csv\"\n",
-    "    ),\n",
-    "    description=\"GitHub URL:\",\n",
-    "    layout=widgets.Layout(width=\"80%\"),\n",
-    ")\n",
-    "\n",
-    "# Ask how many index columns are on the far right\n",
-    "n_indices_widget = widgets.BoundedIntText(\n",
-    "    value=0,\n",
-    "    min=0,\n",
-    "    max=10,  # adjust if you expect more than 10 indices\n",
-    "    description='# Index cols:',\n",
-    "    style={'description_width': '120px'},\n",
-    "    tooltip=\"Enter the number of index columns at the far right of your CSV\"\n",
-    ")\n",
-    "\n",
-    "# Load button\n",
-    "load_button = widgets.Button(description=\"Load Data\", button_style=\"success\")\n",
-    "\n",
-    "# Output area for status and debug prints\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 3) Show/hide widgets depending on source selection\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_source_change(change):\n",
-    "    if change[\"new\"] == \"Local\":\n",
-    "        fc.layout.display = \"block\"\n",
-    "        github_text.layout.display = \"none\"\n",
-    "    else:\n",
-    "        fc.layout.display = \"none\"\n",
-    "        github_text.layout.display = \"block\"\n",
-    "\n",
-    "# Initially, GitHub textbox is hidden; FileChooser is visible\n",
-    "github_text.layout.display = \"none\"\n",
-    "fc.layout.display = \"block\"\n",
-    "\n",
-    "source_dropdown.observe(on_source_change, names=\"value\")\n",
-    "\n",
-    "ui_load = widgets.VBox([\n",
-    "    source_info,\n",
-    "    source_dropdown,\n",
-    "    fc,\n",
-    "    github_text,\n",
-    "    n_indices_widget,   # ← new widget here\n",
-    "    load_button,\n",
-    "    output_area\n",
-    "])\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 4) Callback for the Load button (auto-detect date format)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_load_clicked(_):\n",
-    "    global df, fund_cols, indices_list, rf_col            # declare df as global\n",
-    "    with output_area:\n",
-    "        output_area.clear_output()\n",
-    "        src_choice = source_dropdown.value\n",
-    "        n_indices = int(n_indices_widget.value)\n",
-    "\n",
-    "        # 4a) Load the DataFrame\n",
-    "        try:\n",
-    "            if src_choice == 'Local':\n",
-    "                local_path = fc.selected  # FileChooser’s selected path\n",
-    "                if not local_path or not os.path.exists(local_path):\n",
-    "                    print(f\"Error: Local file not found:\\n  {local_path}\")\n",
-    "                    return\n",
-    "                print(f\"Loading from local file:\\n  {local_path}\")\n",
-    "                df = pd.read_csv(local_path)\n",
-    "            else:\n",
-    "                github_url = github_text.value.strip()\n",
-    "                if not github_url:\n",
-    "                    print(\"Error: Please enter a valid GitHub raw URL.\")\n",
-    "                    return\n",
-    "                print(f\"Loading from GitHub URL:\\n  {github_url}\")\n",
-    "                df = pd.read_csv(github_url)\n",
-    "        except Exception as e:\n",
-    "            print(\"Failed to load CSV:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4b) Debug: print columns & a few rows\n",
-    "        print(\"Columns found in DataFrame:\", df.columns.tolist())\n",
-    "        display(df.head(3))\n",
-    "\n",
-    "        # 4c) Identify which column is the date\n",
-    "        date_col = None\n",
-    "        for candidate in [\"Date\", \"DATE\", \"date\"]:\n",
-    "            if candidate in df.columns:\n",
-    "                date_col = candidate\n",
-    "                break\n",
-    "\n",
-    "        if date_col is None:\n",
-    "            print(\"Error: No column named 'Date' / 'DATE' / 'date' found.\")\n",
-    "            print(\"Please check the column names above and adjust code accordingly.\")\n",
-    "            return\n",
-    "\n",
-    "        date_col = 'Date'\n",
-    "\n",
-    "        # 1) Show the first few raw date strings (un‐parsed) so we can inspect them\n",
-    "        raw_samples = df[date_col].dropna().astype(str).head(10).tolist()\n",
-    "        print(f\"Raw {date_col} samples (first 10 non‐null): {raw_samples!r}\")\n",
-    "\n",
-    "        # 2) Strip leading/trailing whitespace from every entry\n",
-    "        df[date_col] = df[date_col].astype(str).str.strip()\n",
-    "\n",
-    "        # 3) Now attempt strict \"%m/%d/%Y\" parsing\n",
-    "        parsed = pd.to_datetime(df[date_col], format=\"%m/%d/%Y\", errors=\"coerce\", infer_datetime_format=True)\n",
-    "        num_valid = parsed.notna().sum()\n",
-    "        print(f\"Number of rows matching '%m/%d/%Y' exactly: {num_valid} / {len(df)}\")\n",
-    "\n",
-    "        if num_valid > 0:\n",
-    "            df[date_col] = parsed\n",
-    "            print(f\"Parsing with '%m/%d/%Y' succeeded for {num_valid} rows.\")\n",
-    "        else:\n",
-    "            print(\n",
-    "                \"Warning: No rows matched '%m/%d/%Y'. \"\n",
-    "                \"Falling back to generic pd.to_datetime(...).\"\n",
-    "            )\n",
-    "            df[date_col] = pd.to_datetime(df[date_col], errors=\"coerce\")\n",
-    "\n",
-    "        # 5) Drop any rows where parsing still failed\n",
-    "        before_drop = len(df)\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        dropped = before_drop - len(df)\n",
-    "        if dropped:\n",
-    "            print(f\"Dropped {dropped} rows where '{date_col}' could not be parsed.\")\n",
-    "        \n",
-    "        # 6) Sort and reset index\n",
-    "        df.sort_values(by=date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "        \n",
-    "        # 7) Show the final parsed dates\n",
-    "        print(f\"After parsing, first 3 {date_col} values:\")\n",
-    "        print(df[[date_col]].head(3))\n",
-    "        print(f\"Loaded {len(df)} rows successfully.\")\n",
-    "\n",
-    "\n",
-    "        # 4d) Identify risk-free column\n",
-    "        try:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            print(f\"Identified risk-free column as: '{rf_col}'\")\n",
-    "        except Exception as e:\n",
-    "            print(\"Error identifying risk-free column:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4f) Determine fund_cols vs indices_list based on n_indices\n",
-    "        all_cols = df.columns.tolist()\n",
-    "        # We assume “Date” and rf_col are present. Everything else is a candidate.\n",
-    "        if 'Date' not in all_cols or rf_col not in all_cols:\n",
-    "            print(\"Error: 'Date' or risk-free column not found in DataFrame columns.\")\n",
-    "            return\n",
-    "        \n",
-    "        # Build list of all columns except 'Date' and rf_col\n",
-    "        remaining = [c for c in all_cols if c not in ['Date', rf_col]]\n",
-    "        \n",
-    "        if n_indices > len(remaining):\n",
-    "            print(\n",
-    "                f\"Error: You asked for {n_indices} index columns, but only \"\n",
-    "                f\"{len(remaining)} columns remain after 'Date' and '{rf_col}'.\"\n",
-    "            )\n",
-    "            return\n",
-    "\n",
-    "        if n_indices > 0:\n",
-    "            indices_list = remaining[-n_indices:]\n",
-    "            fund_cols    = remaining[:-n_indices]\n",
-    "        else:\n",
-    "            indices_list = []\n",
-    "            fund_cols    = remaining[:]\n",
-    "        print(\"\\n>> Debug (post‐load): fund_cols =\", fund_cols)\n",
-    "        print(\">> Debug (post‐load): indices_list =\", indices_list, \"\\n\")\n",
-    "        \n",
-    "        # 2F) Print out what we found\n",
-    "        print(f\"Detected fund columns ({len(fund_cols)}): {fund_cols}\")\n",
-    "        print(f\"Detected index columns ({len(indices_list)}): {indices_list}\")\n",
-    "        print(\n",
-    "            \"Data loaded and classified successfully.\\n\"\n",
-    "            \"Proceed to Step 2 (Run Analysis).\"\n",
-    "        )\n",
-    "\n",
-    " \n",
-    "        # 8) Confirm that df is now in global scope\n",
-    "        print(\">> df defined with\", len(df), \"rows and columns:\", df.columns.tolist())\n",
-    "\n",
-    "\n",
-    "# 5) Wire up and display the UI\n",
-    "load_button.on_click(on_load_clicked)\n",
-    "\n",
-    "\n",
-    "display(ui_load)\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "982ef5a9-d579-4289-bb9c-59e1378e15d6",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "(1) Funds with absolutely no NaNs over both windows (count = 27):\n",
-      "['Quantum Capital', 'Quantum Group', 'Echo Strategies', 'Echo Group', 'Meridian Strategies', 'Axiom LP', 'Crescent Partners', 'Forge Advisors', 'Sentinel Global', 'Axiom Advisors', 'Vista Holdings', 'Sentinel Advisors', 'Crescent Group', 'Adaptive Holdings', 'Vista Capital', 'Forge Investments', 'Ascent Global', 'Vista Global', 'Forge Group', 'Axiom Holdings', 'Adaptive Global', 'Ascent Advisors', 'Quantum Advisors', 'Ascent Group', 'Quantum Holdings', 'Sentinel LP', 'Adaptive LP']\n",
-      "\n",
-      "None of the post‐full‐history funds has a run of ≥ 3 NaNs in either window.\n"
-     ]
-    }
-   ],
-   "source": [
-    "import pandas as pd\n",
-    "import numpy as np\n",
-    "\n",
-    "# ────────────── 1) Re‐compute in_sdate, in_edate, out_sdate, out_edate ──────────────\n",
-    "in_sdate  = pd.to_datetime(\"2005-07-01\", errors=\"coerce\")\n",
-    "in_edate  = pd.to_datetime(\"2008-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "out_sdate = pd.to_datetime(\"2008-07-01\", errors=\"coerce\")\n",
-    "out_edate = pd.to_datetime(\"2009-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "# ────────────── 2) Build the full‐history list (no NaNs anywhere in each window) ──────────────\n",
-    "#    We assume that 'rf_col' is already defined and holds the risk‐free column name.\n",
-    "#    We also assume that any index columns are in a list called 'indices_list'.\n",
-    "all_candidates = [\n",
-    "    c for c in df.columns \n",
-    "    if c not in [\"Date\", rf_col] + indices_list\n",
-    "]\n",
-    "\n",
-    "# (A) Select only those f where in‐sample AND out‐sample both have no NaNs anywhere:\n",
-    "post_full_history_funds = []\n",
-    "for f in all_candidates:\n",
-    "    in_sub  = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "    out_sub = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "    if in_sub.notna().all() and out_sub.notna().all():\n",
-    "        post_full_history_funds.append(f)\n",
-    "\n",
-    "print(f\"(1) Funds with absolutely no NaNs over both windows (count = {len(post_full_history_funds)}):\")\n",
-    "print(post_full_history_funds)\n",
-    "\n",
-    "\n",
-    "# ────────────── 3) Now run the “3+ consecutive NaNs” check only on that list ──────────────\n",
-    "flagged_exact = []  # will hold (fund_name, window_name, max_consecutive_nans)\n",
-    "for f in post_full_history_funds:\n",
-    "    # In‐sample gap‐runs\n",
-    "    sub_in   = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "    isnan_in = sub_in.isna().astype(int)\n",
-    "    run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "    max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "    if max_run_in >= 3:\n",
-    "        flagged_exact.append((f, \"in-sample\", int(max_run_in)))\n",
-    "\n",
-    "    # Out‐sample gap‐runs\n",
-    "    sub_out   = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "    isnan_out = sub_out.isna().astype(int)\n",
-    "    run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "    max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "    if max_run_out >= 3:\n",
-    "        flagged_exact.append((f, \"out-sample\", int(max_run_out)))\n",
-    "\n",
-    "\n",
-    "# ────────────── 4) Report results ──────────────\n",
-    "if flagged_exact:\n",
-    "    print(\"\\nFunds that actually *do* have 3+ consecutive NaNs inside one of the windows:\")\n",
-    "    for (fund_name, window_name, length) in flagged_exact:\n",
-    "        print(f\"  • {fund_name!r} → {length} consecutive NaNs in {window_name}\")\n",
-    "else:\n",
-    "    print(\"\\nNone of the post‐full‐history funds has a run of ≥ 3 NaNs in either window.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "767e697c-eeb3-4e0f-b29e-43597a05e177",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "import pandas as pd\n",
-    "\n",
-    "# ─────────── Define your date boundaries ───────────\n",
-    "in_sdate  = pd.to_datetime(\"2005-07-01\", errors=\"coerce\")\n",
-    "in_edate  = pd.to_datetime(\"2008-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "out_sdate = pd.to_datetime(\"2008-07-01\", errors=\"coerce\")\n",
-    "out_edate = pd.to_datetime(\"2009-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "# (Also ensure 'df' and 'fund_cols' are already defined above this cell.)\n",
-    "\n",
-    "flagged = []  # will hold (fund_name, window_name, max_consecutive_nans) tuples\n",
-    "\n",
-    "for f in fund_cols:\n",
-    "    # ─── In‐sample window check ───\n",
-    "    sub_in = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "    isnan_in = sub_in.isna().astype(int)                         # 1 where NaN, 0 otherwise\n",
-    "    # group by cumulative “not-NaN” runs to measure each NaN‐block length\n",
-    "    run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "    max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "    if max_run_in >= 3:\n",
-    "        flagged.append((f, 'in-sample', int(max_run_in)))\n",
-    "    \n",
-    "    # ─── Out‐sample window check ───\n",
-    "    sub_out = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "    isnan_out = sub_out.isna().astype(int)\n",
-    "    run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "    max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "    if max_run_out >= 3:\n",
-    "        flagged.append((f, 'out-sample', int(max_run_out)))\n",
-    "\n",
-    "# Finally, print any funds with ≥ 3 consecutive NaNs\n",
-    "if flagged:\n",
-    "    print(\"Funds with a 3+ consecutive‐NaN run inside one of the windows:\")\n",
-    "    for (fund_name, window_name, length) in flagged:\n",
-    "        print(f\"  • {fund_name!r} has {length} consecutive NaNs in the {window_name} window\")\n",
-    "else:\n",
-    "    print(\"All funds have at most 2 consecutive NaNs in both in‐sample and out‐sample windows.\")"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 7,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Utility functions loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Check if a series (sorted chronologically) has >= threshold consecutive NaNs.\n",
-    "    Return True if such a gap exists, False otherwise.\n",
-    "    \"\"\"\n",
-    "    consecutive = 0\n",
-    "    for val in series:\n",
-    "        if pd.isna(val):\n",
-    "            consecutive += 1\n",
-    "        else:\n",
-    "            consecutive = 0\n",
-    "        if consecutive >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series, max_short_gap=2):\n",
-    "    \"\"\"\n",
-    "    Replace missing values (NaN) with 0 if they appear in runs of <= max_short_gap.\n",
-    "    Longer runs remain NaN.\n",
-    "    \"\"\"\n",
-    "    filled = series.copy()\n",
-    "    n = len(series)\n",
-    "    i = 0\n",
-    "    while i < n:\n",
-    "        if pd.isna(filled[i]):\n",
-    "            run_start = i\n",
-    "            while i < n and pd.isna(filled[i]):\n",
-    "                i += 1\n",
-    "            run_end = i  # first non-NaN after run\n",
-    "            gap_length = run_end - run_start\n",
-    "            if gap_length <= max_short_gap:\n",
-    "                filled[run_start:run_end] = 0.0\n",
-    "        else:\n",
-    "            i += 1\n",
-    "    return filled\n",
-    "\n",
-    "\n",
-    "def annualize_return(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized (geometric) return from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    growth_factor = (1 + valid_rets).prod()\n",
-    "    n_months = len(valid_rets)\n",
-    "    if growth_factor <= 0:\n",
-    "        return -1.0\n",
-    "    ann_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    return ann_ret\n",
-    "\n",
-    "def annualize_volatility(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized stdev of monthly returns, i.e. stdev * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) < 2:\n",
-    "        return np.nan\n",
-    "    return valid_rets.std() * np.sqrt(12)\n",
-    "\n",
-    "def sharpe_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe ratio = (annual_excess_return) / (annual_excess_vol).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    ann_excess_vol = excess.std() * np.sqrt(12)\n",
-    "    if ann_excess_vol == 0:\n",
-    "        return np.nan\n",
-    "    return ann_excess_ret / ann_excess_vol\n",
-    "\n",
-    "def sortino_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino ratio = (annual_excess_return) / (annual_downside_stdev).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "\n",
-    "    negative_mask = excess < 0\n",
-    "    negative_returns = excess[negative_mask]\n",
-    "    if len(negative_returns) == 0:\n",
-    "        return np.inf  # no negative => infinite sortino\n",
-    "    downside_stdev = negative_returns.std() * np.sqrt(12)\n",
-    "    return ann_excess_ret / downside_stdev\n",
-    "\n",
-    "def max_drawdown(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Compute max drawdown from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    wealth_index = (1 + valid_rets).cumprod()\n",
-    "    rolling_max = wealth_index.cummax()\n",
-    "    dd_series = 1 - (wealth_index / rolling_max)\n",
-    "    return dd_series.max()\n",
-    "\n",
-    "def calc_portfolio_returns(weights, df_returns):\n",
-    "    \"\"\"\n",
-    "    Compute monthly portfolio returns (Series) as weighted sum of columns in df_returns.\n",
-    "    \"\"\"\n",
-    "    return (df_returns * weights).sum(axis=1)\n",
-    "\n",
-    "print(\"Utility functions loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "4f1619c9",
-   "metadata": {},
-   "source": [
-    "## 4. Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "## 5. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 8,
-   "id": "ffad994f",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─────────────── Widget Setup + Callback ───────────────\n",
-    "\n",
-    "# (A) Build widgets\n",
-    "in_sample_start = widgets.Text(value='2003-01', description='In-Sample Start:')\n",
-    "in_sample_end   = widgets.Text(value='2005-12', description='In-Sample End:')\n",
-    "out_sample_start= widgets.Text(value='2006-01', description='Out-Sample Start:')\n",
-    "out_sample_end  = widgets.Text(value='2010-12', description='Out-Sample End:')\n",
-    "\n",
-    "target_vol_widget   = widgets.FloatText(value=0.10,  description='Target Vol:')\n",
-    "monthly_cost_widget = widgets.FloatText(value=0.002, description='Monthly Cost:')\n",
-    "\n",
-    "selection_mode_widget = widgets.Dropdown(\n",
-    "    options=[('All Funds','all'), ('Random Sample','random'), ('Manual','manual')],\n",
-    "    value='all',\n",
-    "    description='Mode:'\n",
-    ")\n",
-    "random_sample_size_widget = widgets.IntText(value=5, description='Sample Size:')\n",
-    "\n",
-    "apply_button = widgets.Button(description='Run Analysis', button_style='success')\n",
-    "\n",
-    "ui_inputs = widgets.VBox([\n",
-    "    in_sample_start, in_sample_end,\n",
-    "    out_sample_start, out_sample_end,\n",
-    "    target_vol_widget, monthly_cost_widget,\n",
-    "    selection_mode_widget, random_sample_size_widget,\n",
-    "    apply_button\n",
-    "])\n",
-    "\n",
-    "output_area = widgets.Output()\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "8107d43e-d54e-4a9f-83c6-d6ffcc0a3c23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "\n",
-    "        # 6) Show a brief summary\n",
-    "        print(\"Analysis complete. Summary:\")\n",
-    "        sf = results['selected_funds']\n",
-    "        print(f\"  Funds selected: {len(sf)} → {sf}\")\n",
-    "        if 'selected_funds' in results:\n",
-    "            print(f\"  Funds selected: {len(results['selected_funds'])}\")\n",
-    "        if 'in_ew_stats' in results:\n",
-    "            ir, iv, isr, _, _ = results['in_ew_stats']\n",
-    "            print(f\"  In-Sample EW → Return: {ir*100:.2f}%, Vol: {iv*100:.2f}%, Sharpe: {isr:.2f}\")\n",
-    "        if 'out_ew_stats' in results:\n",
-    "            or_, ov, osr, _, _ = results['out_ew_stats']\n",
-    "            print(f\"  Out-Sample EW → Return: {or_*100:.2f}%, Vol: {ov*100:.2f}%, Sharpe: {osr:.2f}\")\n",
-    "        \n",
-    "\n",
-    "print(\"Widgets defined. Use 'display(ui_inputs)' in a cell to show them after other functions run\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 6. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 9,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "get_custom_weights function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    Returns dict {fund: weight_decimal}.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=f\"{fund}\",\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    \n",
-    "    confirm_button = widgets.Button(\n",
-    "        description='Confirm Weights',\n",
-    "        button_style='success'\n",
-    "    )\n",
-    "    error_label = widgets.Label(value='', layout=widgets.Layout(color='red'))\n",
-    "    \n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm_button, error_label])\n",
-    "    display(box)\n",
-    "    \n",
-    "    weights_container = {}\n",
-    "    \n",
-    "    def on_confirm_clicked(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_label.value = f\"Error: Weights sum to {total}, must be 100.\"\n",
-    "            weights_container.clear()\n",
-    "        else:\n",
-    "            for fund, wdg in weight_widgets.items():\n",
-    "                weights_container[fund] = wdg.value / 100.0\n",
-    "            error_label.value = \"Weights confirmed!\"\n",
-    "    \n",
-    "    confirm_button.on_click(on_confirm_clicked)\n",
-    "    return weights_container\n",
-    "\n",
-    "print(\"get_custom_weights function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 7. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 8. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 10,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "export_to_excel function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def export_to_excel(results_dict, output_filename=\"AnalysisOutput.xlsx\"):\n",
-    "    \"\"\"\n",
-    "    Create an Excel file with two tabs: In-Sample, Out-of-Sample.\n",
-    "    Each has two tables: (1) Equal-Weight, (2) User-Weighted.\n",
-    "    Columns for Return(%), Vol(%), Sharpe, Sortino, MaxDD(%).\n",
-    "    For OOS, also show 'before scaling' vs. 'after scaling' returns/vol.\n",
-    "    \"\"\"\n",
-    "    selected_funds = results_dict['selected_funds']\n",
-    "    in_sample_stats = results_dict['in_sample_stats']\n",
-    "    out_sample_stats_scaled = results_dict['out_sample_stats']\n",
-    "    out_sample_stats_raw = results_dict['out_sample_stats_raw']\n",
-    "\n",
-    "    in_ew_stats = results_dict['in_ew_stats']\n",
-    "    out_ew_stats_scaled = results_dict['out_ew_stats']\n",
-    "    out_ew_stats_raw = results_dict['out_ew_stats_raw']\n",
-    "\n",
-    "    in_user_stats = results_dict['in_user_stats']\n",
-    "    out_user_stats_scaled = results_dict['out_user_stats']\n",
-    "    out_user_stats_raw = results_dict['out_user_stats_raw']\n",
-    "\n",
-    "    # --- In-Sample DataFrames ---\n",
-    "    in_eq_data = []\n",
-    "    in_user_data = []\n",
-    "    for fund in selected_funds:\n",
-    "        r, v, s, so, mdd = in_sample_stats[fund]\n",
-    "        in_eq_data.append([fund, r, v, s, so, mdd])\n",
-    "        in_user_data.append([fund, r, v, s, so, mdd])\n",
-    "\n",
-    "    in_eq_data.append([\n",
-    "        'Equal-Weight Portfolio',\n",
-    "        in_ew_stats[0],\n",
-    "        in_ew_stats[1],\n",
-    "        in_ew_stats[2],\n",
-    "        in_ew_stats[3],\n",
-    "        in_ew_stats[4]\n",
-    "    ])\n",
-    "    in_user_data.append([\n",
-    "        'User-Weighted Portfolio',\n",
-    "        in_user_stats[0],\n",
-    "        in_user_stats[1],\n",
-    "        in_user_stats[2],\n",
-    "        in_user_stats[3],\n",
-    "        in_user_stats[4]\n",
-    "    ])\n",
-    "\n",
-    "    in_eq_df = pd.DataFrame(\n",
-    "        in_eq_data,\n",
-    "        columns=['Fund', 'Return (%)', 'Volatility (%)', 'Sharpe', 'Sortino', 'MaxDD (%)']\n",
-    "    )\n",
-    "    in_user_df = pd.DataFrame(\n",
-    "        in_user_data,\n",
-    "        columns=['Fund', 'Return (%)', 'Volatility (%)', 'Sharpe', 'Sortino', 'MaxDD (%)']\n",
-    "    )\n",
-    "\n",
-    "    # --- Out-of-Sample DataFrames ---\n",
-    "    # columns: [Fund, RetBefore(%), VolBefore(%), RetAfter(%), VolAfter(%), Sharpe(After), Sortino(After), MaxDD(After)(%)]\n",
-    "    out_eq_data = []\n",
-    "    out_user_data = []\n",
-    "\n",
-    "    for fund in selected_funds:\n",
-    "        r_raw, v_raw, _, _, _ = out_sample_stats_raw[fund]\n",
-    "        r_scaled, v_scaled, s_scaled, so_scaled, mdd_scaled = out_sample_stats_scaled[fund]\n",
-    "        out_eq_data.append([\n",
-    "            fund,\n",
-    "            r_raw,\n",
-    "            v_raw,\n",
-    "            r_scaled,\n",
-    "            v_scaled,\n",
-    "            s_scaled,\n",
-    "            so_scaled,\n",
-    "            mdd_scaled\n",
-    "        ])\n",
-    "        out_user_data.append([\n",
-    "            fund,\n",
-    "            r_raw,\n",
-    "            v_raw,\n",
-    "            r_scaled,\n",
-    "            v_scaled,\n",
-    "            s_scaled,\n",
-    "            so_scaled,\n",
-    "            mdd_scaled\n",
-    "        ])\n",
-    "\n",
-    "    r_ew_raw, v_ew_raw, _, _, _ = out_ew_stats_raw\n",
-    "    r_ew_scaled, v_ew_scaled, s_ew_scaled, so_ew_scaled, mdd_ew_scaled = out_ew_stats_scaled\n",
-    "    out_eq_data.append([\n",
-    "        'Equal-Weight Portfolio',\n",
-    "        r_ew_raw,\n",
-    "        v_ew_raw,\n",
-    "        r_ew_scaled,\n",
-    "        v_ew_scaled,\n",
-    "        s_ew_scaled,\n",
-    "        so_ew_scaled,\n",
-    "        mdd_ew_scaled\n",
-    "    ])\n",
-    "\n",
-    "    r_user_raw, v_user_raw, _, _, _ = out_user_stats_raw\n",
-    "    r_user_scaled, v_user_scaled, s_user_scaled, so_user_scaled, mdd_user_scaled = out_user_stats_scaled\n",
-    "    out_user_data.append([\n",
-    "        'User-Weighted Portfolio',\n",
-    "        r_user_raw,\n",
-    "        v_user_raw,\n",
-    "        r_user_scaled,\n",
-    "        v_user_scaled,\n",
-    "        s_user_scaled,\n",
-    "        so_user_scaled,\n",
-    "        mdd_user_scaled\n",
-    "    ])\n",
-    "\n",
-    "    out_eq_df = pd.DataFrame(\n",
-    "        out_eq_data,\n",
-    "        columns=['Fund', 'RetBefore(%)', 'VolBefore(%)', 'RetAfter(%)', 'VolAfter(%)', 'Sharpe(After)', 'Sortino(After)', 'MaxDD(After)(%)']\n",
-    "    )\n",
-    "    out_user_df = pd.DataFrame(\n",
-    "        out_user_data,\n",
-    "        columns=['Fund', 'RetBefore(%)', 'VolBefore(%)', 'RetAfter(%)', 'VolAfter(%)', 'Sharpe(After)', 'Sortino(After)', 'MaxDD(After)(%)']\n",
-    "    )\n",
-    "\n",
-    "    writer = pd.ExcelWriter(output_filename, engine='xlsxwriter')\n",
-    "\n",
-    "    # In-Sample Sheet\n",
-    "    in_eq_df.to_excel(writer, sheet_name='In-Sample', startrow=0, index=False)\n",
-    "    in_user_df.to_excel(writer, sheet_name='In-Sample', startrow=len(in_eq_df)+3, index=False)\n",
-    "\n",
-    "    # Out-of-Sample Sheet\n",
-    "    out_eq_df.to_excel(writer, sheet_name='Out-of-Sample', startrow=0, index=False)\n",
-    "    out_user_df.to_excel(writer, sheet_name='Out-of-Sample', startrow=len(out_eq_df)+3, index=False)\n",
-    "\n",
-    "    workbook = writer.book\n",
-    "    pct_format = workbook.add_format({'num_format': '0.0%'})\n",
-    "    decimal_format = workbook.add_format({'num_format': '0.00'})  # for non-percent columns\n",
-    "    bold_format = workbook.add_format({'bold': True})\n",
-    "\n",
-    "    # Format In-Sample\n",
-    "    in_sample_ws = writer.sheets['In-Sample']\n",
-    "    in_sample_ws.set_column(0, 0, 28)  # Fund column\n",
-    "    in_sample_ws.set_column(1, 2, 8, pct_format)\n",
-    "    in_sample_ws.set_column(3, 4, 8, decimal_format)\n",
-    "    in_sample_ws.set_column(5, 5, 8, pct_format)\n",
-    "    \n",
-    "    # Bold headers\n",
-    "    for colx in range(in_eq_df.shape[1]):\n",
-    "        in_sample_ws.write(0, colx, in_eq_df.columns[colx], bold_format)\n",
-    "    for colx in range(in_user_df.shape[1]):\n",
-    "        in_sample_ws.write(len(in_eq_df)+3, colx, in_user_df.columns[colx], bold_format)\n",
-    "\n",
-    "    # Format Out-of-Sample\n",
-    "    out_sample_ws = writer.sheets['Out-of-Sample']\n",
-    "    out_sample_ws.set_column(0, 0, 28)\n",
-    "    out_sample_ws.set_column(1, 7, 15, pct_format)\n",
-    "    for colx in range(out_eq_df.shape[1]):\n",
-    "        out_sample_ws.write(0, colx, out_eq_df.columns[colx], bold_format)\n",
-    "    for colx in range(out_user_df.shape[1]):\n",
-    "        out_sample_ws.write(len(out_eq_df)+3, colx, out_user_df.columns[colx], bold_format)\n",
-    "\n",
-    "    writer.close()\n",
-    "    logging.info(f\"Exported analysis to {output_filename} successfully.\")\n",
-    "    print(f\"Excel file created: {output_filename}\")\n",
-    "\n",
-    "print(\"export_to_excel function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Demo Run\n",
-    "The `demo_run()` function creates a small dummy dataset, runs the analysis, and exports the results to an Excel file."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "d89721c8",
-   "metadata": {
-    "collapsed": false,
-    "jupyter": {
-     "outputs_hidden": false
-    }
-   },
-   "outputs": [],
-   "source": [
-    "def demo_run():\n",
-    "    \"\"\"\n",
-    "    Create a small dummy dataset, run analysis, export results.\n",
-    "    \"\"\"\n",
-    "    # Create monthly date range\n",
-    "    rng = pd.date_range(start='2003-01-01', end='2010-12-01', freq='MS')\n",
-    "    df_demo = pd.DataFrame({'Date': rng})\n",
-    "\n",
-    "    np.random.seed(42)\n",
-    "    rf_values = np.random.normal(loc=0.002, scale=0.0001, size=len(rng))\n",
-    "    df_demo['RF'] = rf_values\n",
-    "\n",
-    "    # Random funds with missing data\n",
-    "    for i in range(1, 6):\n",
-    "        fund_name = f\"Fund_{i}\"\n",
-    "        mean_r = 0.01 * i / 10.0\n",
-    "        stdev_r = 0.02 * (i / 5.0)\n",
-    "        rets = np.random.normal(loc=mean_r, scale=stdev_r, size=len(rng))\n",
-    "\n",
-    "        # Introduce random short or long gaps\n",
-    "        if i == 3:\n",
-    "            missing_idx = np.random.choice(len(rng), 2, replace=False)\n",
-    "            for idx in missing_idx:\n",
-    "                rets[idx] = np.nan\n",
-    "        if i == 4:\n",
-    "            rets[10:13] = np.nan  # 3 consecutive -> exclude\n",
-    "\n",
-    "        df_demo[fund_name] = rets\n",
-    "\n",
-    "    # Shuffle rows to test sorting\n",
-    "    df_demo = df_demo.sample(frac=1).reset_index(drop=True)\n",
-    "\n",
-    " \n",
-    "    results = run_analysis(\n",
-    "        df_demo,\n",
-    "        in_start='2003-01', in_end='2005-12',\n",
-    "        out_start='2006-01', out_end='2010-12',\n",
-    "        target_vol=0.10,\n",
-    "        monthly_cost=0.002,\n",
-    "        selection_mode='all',\n",
-    "        random_n=2\n",
-    "    )\n",
-    "\n",
-    "    \n",
-    "    \n",
-    "    if results is not None:\n",
-    "        export_to_excel(results, \"DemoAnalysisOutput.xlsx\")\n",
-    "        print(\"Demo run complete.\")\n",
-    "\n",
-    "print(\"demo_run function ready. Call 'demo_run()' to test.\")"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 11,
-   "id": "d7b7c730-225c-4c69-9dbf-d1ec9971a26f",
-   "metadata": {
-    "scrolled": true
-   },
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "72d65155741c4205a9fd8566d9388150",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(Text(value='2003-01', description='In-Sample Start:'), Text(value='2005-12', description='In-Sa…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "86311365b69b4b95b6a83fc3ac7cde41",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Output()"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# (C) Wire the button and display\n",
-    "apply_button.on_click(on_apply_clicked)\n",
-    "display(ui_inputs, output_area)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis1.2.TrEx-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis1.2.TrEx-checkpoint.ipynb
deleted file mode 100644
index 3636f9f539c36484eb4c6978edad1c708931e4a1..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis1.2.TrEx-checkpoint.ipynb
+++ /dev/null
@@ -1,1034 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "22994893-0193-45bc-b9e3-a97b328ecaea",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Imports, Data Loader and Rf Detector\n",
-    "2. Select fund (month period logic)\n",
-    "3. Weight prep\n",
-    "4. Core Stats + Run Analysis\n",
-    "5. Export\n",
-    "6. Widget /UI\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "#      VOL-ADJ TREND ANALYSIS  –  SINGLE-FILE VERSION\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  0 · IMPORTS  (all in one place)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "import pandas as pd\n",
-    "import numpy as np\n",
-    "from dataclasses import dataclass, field\n",
-    "from collections import namedtuple\n",
-    "import xlsxwriter\n",
-    "import logging\n",
-    "from io import BytesIO\n",
-    "import ipywidgets as widgets\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "from typing import List, Dict, Optional, Callable\n",
-    "\n",
-    "logging.getLogger().setLevel(logging.ERROR)\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  1 · Class Configurations\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "@dataclass\n",
-    "class FundSelectionConfig:\n",
-    "    max_missing_months:         int = 3\n",
-    "    max_consecutive_month_gap:  int = 6\n",
-    "    implausible_value_limit: float  = 1\n",
-    "    outlier_threshold: float = 0.5\n",
-    "    zero_return_threshold: float = 0.2\n",
-    "    enforce_monotonic_index: bool = True\n",
-    "    allow_duplicate_dates: bool = False\n",
-    "    max_missing_ratio: float      = 0.05\n",
-    "    max_drawdown: float           = 0.3\n",
-    "    min_volatility: float         = 0.05\n",
-    "    max_volatility: float         = 1.0\n",
-    "    min_avg_return: float         = 0.0\n",
-    "    max_skewness: float           = 3.0\n",
-    "    max_kurtosis: float           = 10.0\n",
-    "    expected_freq: str            = \"B\"\n",
-    "    max_gap_days: int             = 3\n",
-    "    min_aum_usd: float            = 1e7\n",
-    "\n",
-    "# Configuration dataclass\n",
-    "@dataclass\n",
-    "class RiskStatsConfig:\n",
-    "    metrics_to_run: List[str] = field(default_factory=lambda: [\n",
-    "        \"AnnualReturn\", \"Volatility\", \"Sharpe\", \"Sortino\", \"MaxDrawdown\"\n",
-    "    ])\n",
-    "    risk_free: float = 0.0\n",
-    "    periods_per_year: int = 12\n",
-    "\n",
-    "# 2. Registry and decorator\n",
-    "METRIC_REGISTRY: Dict[str, Callable[[pd.Series, float, int], float]] = {}\n",
-    "\n",
-    "def register_metric(name: str):\n",
-    "    \"\"\"\n",
-    "    Decorator to register a metric function under a given name.\n",
-    "    \"\"\"\n",
-    "    def decorator(fn: Callable[pd.Series, float]):\n",
-    "        METRIC_REGISTRY[name] = fn\n",
-    "        return fn\n",
-    "    return decorator\n",
-    "\n",
-    "FORMATTERS_EXCEL: dict[str, Callable] = {}\n",
-    "def register_formatter_excel(category: str):\n",
-    "    def decorator(fn: Callable):\n",
-    "        FORMATTERS_EXCEL[category] = fn\n",
-    "        return fn\n",
-    "    return decorator\n",
-    "\n",
-    "# Example formatters (extend as needed)\n",
-    "def safe(v):\n",
-    "    \"\"\"\n",
-    "    Return blank string for missing/non-finite values; else return the value.\n",
-    "    \"\"\"\n",
-    "    if v == \"\" or pd.isna(v):\n",
-    "        return \"\"\n",
-    "    if isinstance(v, (int, float, np.generic)):\n",
-    "        return v if np.isfinite(v) else \"\"\n",
-    "    return \"\"\n",
-    "\n",
-    "def pct(t: tuple[float, float, float, float, float]) -> list[float]:\n",
-    "    \"\"\"\n",
-    "    Convert a Stat tuple of five elements into a list of values scaled as percentages for\n",
-    "    the 1st, 2nd, and 5th elements.\n",
-    "    \"\"\"\n",
-    "    return [t[0]*100, t[1]*100, t[2], t[3], t[4]*100]\n",
-    "    if isinstance(v, (int, float, np.generic)):\n",
-    "        return v if np.isfinite(v) else \"\"\n",
-    "    return \"\"\n",
-    "\n",
-    "# Consolidated Summary Formatter Factory\n",
-    "\n",
-    "def make_summary_formatter(\n",
-    "    res: dict,\n",
-    "    in_start: str,\n",
-    "    in_end: str,\n",
-    "    out_start: str,\n",
-    "    out_end: str\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Registers a single 'summary' sheet formatter that writes:\n",
-    "      1. Portfolio rows (Equal & User weight),\n",
-    "      2. Blank spacer,\n",
-    "      3. Fund rows,\n",
-    "      4. Blank spacer,\n",
-    "      5. Index rows\n",
-    "    using the data in `res`.\n",
-    "    \"\"\"\n",
-    "    @register_formatter_excel(\"summary\")\n",
-    "    def fmt_summary(ws, wb):\n",
-    "        # Predefine formats\n",
-    "        bold = wb.add_format({\"bold\": True})\n",
-    "        int0 = wb.add_format({\"num_format\": \"0\"})\n",
-    "        num2 = wb.add_format({\"num_format\": \"0.00\"})\n",
-    "        red  = wb.add_format({\"num_format\": \"0.00\", \"font_color\": \"red\"})\n",
-    "        pct  = lambda t: [t[0]*100, t[1]*100, t[2], t[3], t[4]*100]\n",
-    "\n",
-    "        # Write static headers\n",
-    "        ws.write_row(0, 0, [\"Vol-Adj Trend Analysis\"], bold)\n",
-    "        ws.write_row(1, 0, [f\"In:  {in_start} → {in_end}\"], bold)\n",
-    "        ws.write_row(2, 0, [f\"Out: {out_start} → {out_end}\"], bold)\n",
-    "\n",
-    "        row = 5\n",
-    "        # 1. Portfolio rows\n",
-    "        for label, in_s, out_s in [\n",
-    "            (\"Equal Weight\", res[\"in_ew_stats\"], res[\"out_ew_stats\"]),\n",
-    "            (\"User Weight\",  res[\"in_user_stats\"], res[\"out_user_stats\"])\n",
-    "        ]:\n",
-    "            ws.write(row, 0, label, bold)\n",
-    "            ws.write(row, 1, safe(\"\") if True else int0)\n",
-    "            vals = pct(tuple(in_s)) + pct(tuple(out_s))\n",
-    "            fmts = ([num2]*4 + [red]) * 2\n",
-    "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-    "                ws.write(row, col, safe(v), fmt)\n",
-    "            row += 1\n",
-    "\n",
-    "        # spacer\n",
-    "        row += 1\n",
-    "\n",
-    "        # 2. Fund rows\n",
-    "        for fund, stat_in in res[\"in_sample_stats\"].items():\n",
-    "            stat_out = res[\"out_sample_stats\"][fund]\n",
-    "            ws.write(row, 0, fund, bold)\n",
-    "            wt = res[\"fund_weights\"][fund]\n",
-    "            ws.write(row, 1, safe(wt*100), int0)\n",
-    "            vals = pct(tuple(stat_in)) + pct(tuple(stat_out))\n",
-    "            fmts = ([num2]*4 + [red]) * 2\n",
-    "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-    "                ws.write(row, col, safe(v), fmt)\n",
-    "            row += 1\n",
-    "\n",
-    "        # spacer\n",
-    "        row += 1\n",
-    "\n",
-    "        # 3. Index rows\n",
-    "        for idx, pair in res.get(\"index_stats\", {}).items():\n",
-    "            in_idx = pair[\"in_sample\"]\n",
-    "            out_idx= pair[\"out_sample\"]\n",
-    "            ws.write(row, 0, idx, bold)\n",
-    "            ws.write(row, 1, safe(\"\") if True else int0)\n",
-    "            vals = pct(tuple(in_idx)) + pct(tuple(out_idx))\n",
-    "            fmts = ([num2]*4 + [red]) * 2\n",
-    "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-    "                ws.write(row, col, safe(v), fmt)\n",
-    "            row += 1\n",
-    "\n",
-    "    return fmt_summary\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  2 · CSV LOADER + RF DETECTOR\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "logger = logging.getLogger(__name__)\n",
-    "\n",
-    "def load_csv(path: str) -> pd.DataFrame | None:\n",
-    "    try:\n",
-    "        df = pd.read_csv(path)\n",
-    "    except FileNotFoundError as e:\n",
-    "        logger.error(f\"File not found: {path}\")\n",
-    "        return None\n",
-    "    except pd.errors.EmptyDataError:\n",
-    "        logger.error(f\"No data in file: {path}\")\n",
-    "        return None\n",
-    "    except pd.errors.ParserError as e:\n",
-    "        logger.error(f\"Parsing error in {path}: {e}\")\n",
-    "        return None\n",
-    "\n",
-    "    if \"Date\" not in df.columns:\n",
-    "        logger.error(f\"Validation failed ({path}): missing 'Date' column\")\n",
-    "        return None\n",
-    "\n",
-    "    # Optionally check for NaNs in 'Date' column\n",
-    "    if df[\"Date\"].isnull().any():\n",
-    "        logger.warning(f\"Null values found in 'Date' column of {path}\")\n",
-    "\n",
-    "    return df\n",
-    "\n",
-    "def identify_risk_free_fund(df: pd.DataFrame) -> str:\n",
-    "    returns = df.drop(columns=\"Date\", errors=\"ignore\")\n",
-    "    stdevs  = returns.std(skipna=True, ddof=0)\n",
-    "    return stdevs.idxmin()"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Select Funds"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "# 2 · SELECT_FUNDS  (restored ≤ 3-missing-months rule)\n",
-    "# ===============================================================\n",
-    "\n",
-    "cfg = FundSelectionConfig(\n",
-    "    max_missing_months           = 3,\n",
-    "    max_consecutive_month_gap    = 6,\n",
-    "    outlier_threshold            = 0.5,\n",
-    "    zero_return_threshold        = 0.2,\n",
-    "    enforce_monotonic_index      = True,\n",
-    "    allow_duplicate_dates        = False,\n",
-    "    max_missing_ratio            = 0.05,\n",
-    "    max_drawdown                 = 0.3,\n",
-    "    min_volatility               = 0.05,\n",
-    "    max_volatility               = 1.0,\n",
-    "    min_avg_return               = 0.0,\n",
-    "    max_skewness                 = 3.0,\n",
-    "    max_kurtosis                 = 10.0,\n",
-    "    expected_freq                = \"B\",\n",
-    "    max_gap_days                 = 3,\n",
-    "    min_aum_usd                  = 1e7,\n",
-    ")\n",
-    "\n",
-    "def select_funds(\n",
-    "    df: pd.DataFrame,\n",
-    "    rf_col: str,\n",
-    "    fund_columns: list[str],\n",
-    "    in_sdate: str,\n",
-    "    in_edate: str,\n",
-    "    out_sdate: str,\n",
-    "    out_edate: str,\n",
-    "    cfg: FundSelectionConfig,\n",
-    "    selection_mode: str = \"all\",\n",
-    "    random_n: int | None = None\n",
-    ") -> list[str]:\n",
-    "    \"\"\"\n",
-    "    Select eligible funds with additional data-validity and coverage checks driven by FundSelectionConfig.\n",
-    "    \"\"\"\n",
-    "    # Ensure Date is datetime and sorted\n",
-    "    if not pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        df = df.copy()\n",
-    "        df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "        df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "    df = df.sort_values(\"Date\")  # guarantee monotonic index\n",
-    "\n",
-    "    # Prepare monthly periods within analysis window\n",
-    "    df[\"Month\"] = df[\"Date\"].dt.to_period(\"M\")\n",
-    "    span = pd.period_range(\n",
-    "        pd.Period(in_sdate, \"M\"), pd.Period(out_edate, \"M\"), freq=\"M\"\n",
-    "    )\n",
-    "\n",
-    "    eligible_funds: list[str] = []\n",
-    "    for f in fund_columns:\n",
-    "        try:\n",
-    "            ser = df.set_index(\"Date\")[f]\n",
-    "            clean = ser.dropna()\n",
-    "\n",
-    "            # 1. Implausible value limits\n",
-    "            if not clean.between(-cfg.implausible_value_limit, cfg.implausible_value_limit).all():\n",
-    "                raise ValueError(f\"Values outside ±{cfg.implausible_value_limit}\")\n",
-    "\n",
-    "            # 2. Extreme outlier threshold\n",
-    "            if (clean.abs() > cfg.outlier_threshold).any():\n",
-    "                raise ValueError(f\"Outliers beyond ±{cfg.outlier_threshold}\")\n",
-    "\n",
-    "            # 3. Excessive zero-return rate\n",
-    "            if (clean == 0).mean() > cfg.zero_return_threshold:\n",
-    "                raise ValueError(f\"Zero-return proportion > {cfg.zero_return_threshold}\")\n",
-    "\n",
-    "            # 4. Monotonic date index\n",
-    "            if cfg.enforce_monotonic_index and not clean.index.is_monotonic_increasing:\n",
-    "                raise ValueError(\"Date index not monotonically increasing\")\n",
-    "\n",
-    "            # 5. Duplicate dates\n",
-    "            if not cfg.allow_duplicate_dates and clean.index.duplicated().any():\n",
-    "                raise ValueError(\"Duplicate dates detected in index\")\n",
-    "\n",
-    "            # 6. Coverage checks using config thresholds\n",
-    "            m_ok = df.groupby(\"Month\")[f].apply(lambda col: col.notna().any())\n",
-    "            mask = m_ok.reindex(span, fill_value=False).to_numpy()\n",
-    "\n",
-    "            # tolerance for missing months per-cfg\n",
-    "            missing_count = (~mask).sum()\n",
-    "            if missing_count > cfg.max_missing_months:\n",
-    "                raise ValueError(f\"Missing-month count {missing_count} exceeds {cfg.max_missing_months}\")\n",
-    "\n",
-    "            # maximum run of consecutive missing months per-cfg with guard\n",
-    "            temp = np.flatnonzero(np.r_[True, mask, True])\n",
-    "            if temp.size <= 1:\n",
-    "                gap = 0\n",
-    "            else:\n",
-    "                gap = np.diff(temp).max() - 1\n",
-    "            if gap > cfg.max_consecutive_month_gap:\n",
-    "                raise ValueError(f\"Consecutive-missing gap {gap} exceeds {cfg.max_consecutive_month_gap}\")\n",
-    "\n",
-    "            eligible_funds.append(f)\n",
-    "\n",
-    "        except ValueError as e:\n",
-    "            logging.warning(\"Excluded %s: %s\", f, e)\n",
-    "        except KeyError as e:\n",
-    "            logging.warning(\"Missing data for %s: %s\", f, e)\n",
-    "        except Exception as e:\n",
-    "            logging.warning(\"Unexpected error on %s: %s\", f, e)\n",
-    "\n",
-    "    # Final selection-mode logic\n",
-    "    if selection_mode == \"all\" or random_n is None:\n",
-    "        return eligible_funds\n",
-    "    if selection_mode == \"random\":\n",
-    "        if random_n > len(eligible_funds):\n",
-    "            raise ValueError(\n",
-    "                f\"random_n exceeds eligible pool: {random_n} > {len(eligible_funds)}\"\n",
-    "            )\n",
-    "        return list(np.random.choice(eligible_funds, random_n, replace=False))\n",
-    "\n",
-    "    raise ValueError(f\"Unsupported selection_mode '{selection_mode}'\")\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Weight Prep"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  3 · WEIGHT PREP\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "def prepare_weights(selected: list[str],\n",
-    "                    custom: Dict[str, int] | None) -> tuple[Dict[str, float], np.ndarray]:\n",
-    "    if not custom:\n",
-    "        w = {f: 1/len(selected) for f in selected}\n",
-    "    else:\n",
-    "        missing = [f for f in selected if f not in custom]\n",
-    "        if missing:\n",
-    "            raise ValueError(f\"Missing weights for {missing}\")\n",
-    "        w = {f: pct/100 for f, pct in custom.items()}\n",
-    "        if abs(sum(w.values()) - 1) > 1e-6:\n",
-    "            raise ValueError(\"Custom weights must sum to 100.\")\n",
-    "    vec = np.array([w[f] for f in selected])\n",
-    "    return w, vec"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 4. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Function definitions\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "# 4 · CORE STATS  +  RUN_ANALYSIS  (helpers included, weight fix)\n",
-    "# ===============================================================\n",
-    "\n",
-    "M_PER_YEAR = 12           # constant used across helpers\n",
-    "\n",
-    "# ---------- helpers --------------------------------------------\n",
-    "def _ensure_dt(df: pd.DataFrame) -> pd.DataFrame:\n",
-    "    \"\"\"Return a copy whose Date column is datetime64[ns].\"\"\"\n",
-    "    if pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        return df\n",
-    "    df = df.copy()\n",
-    "    df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "    df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "    return df\n",
-    "\n",
-    "# 3. Metric function definitions\n",
-    "# === Metric Function Definitions with flexible annualization ===\n",
-    "@register_metric(\"AnnualReturn\")\n",
-    "def compute_annual_return(\n",
-    "    returns: pd.Series,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Geometric annualized return based on periods_per_year.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return np.nan\n",
-    "    total_growth = (1 + r).prod()\n",
-    "    n_periods = len(r)\n",
-    "    return total_growth ** (periods_per_year / n_periods) - 1\n",
-    "\n",
-    "@register_metric(\"Volatility\")\n",
-    "def compute_volatility(\n",
-    "    returns: pd.Series,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Annualized standard deviation of returns with flexible scaling.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return 0.0\n",
-    "    return r.std(ddof=0) * np.sqrt(periods_per_year)\n",
-    "\n",
-    "@register_metric(\"Sharpe\")\n",
-    "def compute_sharpe(\n",
-    "    returns: pd.Series,\n",
-    "    risk_free: float = 0.0,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Sharpe ratio using flexible annualized return and volatility.\n",
-    "    \"\"\"\n",
-    "    vol = compute_volatility(returns, periods_per_year=periods_per_year)\n",
-    "    if vol == 0:\n",
-    "        return np.nan\n",
-    "    ann_ret = compute_annual_return(returns, periods_per_year=periods_per_year)\n",
-    "    return (ann_ret - risk_free) / vol\n",
-    "\n",
-    "@register_metric(\"Sortino\")\n",
-    "def compute_sortino(\n",
-    "    returns: pd.Series,\n",
-    "    risk_free: float = 0.0,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Sortino ratio using flexible annualized return and downside deviation.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return np.nan\n",
-    "    ann_ret = compute_annual_return(returns, periods_per_year=periods_per_year)\n",
-    "    # Define per-period risk-free rate\n",
-    "    period_rf = risk_free / periods_per_year\n",
-    "    excess = r - period_rf\n",
-    "    downside = excess[excess < 0]\n",
-    "    if downside.empty:\n",
-    "        return np.nan\n",
-    "    down_dev = np.sqrt((downside ** 2).mean()) * np.sqrt(periods_per_year)\n",
-    "    if down_dev == 0:\n",
-    "        return np.nan\n",
-    "    return (ann_ret - risk_free) / down_dev\n",
-    "\n",
-    "@register_metric(\"MaxDrawdown\")\n",
-    "def compute_max_drawdown(\n",
-    "    returns: pd.Series,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Maximum drawdown (peak-to-trough) of cumulative returns.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return 0.0\n",
-    "    cum = (1 + r).cumprod()\n",
-    "    peak = cum.cummax()\n",
-    "    drawdown = (cum / peak) - 1\n",
-    "    return float(drawdown.min())\n",
-    "\n",
-    "# Alias for backward compatibility\n",
-    "_ann_vol = compute_volatility\n",
-    "\n",
-    "# === Aggregator with Centralized Error Handling ===\n",
-    "\n",
-    "def _stats(\n",
-    "    returns: pd.Series,\n",
-    "    cfg: RiskStatsConfig,\n",
-    "    **metric_kwargs\n",
-    ") -> namedtuple:\n",
-    "    \"\"\"\n",
-    "    Run each metric in cfg.metrics_to_run, returning a namedtuple of values.\n",
-    "    Uses cfg.periods_per_year for annualization.\n",
-    "    Centralized try/except ensures one failing metric doesn’t break the batch.\n",
-    "    \"\"\"\n",
-    "    Stat = namedtuple(\"Stat\", cfg.metrics_to_run)\n",
-    "    values: list[float] = []\n",
-    "    for name in cfg.metrics_to_run:\n",
-    "        fn = METRIC_REGISTRY.get(name)\n",
-    "        if fn is None:\n",
-    "            logging.error(\"Metric '%s' not registered\", name)\n",
-    "            values.append(np.nan)\n",
-    "            continue\n",
-    "        try:\n",
-    "            params = {\n",
-    "                \"risk_free\": cfg.risk_free,\n",
-    "                \"periods_per_year\": cfg.periods_per_year,\n",
-    "                **metric_kwargs\n",
-    "            }\n",
-    "            val = fn(returns, **params)\n",
-    "        except ZeroDivisionError:\n",
-    "            logging.warning(\"%s: division by zero, setting NaN\", name)\n",
-    "            val = np.nan\n",
-    "        except (ValueError, TypeError) as e:\n",
-    "            logging.warning(\"%s: invalid input (%s), setting NaN\", name, e)\n",
-    "            val = np.nan\n",
-    "        except Exception as e:\n",
-    "            logging.error(\"%s: unexpected error (%s), setting NaN\", name, e)\n",
-    "            val = np.nan\n",
-    "        values.append(val)\n",
-    "    return Stat(*values)\n",
-    "\n",
-    "# ---------- main ------------------------------------------------\n",
-    "def run_analysis(\n",
-    "    df,\n",
-    "    selected,\n",
-    "    w_vec,\n",
-    "    w_dict,\n",
-    "    rf_col,\n",
-    "    in_start,\n",
-    "    in_end,\n",
-    "    out_start,\n",
-    "    out_end,\n",
-    "    target_vol,\n",
-    "    monthly_cost,\n",
-    "    indices_list\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Vectorised run_analysis with correct weight re-normalisation\n",
-    "    after funds are dropped.\n",
-    "    Returns the same keys used by the UI and export functions.\n",
-    "    \"\"\"\n",
-    "    df = _ensure_dt(df)\n",
-    "\n",
-    "    # ---- date masks --------------------------------------------------\n",
-    "    in_s = pd.to_datetime(in_start)  + pd.offsets.MonthEnd(0)\n",
-    "    in_e = pd.to_datetime(in_end)    + pd.offsets.MonthEnd(0)\n",
-    "    out_s= pd.to_datetime(out_start) + pd.offsets.MonthEnd(0)\n",
-    "    out_e= pd.to_datetime(out_end)   + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    m_in  = df[\"Date\"].between(in_s,  in_e)\n",
-    "    m_out = df[\"Date\"].between(out_s, out_e)\n",
-    "\n",
-    "    in_df,  out_df  = df.loc[m_in,  selected], df.loc[m_out, selected]\n",
-    "    in_rf,  out_rf  = df.loc[m_in,  rf_col],   df.loc[m_out, rf_col]\n",
-    "\n",
-    "    # ---- drop funds with any NaNs in either window ------------------\n",
-    "    good = [f for f in selected\n",
-    "            if in_df[f].notna().all() and out_df[f].notna().all()]\n",
-    "    dropped = list(set(selected) - set(good))\n",
-    "    if dropped:\n",
-    "        logging.warning(\"Dropped funds: %s\", dropped)\n",
-    "\n",
-    "    selected = good\n",
-    "    # >>>> new guard: kick out any accidental index columns\n",
-    "    selected = [f for f in selected if f not in (indices_list or [])]\n",
-    "    # <<<<\n",
-    "\n",
-    "    in_df, out_df = in_df[selected], out_df[selected]\n",
-    "\n",
-    "    # rebuild weights\n",
-    "    if w_dict is None:                      # equal-weight path\n",
-    "        w_dict = {f: 1/len(selected) for f in selected}\n",
-    "    else:                                   # manual path → rescale\n",
-    "        pct   = {f: w_dict[f]*100 for f in selected}\n",
-    "        total = sum(pct.values())\n",
-    "        w_dict = {f: p/total for f, p in pct.items()}\n",
-    "    w_vec = np.array([w_dict[f] for f in selected])\n",
-    "\n",
-    "    # ---- scaling ----------------------------------------------------\n",
-    "    vols = in_df.apply(compute_volatility)\n",
-    "    scale = np.where(vols > 0, target_vol / vols, 1.0)\n",
-    "    in_sc  = (in_df * scale) - monthly_cost\n",
-    "    out_sc = (out_df * scale) - monthly_cost\n",
-    "    in_sc.clip(lower=-1, inplace=True)\n",
-    "    out_sc.clip(lower=-1, inplace=True)\n",
-    "\n",
-    "    # ---- stats ------------------------------------------------------\n",
-    "    rf_value = in_rf.mean() if hasattr(in_rf, \"mean\") else float(in_rf)\n",
-    "\n",
-    "    # Create a RiskStatsConfig for in-sample stats\n",
-    "    stats_cfg = RiskStatsConfig(risk_free=rf_value)\n",
-    "\n",
-    "    # Now compute stats for each scenario, always passing stats_cfg first\n",
-    "    in_stat = {\n",
-    "        f: _stats(in_sc[f], stats_cfg)\n",
-    "        for f in selected\n",
-    "    }\n",
-    "    out_rf_value = out_rf.mean() if hasattr(out_rf, \"mean\") else float(out_rf)\n",
-    "\n",
-    "    # Re‐use the same config, updating only the risk_free field\n",
-    "    stats_cfg.risk_free = out_rf_value\n",
-    "\n",
-    "    out_stat = {\n",
-    "        f: _stats(out_sc[f], stats_cfg)\n",
-    "        for f in selected\n",
-    "    }\n",
-    "\n",
-    "    ew_vec = np.full(len(selected), 1/len(selected))\n",
-    "    w_vec = np.full(len(selected), 1/len(selected))\n",
-    "\n",
-    "    in_ew_stats  = _stats(in_sc.dot(ew_vec),  stats_cfg)\n",
-    "    out_ew_stats = _stats(out_sc.dot(ew_vec), stats_cfg)\n",
-    "    in_user_stats  = _stats(in_sc.dot(w_vec),  stats_cfg)\n",
-    "    out_user_stats = _stats(out_sc.dot(w_vec), stats_cfg)\n",
-    "\n",
-    "    results = {\n",
-    "        \"selected_funds\": selected,\n",
-    "        \"indices_list\":   indices_list or [],\n",
-    "        \"fund_weights\":   w_dict,\n",
-    "        \"ew_weights\":     {f: 1/len(selected) for f in selected},\n",
-    "        \"in_sample_stats\":  in_stat,\n",
-    "        \"out_sample_stats\": out_stat,\n",
-    "        \"in_ew_stats\":     in_ew_stats,\n",
-    "        \"out_ew_stats\":    out_ew_stats,\n",
-    "        \"in_user_stats\":   in_user_stats,\n",
-    "        \"out_user_stats\":  out_user_stats,\n",
-    "        \"dropped\":         dropped,\n",
-    "    }\n",
-    "\n",
-    "    # ---- optional index stats ---------------------------------------\n",
-    "    if indices_list:\n",
-    "        idx_stats = {}\n",
-    "        for col in indices_list:\n",
-    "            idx_stats[col] = {\n",
-    "                \"in_sample\":  _stats(df.loc[m_in,  col], stats_cfg),\n",
-    "                \"out_sample\": _stats(df.loc[m_out, col], stats_cfg),\n",
-    "            }\n",
-    "        results[\"index_stats\"] = idx_stats\n",
-    "\n",
-    "    return results\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 5. Excel Export\n",
-    "Creates an Excel file with In-Sample, Out-of-Sample and Equal-weight and User-weight."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  5 · EXPORT  (NaN-safe, weight-format fix)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# ───────── 5 · EXPORT  (final, bug-free) ───────────────────────\n",
-    "# ───────── 5 · EXPORT  (self-healing index section) ───────────\n",
-    "# ───────── 5 · EXPORT  (final safe version) ───────────────────\n",
-    "\n",
-    "def export_to_excel(\n",
-    "    data: dict[str, pd.DataFrame],\n",
-    "    output_path: str,\n",
-    "    default_format: Optional[Callable] = None\n",
-    ") -> None:\n",
-    "    \"\"\"\n",
-    "    Exports each DataFrame in `data` to its own sheet in `output_path`.\n",
-    "    Applies a registered formatter for each category (sheet name).\n",
-    "    If no formatter is found, applies `default_format` if provided.\n",
-    "\n",
-    "    For the Summary sheet, data is written starting at row 5 to make room for custom headers.\n",
-    "    \"\"\"\n",
-    "    startrows = {\"summary\": 5}\n",
-    "    with pd.ExcelWriter(output_path, engine=\"xlsxwriter\") as writer:\n",
-    "        for category, df in data.items():\n",
-    "            startrow = startrows.get(category, 0)\n",
-    "            df.to_excel(writer, sheet_name=category, index=False, startrow=startrow)\n",
-    "            fn = FORMATTERS_EXCEL.get(category, default_format)\n",
-    "            if fn: fn(writer.sheets[category], writer.book)\n",
-    "    # Workbook is auto-saved and closed by the context manager\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 6. Run Parameters, Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc. Also lets us use custom weights."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "687e0d59-d17a-41c8-b991-1d91d29a22d1",
-   "metadata": {
-    "outputId": "795bb6da-96a0-42e2-c760-7d516fd82610"
-   },
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "8b1481dc6f354447ba37b4a989c0f749",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<h4>1. Load data</h4>'), ToggleButtons(description='Source:', options=(('Local', 'l…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# ===============================================================\n",
-    "#            STREAMLINED ANALYSIS UI  (phase-2 clean)\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ---------- session store ----------\n",
-    "session = {\"df\": None, \"rf\": None, \"sel\": None, \"cweights\": None}\n",
-    "\n",
-    "# ---------- 1 · DATA LOAD ----------\n",
-    "src = widgets.ToggleButtons(\n",
-    "    options=[(\"Local\", \"local\"), (\"URL\", \"url\")],\n",
-    "    description=\"Source:\"\n",
-    ")\n",
-    "\n",
-    "chooser = FileChooser()\n",
-    "url_box = widgets.Text(placeholder=\"https://…/file.csv\", layout={\"width\":\"70%\"})\n",
-    "load_btn = widgets.Button(description=\"Load CSV\", button_style=\"success\")\n",
-    "load_out = widgets.Output()\n",
-    "\n",
-    "def _toggle_src(c):\n",
-    "    chooser.layout.display = \"block\" if c[\"new\"]==\"local\" else \"none\"\n",
-    "    url_box.layout.display  = \"block\" if c[\"new\"]==\"url\"   else \"none\"\n",
-    "src.observe(_toggle_src, names=\"value\"); _toggle_src({\"new\":src.value})\n",
-    "\n",
-    "def _load(_):\n",
-    "    with load_out:\n",
-    "        clear_output()\n",
-    "        try:\n",
-    "            path = chooser.selected if src.value==\"local\" else url_box.value.strip()\n",
-    "            if not path: raise ValueError(\"choose file / URL\")\n",
-    "            if src.value==\"url\" and not path.lower().endswith(\".csv\"):\n",
-    "                raise ValueError(\"URL must end with .csv\")\n",
-    "            df = load_csv(path)\n",
-    "            df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")  # single coercion\n",
-    "            rf = identify_risk_free_fund(df)\n",
-    "            session.update(df=df, rf=rf, sel=None, cweights=None)\n",
-    "            print(f\"✅ Loaded {len(df):,} rows × {df.shape[1]} cols | RF → {rf}\")\n",
-    "        except Exception as e:\n",
-    "            print(\"❌\", e); session[\"df\"]=None\n",
-    "load_btn.on_click(_load)\n",
-    "\n",
-    "# ---------- 2 · PARAMS ------------\n",
-    "index_cnt = widgets.BoundedIntText(0, min=0, max=10, description=\"# Indices:\")\n",
-    "in_start,in_end  = widgets.Text(\"2005-07\"), widgets.Text(\"2008-06\")\n",
-    "out_start,out_end= widgets.Text(\"2008-07\"), widgets.Text(\"2009-06\")\n",
-    "for w,lbl in [(in_start,\"In Start:\"),(in_end,\"In End:\"),\n",
-    "              (out_start,\"Out Start:\"),(out_end,\"Out End:\")]:\n",
-    "    w.description = lbl\n",
-    "target_vol   = widgets.FloatText(0.25,  description=\"Target Vol:\")\n",
-    "monthly_cost = widgets.FloatText(0.0033, description=\"Monthly Cost:\")\n",
-    "\n",
-    "# ---------- 3 · SELECTION ----------\n",
-    "mode_dd = widgets.Dropdown(\n",
-    "    options=[(\"All\", \"all\"), (\"Random\", \"random\"), (\"Manual\", \"manual\")],\n",
-    "    value=\"all\",\n",
-    "    description=\"Mode:\"\n",
-    ")\n",
-    "rand_n   = widgets.BoundedIntText(5, min=2, max=100, description=\"Sample N:\")\n",
-    "fund_table, total_lbl = widgets.VBox([]), widgets.Label(\"Total = 0 %\")\n",
-    "\n",
-    "def _toggle_sel(_=None):\n",
-    "    rand_n.layout.display  = \"block\" if mode_dd.value==\"random\" else \"none\"\n",
-    "    vis = \"block\" if mode_dd.value==\"manual\" else \"none\"\n",
-    "    fund_table.layout.display = total_lbl.layout.display = vis\n",
-    "mode_dd.observe(_toggle_sel, names=\"value\"); _toggle_sel()\n",
-    "\n",
-    "# ---------- helpers ---------------\n",
-    "def _eligible_pool():\n",
-    "    df, rf = session[\"df\"], session[\"rf\"]\n",
-    "    if df is None:\n",
-    "        print(\"⚠️ data not loaded\"); return []\n",
-    "\n",
-    "    # ---- date parse guard -----------------------------------\n",
-    "    try:\n",
-    "        in_s  = pd.to_datetime(in_start.value)+pd.offsets.MonthEnd(0)\n",
-    "        in_e  = pd.to_datetime(in_end.value)  +pd.offsets.MonthEnd(0)\n",
-    "        out_s = pd.to_datetime(out_start.value)+pd.offsets.MonthEnd(0)\n",
-    "        out_e = pd.to_datetime(out_end.value)  +pd.offsets.MonthEnd(0)\n",
-    "    except Exception:\n",
-    "        print(\"❌ invalid dates\"); return []\n",
-    "\n",
-    "    # ---- build indices (RIGHT-most idx_n non-RF columns) ----\n",
-    "    idx_n     = index_cnt.value\n",
-    "    data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-    "    non_rf    = [c for c in data_cols if c != rf]\n",
-    "    indices   = non_rf[-idx_n:] if idx_n else []          # <- fixed\n",
-    "    cand      = [c for c in data_cols if c not in indices]\n",
-    "\n",
-    "    # ---- run select_funds ----------------------------------\n",
-    "    elig = select_funds(\n",
-    "        df=df,\n",
-    "        rf_col=rf,\n",
-    "        fund_columns=cand,\n",
-    "        in_sdate=in_s,\n",
-    "        in_edate=in_e,\n",
-    "        out_sdate=out_s,\n",
-    "        out_edate=out_e,\n",
-    "        cfg=cfg,                   \n",
-    "        selection_mode=\"all\",\n",
-    "    )\n",
-    "    # … diagnostics print unchanged …\n",
-    "    return elig\n",
-    "\n",
-    "def _build_manual(*_):\n",
-    "    if mode_dd.value!=\"manual\" or session[\"df\"] is None: return\n",
-    "    valid = _eligible_pool()\n",
-    "    print(\"DEBUG  eligible funds =\", len(valid))              # ← line 1\n",
-    "    print(\"DEBUG  list sample   →\", valid[:25], \"…\")           # ← line 2\n",
-    "    if not valid:\n",
-    "        print(\"❌ No eligible funds\"); return\n",
-    "    fund_table.children = []                # reset\n",
-    "\n",
-    "    def _update_total(*_):\n",
-    "        tot = sum(r.children[1].value for r in fund_table.children\n",
-    "                  if r.children[0].value)\n",
-    "        total_lbl.value = f\"Total = {tot} %\"\n",
-    "\n",
-    "    for f in valid:\n",
-    "        cb = widgets.Checkbox(description=f, layout={\"width\":\"200px\"})\n",
-    "        wt = widgets.BoundedIntText(0, min=0, max=100,\n",
-    "                                    layout={\"width\":\"60px\"}, disabled=True)\n",
-    "        def _toggle(ch, box=wt):           # single observer\n",
-    "            box.disabled = not ch[\"new\"]\n",
-    "            if box.disabled: box.value = 0\n",
-    "            _update_total()\n",
-    "        cb.observe(_toggle, names=\"value\")\n",
-    "        wt.observe(_update_total, names=\"value\")\n",
-    "        fund_table.children += (widgets.HBox([cb, wt]),)\n",
-    "    _update_total()\n",
-    "\n",
-    "mode_dd.observe(lambda ch: _build_manual() if ch[\"new\"]==\"manual\" else None,\n",
-    "                names=\"value\")\n",
-    "for w in (in_start,in_end,out_start,out_end): w.observe(_build_manual,names=\"value\")\n",
-    "\n",
-    "# ---------- 4 · RUN ---------------\n",
-    "run_btn = widgets.Button(description=\"Run Analysis\", button_style=\"success\")\n",
-    "run_out = widgets.Output(layout={\"border\":\"1px solid #999\",\n",
-    "                                 \"height\":\"340px\",\"overflow_y\":\"auto\"})\n",
-    "\n",
-    "def _run(_):\n",
-    "    with run_out:\n",
-    "        clear_output()\n",
-    "        df, rf = session[\"df\"], session[\"rf\"]\n",
-    "        if df is None: print(\"⚠️ Load data first\"); return\n",
-    "\n",
-    "        # indices (robust)\n",
-    "        idx_n     = index_cnt.value\n",
-    "        data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-    "        non_rf    = [c for c in data_cols if c != rf]\n",
-    "        indices   = non_rf[-idx_n:] if idx_n else []\n",
-    "\n",
-    "        # pool + selection\n",
-    "        pool = _eligible_pool()\n",
-    "        if not pool: print(\"❌ No eligible funds\"); return\n",
-    "        if mode_dd.value==\"all\":\n",
-    "            sel, custom = pool, None\n",
-    "        elif mode_dd.value==\"random\":\n",
-    "            if rand_n.value>len(pool): print(\"⚠️ Sample N too big\"); return\n",
-    "            sel, custom = list(np.random.choice(pool, rand_n.value, replace=False)), None\n",
-    "        else:\n",
-    "            sel, custom = [], {}\n",
-    "            if not fund_table.children: _build_manual()\n",
-    "            for row in fund_table.children:\n",
-    "                cb, wt = row.children\n",
-    "                if cb.value: sel.append(cb.description); custom[cb.description]=wt.value\n",
-    "            if sum(custom.values())!=100: print(\"⚠️ Weights ≠ 100\"); return\n",
-    "\n",
-    "        w_dict,w_vec = prepare_weights(sel, custom)\n",
-    "\n",
-    "        res = run_analysis(df, sel, w_vec, w_dict, rf,\n",
-    "                           in_start.value, in_end.value,\n",
-    "                           out_start.value, out_end.value,\n",
-    "                           target_vol.value, monthly_cost.value,\n",
-    "                           indices)\n",
-    "\n",
-    "        print(\"✅ analysis complete |\", len(sel), \"funds\")\n",
-    "        if res[\"dropped\"]:\n",
-    "            print(\"⚠️ Dropped:\", res[\"dropped\"])\n",
-    "        if indices: print(\"📊 Indices:\", indices)\n",
-    "\n",
-    "        fname=f\"IS_{in_start.value}_{out_start.value}.xlsx\"\n",
-    "        # register only the combined summary formatter\n",
-    "        make_summary_formatter(\n",
-    "            res,\n",
-    "            in_start.value,\n",
-    "            in_end.value,\n",
-    "            out_start.value,\n",
-    "            out_end.value\n",
-    "        )\n",
-    "\n",
-    "        # Build a minimal data dict with just the 'summary' sheet.\n",
-    "        # The formatter will populate all rows (portfolio, funds, spacer, indices).\n",
-    "        data = {\n",
-    "            \"summary\": pd.DataFrame()\n",
-    "        }\n",
-    "\n",
-    "        print(\"Sheets to write:\", list(data.keys()))\n",
-    "        print(\"Formatters:\", list(FORMATTERS_EXCEL.keys()))\n",
-    "\n",
-    "        # Export — this will call fmt_summary(ws, wb) on the 'summary' sheet.\n",
-    "        export_to_excel(data, fname)\n",
-    "        print(\"Workbook saved as\", fname)\n",
-    "\n",
-    "run_btn.on_click(_run)\n",
-    "\n",
-    "# ---------- DISPLAY --------------\n",
-    "display(widgets.VBox([\n",
-    "    widgets.HTML(\"<h4>1. Load data</h4>\"),\n",
-    "    src, chooser, url_box, load_btn, load_out,\n",
-    "    widgets.HTML(\"<hr><h4>2. Parameters</h4>\"),\n",
-    "    widgets.HBox([index_cnt]),\n",
-    "    widgets.HBox([in_start,in_end,out_start,out_end]),\n",
-    "    widgets.HBox([target_vol,monthly_cost]),\n",
-    "    widgets.HTML(\"<hr><h4>3. Fund selection</h4>\"),\n",
-    "    widgets.HBox([mode_dd,rand_n]),\n",
-    "    fund_table, total_lbl,\n",
-    "    widgets.HTML(\"<hr>\"),\n",
-    "    run_btn,\n",
-    "    run_out\n",
-    "]))\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_1.1.TrEx-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_1.1.TrEx-checkpoint.ipynb
deleted file mode 100644
index 7c87f2c9e22eb04d408f0624139cb0b7f803ba81..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_1.1.TrEx-checkpoint.ipynb
+++ /dev/null
@@ -1,1046 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "22994893-0193-45bc-b9e3-a97b328ecaea",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Imports, Data Loader and Rf Detector\n",
-    "2. Select fund (month period logic)\n",
-    "3. Weight prep\n",
-    "4. Core Stats + Run Analysis\n",
-    "5. Export\n",
-    "6. Widget /UI\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "#      VOL-ADJ TREND ANALYSIS  –  SINGLE-FILE VERSION\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  0 · IMPORTS  (all in one place)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "import pandas as pd\n",
-    "import numpy as np\n",
-    "from dataclasses import dataclass, field\n",
-    "from collections import namedtuple\n",
-    "import xlsxwriter\n",
-    "import logging\n",
-    "from io import BytesIO\n",
-    "import ipywidgets as widgets\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "from typing import List, Dict, Optional, Callable\n",
-    "\n",
-    "logging.getLogger().setLevel(logging.ERROR)\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  1 · Class Configurations\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "@dataclass\n",
-    "class FundSelectionConfig:\n",
-    "    max_missing_months:         int = 3   # used to replace the “<=3 missing” rule\n",
-    "    max_consecutive_month_gap:  int = 6   # used to replace the “<=6 gap” ruleimplausible_value_limit: float = 1.0\n",
-    "    implausible_value_limit: float  = 1\n",
-    "    outlier_threshold: float = 0.5\n",
-    "    zero_return_threshold: float = 0.2\n",
-    "    enforce_monotonic_index: bool = True\n",
-    "    allow_duplicate_dates: bool = False\n",
-    "    max_missing_ratio: float      = 0.05\n",
-    "    max_drawdown: float           = 0.3\n",
-    "    min_volatility: float         = 0.05\n",
-    "    max_volatility: float         = 1.0\n",
-    "    min_avg_return: float         = 0.0\n",
-    "    max_skewness: float           = 3.0\n",
-    "    max_kurtosis: float           = 10.0\n",
-    "    expected_freq: str            = \"B\"\n",
-    "    max_gap_days: int             = 3\n",
-    "    min_aum_usd: float            = 1e7\n",
-    "\n",
-    "# Configuration dataclass\n",
-    "@dataclass\n",
-    "class RiskStatsConfig:\n",
-    "    \"\"\"\n",
-    "    Configuration for which metrics to run, risk-free rate, and data frequency.\n",
-    "    periods_per_year specifies the number of data points per year (e.g., 12 for monthly).\n",
-    "    \"\"\"\n",
-    "    metrics_to_run: List[str] = field(\n",
-    "        default_factory=lambda: [\n",
-    "            \"AnnualReturn\",\n",
-    "            \"Volatility\",\n",
-    "            \"Sharpe\",\n",
-    "            \"Sortino\",\n",
-    "            \"MaxDrawdown\",\n",
-    "        ]\n",
-    "    )\n",
-    "    # Annualized risk-free rate for ratio computations\n",
-    "    risk_free: float = 0.0\n",
-    "    # Number of periods per year (e.g., 12 for monthly, 252 for daily)\n",
-    "    periods_per_year: int = 12\n",
-    "\n",
-    "# 2. Registry and decorator\n",
-    "METRIC_REGISTRY: Dict[str, Callable[..., float]] = {}\n",
-    "\n",
-    "def register_metric(name: str):\n",
-    "    \"\"\"\n",
-    "    Decorator to register a metric function under a given name.\n",
-    "    \"\"\"\n",
-    "    def decorator(fn: Callable[..., float]):\n",
-    "        METRIC_REGISTRY[name] = fn\n",
-    "        return fn\n",
-    "    return decorator\n",
-    "\n",
-    "FORMATTERS_EXCEL: dict[str, Callable] = {}\n",
-    "def register_formatter_excel(category: str):\n",
-    "    def decorator(fn: Callable):\n",
-    "        FORMATTERS_EXCEL[category] = fn\n",
-    "        return fn\n",
-    "    return decorator\n",
-    "\n",
-    "# Example formatters (extend as needed)\n",
-    "@register_formatter_excel(\"portfolio\")\n",
-    "def fmt_portfolio(ws, wb):\n",
-    "    header_fmt = wb.add_format({\"bold\": True, \"bottom\": 2})\n",
-    "    ws.set_row(0, None, header_fmt)\n",
-    "\n",
-    "@register_formatter_excel(\"indices\")\n",
-    "def fmt_indices(ws, wb):\n",
-    "    \"\"\"\n",
-    "    Formatter for the indices sheet: inserts a blank column where 'Weight' would be,\n",
-    "    then draws a border around the entire table.\n",
-    "    \"\"\"\n",
-    "    # 1. Insert a blank column at position 1 (after the 'Name' column)\n",
-    "    #    This creates the space where fund weights would sit for other sheets.\n",
-    "    ws.set_column(1, 1, 5)  # width 5 (or adjust as needed)\n",
-    "\n",
-    "    # 2. Apply a border around all non-blank cells\n",
-    "    box_fmt = wb.add_format({\"border\": 1})\n",
-    "    max_row = ws.dim_rowmax\n",
-    "    max_col = ws.dim_colmax\n",
-    "    ws.conditional_format(0, 0, max_row, max_col, {\"type\": \"no_errors\", \"format\": box_fmt})\n",
-    "    box = wb.add_format({\"border\": 1}); r,c = ws.dim_rowmax, ws.dim_colmax\n",
-    "    ws.conditional_format(0, 0, r, c, {\"type\":\"no_errors\",\"format\":box})\n",
-    "\n",
-    "# Custom summary sheet formatter to match old presentation\n",
-    "@register_formatter_excel(\"summary\")\n",
-    "def fmt_summary(ws, wb):\n",
-    "    # Define commonly used formats\n",
-    "    bold = wb.add_format({\"bold\": True})\n",
-    "    int0 = wb.add_format({\"num_format\": \"0\"})\n",
-    "    num2 = wb.add_format({\"num_format\": \"0.00\"})\n",
-    "    red  = wb.add_format({\"num_format\": \"0.00\", \"font_color\": \"red\"})\n",
-    "\n",
-    "    # Helper functions\n",
-    "    safe = lambda v: \"\" if (pd.isna(v) or not np.isfinite(v)) else v\n",
-    "    pct  = lambda t: [t[0]*100, t[1]*100, t[2], t[3], t[4]*100]\n",
-    "\n",
-    "    # Write header rows\n",
-    "    ws.write_row(0, 0, [\"Vol-Adj Trend Analysis\"], bold)\n",
-    "    ws.write_row(1, 0, [f\"In:  {{in_start}} → {{in_end}}\"])\n",
-    "    ws.write_row(2, 0, [f\"Out: {{out_start}} → {{out_end}}\"])\n",
-    "\n",
-    "    # Column headers at row 4\n",
-    "    hdr = [\n",
-    "        \"Name\", \"Weight %\",\n",
-    "        \"R (IN)%\", \"V (IN)%\", \"Sharpe\", \"Sortino\", \"MDD (IN)%\",\n",
-    "        \"R (OUT)%\", \"V (OUT)%\", \"Sharpe\", \"Sortino\", \"MDD (OUT)%\"\n",
-    "    ]\n",
-    "    ws.write_row(4, 0, hdr, bold)\n",
-    "\n",
-    "    # Note: DataFrame rows should start at row index 5 via export_to_excel startrow\n",
-    "    \n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  2 · CSV LOADER + RF DETECTOR\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "logger = logging.getLogger(__name__)\n",
-    "\n",
-    "def load_csv(path: str) -> pd.DataFrame | None:\n",
-    "    try:\n",
-    "        df = pd.read_csv(path)\n",
-    "    except FileNotFoundError as e:\n",
-    "        logger.error(f\"File not found: {path}\")\n",
-    "        return None\n",
-    "    except pd.errors.EmptyDataError:\n",
-    "        logger.error(f\"No data in file: {path}\")\n",
-    "        return None\n",
-    "    except pd.errors.ParserError as e:\n",
-    "        logger.error(f\"Parsing error in {path}: {e}\")\n",
-    "        return None\n",
-    "\n",
-    "    if \"Date\" not in df.columns:\n",
-    "        logger.error(f\"Validation failed ({path}): missing 'Date' column\")\n",
-    "        return None\n",
-    "\n",
-    "    # Optionally check for NaNs in 'Date' column\n",
-    "    if df[\"Date\"].isnull().any():\n",
-    "        logger.warning(f\"Null values found in 'Date' column of {path}\")\n",
-    "\n",
-    "    return df\n",
-    "\n",
-    "def identify_risk_free_fund(df: pd.DataFrame) -> str:\n",
-    "    returns = df.drop(columns=\"Date\", errors=\"ignore\")\n",
-    "    stdevs  = returns.std(skipna=True, ddof=0)\n",
-    "    return stdevs.idxmin()"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "93582c5f-d5f9-4bc8-8083-b54fe6ea2007",
-   "metadata": {},
-   "outputs": [],
-   "source": []
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Select Funds"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "# 2 · SELECT_FUNDS  (restored ≤ 3-missing-months rule)\n",
-    "# ===============================================================\n",
-    "\n",
-    "cfg = FundSelectionConfig(\n",
-    "    max_missing_months           = 3,\n",
-    "    max_consecutive_month_gap    = 6,\n",
-    "    outlier_threshold            = 0.5,\n",
-    "    zero_return_threshold        = 0.2,\n",
-    "    enforce_monotonic_index      = True,\n",
-    "    allow_duplicate_dates        = False,\n",
-    "    max_missing_ratio            = 0.05,\n",
-    "    max_drawdown                 = 0.3,\n",
-    "    min_volatility               = 0.05,\n",
-    "    max_volatility               = 1.0,\n",
-    "    min_avg_return               = 0.0,\n",
-    "    max_skewness                 = 3.0,\n",
-    "    max_kurtosis                 = 10.0,\n",
-    "    expected_freq                = \"B\",\n",
-    "    max_gap_days                 = 3,\n",
-    "    min_aum_usd                  = 1e7,\n",
-    ")\n",
-    "\n",
-    "def select_funds(\n",
-    "    df: pd.DataFrame,\n",
-    "    rf_col: str,\n",
-    "    fund_columns: list[str],\n",
-    "    in_sdate: str,\n",
-    "    in_edate: str,\n",
-    "    out_sdate: str,\n",
-    "    out_edate: str,\n",
-    "    cfg: FundSelectionConfig,\n",
-    "    selection_mode: str = \"all\",\n",
-    "    random_n: int | None = None\n",
-    ") -> list[str]:\n",
-    "    \"\"\"\n",
-    "    Select eligible funds with additional data-validity and coverage checks driven by FundSelectionConfig.\n",
-    "    \"\"\"\n",
-    "    # Ensure Date is datetime and sorted\n",
-    "    if not pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        df = df.copy()\n",
-    "        df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "        df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "    df = df.sort_values(\"Date\")  # guarantee monotonic index\n",
-    "\n",
-    "    # Prepare monthly periods within analysis window\n",
-    "    df[\"Month\"] = df[\"Date\"].dt.to_period(\"M\")\n",
-    "    span = pd.period_range(\n",
-    "        pd.Period(in_sdate, \"M\"), pd.Period(out_edate, \"M\"), freq=\"M\"\n",
-    "    )\n",
-    "\n",
-    "    eligible_funds: list[str] = []\n",
-    "    for f in fund_columns:\n",
-    "        try:\n",
-    "            ser = df.set_index(\"Date\")[f]\n",
-    "            clean = ser.dropna()\n",
-    "\n",
-    "            # 1. Implausible value limits\n",
-    "            if not clean.between(-cfg.implausible_value_limit, cfg.implausible_value_limit).all():\n",
-    "                raise ValueError(f\"Values outside ±{cfg.implausible_value_limit}\")\n",
-    "\n",
-    "            # 2. Extreme outlier threshold\n",
-    "            if (clean.abs() > cfg.outlier_threshold).any():\n",
-    "                raise ValueError(f\"Outliers beyond ±{cfg.outlier_threshold}\")\n",
-    "\n",
-    "            # 3. Excessive zero-return rate\n",
-    "            if (clean == 0).mean() > cfg.zero_return_threshold:\n",
-    "                raise ValueError(f\"Zero-return proportion > {cfg.zero_return_threshold}\")\n",
-    "\n",
-    "            # 4. Monotonic date index\n",
-    "            if cfg.enforce_monotonic_index and not clean.index.is_monotonic_increasing:\n",
-    "                raise ValueError(\"Date index not monotonically increasing\")\n",
-    "\n",
-    "            # 5. Duplicate dates\n",
-    "            if not cfg.allow_duplicate_dates and clean.index.duplicated().any():\n",
-    "                raise ValueError(\"Duplicate dates detected in index\")\n",
-    "\n",
-    "            # 6. Coverage checks using config thresholds\n",
-    "            m_ok = df.groupby(\"Month\")[f].apply(lambda col: col.notna().any())\n",
-    "            mask = m_ok.reindex(span, fill_value=False).to_numpy()\n",
-    "\n",
-    "            # tolerance for missing months per-cfg\n",
-    "            missing_count = (~mask).sum()\n",
-    "            if missing_count > cfg.max_missing_months:\n",
-    "                raise ValueError(f\"Missing-month count {missing_count} exceeds {cfg.max_missing_months}\")\n",
-    "\n",
-    "            # maximum run of consecutive missing months per-cfg with guard\n",
-    "            temp = np.flatnonzero(np.r_[True, mask, True])\n",
-    "            if temp.size <= 1:\n",
-    "                gap = 0\n",
-    "            else:\n",
-    "                gap = np.diff(temp).max() - 1\n",
-    "            if gap > cfg.max_consecutive_month_gap:\n",
-    "                raise ValueError(f\"Consecutive-missing gap {gap} exceeds {cfg.max_consecutive_month_gap}\")\n",
-    "\n",
-    "            eligible_funds.append(f)\n",
-    "\n",
-    "        except ValueError as e:\n",
-    "            logging.warning(\"Excluded %s: %s\", f, e)\n",
-    "        except KeyError as e:\n",
-    "            logging.warning(\"Missing data for %s: %s\", f, e)\n",
-    "        except Exception as e:\n",
-    "            logging.warning(\"Unexpected error on %s: %s\", f, e)\n",
-    "\n",
-    "    # Final selection-mode logic\n",
-    "    if selection_mode == \"all\" or random_n is None:\n",
-    "        return eligible_funds\n",
-    "    if selection_mode == \"random\":\n",
-    "        if random_n > len(eligible_funds):\n",
-    "            raise ValueError(\n",
-    "                f\"random_n exceeds eligible pool: {random_n} > {len(eligible_funds)}\"\n",
-    "            )\n",
-    "        return list(np.random.choice(eligible_funds, random_n, replace=False))\n",
-    "\n",
-    "    raise ValueError(f\"Unsupported selection_mode '{selection_mode}'\")\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Weight Prep"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  3 · WEIGHT PREP\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "def prepare_weights(selected: list[str],\n",
-    "                    custom: Dict[str, int] | None) -> tuple[Dict[str, float], np.ndarray]:\n",
-    "    if not custom:\n",
-    "        w = {f: 1/len(selected) for f in selected}\n",
-    "    else:\n",
-    "        missing = [f for f in selected if f not in custom]\n",
-    "        if missing:\n",
-    "            raise ValueError(f\"Missing weights for {missing}\")\n",
-    "        w = {f: pct/100 for f, pct in custom.items()}\n",
-    "        if abs(sum(w.values()) - 1) > 1e-6:\n",
-    "            raise ValueError(\"Custom weights must sum to 100.\")\n",
-    "    vec = np.array([w[f] for f in selected])\n",
-    "    return w, vec"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 4. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Function definitions\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "# 4 · CORE STATS  +  RUN_ANALYSIS  (helpers included, weight fix)\n",
-    "# ===============================================================\n",
-    "\n",
-    "M_PER_YEAR = 12           # constant used across helpers\n",
-    "\n",
-    "# ---------- helpers --------------------------------------------\n",
-    "def _ensure_dt(df: pd.DataFrame) -> pd.DataFrame:\n",
-    "    \"\"\"Return a copy whose Date column is datetime64[ns].\"\"\"\n",
-    "    if pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        return df\n",
-    "    df = df.copy()\n",
-    "    df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "    df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "    return df\n",
-    "\n",
-    "# 3. Metric function definitions\n",
-    "# === Metric Function Definitions with flexible annualization ===\n",
-    "@register_metric(\"AnnualReturn\")\n",
-    "def compute_annual_return(\n",
-    "    returns: pd.Series,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Geometric annualized return based on periods_per_year.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return np.nan\n",
-    "    total_growth = (1 + r).prod()\n",
-    "    n_periods = len(r)\n",
-    "    return total_growth ** (periods_per_year / n_periods) - 1\n",
-    "\n",
-    "@register_metric(\"Volatility\")\n",
-    "def compute_volatility(\n",
-    "    returns: pd.Series,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Annualized standard deviation of returns with flexible scaling.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return 0.0\n",
-    "    return r.std(ddof=0) * np.sqrt(periods_per_year)\n",
-    "\n",
-    "@register_metric(\"Sharpe\")\n",
-    "def compute_sharpe(\n",
-    "    returns: pd.Series,\n",
-    "    risk_free: float = 0.0,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Sharpe ratio using flexible annualized return and volatility.\n",
-    "    \"\"\"\n",
-    "    vol = compute_volatility(returns, periods_per_year=periods_per_year)\n",
-    "    if vol == 0:\n",
-    "        return np.nan\n",
-    "    ann_ret = compute_annual_return(returns, periods_per_year=periods_per_year)\n",
-    "    return (ann_ret - risk_free) / vol\n",
-    "\n",
-    "@register_metric(\"Sortino\")\n",
-    "def compute_sortino(\n",
-    "    returns: pd.Series,\n",
-    "    risk_free: float = 0.0,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Sortino ratio using flexible annualized return and downside deviation.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return np.nan\n",
-    "    ann_ret = compute_annual_return(returns, periods_per_year=periods_per_year)\n",
-    "    # Define per-period risk-free rate\n",
-    "    period_rf = risk_free / periods_per_year\n",
-    "    excess = r - period_rf\n",
-    "    downside = excess[excess < 0]\n",
-    "    if downside.empty:\n",
-    "        return np.nan\n",
-    "    down_dev = np.sqrt((downside ** 2).mean()) * np.sqrt(periods_per_year)\n",
-    "    if down_dev == 0:\n",
-    "        return np.nan\n",
-    "    return (ann_ret - risk_free) / down_dev\n",
-    "\n",
-    "@register_metric(\"MaxDrawdown\")\n",
-    "def compute_max_drawdown(\n",
-    "    returns: pd.Series,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Maximum drawdown (peak-to-trough) of cumulative returns.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return 0.0\n",
-    "    cum = (1 + r).cumprod()\n",
-    "    peak = cum.cummax()\n",
-    "    drawdown = (cum / peak) - 1\n",
-    "    return float(drawdown.min())\n",
-    "\n",
-    "# Alias for backward compatibility\n",
-    "_ann_vol = compute_volatility\n",
-    "\n",
-    "# === Aggregator with Centralized Error Handling ===\n",
-    "\n",
-    "def _stats(\n",
-    "    returns: pd.Series,\n",
-    "    cfg: RiskStatsConfig,\n",
-    "    **metric_kwargs\n",
-    ") -> namedtuple:\n",
-    "    \"\"\"\n",
-    "    Run each metric in cfg.metrics_to_run, returning a namedtuple of values.\n",
-    "    Uses cfg.periods_per_year for annualization.\n",
-    "    Centralized try/except ensures one failing metric doesn’t break the batch.\n",
-    "    \"\"\"\n",
-    "    Stat = namedtuple(\"Stat\", cfg.metrics_to_run)\n",
-    "    values: list[float] = []\n",
-    "    for name in cfg.metrics_to_run:\n",
-    "        fn = METRIC_REGISTRY.get(name)\n",
-    "        if fn is None:\n",
-    "            logging.error(\"Metric '%s' not registered\", name)\n",
-    "            values.append(np.nan)\n",
-    "            continue\n",
-    "        try:\n",
-    "            params = {\n",
-    "                \"risk_free\": cfg.risk_free,\n",
-    "                \"periods_per_year\": cfg.periods_per_year,\n",
-    "                **metric_kwargs\n",
-    "            }\n",
-    "            val = fn(returns, **params)\n",
-    "        except ZeroDivisionError:\n",
-    "            logging.warning(\"%s: division by zero, setting NaN\", name)\n",
-    "            val = np.nan\n",
-    "        except (ValueError, TypeError) as e:\n",
-    "            logging.warning(\"%s: invalid input (%s), setting NaN\", name, e)\n",
-    "            val = np.nan\n",
-    "        except Exception as e:\n",
-    "            logging.error(\"%s: unexpected error (%s), setting NaN\", name, e)\n",
-    "            val = np.nan\n",
-    "        values.append(val)\n",
-    "    return Stat(*values)\n",
-    "\n",
-    "# ---------- main ------------------------------------------------\n",
-    "def run_analysis(\n",
-    "    df,\n",
-    "    selected,\n",
-    "    w_vec,\n",
-    "    w_dict,\n",
-    "    rf_col,\n",
-    "    in_start,\n",
-    "    in_end,\n",
-    "    out_start,\n",
-    "    out_end,\n",
-    "    target_vol,\n",
-    "    monthly_cost,\n",
-    "    indices_list\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Vectorised run_analysis with correct weight re-normalisation\n",
-    "    after funds are dropped.\n",
-    "    Returns the same keys used by the UI and export functions.\n",
-    "    \"\"\"\n",
-    "    df = _ensure_dt(df)\n",
-    "\n",
-    "    # ---- date masks --------------------------------------------------\n",
-    "    in_s = pd.to_datetime(in_start)  + pd.offsets.MonthEnd(0)\n",
-    "    in_e = pd.to_datetime(in_end)    + pd.offsets.MonthEnd(0)\n",
-    "    out_s= pd.to_datetime(out_start) + pd.offsets.MonthEnd(0)\n",
-    "    out_e= pd.to_datetime(out_end)   + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    m_in  = df[\"Date\"].between(in_s,  in_e)\n",
-    "    m_out = df[\"Date\"].between(out_s, out_e)\n",
-    "\n",
-    "    in_df,  out_df  = df.loc[m_in,  selected], df.loc[m_out, selected]\n",
-    "    in_rf,  out_rf  = df.loc[m_in,  rf_col],   df.loc[m_out, rf_col]\n",
-    "\n",
-    "    # ---- drop funds with any NaNs in either window ------------------\n",
-    "    good = [f for f in selected\n",
-    "            if in_df[f].notna().all() and out_df[f].notna().all()]\n",
-    "    dropped = list(set(selected) - set(good))\n",
-    "    if dropped:\n",
-    "        logging.warning(\"Dropped funds: %s\", dropped)\n",
-    "\n",
-    "    selected = good\n",
-    "    # >>>> new guard: kick out any accidental index columns\n",
-    "    selected = [f for f in selected if f not in (indices_list or [])]\n",
-    "    # <<<<\n",
-    "\n",
-    "    in_df, out_df = in_df[selected], out_df[selected]\n",
-    "\n",
-    "    # rebuild weights\n",
-    "    if w_dict is None:                      # equal-weight path\n",
-    "        w_dict = {f: 1/len(selected) for f in selected}\n",
-    "    else:                                   # manual path → rescale\n",
-    "        pct   = {f: w_dict[f]*100 for f in selected}\n",
-    "        total = sum(pct.values())\n",
-    "        w_dict = {f: p/total for f, p in pct.items()}\n",
-    "    w_vec = np.array([w_dict[f] for f in selected])\n",
-    "\n",
-    "    # ---- scaling ----------------------------------------------------\n",
-    "    vols = in_df.apply(compute_volatility)\n",
-    "    scale = np.where(vols > 0, target_vol / vols, 1.0)\n",
-    "    in_sc  = (in_df * scale) - monthly_cost\n",
-    "    out_sc = (out_df * scale) - monthly_cost\n",
-    "    in_sc.clip(lower=-1, inplace=True)\n",
-    "    out_sc.clip(lower=-1, inplace=True)\n",
-    "\n",
-    "    # ---- stats ------------------------------------------------------\n",
-    "    rf_value = in_rf.mean() if hasattr(in_rf, \"mean\") else float(in_rf)\n",
-    "\n",
-    "    # Create a RiskStatsConfig for in-sample stats\n",
-    "    stats_cfg = RiskStatsConfig(risk_free=rf_value)\n",
-    "    \n",
-    "    # Now compute stats for each scenario, always passing stats_cfg first\n",
-    "    in_stat = {\n",
-    "        f: _stats(in_sc[f], stats_cfg)\n",
-    "        for f in selected\n",
-    "    }\n",
-    "    out_rf_value = out_rf.mean() if hasattr(out_rf, \"mean\") else float(out_rf)\n",
-    "    \n",
-    "    # Re‐use the same config, updating only the risk_free field\n",
-    "    stats_cfg.risk_free = out_rf_value\n",
-    "    \n",
-    "    out_stat = {\n",
-    "        f: _stats(out_sc[f], stats_cfg)\n",
-    "        for f in selected\n",
-    "    }\n",
-    "\n",
-    "    ew_vec = np.full(len(selected), 1/len(selected))\n",
-    "    w_vec = np.full(len(selected), 1/len(selected))\n",
-    "\n",
-    "    in_ew_stats  = _stats(in_sc.dot(ew_vec),  stats_cfg)\n",
-    "    out_ew_stats = _stats(out_sc.dot(ew_vec), stats_cfg)\n",
-    "    in_user_stats  = _stats(in_sc.dot(w_vec),  stats_cfg)\n",
-    "    out_user_stats = _stats(out_sc.dot(w_vec), stats_cfg)\n",
-    "\n",
-    "    results = {\n",
-    "        \"selected_funds\": selected,\n",
-    "        \"indices_list\":   indices_list or [],\n",
-    "        \"fund_weights\":   w_dict,\n",
-    "        \"ew_weights\":     {f: 1/len(selected) for f in selected},\n",
-    "        \"in_sample_stats\":  in_stat,\n",
-    "        \"out_sample_stats\": out_stat,\n",
-    "        \"in_ew_stats\":     in_ew_stats,\n",
-    "        \"out_ew_stats\":    out_ew_stats,\n",
-    "        \"in_user_stats\":   in_user_stats,\n",
-    "        \"out_user_stats\":  out_user_stats,\n",
-    "        \"dropped\":         dropped,\n",
-    "    }\n",
-    "\n",
-    "    # ---- optional index stats ---------------------------------------\n",
-    "    if indices_list:\n",
-    "        idx_stats = {}\n",
-    "        for col in indices_list:\n",
-    "            idx_stats[col] = {\n",
-    "                \"in_sample\":  _stats(df.loc[m_in,  col], stats_cfg),\n",
-    "                \"out_sample\": _stats(df.loc[m_out, col], stats_cfg),\n",
-    "            }\n",
-    "        results[\"index_stats\"] = idx_stats\n",
-    "\n",
-    "    return results\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 5. Excel Export\n",
-    "Creates an Excel file with In-Sample, Out-of-Sample and Equal-weight and User-weight."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  5 · EXPORT  (NaN-safe, weight-format fix)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# ───────── 5 · EXPORT  (final, bug-free) ───────────────────────\n",
-    "# ───────── 5 · EXPORT  (self-healing index section) ───────────\n",
-    "# ───────── 5 · EXPORT  (final safe version) ───────────────────\n",
-    "\n",
-    "def export_to_excel(\n",
-    "    data: dict[str, pd.DataFrame],\n",
-    "    output_path: str,\n",
-    "    default_format: Optional[Callable] = None\n",
-    ") -> None:\n",
-    "    \"\"\"\n",
-    "    Exports each DataFrame in `data` to its own sheet in `output_path`.\n",
-    "    Applies a registered formatter for each category (sheet name).\n",
-    "    If no formatter is found, applies `default_format` if provided.\n",
-    "\n",
-    "    For the Summary sheet, data is written starting at row 5 to make room for custom headers.\n",
-    "    \"\"\"\n",
-    "    startrows = {\"summary\": 5}\n",
-    "    with pd.ExcelWriter(output_path, engine=\"xlsxwriter\") as writer:\n",
-    "        for category, df in data.items():\n",
-    "            startrow = startrows.get(category, 0)\n",
-    "            df.to_excel(writer, sheet_name=category, index=False, startrow=startrow)\n",
-    "            fmt_fn = FORMATTERS_EXCEL.get(category)\n",
-    "            if fmt_fn:\n",
-    "                fmt_fn(writer.sheets[category], writer.book)\n",
-    "            elif default_format:\n",
-    "                default_format(writer.sheets[category], writer.book)\n",
-    "    # Workbook is auto-saved and closed by the context manager\n",
-    "    "
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 6. Run Parameters, Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc. Also lets us use custom weights."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "e48de568-962e-4690-a6fc-be7a4ec0a3c6",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "245d0f1fad0f4804a448f9e666313be1",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<h4>1. Load data</h4>'), ToggleButtons(description='Source:', options=(('Local', 'l…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# ===============================================================\n",
-    "#            STREAMLINED ANALYSIS UI  (phase-2 clean)\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ---------- session store ----------\n",
-    "session = {\"df\": None, \"rf\": None, \"sel\": None, \"cweights\": None}\n",
-    "\n",
-    "# ---------- 1 · DATA LOAD ----------\n",
-    "src = widgets.ToggleButtons(\n",
-    "    options=[(\"Local\", \"local\"), (\"URL\", \"url\")],\n",
-    "    description=\"Source:\"\n",
-    ")\n",
-    "\n",
-    "chooser = FileChooser()\n",
-    "url_box = widgets.Text(placeholder=\"https://…/file.csv\", layout={\"width\":\"70%\"})\n",
-    "load_btn = widgets.Button(description=\"Load CSV\", button_style=\"success\")\n",
-    "load_out = widgets.Output()\n",
-    "\n",
-    "def _toggle_src(c):\n",
-    "    chooser.layout.display = \"block\" if c[\"new\"]==\"local\" else \"none\"\n",
-    "    url_box.layout.display  = \"block\" if c[\"new\"]==\"url\"   else \"none\"\n",
-    "src.observe(_toggle_src, names=\"value\"); _toggle_src({\"new\":src.value})\n",
-    "\n",
-    "def _load(_):\n",
-    "    with load_out:\n",
-    "        clear_output()\n",
-    "        try:\n",
-    "            path = chooser.selected if src.value==\"local\" else url_box.value.strip()\n",
-    "            if not path: raise ValueError(\"choose file / URL\")\n",
-    "            if src.value==\"url\" and not path.lower().endswith(\".csv\"):\n",
-    "                raise ValueError(\"URL must end with .csv\")\n",
-    "            df = load_csv(path)\n",
-    "            df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")  # single coercion\n",
-    "            rf = identify_risk_free_fund(df)\n",
-    "            session.update(df=df, rf=rf, sel=None, cweights=None)\n",
-    "            print(f\"✅ Loaded {len(df):,} rows × {df.shape[1]} cols | RF → {rf}\")\n",
-    "        except Exception as e:\n",
-    "            print(\"❌\", e); session[\"df\"]=None\n",
-    "load_btn.on_click(_load)\n",
-    "\n",
-    "# ---------- 2 · PARAMS ------------\n",
-    "index_cnt = widgets.BoundedIntText(0, min=0, max=10, description=\"# Indices:\")\n",
-    "in_start,in_end  = widgets.Text(\"2005-07\"), widgets.Text(\"2008-06\")\n",
-    "out_start,out_end= widgets.Text(\"2008-07\"), widgets.Text(\"2009-06\")\n",
-    "for w,lbl in [(in_start,\"In Start:\"),(in_end,\"In End:\"),\n",
-    "              (out_start,\"Out Start:\"),(out_end,\"Out End:\")]:\n",
-    "    w.description = lbl\n",
-    "target_vol   = widgets.FloatText(0.25,  description=\"Target Vol:\")\n",
-    "monthly_cost = widgets.FloatText(0.0033, description=\"Monthly Cost:\")\n",
-    "\n",
-    "# ---------- 3 · SELECTION ----------\n",
-    "mode_dd = widgets.Dropdown(\n",
-    "    options=[(\"All\", \"all\"), (\"Random\", \"random\"), (\"Manual\", \"manual\")],\n",
-    "    value=\"all\",\n",
-    "    description=\"Mode:\"\n",
-    ")\n",
-    "rand_n   = widgets.BoundedIntText(5, min=2, max=100, description=\"Sample N:\")\n",
-    "fund_table, total_lbl = widgets.VBox([]), widgets.Label(\"Total = 0 %\")\n",
-    "\n",
-    "def _toggle_sel(_=None):\n",
-    "    rand_n.layout.display  = \"block\" if mode_dd.value==\"random\" else \"none\"\n",
-    "    vis = \"block\" if mode_dd.value==\"manual\" else \"none\"\n",
-    "    fund_table.layout.display = total_lbl.layout.display = vis\n",
-    "mode_dd.observe(_toggle_sel, names=\"value\"); _toggle_sel()\n",
-    "\n",
-    "# ---------- helpers ---------------\n",
-    "def _eligible_pool():\n",
-    "    df, rf = session[\"df\"], session[\"rf\"]\n",
-    "    if df is None: \n",
-    "        print(\"⚠️ data not loaded\"); return []\n",
-    "\n",
-    "    # ---- date parse guard -----------------------------------\n",
-    "    try:\n",
-    "        in_s  = pd.to_datetime(in_start.value)+pd.offsets.MonthEnd(0)\n",
-    "        in_e  = pd.to_datetime(in_end.value)  +pd.offsets.MonthEnd(0)\n",
-    "        out_s = pd.to_datetime(out_start.value)+pd.offsets.MonthEnd(0)\n",
-    "        out_e = pd.to_datetime(out_end.value)  +pd.offsets.MonthEnd(0)\n",
-    "    except Exception:\n",
-    "        print(\"❌ invalid dates\"); return []\n",
-    "\n",
-    "    # ---- build indices (RIGHT-most idx_n non-RF columns) ----\n",
-    "    idx_n     = index_cnt.value\n",
-    "    data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-    "    non_rf    = [c for c in data_cols if c != rf]\n",
-    "    indices   = non_rf[-idx_n:] if idx_n else []          # <- fixed\n",
-    "    cand      = [c for c in data_cols if c not in indices]\n",
-    "\n",
-    "    # ---- run select_funds ----------------------------------\n",
-    "    elig = select_funds(\n",
-    "        df=df,\n",
-    "        rf_col=rf,\n",
-    "        fund_columns=cand,\n",
-    "        in_sdate=in_s,\n",
-    "        in_edate=in_e,\n",
-    "        out_sdate=out_s,\n",
-    "        out_edate=out_e,\n",
-    "        cfg=cfg,                     # ← Explicitly supply your config here\n",
-    "        selection_mode=\"all\",\n",
-    "    )\n",
-    "    # … diagnostics print unchanged …\n",
-    "    return elig\n",
-    "\n",
-    "def _build_manual(*_):\n",
-    "    if mode_dd.value!=\"manual\" or session[\"df\"] is None: return\n",
-    "    valid = _eligible_pool()\n",
-    "    print(\"DEBUG  eligible funds =\", len(valid))              # ← line 1\n",
-    "    print(\"DEBUG  list sample   →\", valid[:25], \"…\")           # ← line 2\n",
-    "    if not valid:\n",
-    "        print(\"❌ No eligible funds\"); return \n",
-    "    fund_table.children = []                # reset\n",
-    "\n",
-    "    def _update_total(*_):\n",
-    "        tot = sum(r.children[1].value for r in fund_table.children\n",
-    "                  if r.children[0].value)\n",
-    "        total_lbl.value = f\"Total = {tot} %\"\n",
-    "\n",
-    "    for f in valid:\n",
-    "        cb = widgets.Checkbox(description=f, layout={\"width\":\"200px\"})\n",
-    "        wt = widgets.BoundedIntText(0, min=0, max=100,\n",
-    "                                    layout={\"width\":\"60px\"}, disabled=True)\n",
-    "        def _toggle(ch, box=wt):           # single observer\n",
-    "            box.disabled = not ch[\"new\"]\n",
-    "            if box.disabled: box.value = 0\n",
-    "            _update_total()\n",
-    "        cb.observe(_toggle, names=\"value\")\n",
-    "        wt.observe(_update_total, names=\"value\")\n",
-    "        fund_table.children += (widgets.HBox([cb, wt]),)\n",
-    "    _update_total()\n",
-    "\n",
-    "mode_dd.observe(lambda ch: _build_manual() if ch[\"new\"]==\"manual\" else None,\n",
-    "                names=\"value\")\n",
-    "for w in (in_start,in_end,out_start,out_end): w.observe(_build_manual,names=\"value\")\n",
-    "\n",
-    "# ---------- 4 · RUN ---------------\n",
-    "run_btn = widgets.Button(description=\"Run Analysis\", button_style=\"success\")\n",
-    "run_out = widgets.Output(layout={\"border\":\"1px solid #999\",\n",
-    "                                 \"height\":\"340px\",\"overflow_y\":\"auto\"})\n",
-    "\n",
-    "def _run(_):\n",
-    "    with run_out:\n",
-    "        clear_output()\n",
-    "        df, rf = session[\"df\"], session[\"rf\"]\n",
-    "        if df is None: print(\"⚠️ Load data first\"); return\n",
-    "\n",
-    "        # indices (robust)\n",
-    "        idx_n     = index_cnt.value\n",
-    "        data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-    "        non_rf    = [c for c in data_cols if c != rf]\n",
-    "        indices   = non_rf[-idx_n:] if idx_n else [] \n",
-    "\n",
-    "        # pool + selection\n",
-    "        pool = _eligible_pool()\n",
-    "        if not pool: print(\"❌ No eligible funds\"); return\n",
-    "        if mode_dd.value==\"all\":\n",
-    "            sel, custom = pool, None\n",
-    "        elif mode_dd.value==\"random\":\n",
-    "            if rand_n.value>len(pool): print(\"⚠️ Sample N too big\"); return\n",
-    "            sel, custom = list(np.random.choice(pool, rand_n.value, replace=False)), None\n",
-    "        else:\n",
-    "            sel, custom = [], {}\n",
-    "            if not fund_table.children: _build_manual()\n",
-    "            for row in fund_table.children:\n",
-    "                cb, wt = row.children\n",
-    "                if cb.value: sel.append(cb.description); custom[cb.description]=wt.value\n",
-    "            if sum(custom.values())!=100: print(\"⚠️ Weights ≠ 100\"); return\n",
-    "\n",
-    "        w_dict,w_vec = prepare_weights(sel, custom)\n",
-    "\n",
-    "        res = run_analysis(df, sel, w_vec, w_dict, rf,\n",
-    "                           in_start.value, in_end.value,\n",
-    "                           out_start.value, out_end.value,\n",
-    "                           target_vol.value, monthly_cost.value,\n",
-    "                           indices)\n",
-    "\n",
-    "        print(\"✅ analysis complete |\", len(sel), \"funds\")\n",
-    "        if res[\"dropped\"]:\n",
-    "            print(\"⚠️ Dropped:\", res[\"dropped\"])\n",
-    "        if indices: print(\"📊 Indices:\", indices)\n",
-    "\n",
-    "        fname=f\"IS_{in_start.value}_{out_start.value}.xlsx\"\n",
-    "        summary_rows = []\n",
-    "        for fund, stats_in in res[\"in_sample_stats\"].items():\n",
-    "            stats_out = res[\"out_sample_stats\"][fund]\n",
-    "            w_user    = res[\"fund_weights\"][fund]    # your custom weights\n",
-    "            w_ew      = res[\"ew_weights\"][fund]      # the equal-weight\n",
-    "            \n",
-    "            summary_rows.append({\n",
-    "                \"Name\":      fund,\n",
-    "                \"Weight %\":  w_user,\n",
-    "                \"EW %\":      w_ew,\n",
-    "                # in-sample metrics:\n",
-    "                \"R (IN)%\":   stats_in.AnnualReturn,\n",
-    "                \"V (IN)%\":   stats_in.Volatility,\n",
-    "                \"Sharpe (IN)\": stats_in.Sharpe,\n",
-    "                \"Sortino (IN)\":stats_in.Sortino,\n",
-    "                \"MDD (IN)%\": stats_in.MaxDrawdown,\n",
-    "                # out-sample metrics:\n",
-    "                \"R (OUT)%\":  stats_out.AnnualReturn,\n",
-    "                \"V (OUT)%\":  stats_out.Volatility,\n",
-    "                \"Sharpe (OUT)\": stats_out.Sharpe,\n",
-    "                \"Sortino (OUT)\":stats_out.Sortino,\n",
-    "                \"MDD (OUT)%\": stats_out.MaxDrawdown,\n",
-    "                })\n",
-    "\n",
-    "        # Now this is rectangular—each dict has the same keys:\n",
-    "        summary_df = pd.DataFrame(summary_rows)\n",
-    "        idx_rows = []\n",
-    "        for idx, idx_pair in res.get(\"index_stats\", {}).items():\n",
-    "            idx_rows.append({\n",
-    "                \"Index\": idx,\n",
-    "                \"R (IN)%\": idx_pair[\"in_sample\"].AnnualReturn,\n",
-    "                \"V (IN)%\":   stats_in.Volatility,\n",
-    "                \"Sharpe (IN)\": stats_in.Sharpe,\n",
-    "                \"Sortino (IN)\":stats_in.Sortino,\n",
-    "                \"MDD (IN)%\": stats_in.MaxDrawdown,\n",
-    "                # out-sample metrics:\n",
-    "                \"R (OUT)%\":  stats_out.AnnualReturn,\n",
-    "                \"V (OUT)%\":  stats_out.Volatility,\n",
-    "                \"Sharpe (OUT)\": stats_out.Sharpe,\n",
-    "                \"Sortino (OUT)\":stats_out.Sortino,\n",
-    "                \"MDD (OUT)%\": stats_out.MaxDrawdown,\n",
-    "                })\n",
-    "        indices_df = pd.DataFrame(idx_rows)\n",
-    "        data = {\n",
-    "            \"summary\": summary_df\n",
-    "            # \"Funds\":   funds_df,\n",
-    "            # \"Indices\": idx_df, (if you want output on separate sheets)\n",
-    "            }\n",
-    "        export_to_excel(data, fname)\n",
-    "        print(\"Workbook saved as\", fname)\n",
-    "\n",
-    "run_btn.on_click(_run)\n",
-    "\n",
-    "# ---------- DISPLAY --------------\n",
-    "display(widgets.VBox([\n",
-    "    widgets.HTML(\"<h4>1. Load data</h4>\"),\n",
-    "    src, chooser, url_box, load_btn, load_out,\n",
-    "    widgets.HTML(\"<hr><h4>2. Parameters</h4>\"),\n",
-    "    widgets.HBox([index_cnt]),\n",
-    "    widgets.HBox([in_start,in_end,out_start,out_end]),\n",
-    "    widgets.HBox([target_vol,monthly_cost]),\n",
-    "    widgets.HTML(\"<hr><h4>3. Fund selection</h4>\"),\n",
-    "    widgets.HBox([mode_dd,rand_n]),\n",
-    "    fund_table, total_lbl,\n",
-    "    widgets.HTML(\"<hr>\"),\n",
-    "    run_btn,\n",
-    "    run_out\n",
-    "]))\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "24b797fd-513c-42a7-b825-3fd5cae034be",
-   "metadata": {},
-   "outputs": [],
-   "source": []
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_1.2.TrEx-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_1.2.TrEx-checkpoint.ipynb
deleted file mode 100644
index 13036a706fb96453b2e702e0fdd06e60f703ba6d..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_1.2.TrEx-checkpoint.ipynb
+++ /dev/null
@@ -1,4333 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "22994893-0193-45bc-b9e3-a97b328ecaea",
-   "metadata": {
-    "id": "22994893-0193-45bc-b9e3-a97b328ecaea"
-   },
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Imports, Data Loader and Rf Detector\n",
-    "2. Select fund (month period logic)\n",
-    "3. Weight prep\n",
-    "4. Core Stats + Run Analysis\n",
-    "5. Export\n",
-    "6. Widget /UI\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "id": "30ea203f",
-    "tags": []
-   },
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "#      VOL-ADJ TREND ANALYSIS  –  SINGLE-FILE VERSION\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  0 · IMPORTS  (all in one place)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "import pandas as pd\n",
-    "import numpy as np\n",
-    "from dataclasses import dataclass, field\n",
-    "from collections import namedtuple\n",
-    "import xlsxwriter\n",
-    "import logging\n",
-    "from io import BytesIO\n",
-    "import ipywidgets as widgets\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "from typing import List, Dict, Optional, Callable\n",
-    "\n",
-    "logging.getLogger().setLevel(logging.ERROR)\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  1 · Class Configurations\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "@dataclass\n",
-    "class FundSelectionConfig:\n",
-    "    max_missing_months:         int = 3\n",
-    "    max_consecutive_month_gap:  int = 6\n",
-    "    implausible_value_limit: float  = 1\n",
-    "    outlier_threshold: float = 0.5\n",
-    "    zero_return_threshold: float = 0.2\n",
-    "    enforce_monotonic_index: bool = True\n",
-    "    allow_duplicate_dates: bool = False\n",
-    "    max_missing_ratio: float      = 0.05\n",
-    "    max_drawdown: float           = 0.3\n",
-    "    min_volatility: float         = 0.05\n",
-    "    max_volatility: float         = 1.0\n",
-    "    min_avg_return: float         = 0.0\n",
-    "    max_skewness: float           = 3.0\n",
-    "    max_kurtosis: float           = 10.0\n",
-    "    expected_freq: str            = \"B\"\n",
-    "    max_gap_days: int             = 3\n",
-    "    min_aum_usd: float            = 1e7\n",
-    "\n",
-    "# Configuration dataclass\n",
-    "@dataclass\n",
-    "class RiskStatsConfig:\n",
-    "    metrics_to_run: List[str] = field(default_factory=lambda: [\n",
-    "        \"AnnualReturn\", \"Volatility\", \"Sharpe\", \"Sortino\", \"MaxDrawdown\"\n",
-    "    ])\n",
-    "    risk_free: float = 0.0\n",
-    "    periods_per_year: int = 12\n",
-    "\n",
-    "# 2. Registry and decorator\n",
-    "METRIC_REGISTRY: Dict[str, Callable[[pd.Series, float, int], float]] = {}\n",
-    "\n",
-    "def register_metric(name: str):\n",
-    "    \"\"\"\n",
-    "    Decorator to register a metric function under a given name.\n",
-    "    \"\"\"\n",
-    "    def decorator(fn: Callable[pd.Series, float]):\n",
-    "        METRIC_REGISTRY[name] = fn\n",
-    "        return fn\n",
-    "    return decorator\n",
-    "\n",
-    "FORMATTERS_EXCEL: dict[str, Callable] = {}\n",
-    "def register_formatter_excel(category: str):\n",
-    "    def decorator(fn: Callable):\n",
-    "        FORMATTERS_EXCEL[category] = fn\n",
-    "        return fn\n",
-    "    return decorator\n",
-    "\n",
-    "# Example formatters (extend as needed)\n",
-    "def safe(v):\n",
-    "    \"\"\"\n",
-    "    Return blank string for missing/non-finite values; else return the value.\n",
-    "    \"\"\"\n",
-    "    if v == \"\" or pd.isna(v):\n",
-    "        return \"\"\n",
-    "    if isinstance(v, (int, float, np.generic)):\n",
-    "        return v if np.isfinite(v) else \"\"\n",
-    "    return \"\"\n",
-    "\n",
-    "def pct(t: tuple[float, float, float, float, float]) -> list[float]:\n",
-    "    \"\"\"\n",
-    "    Convert a Stat tuple of five elements into a list of values scaled as percentages for\n",
-    "    the 1st, 2nd, and 5th elements.\n",
-    "    \"\"\"\n",
-    "    return [t[0]*100, t[1]*100, t[2], t[3], t[4]*100]\n",
-    "    if isinstance(v, (int, float, np.generic)):\n",
-    "        return v if np.isfinite(v) else \"\"\n",
-    "    return \"\"\n",
-    "\n",
-    "# Consolidated Summary Formatter Factory\n",
-    "\n",
-    "def make_summary_formatter(\n",
-    "    res: dict,\n",
-    "    in_start: str,\n",
-    "    in_end: str,\n",
-    "    out_start: str,\n",
-    "    out_end: str\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Registers a single 'summary' sheet formatter that writes:\n",
-    "      1. Portfolio rows (Equal & User weight),\n",
-    "      2. Blank spacer,\n",
-    "      3. Fund rows,\n",
-    "      4. Blank spacer,\n",
-    "      5. Index rows\n",
-    "    using the data in `res`.\n",
-    "    \"\"\"\n",
-    "    @register_formatter_excel(\"summary\")\n",
-    "    def fmt_summary(ws, wb):\n",
-    "        # Predefine formats\n",
-    "        bold = wb.add_format({\"bold\": True})\n",
-    "        int0 = wb.add_format({\"num_format\": \"0\"})\n",
-    "        num2 = wb.add_format({\"num_format\": \"0.00\"})\n",
-    "        red  = wb.add_format({\"num_format\": \"0.00\", \"font_color\": \"red\"})\n",
-    "        safe = lambda v: \"\" if (pd.isna(v) or not np.isfinite(v)) else v\n",
-    "        pct  = lambda t: [t[0]*100, t[1]*100, t[2], t[3], t[4]*100]\n",
-    "\n",
-    "        # Write static headers\n",
-    "        ws.write_row(0, 0, [\"Vol-Adj Trend Analysis\"], bold)\n",
-    "        ws.write_row(1, 0, [f\"In:  {in_start} → {in_end}\"], bold)\n",
-    "        ws.write_row(2, 0, [f\"Out: {out_start} → {out_end}\"], bold)\n",
-    "\n",
-    "        row = 5\n",
-    "        # 1. Portfolio rows\n",
-    "        for label, in_s, out_s in [\n",
-    "            (\"Equal Weight\", res[\"in_ew_stats\"], res[\"out_ew_stats\"]),\n",
-    "            (\"User Weight\",  res[\"in_user_stats\"], res[\"out_user_stats\"])\n",
-    "        ]:\n",
-    "            ws.write(row, 0, label, bold)\n",
-    "            ws.write(row, 1, safe(\"\") if True else int0)\n",
-    "            vals = pct(tuple(in_s)) + pct(tuple(out_s))\n",
-    "            fmts = ([num2]*4 + [red]) * 2\n",
-    "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-    "                ws.write(row, col, safe(v), fmt)\n",
-    "            row += 1\n",
-    "\n",
-    "        # spacer\n",
-    "        row += 1\n",
-    "\n",
-    "        # 2. Fund rows\n",
-    "        for fund, stat_in in res[\"in_sample_stats\"].items():\n",
-    "            stat_out = res[\"out_sample_stats\"][fund]\n",
-    "            ws.write(row, 0, fund, bold)\n",
-    "            wt = res[\"fund_weights\"][fund]\n",
-    "            ws.write(row, 1, safe(wt*100), int0)\n",
-    "            vals = pct(tuple(stat_in)) + pct(tuple(stat_out))\n",
-    "            fmts = ([num2]*4 + [red]) * 2\n",
-    "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-    "                ws.write(row, col, safe(v), fmt)\n",
-    "            row += 1\n",
-    "\n",
-    "        # spacer\n",
-    "        row += 1\n",
-    "\n",
-    "        # 3. Index rows\n",
-    "        for idx, pair in res.get(\"index_stats\", {}).items():\n",
-    "            in_idx = pair[\"in_sample\"]\n",
-    "            out_idx= pair[\"out_sample\"]\n",
-    "            ws.write(row, 0, idx, bold)\n",
-    "            ws.write(row, 1, safe(\"\") if True else int0)\n",
-    "            vals = pct(tuple(in_idx)) + pct(tuple(out_idx))\n",
-    "            fmts = ([num2]*4 + [red]) * 2\n",
-    "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-    "                ws.write(row, col, safe(v), fmt)\n",
-    "            row += 1\n",
-    "\n",
-    "    return fmt_summary\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  2 · CSV LOADER + RF DETECTOR\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "logger = logging.getLogger(__name__)\n",
-    "\n",
-    "def load_csv(path: str) -> pd.DataFrame | None:\n",
-    "    try:\n",
-    "        df = pd.read_csv(path)\n",
-    "    except FileNotFoundError as e:\n",
-    "        logger.error(f\"File not found: {path}\")\n",
-    "        return None\n",
-    "    except pd.errors.EmptyDataError:\n",
-    "        logger.error(f\"No data in file: {path}\")\n",
-    "        return None\n",
-    "    except pd.errors.ParserError as e:\n",
-    "        logger.error(f\"Parsing error in {path}: {e}\")\n",
-    "        return None\n",
-    "\n",
-    "    if \"Date\" not in df.columns:\n",
-    "        logger.error(f\"Validation failed ({path}): missing 'Date' column\")\n",
-    "        return None\n",
-    "\n",
-    "    # Optionally check for NaNs in 'Date' column\n",
-    "    if df[\"Date\"].isnull().any():\n",
-    "        logger.warning(f\"Null values found in 'Date' column of {path}\")\n",
-    "\n",
-    "    return df\n",
-    "\n",
-    "def identify_risk_free_fund(df: pd.DataFrame) -> str:\n",
-    "    returns = df.drop(columns=\"Date\", errors=\"ignore\")\n",
-    "    stdevs  = returns.std(skipna=True, ddof=0)\n",
-    "    return stdevs.idxmin()"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {
-    "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c"
-   },
-   "source": [
-    "## 2. Select Funds"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {
-    "id": "ff528d69-5a52-4b75-8af4-17974826f4ab"
-   },
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "# 2 · SELECT_FUNDS  (restored ≤ 3-missing-months rule)\n",
-    "# ===============================================================\n",
-    "\n",
-    "cfg = FundSelectionConfig(\n",
-    "    max_missing_months           = 3,\n",
-    "    max_consecutive_month_gap    = 6,\n",
-    "    outlier_threshold            = 0.5,\n",
-    "    zero_return_threshold        = 0.2,\n",
-    "    enforce_monotonic_index      = True,\n",
-    "    allow_duplicate_dates        = False,\n",
-    "    max_missing_ratio            = 0.05,\n",
-    "    max_drawdown                 = 0.3,\n",
-    "    min_volatility               = 0.05,\n",
-    "    max_volatility               = 1.0,\n",
-    "    min_avg_return               = 0.0,\n",
-    "    max_skewness                 = 3.0,\n",
-    "    max_kurtosis                 = 10.0,\n",
-    "    expected_freq                = \"B\",\n",
-    "    max_gap_days                 = 3,\n",
-    "    min_aum_usd                  = 1e7,\n",
-    ")\n",
-    "\n",
-    "def select_funds(\n",
-    "    df: pd.DataFrame,\n",
-    "    rf_col: str,\n",
-    "    fund_columns: list[str],\n",
-    "    in_sdate: str,\n",
-    "    in_edate: str,\n",
-    "    out_sdate: str,\n",
-    "    out_edate: str,\n",
-    "    cfg: FundSelectionConfig,\n",
-    "    selection_mode: str = \"all\",\n",
-    "    random_n: int | None = None\n",
-    ") -> list[str]:\n",
-    "    \"\"\"\n",
-    "    Select eligible funds with additional data-validity and coverage checks driven by FundSelectionConfig.\n",
-    "    \"\"\"\n",
-    "    # Ensure Date is datetime and sorted\n",
-    "    if not pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        df = df.copy()\n",
-    "        df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "        df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "    df = df.sort_values(\"Date\")  # guarantee monotonic index\n",
-    "\n",
-    "    # Prepare monthly periods within analysis window\n",
-    "    df[\"Month\"] = df[\"Date\"].dt.to_period(\"M\")\n",
-    "    span = pd.period_range(\n",
-    "        pd.Period(in_sdate, \"M\"), pd.Period(out_edate, \"M\"), freq=\"M\"\n",
-    "    )\n",
-    "\n",
-    "    eligible_funds: list[str] = []\n",
-    "    for f in fund_columns:\n",
-    "        try:\n",
-    "            ser = df.set_index(\"Date\")[f]\n",
-    "            clean = ser.dropna()\n",
-    "\n",
-    "            # 1. Implausible value limits\n",
-    "            if not clean.between(-cfg.implausible_value_limit, cfg.implausible_value_limit).all():\n",
-    "                raise ValueError(f\"Values outside ±{cfg.implausible_value_limit}\")\n",
-    "\n",
-    "            # 2. Extreme outlier threshold\n",
-    "            if (clean.abs() > cfg.outlier_threshold).any():\n",
-    "                raise ValueError(f\"Outliers beyond ±{cfg.outlier_threshold}\")\n",
-    "\n",
-    "            # 3. Excessive zero-return rate\n",
-    "            if (clean == 0).mean() > cfg.zero_return_threshold:\n",
-    "                raise ValueError(f\"Zero-return proportion > {cfg.zero_return_threshold}\")\n",
-    "\n",
-    "            # 4. Monotonic date index\n",
-    "            if cfg.enforce_monotonic_index and not clean.index.is_monotonic_increasing:\n",
-    "                raise ValueError(\"Date index not monotonically increasing\")\n",
-    "\n",
-    "            # 5. Duplicate dates\n",
-    "            if not cfg.allow_duplicate_dates and clean.index.duplicated().any():\n",
-    "                raise ValueError(\"Duplicate dates detected in index\")\n",
-    "\n",
-    "            # 6. Coverage checks using config thresholds\n",
-    "            m_ok = df.groupby(\"Month\")[f].apply(lambda col: col.notna().any())\n",
-    "            mask = m_ok.reindex(span, fill_value=False).to_numpy()\n",
-    "\n",
-    "            # tolerance for missing months per-cfg\n",
-    "            missing_count = (~mask).sum()\n",
-    "            if missing_count > cfg.max_missing_months:\n",
-    "                raise ValueError(f\"Missing-month count {missing_count} exceeds {cfg.max_missing_months}\")\n",
-    "\n",
-    "            # maximum run of consecutive missing months per-cfg with guard\n",
-    "            temp = np.flatnonzero(np.r_[True, mask, True])\n",
-    "            if temp.size <= 1:\n",
-    "                gap = 0\n",
-    "            else:\n",
-    "                gap = np.diff(temp).max() - 1\n",
-    "            if gap > cfg.max_consecutive_month_gap:\n",
-    "                raise ValueError(f\"Consecutive-missing gap {gap} exceeds {cfg.max_consecutive_month_gap}\")\n",
-    "\n",
-    "            eligible_funds.append(f)\n",
-    "\n",
-    "        except ValueError as e:\n",
-    "            logging.warning(\"Excluded %s: %s\", f, e)\n",
-    "        except KeyError as e:\n",
-    "            logging.warning(\"Missing data for %s: %s\", f, e)\n",
-    "        except Exception as e:\n",
-    "            logging.warning(\"Unexpected error on %s: %s\", f, e)\n",
-    "\n",
-    "    # Final selection-mode logic\n",
-    "    if selection_mode == \"all\" or random_n is None:\n",
-    "        return eligible_funds\n",
-    "    if selection_mode == \"random\":\n",
-    "        if random_n > len(eligible_funds):\n",
-    "            raise ValueError(\n",
-    "                f\"random_n exceeds eligible pool: {random_n} > {len(eligible_funds)}\"\n",
-    "            )\n",
-    "        return list(np.random.choice(eligible_funds, random_n, replace=False))\n",
-    "\n",
-    "    raise ValueError(f\"Unsupported selection_mode '{selection_mode}'\")\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {
-    "id": "ac53bc18"
-   },
-   "source": [
-    "## 3. Weight Prep"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {
-    "id": "59a9bf13"
-   },
-   "outputs": [],
-   "source": [
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  3 · WEIGHT PREP\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "def prepare_weights(selected: list[str],\n",
-    "                    custom: Dict[str, int] | None) -> tuple[Dict[str, float], np.ndarray]:\n",
-    "    if not custom:\n",
-    "        w = {f: 1/len(selected) for f in selected}\n",
-    "    else:\n",
-    "        missing = [f for f in selected if f not in custom]\n",
-    "        if missing:\n",
-    "            raise ValueError(f\"Missing weights for {missing}\")\n",
-    "        w = {f: pct/100 for f, pct in custom.items()}\n",
-    "        if abs(sum(w.values()) - 1) > 1e-6:\n",
-    "            raise ValueError(\"Custom weights must sum to 100.\")\n",
-    "    vec = np.array([w[f] for f in selected])\n",
-    "    return w, vec"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {
-    "id": "b3666a84"
-   },
-   "source": [
-    "## 4. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Function definitions\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {
-    "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44"
-   },
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "# 4 · CORE STATS  +  RUN_ANALYSIS  (helpers included, weight fix)\n",
-    "# ===============================================================\n",
-    "\n",
-    "M_PER_YEAR = 12           # constant used across helpers\n",
-    "\n",
-    "# ---------- helpers --------------------------------------------\n",
-    "def _ensure_dt(df: pd.DataFrame) -> pd.DataFrame:\n",
-    "    \"\"\"Return a copy whose Date column is datetime64[ns].\"\"\"\n",
-    "    if pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        return df\n",
-    "    df = df.copy()\n",
-    "    df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "    df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "    return df\n",
-    "\n",
-    "# 3. Metric function definitions\n",
-    "# === Metric Function Definitions with flexible annualization ===\n",
-    "@register_metric(\"AnnualReturn\")\n",
-    "def compute_annual_return(\n",
-    "    returns: pd.Series,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Geometric annualized return based on periods_per_year.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return np.nan\n",
-    "    total_growth = (1 + r).prod()\n",
-    "    n_periods = len(r)\n",
-    "    return total_growth ** (periods_per_year / n_periods) - 1\n",
-    "\n",
-    "@register_metric(\"Volatility\")\n",
-    "def compute_volatility(\n",
-    "    returns: pd.Series,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Annualized standard deviation of returns with flexible scaling.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return 0.0\n",
-    "    return r.std(ddof=0) * np.sqrt(periods_per_year)\n",
-    "\n",
-    "@register_metric(\"Sharpe\")\n",
-    "def compute_sharpe(\n",
-    "    returns: pd.Series,\n",
-    "    risk_free: float = 0.0,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Sharpe ratio using flexible annualized return and volatility.\n",
-    "    \"\"\"\n",
-    "    vol = compute_volatility(returns, periods_per_year=periods_per_year)\n",
-    "    if vol == 0:\n",
-    "        return np.nan\n",
-    "    ann_ret = compute_annual_return(returns, periods_per_year=periods_per_year)\n",
-    "    return (ann_ret - risk_free) / vol\n",
-    "\n",
-    "@register_metric(\"Sortino\")\n",
-    "def compute_sortino(\n",
-    "    returns: pd.Series,\n",
-    "    risk_free: float = 0.0,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Sortino ratio using flexible annualized return and downside deviation.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return np.nan\n",
-    "    ann_ret = compute_annual_return(returns, periods_per_year=periods_per_year)\n",
-    "    # Define per-period risk-free rate\n",
-    "    period_rf = risk_free / periods_per_year\n",
-    "    excess = r - period_rf\n",
-    "    downside = excess[excess < 0]\n",
-    "    if downside.empty:\n",
-    "        return np.nan\n",
-    "    down_dev = np.sqrt((downside ** 2).mean()) * np.sqrt(periods_per_year)\n",
-    "    if down_dev == 0:\n",
-    "        return np.nan\n",
-    "    return (ann_ret - risk_free) / down_dev\n",
-    "\n",
-    "@register_metric(\"MaxDrawdown\")\n",
-    "def compute_max_drawdown(\n",
-    "    returns: pd.Series,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Maximum drawdown (peak-to-trough) of cumulative returns.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return 0.0\n",
-    "    cum = (1 + r).cumprod()\n",
-    "    peak = cum.cummax()\n",
-    "    drawdown = (cum / peak) - 1\n",
-    "    return float(drawdown.min())\n",
-    "\n",
-    "# Alias for backward compatibility\n",
-    "_ann_vol = compute_volatility\n",
-    "\n",
-    "# === Aggregator with Centralized Error Handling ===\n",
-    "\n",
-    "def _stats(\n",
-    "    returns: pd.Series,\n",
-    "    cfg: RiskStatsConfig,\n",
-    "    **metric_kwargs\n",
-    ") -> namedtuple:\n",
-    "    \"\"\"\n",
-    "    Run each metric in cfg.metrics_to_run, returning a namedtuple of values.\n",
-    "    Uses cfg.periods_per_year for annualization.\n",
-    "    Centralized try/except ensures one failing metric doesn’t break the batch.\n",
-    "    \"\"\"\n",
-    "    Stat = namedtuple(\"Stat\", cfg.metrics_to_run)\n",
-    "    values: list[float] = []\n",
-    "    for name in cfg.metrics_to_run:\n",
-    "        fn = METRIC_REGISTRY.get(name)\n",
-    "        if fn is None:\n",
-    "            logging.error(\"Metric '%s' not registered\", name)\n",
-    "            values.append(np.nan)\n",
-    "            continue\n",
-    "        try:\n",
-    "            params = {\n",
-    "                \"risk_free\": cfg.risk_free,\n",
-    "                \"periods_per_year\": cfg.periods_per_year,\n",
-    "                **metric_kwargs\n",
-    "            }\n",
-    "            val = fn(returns, **params)\n",
-    "        except ZeroDivisionError:\n",
-    "            logging.warning(\"%s: division by zero, setting NaN\", name)\n",
-    "            val = np.nan\n",
-    "        except (ValueError, TypeError) as e:\n",
-    "            logging.warning(\"%s: invalid input (%s), setting NaN\", name, e)\n",
-    "            val = np.nan\n",
-    "        except Exception as e:\n",
-    "            logging.error(\"%s: unexpected error (%s), setting NaN\", name, e)\n",
-    "            val = np.nan\n",
-    "        values.append(val)\n",
-    "    return Stat(*values)\n",
-    "\n",
-    "# ---------- main ------------------------------------------------\n",
-    "def run_analysis(\n",
-    "    df,\n",
-    "    selected,\n",
-    "    w_vec,\n",
-    "    w_dict,\n",
-    "    rf_col,\n",
-    "    in_start,\n",
-    "    in_end,\n",
-    "    out_start,\n",
-    "    out_end,\n",
-    "    target_vol,\n",
-    "    monthly_cost,\n",
-    "    indices_list\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Vectorised run_analysis with correct weight re-normalisation\n",
-    "    after funds are dropped.\n",
-    "    Returns the same keys used by the UI and export functions.\n",
-    "    \"\"\"\n",
-    "    df = _ensure_dt(df)\n",
-    "\n",
-    "    # ---- date masks --------------------------------------------------\n",
-    "    in_s = pd.to_datetime(in_start)  + pd.offsets.MonthEnd(0)\n",
-    "    in_e = pd.to_datetime(in_end)    + pd.offsets.MonthEnd(0)\n",
-    "    out_s= pd.to_datetime(out_start) + pd.offsets.MonthEnd(0)\n",
-    "    out_e= pd.to_datetime(out_end)   + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    m_in  = df[\"Date\"].between(in_s,  in_e)\n",
-    "    m_out = df[\"Date\"].between(out_s, out_e)\n",
-    "\n",
-    "    in_df,  out_df  = df.loc[m_in,  selected], df.loc[m_out, selected]\n",
-    "    in_rf,  out_rf  = df.loc[m_in,  rf_col],   df.loc[m_out, rf_col]\n",
-    "\n",
-    "    # ---- drop funds with any NaNs in either window ------------------\n",
-    "    good = [f for f in selected\n",
-    "            if in_df[f].notna().all() and out_df[f].notna().all()]\n",
-    "    dropped = list(set(selected) - set(good))\n",
-    "    if dropped:\n",
-    "        logging.warning(\"Dropped funds: %s\", dropped)\n",
-    "\n",
-    "    selected = good\n",
-    "    # >>>> new guard: kick out any accidental index columns\n",
-    "    selected = [f for f in selected if f not in (indices_list or [])]\n",
-    "    # <<<<\n",
-    "\n",
-    "    in_df, out_df = in_df[selected], out_df[selected]\n",
-    "\n",
-    "    # rebuild weights\n",
-    "    if w_dict is None:                      # equal-weight path\n",
-    "        w_dict = {f: 1/len(selected) for f in selected}\n",
-    "    else:                                   # manual path → rescale\n",
-    "        pct   = {f: w_dict[f]*100 for f in selected}\n",
-    "        total = sum(pct.values())\n",
-    "        w_dict = {f: p/total for f, p in pct.items()}\n",
-    "    w_vec = np.array([w_dict[f] for f in selected])\n",
-    "\n",
-    "    # ---- scaling ----------------------------------------------------\n",
-    "    vols = in_df.apply(compute_volatility)\n",
-    "    scale = np.where(vols > 0, target_vol / vols, 1.0)\n",
-    "    in_sc  = (in_df * scale) - monthly_cost\n",
-    "    out_sc = (out_df * scale) - monthly_cost\n",
-    "    in_sc.clip(lower=-1, inplace=True)\n",
-    "    out_sc.clip(lower=-1, inplace=True)\n",
-    "\n",
-    "    # ---- stats ------------------------------------------------------\n",
-    "    rf_value = in_rf.mean() if hasattr(in_rf, \"mean\") else float(in_rf)\n",
-    "\n",
-    "    # Create a RiskStatsConfig for in-sample stats\n",
-    "    stats_cfg = RiskStatsConfig(risk_free=rf_value)\n",
-    "\n",
-    "    # Now compute stats for each scenario, always passing stats_cfg first\n",
-    "    in_stat = {\n",
-    "        f: _stats(in_sc[f], stats_cfg)\n",
-    "        for f in selected\n",
-    "    }\n",
-    "    out_rf_value = out_rf.mean() if hasattr(out_rf, \"mean\") else float(out_rf)\n",
-    "\n",
-    "    # Re‐use the same config, updating only the risk_free field\n",
-    "    stats_cfg.risk_free = out_rf_value\n",
-    "\n",
-    "    out_stat = {\n",
-    "        f: _stats(out_sc[f], stats_cfg)\n",
-    "        for f in selected\n",
-    "    }\n",
-    "\n",
-    "    ew_vec = np.full(len(selected), 1/len(selected))\n",
-    "    w_vec = np.full(len(selected), 1/len(selected))\n",
-    "\n",
-    "    in_ew_stats  = _stats(in_sc.dot(ew_vec),  stats_cfg)\n",
-    "    out_ew_stats = _stats(out_sc.dot(ew_vec), stats_cfg)\n",
-    "    in_user_stats  = _stats(in_sc.dot(w_vec),  stats_cfg)\n",
-    "    out_user_stats = _stats(out_sc.dot(w_vec), stats_cfg)\n",
-    "\n",
-    "    results = {\n",
-    "        \"selected_funds\": selected,\n",
-    "        \"indices_list\":   indices_list or [],\n",
-    "        \"fund_weights\":   w_dict,\n",
-    "        \"ew_weights\":     {f: 1/len(selected) for f in selected},\n",
-    "        \"in_sample_stats\":  in_stat,\n",
-    "        \"out_sample_stats\": out_stat,\n",
-    "        \"in_ew_stats\":     in_ew_stats,\n",
-    "        \"out_ew_stats\":    out_ew_stats,\n",
-    "        \"in_user_stats\":   in_user_stats,\n",
-    "        \"out_user_stats\":  out_user_stats,\n",
-    "        \"dropped\":         dropped,\n",
-    "    }\n",
-    "\n",
-    "    # ---- optional index stats ---------------------------------------\n",
-    "    if indices_list:\n",
-    "        idx_stats = {}\n",
-    "        for col in indices_list:\n",
-    "            idx_stats[col] = {\n",
-    "                \"in_sample\":  _stats(df.loc[m_in,  col], stats_cfg),\n",
-    "                \"out_sample\": _stats(df.loc[m_out, col], stats_cfg),\n",
-    "            }\n",
-    "        results[\"index_stats\"] = idx_stats\n",
-    "\n",
-    "    return results\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {
-    "id": "183dc5df"
-   },
-   "source": [
-    "## 5. Excel Export\n",
-    "Creates an Excel file with In-Sample, Out-of-Sample and Equal-weight and User-weight."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "8e2cce23",
-   "metadata": {
-    "id": "8e2cce23"
-   },
-   "outputs": [],
-   "source": [
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  5 · EXPORT  (NaN-safe, weight-format fix)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# ───────── 5 · EXPORT  (final, bug-free) ───────────────────────\n",
-    "# ───────── 5 · EXPORT  (self-healing index section) ───────────\n",
-    "# ───────── 5 · EXPORT  (final safe version) ───────────────────\n",
-    "\n",
-    "def export_to_excel(\n",
-    "    data: dict[str, pd.DataFrame],\n",
-    "    output_path: str,\n",
-    "    default_format: Optional[Callable] = None\n",
-    ") -> None:\n",
-    "    \"\"\"\n",
-    "    Exports each DataFrame in `data` to its own sheet in `output_path`.\n",
-    "    Applies a registered formatter for each category (sheet name).\n",
-    "    If no formatter is found, applies `default_format` if provided.\n",
-    "\n",
-    "    For the Summary sheet, data is written starting at row 5 to make room for custom headers.\n",
-    "    \"\"\"\n",
-    "    startrows = {\"summary\": 5}\n",
-    "    with pd.ExcelWriter(output_path, engine=\"xlsxwriter\") as writer:\n",
-    "        for category, df in data.items():\n",
-    "            startrow = startrows.get(category, 0)\n",
-    "            df.to_excel(writer, sheet_name=category, index=False, startrow=startrow, header=False)\n",
-    "            fn = FORMATTERS_EXCEL.get(category, default_format)\n",
-    "            if fn: fn(writer.sheets[category], writer.book)\n",
-    "    # Workbook is auto-saved and closed by the context manager\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {
-    "id": "ee8c2c6d"
-   },
-   "source": [
-    "## 6. Run Parameters, Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc. Also lets us use custom weights."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {
-    "id": "86794206"
-   },
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  },
-  {
-   "cell_type": "raw",
-   "id": "acfafc55-1801-4641-9e81-4b7239e99010",
-   "metadata": {
-    "colab": {
-     "base_uri": "https://localhost:8080/",
-     "height": 896,
-     "referenced_widgets": [
-      "8face5cf545b40ceaf10b1506e754d71",
-      "db185d3992024056acfa2ffe419931d8",
-      "c459f2c677ff4bea8db916696b7b600e",
-      "170d05f5ba184c13bb39914b17257476",
-      "64045569d769471e92ac17aebf71022f",
-      "f83a99900b324015862cad100f5bfc0c",
-      "ee231bb4cb97454591e7a6774bb2f7bd",
-      "eceecb3f8a864d1eb15aab7d531e3cd1",
-      "75ad9c9f175f4960999958cd9f6d056a",
-      "e0d83789c4034d9ab9b3c2fa85870beb",
-      "ae753571f5814a65865abbdb10540373",
-      "125e415320644832a8be95b92713e257",
-      "8c053f4df9ff486f84b123eda524cbe7",
-      "d3bae0e7a2474ea4bdce0b0b9e413059",
-      "516389ac0f0042a0bbeab3bd64493997",
-      "e7dc4acbb2eb4a0e8c5112e4b2a85393",
-      "332172fad96e4be2857e530ba9df86c6",
-      "354bbc188daa4493967e2b143ceea510",
-      "6dc67c18884044ac811b3a256f69171e",
-      "d80f632f65c44c338a41d0b4e3dc5ea7",
-      "9a302560059a43338397161ea2ad37c7",
-      "a8d2ae4652394bb4b2a740097a4d7ea7",
-      "dbe1076d681040169eca1b570e2485e2",
-      "593aad971d274b90b56cecc15e09dc39",
-      "6418ed5196fd485cae29568a24bf60ae",
-      "d12e413cbeac41a39fd9b94479c1eca8",
-      "10e898df8a0e460b9f3e3a40b48f51f4",
-      "97212667726d480eb944e25ec32cfc25",
-      "6e75d93c40ea4c40b9162ab51e807d98",
-      "646d2e69e110438fa2feb8b60af24bb7",
-      "47ae7b5e18314a2596b33cc6c774942b",
-      "05a596b6c3864ddc931b3112153f12ab",
-      "8f3ec331c368446b8552a06238a12608",
-      "3814c0e0fa1c438e87df5b60a82dd3e4",
-      "6c7f140622534a6cab6133758aa7a936",
-      "5759bee9a2034ed3b9b4196e158b58eb",
-      "6e5e4fc36c674146a86dc3f8b6edbd7d",
-      "fa9ee776b338497e9385f3d1a8d02fff",
-      "32bac6722d6d47a6b5a88372e9e5d44e",
-      "dfbe93388b474442833b5e7b7efc1e5f",
-      "d13209a7e5c94f6585d47c2430fa7885",
-      "704f7526c3934eed85b653fb00714114",
-      "08882c12ccaa4d058bc554020c044559",
-      "1c01c7f8d62041198190f4bfbe21aff5",
-      "9ac98c85e0f147f8a191f6d32651d0cc",
-      "e00ed42085424c6f91fb07fb2d22ee62",
-      "818aa783706f4087a3754d39d861ced6",
-      "258e8504f9cc4be783ea207c43e56214",
-      "bedc16eeb19740bb9ee6e810bc9b7a71",
-      "2e2775bb4c6e4b98ba4706d90b24e042",
-      "b411a590b161465185dfd853a6dd95d6",
-      "a503b43ca679455f978c6903bdb598cf",
-      "70dfa008682a460aa02625a933b33606",
-      "514e5aafad0044cb9df9232ef0a4e264",
-      "367366f650c644d59791946a3c8d86d0",
-      "15de8a73c52642c598ad8baeb3609499",
-      "2e6724a498d54c73a8f594b19c6a3d20",
-      "09e8f8999ea1463a9d603da4f4f70b12",
-      "1da4518f46b84fc7b84d387c7e34f050",
-      "021e4dc72d814e5d8c42592b541b6723",
-      "97f4dce2a3874dafaeb0ba92775ae2a0",
-      "f5539db7aca6440e9c3dee43697c4fae",
-      "2e96cf393a754d279bcf02c66548f6dd",
-      "0b231b28c644443db3e659a17096f55c",
-      "62c2030d08cf4f1e91c9c9038f31b864",
-      "e5c317ba51ed45818d7d60cc4aaec11d",
-      "7e5dd5f9379a4104ad7965a34e569a7a",
-      "383dee58194446698cb8eb9df41b7778",
-      "72bdf8a1ccfa4d0985547020c90908a0",
-      "8a9b22cd239d43d191387ebc9e660ff8",
-      "86a9efbe68f5450685a4e8aa1c96e84e",
-      "38d3e511fdc14bcaa7b04d8583be18dc",
-      "8d9670b7900c40b8849f7e4629d50424",
-      "eed45853cf99427398e7b16f2cab9f8b",
-      "5363ac1b24b24811ae9c63b86dfbf359",
-      "74577bb60c55412d9c38960d7d865fd6",
-      "d37456fcb76f4acda7978257483bf2ad",
-      "d6710d2b4b0b4b02b5358d2d152fbad9",
-      "ca05ab87b3e040cbbf4016ae0671fc40",
-      "958a21d97fa546a2b314e2c988b43589",
-      "202010c9f8324e1493baa92d83ff9335",
-      "4a022a6055c34004b7a3aa671a168ee3",
-      "c9b1027aad95413c94835aef5ce74a5b",
-      "ae45af3a4d3d4fb8b1c2827585ed7f7f",
-      "574d70e37e6a449dbdd4365c2d86fda8",
-      "d9f6106f986b4ea49d957594d8d5c324",
-      "e8b9fd55c6094126b24ab2e7cffa4dc5",
-      "f5e355edbbc946b3b6e1ba36f839d45b",
-      "78906e475e9d4bda8b7e0c4ca4de577c",
-      "65dbf5a3b3a2406aa9f807b74dc5543b",
-      "269ab898c24e4cf697ad3dc2854a7215",
-      "ff9bd5c776a741248e4a64d445950c90",
-      "4b551eab21b34f488d743ea730a541d8",
-      "05b7cb98ce374c10828efb3d205fe4ff",
-      "6c1e290b8fdf4e31872f11e0c5438b5d",
-      "be7153ab36374e62a7d6a234dc1c973e",
-      "d22068b3d502469fa1631d698a3d3779",
-      "e02a002607844c6ba0249122b505b8f5",
-      "d807a3a60ca14ddda5fbec481049b6d4"
-     ]
-    },
-    "id": "e48de568-962e-4690-a6fc-be7a4ec0a3c6",
-    "outputId": "795bb6da-96a0-42e2-c760-7d516fd82610"
-   },
-   "source": [
-    "# ===============================================================\n",
-    "#            STREAMLINED ANALYSIS UI  (phase-2 clean)\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ---------- session store ----------\n",
-    "session = {\"df\": None, \"rf\": None, \"sel\": None, \"cweights\": None}\n",
-    "\n",
-    "# ---------- 1 · DATA LOAD ----------\n",
-    "src = widgets.ToggleButtons(\n",
-    "    options=[(\"Local\", \"local\"), (\"URL\", \"url\")],\n",
-    "    description=\"Source:\"\n",
-    ")\n",
-    "\n",
-    "chooser = FileChooser()\n",
-    "url_box = widgets.Text(placeholder=\"https://…/file.csv\", layout={\"width\":\"70%\"})\n",
-    "load_btn = widgets.Button(description=\"Load CSV\", button_style=\"success\")\n",
-    "load_out = widgets.Output()\n",
-    "\n",
-    "def _toggle_src(c):\n",
-    "    chooser.layout.display = \"block\" if c[\"new\"]==\"local\" else \"none\"\n",
-    "    url_box.layout.display  = \"block\" if c[\"new\"]==\"url\"   else \"none\"\n",
-    "src.observe(_toggle_src, names=\"value\"); _toggle_src({\"new\":src.value})\n",
-    "\n",
-    "def _load(_):\n",
-    "    with load_out:\n",
-    "        clear_output()\n",
-    "        try:\n",
-    "            path = chooser.selected if src.value==\"local\" else url_box.value.strip()\n",
-    "            if not path: raise ValueError(\"choose file / URL\")\n",
-    "            if src.value==\"url\" and not path.lower().endswith(\".csv\"):\n",
-    "                raise ValueError(\"URL must end with .csv\")\n",
-    "            df = load_csv(path)\n",
-    "            df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")  # single coercion\n",
-    "            rf = identify_risk_free_fund(df)\n",
-    "            session.update(df=df, rf=rf, sel=None, cweights=None)\n",
-    "            print(f\"✅ Loaded {len(df):,} rows × {df.shape[1]} cols | RF → {rf}\")\n",
-    "        except Exception as e:\n",
-    "            print(\"❌\", e); session[\"df\"]=None\n",
-    "load_btn.on_click(_load)\n",
-    "\n",
-    "# ---------- 2 · PARAMS ------------\n",
-    "index_cnt = widgets.BoundedIntText(0, min=0, max=10, description=\"# Indices:\")\n",
-    "in_start,in_end  = widgets.Text(\"2005-07\"), widgets.Text(\"2008-06\")\n",
-    "out_start,out_end= widgets.Text(\"2008-07\"), widgets.Text(\"2009-06\")\n",
-    "for w,lbl in [(in_start,\"In Start:\"),(in_end,\"In End:\"),\n",
-    "              (out_start,\"Out Start:\"),(out_end,\"Out End:\")]:\n",
-    "    w.description = lbl\n",
-    "target_vol   = widgets.FloatText(0.25,  description=\"Target Vol:\")\n",
-    "monthly_cost = widgets.FloatText(0.0033, description=\"Monthly Cost:\")\n",
-    "\n",
-    "# ---------- 3 · SELECTION ----------\n",
-    "mode_dd = widgets.Dropdown(\n",
-    "    options=[(\"All\", \"all\"), (\"Random\", \"random\"), (\"Manual\", \"manual\")],\n",
-    "    value=\"all\",\n",
-    "    description=\"Mode:\"\n",
-    ")\n",
-    "rand_n   = widgets.BoundedIntText(5, min=2, max=100, description=\"Sample N:\")\n",
-    "fund_table, total_lbl = widgets.VBox([]), widgets.Label(\"Total = 0 %\")\n",
-    "\n",
-    "def _toggle_sel(_=None):\n",
-    "    rand_n.layout.display  = \"block\" if mode_dd.value==\"random\" else \"none\"\n",
-    "    vis = \"block\" if mode_dd.value==\"manual\" else \"none\"\n",
-    "    fund_table.layout.display = total_lbl.layout.display = vis\n",
-    "mode_dd.observe(_toggle_sel, names=\"value\"); _toggle_sel()\n",
-    "\n",
-    "# ---------- helpers ---------------\n",
-    "def _eligible_pool():\n",
-    "    df, rf = session[\"df\"], session[\"rf\"]\n",
-    "    if df is None:\n",
-    "        print(\"⚠️ data not loaded\"); return []\n",
-    "\n",
-    "    # ---- date parse guard -----------------------------------\n",
-    "    try:\n",
-    "        in_s  = pd.to_datetime(in_start.value)+pd.offsets.MonthEnd(0)\n",
-    "        in_e  = pd.to_datetime(in_end.value)  +pd.offsets.MonthEnd(0)\n",
-    "        out_s = pd.to_datetime(out_start.value)+pd.offsets.MonthEnd(0)\n",
-    "        out_e = pd.to_datetime(out_end.value)  +pd.offsets.MonthEnd(0)\n",
-    "    except Exception:\n",
-    "        print(\"❌ invalid dates\"); return []\n",
-    "\n",
-    "    # ---- build indices (RIGHT-most idx_n non-RF columns) ----\n",
-    "    idx_n     = index_cnt.value\n",
-    "    data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-    "    non_rf    = [c for c in data_cols if c != rf]\n",
-    "    indices   = non_rf[-idx_n:] if idx_n else []          # <- fixed\n",
-    "    cand      = [c for c in data_cols if c not in indices]\n",
-    "\n",
-    "    # ---- run select_funds ----------------------------------\n",
-    "    elig = select_funds(\n",
-    "        df=df,\n",
-    "        rf_col=rf,\n",
-    "        fund_columns=cand,\n",
-    "        in_sdate=in_s,\n",
-    "        in_edate=in_e,\n",
-    "        out_sdate=out_s,\n",
-    "        out_edate=out_e,\n",
-    "        cfg=cfg,                     # ← Explicitly supply your config here\n",
-    "        selection_mode=\"all\",\n",
-    "    )\n",
-    "    # … diagnostics print unchanged …\n",
-    "    return elig\n",
-    "\n",
-    "def _build_manual(*_):\n",
-    "    if mode_dd.value!=\"manual\" or session[\"df\"] is None: return\n",
-    "    valid = _eligible_pool()\n",
-    "    print(\"DEBUG  eligible funds =\", len(valid))              # ← line 1\n",
-    "    print(\"DEBUG  list sample   →\", valid[:25], \"…\")           # ← line 2\n",
-    "    if not valid:\n",
-    "        print(\"❌ No eligible funds\"); return\n",
-    "    fund_table.children = []                # reset\n",
-    "\n",
-    "    def _update_total(*_):\n",
-    "        tot = sum(r.children[1].value for r in fund_table.children\n",
-    "                  if r.children[0].value)\n",
-    "        total_lbl.value = f\"Total = {tot} %\"\n",
-    "\n",
-    "    for f in valid:\n",
-    "        cb = widgets.Checkbox(description=f, layout={\"width\":\"200px\"})\n",
-    "        wt = widgets.BoundedIntText(0, min=0, max=100,\n",
-    "                                    layout={\"width\":\"60px\"}, disabled=True)\n",
-    "        def _toggle(ch, box=wt):           # single observer\n",
-    "            box.disabled = not ch[\"new\"]\n",
-    "            if box.disabled: box.value = 0\n",
-    "            _update_total()\n",
-    "        cb.observe(_toggle, names=\"value\")\n",
-    "        wt.observe(_update_total, names=\"value\")\n",
-    "        fund_table.children += (widgets.HBox([cb, wt]),)\n",
-    "    _update_total()\n",
-    "\n",
-    "mode_dd.observe(lambda ch: _build_manual() if ch[\"new\"]==\"manual\" else None,\n",
-    "                names=\"value\")\n",
-    "for w in (in_start,in_end,out_start,out_end): w.observe(_build_manual,names=\"value\")\n",
-    "\n",
-    "# ---------- 4 · RUN ---------------\n",
-    "run_btn = widgets.Button(description=\"Run Analysis\", button_style=\"success\")\n",
-    "run_out = widgets.Output(layout={\"border\":\"1px solid #999\",\n",
-    "                                 \"height\":\"340px\",\"overflow_y\":\"auto\"})\n",
-    "\n",
-    "def _run(_):\n",
-    "    with run_out:\n",
-    "        clear_output()\n",
-    "        df, rf = session[\"df\"], session[\"rf\"]\n",
-    "        if df is None: print(\"⚠️ Load data first\"); return\n",
-    "\n",
-    "        # indices (robust)\n",
-    "        idx_n     = index_cnt.value\n",
-    "        data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-    "        non_rf    = [c for c in data_cols if c != rf]\n",
-    "        indices   = non_rf[-idx_n:] if idx_n else []\n",
-    "\n",
-    "        # pool + selection\n",
-    "        pool = _eligible_pool()\n",
-    "        if not pool: print(\"❌ No eligible funds\"); return\n",
-    "        if mode_dd.value==\"all\":\n",
-    "            sel, custom = pool, None\n",
-    "        elif mode_dd.value==\"random\":\n",
-    "            if rand_n.value>len(pool): print(\"⚠️ Sample N too big\"); return\n",
-    "            sel, custom = list(np.random.choice(pool, rand_n.value, replace=False)), None\n",
-    "        else:\n",
-    "            sel, custom = [], {}\n",
-    "            if not fund_table.children: _build_manual()\n",
-    "            for row in fund_table.children:\n",
-    "                cb, wt = row.children\n",
-    "                if cb.value: sel.append(cb.description); custom[cb.description]=wt.value\n",
-    "            if sum(custom.values())!=100: print(\"⚠️ Weights ≠ 100\"); return\n",
-    "\n",
-    "        w_dict,w_vec = prepare_weights(sel, custom)\n",
-    "\n",
-    "        res = run_analysis(df, sel, w_vec, w_dict, rf,\n",
-    "                           in_start.value, in_end.value,\n",
-    "                           out_start.value, out_end.value,\n",
-    "                           target_vol.value, monthly_cost.value,\n",
-    "                           indices)\n",
-    "\n",
-    "        print(\"✅ analysis complete |\", len(sel), \"funds\")\n",
-    "        if res[\"dropped\"]:\n",
-    "            print(\"⚠️ Dropped:\", res[\"dropped\"])\n",
-    "        if indices: print(\"📊 Indices:\", indices)\n",
-    "\n",
-    "        fname=f\"IS_{in_start.value}_{out_start.value}.xlsx\"\n",
-    "        # register only the combined summary formatter\n",
-    "        make_summary_formatter(\n",
-    "            res,\n",
-    "            in_start.value,\n",
-    "            in_end.value,\n",
-    "            out_start.value,\n",
-    "            out_end.value\n",
-    "        )\n",
-    "\n",
-    "        # Build a minimal data dict with just the 'summary' sheet.\n",
-    "        # The formatter will populate all rows (portfolio, funds, spacer, indices).\n",
-    "        data = {\n",
-    "            \"summary\": pd.DataFrame()\n",
-    "        }\n",
-    "\n",
-    "        print(\"Sheets to write:\", list(data.keys()))\n",
-    "        print(\"Formatters:\", list(FORMATTERS_EXCEL.keys()))\n",
-    "\n",
-    "        # Export — this will call fmt_summary(ws, wb) on the 'summary' sheet.\n",
-    "        export_to_excel(data, fname)\n",
-    "        print(\"Workbook saved as\", fname)\n",
-    "\n",
-    "run_btn.on_click(_run)\n",
-    "\n",
-    "# ---------- DISPLAY --------------\n",
-    "display(widgets.VBox([\n",
-    "    widgets.HTML(\"<h4>1. Load data</h4>\"),\n",
-    "    src, chooser, url_box, load_btn, load_out,\n",
-    "    widgets.HTML(\"<hr><h4>2. Parameters</h4>\"),\n",
-    "    widgets.HBox([index_cnt]),\n",
-    "    widgets.HBox([in_start,in_end,out_start,out_end]),\n",
-    "    widgets.HBox([target_vol,monthly_cost]),\n",
-    "    widgets.HTML(\"<hr><h4>3. Fund selection</h4>\"),\n",
-    "    widgets.HBox([mode_dd,rand_n]),\n",
-    "    fund_table, total_lbl,\n",
-    "    widgets.HTML(\"<hr>\"),\n",
-    "    run_btn,\n",
-    "    run_out\n",
-    "]))\n"
-   ]
-  }
- ],
- "metadata": {
-  "colab": {
-   "provenance": []
-  },
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  },
-  "widgets": {
-   "application/vnd.jupyter.widget-state+json": {
-    "021e4dc72d814e5d8c42592b541b6723": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "SelectModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "SelectModel",
-      "_options_labels": [
-       "📁 ..",
-       "📁 sample_data",
-       "Vol_Adj_Trend_Analysis_1_3_TrEx.ipynb"
-      ],
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "SelectView",
-      "description": "",
-      "description_tooltip": null,
-      "disabled": false,
-      "index": null,
-      "layout": "IPY_MODEL_f5e355edbbc946b3b6e1ba36f839d45b",
-      "rows": 8,
-      "style": "IPY_MODEL_78906e475e9d4bda8b7e0c4ca4de577c"
-     }
-    },
-    "05a596b6c3864ddc931b3112153f12ab": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "05b7cb98ce374c10828efb3d205fe4ff": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_be7153ab36374e62a7d6a234dc1c973e",
-      "placeholder": "",
-      "style": "IPY_MODEL_d22068b3d502469fa1631d698a3d3779",
-      "value": "<span style=\"color:black;\">No selection</span>"
-     }
-    },
-    "08882c12ccaa4d058bc554020c044559": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "09e8f8999ea1463a9d603da4f4f70b12": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DropdownModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DropdownModel",
-      "_options_labels": [
-       "/content",
-       "/"
-      ],
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "DropdownView",
-      "description": "",
-      "description_tooltip": null,
-      "disabled": false,
-      "index": 0,
-      "layout": "IPY_MODEL_ae45af3a4d3d4fb8b1c2827585ed7f7f",
-      "style": "IPY_MODEL_574d70e37e6a449dbdd4365c2d86fda8"
-     }
-    },
-    "0b231b28c644443db3e659a17096f55c": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "BoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "BoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "BoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_05b7cb98ce374c10828efb3d205fe4ff"
-      ],
-      "layout": "IPY_MODEL_6c1e290b8fdf4e31872f11e0c5438b5d"
-     }
-    },
-    "10e898df8a0e460b9f3e3a40b48f51f4": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "500px"
-     }
-    },
-    "125e415320644832a8be95b92713e257": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_1c01c7f8d62041198190f4bfbe21aff5",
-      "placeholder": "​",
-      "style": "IPY_MODEL_9ac98c85e0f147f8a191f6d32651d0cc",
-      "value": "<hr><h4>3. Fund selection</h4>"
-     }
-    },
-    "15de8a73c52642c598ad8baeb3609499": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "170d05f5ba184c13bb39914b17257476": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "VBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "VBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "VBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_593aad971d274b90b56cecc15e09dc39",
-       "IPY_MODEL_6418ed5196fd485cae29568a24bf60ae",
-       "IPY_MODEL_d12e413cbeac41a39fd9b94479c1eca8"
-      ],
-      "layout": "IPY_MODEL_10e898df8a0e460b9f3e3a40b48f51f4"
-     }
-    },
-    "1c01c7f8d62041198190f4bfbe21aff5": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "1da4518f46b84fc7b84d387c7e34f050": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_d9f6106f986b4ea49d957594d8d5c324",
-      "placeholder": "output filename",
-      "style": "IPY_MODEL_e8b9fd55c6094126b24ab2e7cffa4dc5",
-      "value": ""
-     }
-    },
-    "202010c9f8324e1493baa92d83ff9335": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "258e8504f9cc4be783ea207c43e56214": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "269ab898c24e4cf697ad3dc2854a7215": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "button_color": null,
-      "font_weight": ""
-     }
-    },
-    "2e2775bb4c6e4b98ba4706d90b24e042": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "2e6724a498d54c73a8f594b19c6a3d20": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "2e96cf393a754d279bcf02c66548f6dd": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ButtonView",
-      "button_style": "",
-      "description": "Cancel",
-      "disabled": false,
-      "icon": "",
-      "layout": "IPY_MODEL_ff9bd5c776a741248e4a64d445950c90",
-      "style": "IPY_MODEL_4b551eab21b34f488d743ea730a541d8",
-      "tooltip": ""
-     }
-    },
-    "32bac6722d6d47a6b5a88372e9e5d44e": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "Out End:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_eed45853cf99427398e7b16f2cab9f8b",
-      "placeholder": "​",
-      "style": "IPY_MODEL_5363ac1b24b24811ae9c63b86dfbf359",
-      "value": "2009-06"
-     }
-    },
-    "332172fad96e4be2857e530ba9df86c6": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ButtonView",
-      "button_style": "success",
-      "description": "Run Analysis",
-      "disabled": false,
-      "icon": "",
-      "layout": "IPY_MODEL_514e5aafad0044cb9df9232ef0a4e264",
-      "style": "IPY_MODEL_367366f650c644d59791946a3c8d86d0",
-      "tooltip": ""
-     }
-    },
-    "354bbc188daa4493967e2b143ceea510": {
-     "model_module": "@jupyter-widgets/output",
-     "model_module_version": "1.0.0",
-     "model_name": "OutputModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/output",
-      "_model_module_version": "1.0.0",
-      "_model_name": "OutputModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/output",
-      "_view_module_version": "1.0.0",
-      "_view_name": "OutputView",
-      "layout": "IPY_MODEL_d807a3a60ca14ddda5fbec481049b6d4",
-      "msg_id": "",
-      "outputs": [
-       {
-        "name": "stdout",
-        "output_type": "stream",
-        "text": [
-         "✅ analysis complete | 15 funds\n",
-         "⚠️ Dropped: ['Crescent Management']\n",
-         "📊 Indices: ['EqualWeight_60', 'EqualWeight_40']\n"
-        ]
-       },
-       {
-        "ename": "TypeError",
-        "evalue": "make_portfolio_formatter() takes 2 positional arguments but 5 were given",
-        "output_type": "error",
-        "traceback": [
-         "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-         "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
-         "\u001b[0;32m<ipython-input-56-445aa7dfbbcf>\u001b[0m in \u001b[0;36m_run\u001b[0;34m(_)\u001b[0m\n\u001b[1;32m    257\u001b[0m         \u001b[0;31m# … build your summary_df, in_stat, out_stat, weights …\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    258\u001b[0m         \u001b[0mmake_summary_formatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msummary_df\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0min_start\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0min_end\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_start\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_end\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0min_stat\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_stat\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mw_dict\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 259\u001b[0;31m         \u001b[0mmake_portfolio_formatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mportfolio_df\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"in_ew_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"out_ew_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"in_user_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"out_user_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    260\u001b[0m         \u001b[0mmake_indices_formatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mindices_df\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"index_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    261\u001b[0m         \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Sheets to write:\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlist\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mkeys\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
-         "\u001b[0;31mTypeError\u001b[0m: make_portfolio_formatter() takes 2 positional arguments but 5 were given"
-        ]
-       }
-      ]
-     }
-    },
-    "367366f650c644d59791946a3c8d86d0": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "button_color": null,
-      "font_weight": ""
-     }
-    },
-    "3814c0e0fa1c438e87df5b60a82dd3e4": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "BoundedIntTextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "BoundedIntTextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "IntTextView",
-      "continuous_update": false,
-      "description": "# Indices:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_e5c317ba51ed45818d7d60cc4aaec11d",
-      "max": 10,
-      "min": 0,
-      "step": 1,
-      "style": "IPY_MODEL_7e5dd5f9379a4104ad7965a34e569a7a",
-      "value": 2
-     }
-    },
-    "383dee58194446698cb8eb9df41b7778": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "38d3e511fdc14bcaa7b04d8583be18dc": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "47ae7b5e18314a2596b33cc6c774942b": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "button_color": null,
-      "font_weight": ""
-     }
-    },
-    "4a022a6055c34004b7a3aa671a168ee3": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "block",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "4b551eab21b34f488d743ea730a541d8": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "button_color": null,
-      "font_weight": ""
-     }
-    },
-    "514e5aafad0044cb9df9232ef0a4e264": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "516389ac0f0042a0bbeab3bd64493997": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "LabelModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "LabelModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "LabelView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_2e2775bb4c6e4b98ba4706d90b24e042",
-      "placeholder": "​",
-      "style": "IPY_MODEL_b411a590b161465185dfd853a6dd95d6",
-      "value": "Total = 0 %"
-     }
-    },
-    "5363ac1b24b24811ae9c63b86dfbf359": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "574d70e37e6a449dbdd4365c2d86fda8": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "5759bee9a2034ed3b9b4196e158b58eb": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "In Start:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_383dee58194446698cb8eb9df41b7778",
-      "placeholder": "​",
-      "style": "IPY_MODEL_72bdf8a1ccfa4d0985547020c90908a0",
-      "value": "2005-07"
-     }
-    },
-    "593aad971d274b90b56cecc15e09dc39": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_15de8a73c52642c598ad8baeb3609499",
-      "placeholder": "​",
-      "style": "IPY_MODEL_2e6724a498d54c73a8f594b19c6a3d20",
-      "value": ""
-     }
-    },
-    "62c2030d08cf4f1e91c9c9038f31b864": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "auto"
-     }
-    },
-    "64045569d769471e92ac17aebf71022f": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_97212667726d480eb944e25ec32cfc25",
-      "placeholder": "https://…/file.csv",
-      "style": "IPY_MODEL_6e75d93c40ea4c40b9162ab51e807d98",
-      "value": "https://raw.githubusercontent.com/stranske/Trend_Model_Project/refs/heads/main/hedge_fund_returns_with_indexes.csv"
-     }
-    },
-    "6418ed5196fd485cae29568a24bf60ae": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "GridBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "GridBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "GridBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_09e8f8999ea1463a9d603da4f4f70b12",
-       "IPY_MODEL_1da4518f46b84fc7b84d387c7e34f050",
-       "IPY_MODEL_021e4dc72d814e5d8c42592b541b6723"
-      ],
-      "layout": "IPY_MODEL_97f4dce2a3874dafaeb0ba92775ae2a0"
-     }
-    },
-    "646d2e69e110438fa2feb8b60af24bb7": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "65dbf5a3b3a2406aa9f807b74dc5543b": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": "6em",
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "6em"
-     }
-    },
-    "6c1e290b8fdf4e31872f11e0c5438b5d": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": "auto",
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "6c7f140622534a6cab6133758aa7a936": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "6dc67c18884044ac811b3a256f69171e": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "6e5e4fc36c674146a86dc3f8b6edbd7d": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "In End:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_8a9b22cd239d43d191387ebc9e660ff8",
-      "placeholder": "​",
-      "style": "IPY_MODEL_86a9efbe68f5450685a4e8aa1c96e84e",
-      "value": "2008-06"
-     }
-    },
-    "6e75d93c40ea4c40b9162ab51e807d98": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "704f7526c3934eed85b653fb00714114": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "FloatTextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "FloatTextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "FloatTextView",
-      "continuous_update": false,
-      "description": "Monthly Cost:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_d6710d2b4b0b4b02b5358d2d152fbad9",
-      "step": null,
-      "style": "IPY_MODEL_ca05ab87b3e040cbbf4016ae0671fc40",
-      "value": 0.0033
-     }
-    },
-    "70dfa008682a460aa02625a933b33606": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "72bdf8a1ccfa4d0985547020c90908a0": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "74577bb60c55412d9c38960d7d865fd6": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "75ad9c9f175f4960999958cd9f6d056a": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_3814c0e0fa1c438e87df5b60a82dd3e4"
-      ],
-      "layout": "IPY_MODEL_6c7f140622534a6cab6133758aa7a936"
-     }
-    },
-    "78906e475e9d4bda8b7e0c4ca4de577c": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "7e5dd5f9379a4104ad7965a34e569a7a": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "818aa783706f4087a3754d39d861ced6": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "BoundedIntTextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "BoundedIntTextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "IntTextView",
-      "continuous_update": false,
-      "description": "Sample N:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_4a022a6055c34004b7a3aa671a168ee3",
-      "max": 100,
-      "min": 2,
-      "step": 1,
-      "style": "IPY_MODEL_c9b1027aad95413c94835aef5ce74a5b",
-      "value": 15
-     }
-    },
-    "86a9efbe68f5450685a4e8aa1c96e84e": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "8a9b22cd239d43d191387ebc9e660ff8": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "8c053f4df9ff486f84b123eda524cbe7": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_e00ed42085424c6f91fb07fb2d22ee62",
-       "IPY_MODEL_818aa783706f4087a3754d39d861ced6"
-      ],
-      "layout": "IPY_MODEL_258e8504f9cc4be783ea207c43e56214"
-     }
-    },
-    "8d9670b7900c40b8849f7e4629d50424": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "8f3ec331c368446b8552a06238a12608": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "8face5cf545b40ceaf10b1506e754d71": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "VBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "VBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "VBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_db185d3992024056acfa2ffe419931d8",
-       "IPY_MODEL_c459f2c677ff4bea8db916696b7b600e",
-       "IPY_MODEL_170d05f5ba184c13bb39914b17257476",
-       "IPY_MODEL_64045569d769471e92ac17aebf71022f",
-       "IPY_MODEL_f83a99900b324015862cad100f5bfc0c",
-       "IPY_MODEL_ee231bb4cb97454591e7a6774bb2f7bd",
-       "IPY_MODEL_eceecb3f8a864d1eb15aab7d531e3cd1",
-       "IPY_MODEL_75ad9c9f175f4960999958cd9f6d056a",
-       "IPY_MODEL_e0d83789c4034d9ab9b3c2fa85870beb",
-       "IPY_MODEL_ae753571f5814a65865abbdb10540373",
-       "IPY_MODEL_125e415320644832a8be95b92713e257",
-       "IPY_MODEL_8c053f4df9ff486f84b123eda524cbe7",
-       "IPY_MODEL_d3bae0e7a2474ea4bdce0b0b9e413059",
-       "IPY_MODEL_516389ac0f0042a0bbeab3bd64493997",
-       "IPY_MODEL_e7dc4acbb2eb4a0e8c5112e4b2a85393",
-       "IPY_MODEL_332172fad96e4be2857e530ba9df86c6",
-       "IPY_MODEL_354bbc188daa4493967e2b143ceea510"
-      ],
-      "layout": "IPY_MODEL_6dc67c18884044ac811b3a256f69171e"
-     }
-    },
-    "958a21d97fa546a2b314e2c988b43589": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "97212667726d480eb944e25ec32cfc25": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "block",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "70%"
-     }
-    },
-    "97f4dce2a3874dafaeb0ba92775ae2a0": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": "0px 0px",
-      "grid_row": null,
-      "grid_template_areas": "\n                    'pathlist filename'\n                    'dircontent dircontent'\n                    ",
-      "grid_template_columns": "60% 40%",
-      "grid_template_rows": "auto auto",
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "auto"
-     }
-    },
-    "9a302560059a43338397161ea2ad37c7": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "9ac98c85e0f147f8a191f6d32651d0cc": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "a503b43ca679455f978c6903bdb598cf": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "a8d2ae4652394bb4b2a740097a4d7ea7": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "ae45af3a4d3d4fb8b1c2827585ed7f7f": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": "pathlist",
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "auto"
-     }
-    },
-    "ae753571f5814a65865abbdb10540373": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_d13209a7e5c94f6585d47c2430fa7885",
-       "IPY_MODEL_704f7526c3934eed85b653fb00714114"
-      ],
-      "layout": "IPY_MODEL_08882c12ccaa4d058bc554020c044559"
-     }
-    },
-    "b411a590b161465185dfd853a6dd95d6": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "be7153ab36374e62a7d6a234dc1c973e": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": "0 0 0 1em",
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "bedc16eeb19740bb9ee6e810bc9b7a71": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "c459f2c677ff4bea8db916696b7b600e": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ToggleButtonsModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ToggleButtonsModel",
-      "_options_labels": [
-       "Local",
-       "URL"
-      ],
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ToggleButtonsView",
-      "button_style": "",
-      "description": "Source:",
-      "description_tooltip": null,
-      "disabled": false,
-      "icons": [],
-      "index": 1,
-      "layout": "IPY_MODEL_a8d2ae4652394bb4b2a740097a4d7ea7",
-      "style": "IPY_MODEL_dbe1076d681040169eca1b570e2485e2",
-      "tooltips": []
-     }
-    },
-    "c9b1027aad95413c94835aef5ce74a5b": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "ca05ab87b3e040cbbf4016ae0671fc40": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "d12e413cbeac41a39fd9b94479c1eca8": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_f5539db7aca6440e9c3dee43697c4fae",
-       "IPY_MODEL_2e96cf393a754d279bcf02c66548f6dd",
-       "IPY_MODEL_0b231b28c644443db3e659a17096f55c"
-      ],
-      "layout": "IPY_MODEL_62c2030d08cf4f1e91c9c9038f31b864"
-     }
-    },
-    "d13209a7e5c94f6585d47c2430fa7885": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "FloatTextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "FloatTextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "FloatTextView",
-      "continuous_update": false,
-      "description": "Target Vol:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_74577bb60c55412d9c38960d7d865fd6",
-      "step": null,
-      "style": "IPY_MODEL_d37456fcb76f4acda7978257483bf2ad",
-      "value": 0.25
-     }
-    },
-    "d22068b3d502469fa1631d698a3d3779": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "d37456fcb76f4acda7978257483bf2ad": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "d3bae0e7a2474ea4bdce0b0b9e413059": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "VBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "VBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "VBoxView",
-      "box_style": "",
-      "children": [],
-      "layout": "IPY_MODEL_bedc16eeb19740bb9ee6e810bc9b7a71"
-     }
-    },
-    "d6710d2b4b0b4b02b5358d2d152fbad9": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "d807a3a60ca14ddda5fbec481049b6d4": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": "1px solid #999",
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": "340px",
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": "auto",
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "d80f632f65c44c338a41d0b4e3dc5ea7": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "d9f6106f986b4ea49d957594d8d5c324": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": "filename",
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "auto"
-     }
-    },
-    "db185d3992024056acfa2ffe419931d8": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_d80f632f65c44c338a41d0b4e3dc5ea7",
-      "placeholder": "​",
-      "style": "IPY_MODEL_9a302560059a43338397161ea2ad37c7",
-      "value": "<h4>1. Load data</h4>"
-     }
-    },
-    "dbe1076d681040169eca1b570e2485e2": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ToggleButtonsStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ToggleButtonsStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "button_width": "",
-      "description_width": "",
-      "font_weight": ""
-     }
-    },
-    "dfbe93388b474442833b5e7b7efc1e5f": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "e00ed42085424c6f91fb07fb2d22ee62": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DropdownModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DropdownModel",
-      "_options_labels": [
-       "All",
-       "Random",
-       "Manual"
-      ],
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "DropdownView",
-      "description": "Mode:",
-      "description_tooltip": null,
-      "disabled": false,
-      "index": 1,
-      "layout": "IPY_MODEL_958a21d97fa546a2b314e2c988b43589",
-      "style": "IPY_MODEL_202010c9f8324e1493baa92d83ff9335"
-     }
-    },
-    "e02a002607844c6ba0249122b505b8f5": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "e0d83789c4034d9ab9b3c2fa85870beb": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_5759bee9a2034ed3b9b4196e158b58eb",
-       "IPY_MODEL_6e5e4fc36c674146a86dc3f8b6edbd7d",
-       "IPY_MODEL_fa9ee776b338497e9385f3d1a8d02fff",
-       "IPY_MODEL_32bac6722d6d47a6b5a88372e9e5d44e"
-      ],
-      "layout": "IPY_MODEL_dfbe93388b474442833b5e7b7efc1e5f"
-     }
-    },
-    "e5c317ba51ed45818d7d60cc4aaec11d": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "e7dc4acbb2eb4a0e8c5112e4b2a85393": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_a503b43ca679455f978c6903bdb598cf",
-      "placeholder": "​",
-      "style": "IPY_MODEL_70dfa008682a460aa02625a933b33606",
-      "value": "<hr>"
-     }
-    },
-    "e8b9fd55c6094126b24ab2e7cffa4dc5": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "eceecb3f8a864d1eb15aab7d531e3cd1": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_05a596b6c3864ddc931b3112153f12ab",
-      "placeholder": "​",
-      "style": "IPY_MODEL_8f3ec331c368446b8552a06238a12608",
-      "value": "<hr><h4>2. Parameters</h4>"
-     }
-    },
-    "ee231bb4cb97454591e7a6774bb2f7bd": {
-     "model_module": "@jupyter-widgets/output",
-     "model_module_version": "1.0.0",
-     "model_name": "OutputModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/output",
-      "_model_module_version": "1.0.0",
-      "_model_name": "OutputModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/output",
-      "_view_module_version": "1.0.0",
-      "_view_name": "OutputView",
-      "layout": "IPY_MODEL_e02a002607844c6ba0249122b505b8f5",
-      "msg_id": "",
-      "outputs": [
-       {
-        "name": "stdout",
-        "output_type": "stream",
-        "text": [
-         "✅ Loaded 312 rows × 104 cols | RF → Risk-Free Rate\n"
-        ]
-       },
-       {
-        "name": "stderr",
-        "output_type": "stream",
-        "text": [
-         "<ipython-input-56-445aa7dfbbcf>:33: UserWarning: Could not infer format, so each element will be parsed individually, falling back to `dateutil`. To ensure parsing is consistent and as-expected, please specify a format.\n",
-         "  df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")  # single coercion\n"
-        ]
-       }
-      ]
-     }
-    },
-    "eed45853cf99427398e7b16f2cab9f8b": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "f5539db7aca6440e9c3dee43697c4fae": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ButtonView",
-      "button_style": "",
-      "description": "Select",
-      "disabled": false,
-      "icon": "",
-      "layout": "IPY_MODEL_65dbf5a3b3a2406aa9f807b74dc5543b",
-      "style": "IPY_MODEL_269ab898c24e4cf697ad3dc2854a7215",
-      "tooltip": ""
-     }
-    },
-    "f5e355edbbc946b3b6e1ba36f839d45b": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": "dircontent",
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "auto"
-     }
-    },
-    "f83a99900b324015862cad100f5bfc0c": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ButtonView",
-      "button_style": "success",
-      "description": "Load CSV",
-      "disabled": false,
-      "icon": "",
-      "layout": "IPY_MODEL_646d2e69e110438fa2feb8b60af24bb7",
-      "style": "IPY_MODEL_47ae7b5e18314a2596b33cc6c774942b",
-      "tooltip": ""
-     }
-    },
-    "fa9ee776b338497e9385f3d1a8d02fff": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "Out Start:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_38d3e511fdc14bcaa7b04d8583be18dc",
-      "placeholder": "​",
-      "style": "IPY_MODEL_8d9670b7900c40b8849f7e4629d50424",
-      "value": "2008-07"
-     }
-    },
-    "ff9bd5c776a741248e4a64d445950c90": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": "6em",
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "6em"
-     }
-    },
-    "state": {}
-   }
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_1_4_TrEx-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_1_4_TrEx-checkpoint.ipynb
deleted file mode 100644
index 1551927fe7780ba677d1ad53bdba6908dee061c2..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_1_4_TrEx-checkpoint.ipynb
+++ /dev/null
@@ -1,4328 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "22994893-0193-45bc-b9e3-a97b328ecaea",
-   "metadata": {
-    "id": "22994893-0193-45bc-b9e3-a97b328ecaea"
-   },
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Imports, Data Loader and Rf Detector\n",
-    "2. Select fund (month period logic)\n",
-    "3. Weight prep\n",
-    "4. Core Stats + Run Analysis\n",
-    "5. Export\n",
-    "6. Widget /UI\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "id": "30ea203f",
-    "tags": []
-   },
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "#      VOL-ADJ TREND ANALYSIS  –  SINGLE-FILE VERSION\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  0 · IMPORTS  (all in one place)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "import pandas as pd\n",
-    "import numpy as np\n",
-    "from dataclasses import dataclass, field\n",
-    "from collections import namedtuple\n",
-    "import xlsxwriter\n",
-    "import logging\n",
-    "from io import BytesIO\n",
-    "import ipywidgets as widgets\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "from typing import List, Dict, Optional, Callable\n",
-    "\n",
-    "logging.getLogger().setLevel(logging.ERROR)\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  1 · Class Configurations\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "@dataclass\n",
-    "class FundSelectionConfig:\n",
-    "    max_missing_months:         int = 3   # used to replace the “<=3 missing” rule\n",
-    "    max_consecutive_month_gap:  int = 6   # used to replace the “<=6 gap” ruleimplausible_value_limit: float = 1.0\n",
-    "    implausible_value_limit: float  = 1\n",
-    "    outlier_threshold: float = 0.5\n",
-    "    zero_return_threshold: float = 0.2\n",
-    "    enforce_monotonic_index: bool = True\n",
-    "    allow_duplicate_dates: bool = False\n",
-    "    max_missing_ratio: float      = 0.05\n",
-    "    max_drawdown: float           = 0.3\n",
-    "    min_volatility: float         = 0.05\n",
-    "    max_volatility: float         = 1.0\n",
-    "    min_avg_return: float         = 0.0\n",
-    "    max_skewness: float           = 3.0\n",
-    "    max_kurtosis: float           = 10.0\n",
-    "    expected_freq: str            = \"B\"\n",
-    "    max_gap_days: int             = 3\n",
-    "    min_aum_usd: float            = 1e7\n",
-    "\n",
-    "# Configuration dataclass\n",
-    "@dataclass\n",
-    "class RiskStatsConfig:\n",
-    "    metrics_to_run: List[str] = field(default_factory=lambda: [\n",
-    "        \"AnnualReturn\", \"Volatility\", \"Sharpe\", \"Sortino\", \"MaxDrawdown\"\n",
-    "    ])\n",
-    "    risk_free: float = 0.0\n",
-    "    periods_per_year: int = 12\n",
-    "\n",
-    "# 2. Registry and decorator\n",
-    "METRIC_REGISTRY: Dict[str, Callable[[pd.Series, float, int], float]] = {}\n",
-    "\n",
-    "def register_metric(name: str):\n",
-    "    \"\"\"\n",
-    "    Decorator to register a metric function under a given name.\n",
-    "    \"\"\"\n",
-    "    def decorator(fn: Callable[pd.Series, float]):\n",
-    "        METRIC_REGISTRY[name] = fn\n",
-    "        return fn\n",
-    "    return decorator\n",
-    "\n",
-    "FORMATTERS_EXCEL: dict[str, Callable] = {}\n",
-    "def register_formatter_excel(category: str):\n",
-    "    def decorator(fn: Callable):\n",
-    "        FORMATTERS_EXCEL[category] = fn\n",
-    "        return fn\n",
-    "    return decorator\n",
-    "\n",
-    "# Example formatters (extend as needed)\n",
-    "\n",
-    "def make_summary_formatter(\n",
-    "    res: dict,\n",
-    "    in_start: str,\n",
-    "    in_end: str,\n",
-    "    out_start: str,\n",
-    "    out_end: str\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Registers a single 'summary' sheet formatter that writes:\n",
-    "      1. Portfolio rows (Equal & User weight),\n",
-    "      2. Blank spacer,\n",
-    "      3. Fund rows,\n",
-    "      4. Blank spacer,\n",
-    "      5. Index rows\n",
-    "    using the data in `res`.\n",
-    "    \"\"\"\n",
-    "    @register_formatter_excel(\"summary\")\n",
-    "    def fmt_summary(ws, wb):\n",
-    "        # Predefine formats\n",
-    "        bold = wb.add_format({\"bold\": True})\n",
-    "        int0 = wb.add_format({\"num_format\": \"0\"})\n",
-    "        num2 = wb.add_format({\"num_format\": \"0.00\"})\n",
-    "        red  = wb.add_format({\"num_format\": \"0.00\", \"font_color\": \"red\"})\n",
-    "        safe = lambda v: \"\" if (pd.isna(v) or not np.isfinite(v)) else v\n",
-    "        pct  = lambda t: [t[0]*100, t[1]*100, t[2], t[3], t[4]*100]\n",
-    "\n",
-    "        # Write static headers\n",
-    "        ws.write_row(0, 0, [\"Vol-Adj Trend Analysis\"], bold)\n",
-    "        ws.write_row(1, 0, [f\"In:  {in_start} → {in_end}\"], bold)\n",
-    "        ws.write_row(2, 0, [f\"Out: {out_start} → {out_end}\"], bold)\n",
-    "\n",
-    "        row = 5\n",
-    "        # 1. Portfolio rows\n",
-    "        for label, in_s, out_s in [\n",
-    "            (\"Equal Weight\", res[\"in_ew_stats\"], res[\"out_ew_stats\"]),\n",
-    "            (\"User Weight\",  res[\"in_user_stats\"], res[\"out_user_stats\"])\n",
-    "        ]:\n",
-    "            ws.write(row, 0, label, bold)\n",
-    "            ws.write(row, 1, safe(\"\") if True else int0)\n",
-    "            vals = pct(tuple(in_s)) + pct(tuple(out_s))\n",
-    "            fmts = ([num2]*4 + [red]) * 2\n",
-    "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-    "                ws.write(row, col, safe(v), fmt)\n",
-    "            row += 1\n",
-    "\n",
-    "        # spacer\n",
-    "        row += 1\n",
-    "\n",
-    "        # 2. Fund rows\n",
-    "        for fund, stat_in in res[\"in_sample_stats\"].items():\n",
-    "            stat_out = res[\"out_sample_stats\"][fund]\n",
-    "            ws.write(row, 0, fund, bold)\n",
-    "            wt = res[\"fund_weights\"][fund]\n",
-    "            ws.write(row, 1, safe(wt*100), int0)\n",
-    "            vals = pct(tuple(stat_in)) + pct(tuple(stat_out))\n",
-    "            fmts = ([num2]*4 + [red]) * 2\n",
-    "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-    "                ws.write(row, col, safe(v), fmt)\n",
-    "            row += 1\n",
-    "\n",
-    "        # spacer\n",
-    "        row += 1\n",
-    "\n",
-    "        # 3. Index rows\n",
-    "        for idx, pair in res.get(\"index_stats\", {}).items():\n",
-    "            in_idx = pair[\"in_sample\"]\n",
-    "            out_idx= pair[\"out_sample\"]\n",
-    "            ws.write(row, 0, idx, bold)\n",
-    "            ws.write(row, 1, safe(\"\") if True else int0)\n",
-    "            vals = pct(tuple(in_idx)) + pct(tuple(out_idx))\n",
-    "            fmts = ([num2]*4 + [red]) * 2\n",
-    "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-    "                ws.write(row, col, safe(v), fmt)\n",
-    "            row += 1\n",
-    "\n",
-    "    return fmt_summary\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  2 · CSV LOADER + RF DETECTOR\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "logger = logging.getLogger(__name__)\n",
-    "\n",
-    "def load_csv(path: str) -> pd.DataFrame | None:\n",
-    "    try:\n",
-    "        df = pd.read_csv(path)\n",
-    "    except FileNotFoundError as e:\n",
-    "        logger.error(f\"File not found: {path}\")\n",
-    "        return None\n",
-    "    except pd.errors.EmptyDataError:\n",
-    "        logger.error(f\"No data in file: {path}\")\n",
-    "        return None\n",
-    "    except pd.errors.ParserError as e:\n",
-    "        logger.error(f\"Parsing error in {path}: {e}\")\n",
-    "        return None\n",
-    "\n",
-    "    if \"Date\" not in df.columns:\n",
-    "        logger.error(f\"Validation failed ({path}): missing 'Date' column\")\n",
-    "        return None\n",
-    "\n",
-    "    # Optionally check for NaNs in 'Date' column\n",
-    "    if df[\"Date\"].isnull().any():\n",
-    "        logger.warning(f\"Null values found in 'Date' column of {path}\")\n",
-    "\n",
-    "    return df\n",
-    "\n",
-    "def identify_risk_free_fund(df: pd.DataFrame) -> str:\n",
-    "    returns = df.drop(columns=\"Date\", errors=\"ignore\")\n",
-    "    stdevs  = returns.std(skipna=True, ddof=0)\n",
-    "    return stdevs.idxmin()"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {
-    "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c"
-   },
-   "source": [
-    "## 2. Select Funds"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {
-    "id": "ff528d69-5a52-4b75-8af4-17974826f4ab"
-   },
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "# 2 · SELECT_FUNDS  (restored ≤ 3-missing-months rule)\n",
-    "# ===============================================================\n",
-    "\n",
-    "cfg = FundSelectionConfig(\n",
-    "    max_missing_months           = 3,\n",
-    "    max_consecutive_month_gap    = 6,\n",
-    "    outlier_threshold            = 0.5,\n",
-    "    zero_return_threshold        = 0.2,\n",
-    "    enforce_monotonic_index      = True,\n",
-    "    allow_duplicate_dates        = False,\n",
-    "    max_missing_ratio            = 0.05,\n",
-    "    max_drawdown                 = 0.3,\n",
-    "    min_volatility               = 0.05,\n",
-    "    max_volatility               = 1.0,\n",
-    "    min_avg_return               = 0.0,\n",
-    "    max_skewness                 = 3.0,\n",
-    "    max_kurtosis                 = 10.0,\n",
-    "    expected_freq                = \"B\",\n",
-    "    max_gap_days                 = 3,\n",
-    "    min_aum_usd                  = 1e7,\n",
-    ")\n",
-    "\n",
-    "def select_funds(\n",
-    "    df: pd.DataFrame,\n",
-    "    rf_col: str,\n",
-    "    fund_columns: list[str],\n",
-    "    in_sdate: str,\n",
-    "    in_edate: str,\n",
-    "    out_sdate: str,\n",
-    "    out_edate: str,\n",
-    "    cfg: FundSelectionConfig,\n",
-    "    selection_mode: str = \"all\",\n",
-    "    random_n: int | None = None\n",
-    ") -> list[str]:\n",
-    "    \"\"\"\n",
-    "    Select eligible funds with additional data-validity and coverage checks driven by FundSelectionConfig.\n",
-    "    \"\"\"\n",
-    "    # Ensure Date is datetime and sorted\n",
-    "    if not pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        df = df.copy()\n",
-    "        df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "        df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "    df = df.sort_values(\"Date\")  # guarantee monotonic index\n",
-    "\n",
-    "    # Prepare monthly periods within analysis window\n",
-    "    df[\"Month\"] = df[\"Date\"].dt.to_period(\"M\")\n",
-    "    span = pd.period_range(\n",
-    "        pd.Period(in_sdate, \"M\"), pd.Period(out_edate, \"M\"), freq=\"M\"\n",
-    "    )\n",
-    "\n",
-    "    eligible_funds: list[str] = []\n",
-    "    for f in fund_columns:\n",
-    "        try:\n",
-    "            ser = df.set_index(\"Date\")[f]\n",
-    "            clean = ser.dropna()\n",
-    "\n",
-    "            # 1. Implausible value limits\n",
-    "            if not clean.between(-cfg.implausible_value_limit, cfg.implausible_value_limit).all():\n",
-    "                raise ValueError(f\"Values outside ±{cfg.implausible_value_limit}\")\n",
-    "\n",
-    "            # 2. Extreme outlier threshold\n",
-    "            if (clean.abs() > cfg.outlier_threshold).any():\n",
-    "                raise ValueError(f\"Outliers beyond ±{cfg.outlier_threshold}\")\n",
-    "\n",
-    "            # 3. Excessive zero-return rate\n",
-    "            if (clean == 0).mean() > cfg.zero_return_threshold:\n",
-    "                raise ValueError(f\"Zero-return proportion > {cfg.zero_return_threshold}\")\n",
-    "\n",
-    "            # 4. Monotonic date index\n",
-    "            if cfg.enforce_monotonic_index and not clean.index.is_monotonic_increasing:\n",
-    "                raise ValueError(\"Date index not monotonically increasing\")\n",
-    "\n",
-    "            # 5. Duplicate dates\n",
-    "            if not cfg.allow_duplicate_dates and clean.index.duplicated().any():\n",
-    "                raise ValueError(\"Duplicate dates detected in index\")\n",
-    "\n",
-    "            # 6. Coverage checks using config thresholds\n",
-    "            m_ok = df.groupby(\"Month\")[f].apply(lambda col: col.notna().any())\n",
-    "            mask = m_ok.reindex(span, fill_value=False).to_numpy()\n",
-    "\n",
-    "            # tolerance for missing months per-cfg\n",
-    "            missing_count = (~mask).sum()\n",
-    "            if missing_count > cfg.max_missing_months:\n",
-    "                raise ValueError(f\"Missing-month count {missing_count} exceeds {cfg.max_missing_months}\")\n",
-    "\n",
-    "            # maximum run of consecutive missing months per-cfg with guard\n",
-    "            temp = np.flatnonzero(np.r_[True, mask, True])\n",
-    "            if temp.size <= 1:\n",
-    "                gap = 0\n",
-    "            else:\n",
-    "                gap = np.diff(temp).max() - 1\n",
-    "            if gap > cfg.max_consecutive_month_gap:\n",
-    "                raise ValueError(f\"Consecutive-missing gap {gap} exceeds {cfg.max_consecutive_month_gap}\")\n",
-    "\n",
-    "            eligible_funds.append(f)\n",
-    "\n",
-    "        except ValueError as e:\n",
-    "            logging.warning(\"Excluded %s: %s\", f, e)\n",
-    "        except KeyError as e:\n",
-    "            logging.warning(\"Missing data for %s: %s\", f, e)\n",
-    "        except Exception as e:\n",
-    "            logging.warning(\"Unexpected error on %s: %s\", f, e)\n",
-    "\n",
-    "    # Final selection-mode logic\n",
-    "    if selection_mode == \"all\" or random_n is None:\n",
-    "        return eligible_funds\n",
-    "    if selection_mode == \"random\":\n",
-    "        if random_n > len(eligible_funds):\n",
-    "            raise ValueError(\n",
-    "                f\"random_n exceeds eligible pool: {random_n} > {len(eligible_funds)}\"\n",
-    "            )\n",
-    "        return list(np.random.choice(eligible_funds, random_n, replace=False))\n",
-    "\n",
-    "    raise ValueError(f\"Unsupported selection_mode '{selection_mode}'\")\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {
-    "id": "ac53bc18"
-   },
-   "source": [
-    "## 3. Weight Prep"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {
-    "id": "59a9bf13"
-   },
-   "outputs": [],
-   "source": [
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  3 · WEIGHT PREP\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "def prepare_weights(selected: list[str],\n",
-    "                    custom: Dict[str, int] | None) -> tuple[Dict[str, float], np.ndarray]:\n",
-    "    if not custom:\n",
-    "        w = {f: 1/len(selected) for f in selected}\n",
-    "    else:\n",
-    "        missing = [f for f in selected if f not in custom]\n",
-    "        if missing:\n",
-    "            raise ValueError(f\"Missing weights for {missing}\")\n",
-    "        w = {f: pct/100 for f, pct in custom.items()}\n",
-    "        if abs(sum(w.values()) - 1) > 1e-6:\n",
-    "            raise ValueError(\"Custom weights must sum to 100.\")\n",
-    "    vec = np.array([w[f] for f in selected])\n",
-    "    return w, vec"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {
-    "id": "b3666a84"
-   },
-   "source": [
-    "## 4. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Function definitions\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {
-    "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44"
-   },
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "# 4 · CORE STATS  +  RUN_ANALYSIS  (helpers included, weight fix)\n",
-    "# ===============================================================\n",
-    "\n",
-    "M_PER_YEAR = 12           # constant used across helpers\n",
-    "\n",
-    "# ---------- helpers --------------------------------------------\n",
-    "def _ensure_dt(df: pd.DataFrame) -> pd.DataFrame:\n",
-    "    \"\"\"Return a copy whose Date column is datetime64[ns].\"\"\"\n",
-    "    if pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        return df\n",
-    "    df = df.copy()\n",
-    "    df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "    df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "    return df\n",
-    "\n",
-    "# 3. Metric function definitions\n",
-    "# === Metric Function Definitions with flexible annualization ===\n",
-    "@register_metric(\"AnnualReturn\")\n",
-    "def compute_annual_return(\n",
-    "    returns: pd.Series,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Geometric annualized return based on periods_per_year.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return np.nan\n",
-    "    total_growth = (1 + r).prod()\n",
-    "    n_periods = len(r)\n",
-    "    return total_growth ** (periods_per_year / n_periods) - 1\n",
-    "\n",
-    "@register_metric(\"Volatility\")\n",
-    "def compute_volatility(\n",
-    "    returns: pd.Series,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Annualized standard deviation of returns with flexible scaling.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return 0.0\n",
-    "    return r.std(ddof=0) * np.sqrt(periods_per_year)\n",
-    "\n",
-    "@register_metric(\"Sharpe\")\n",
-    "def compute_sharpe(\n",
-    "    returns: pd.Series,\n",
-    "    risk_free: float = 0.0,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Sharpe ratio using flexible annualized return and volatility.\n",
-    "    \"\"\"\n",
-    "    vol = compute_volatility(returns, periods_per_year=periods_per_year)\n",
-    "    if vol == 0:\n",
-    "        return np.nan\n",
-    "    ann_ret = compute_annual_return(returns, periods_per_year=periods_per_year)\n",
-    "    return (ann_ret - risk_free) / vol\n",
-    "\n",
-    "@register_metric(\"Sortino\")\n",
-    "def compute_sortino(\n",
-    "    returns: pd.Series,\n",
-    "    risk_free: float = 0.0,\n",
-    "    periods_per_year: int = 252,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Sortino ratio using flexible annualized return and downside deviation.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return np.nan\n",
-    "    ann_ret = compute_annual_return(returns, periods_per_year=periods_per_year)\n",
-    "    # Define per-period risk-free rate\n",
-    "    period_rf = risk_free / periods_per_year\n",
-    "    excess = r - period_rf\n",
-    "    downside = excess[excess < 0]\n",
-    "    if downside.empty:\n",
-    "        return np.nan\n",
-    "    down_dev = np.sqrt((downside ** 2).mean()) * np.sqrt(periods_per_year)\n",
-    "    if down_dev == 0:\n",
-    "        return np.nan\n",
-    "    return (ann_ret - risk_free) / down_dev\n",
-    "\n",
-    "@register_metric(\"MaxDrawdown\")\n",
-    "def compute_max_drawdown(\n",
-    "    returns: pd.Series,\n",
-    "    **kwargs\n",
-    ") -> float:\n",
-    "    \"\"\"\n",
-    "    Maximum drawdown (peak-to-trough) of cumulative returns.\n",
-    "    \"\"\"\n",
-    "    r = returns.dropna()\n",
-    "    if r.empty:\n",
-    "        return 0.0\n",
-    "    cum = (1 + r).cumprod()\n",
-    "    peak = cum.cummax()\n",
-    "    drawdown = (cum / peak) - 1\n",
-    "    return float(drawdown.min())\n",
-    "\n",
-    "# Alias for backward compatibility\n",
-    "_ann_vol = compute_volatility\n",
-    "\n",
-    "# === Aggregator with Centralized Error Handling ===\n",
-    "\n",
-    "def _stats(\n",
-    "    returns: pd.Series,\n",
-    "    cfg: RiskStatsConfig,\n",
-    "    **metric_kwargs\n",
-    ") -> namedtuple:\n",
-    "    \"\"\"\n",
-    "    Run each metric in cfg.metrics_to_run, returning a namedtuple of values.\n",
-    "    Uses cfg.periods_per_year for annualization.\n",
-    "    Centralized try/except ensures one failing metric doesn’t break the batch.\n",
-    "    \"\"\"\n",
-    "    Stat = namedtuple(\"Stat\", cfg.metrics_to_run)\n",
-    "    values: list[float] = []\n",
-    "    for name in cfg.metrics_to_run:\n",
-    "        fn = METRIC_REGISTRY.get(name)\n",
-    "        if fn is None:\n",
-    "            logging.error(\"Metric '%s' not registered\", name)\n",
-    "            values.append(np.nan)\n",
-    "            continue\n",
-    "        try:\n",
-    "            params = {\n",
-    "                \"risk_free\": cfg.risk_free,\n",
-    "                \"periods_per_year\": cfg.periods_per_year,\n",
-    "                **metric_kwargs\n",
-    "            }\n",
-    "            val = fn(returns, **params)\n",
-    "        except ZeroDivisionError:\n",
-    "            logging.warning(\"%s: division by zero, setting NaN\", name)\n",
-    "            val = np.nan\n",
-    "        except (ValueError, TypeError) as e:\n",
-    "            logging.warning(\"%s: invalid input (%s), setting NaN\", name, e)\n",
-    "            val = np.nan\n",
-    "        except Exception as e:\n",
-    "            logging.error(\"%s: unexpected error (%s), setting NaN\", name, e)\n",
-    "            val = np.nan\n",
-    "        values.append(val)\n",
-    "    return Stat(*values)\n",
-    "\n",
-    "# ---------- main ------------------------------------------------\n",
-    "def run_analysis(\n",
-    "    df,\n",
-    "    selected,\n",
-    "    w_vec,\n",
-    "    w_dict,\n",
-    "    rf_col,\n",
-    "    in_start,\n",
-    "    in_end,\n",
-    "    out_start,\n",
-    "    out_end,\n",
-    "    target_vol,\n",
-    "    monthly_cost,\n",
-    "    indices_list\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Vectorised run_analysis with correct weight re-normalisation\n",
-    "    after funds are dropped.\n",
-    "    Returns the same keys used by the UI and export functions.\n",
-    "    \"\"\"\n",
-    "    df = _ensure_dt(df)\n",
-    "\n",
-    "    # ---- date masks --------------------------------------------------\n",
-    "    in_s = pd.to_datetime(in_start)  + pd.offsets.MonthEnd(0)\n",
-    "    in_e = pd.to_datetime(in_end)    + pd.offsets.MonthEnd(0)\n",
-    "    out_s= pd.to_datetime(out_start) + pd.offsets.MonthEnd(0)\n",
-    "    out_e= pd.to_datetime(out_end)   + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    m_in  = df[\"Date\"].between(in_s,  in_e)\n",
-    "    m_out = df[\"Date\"].between(out_s, out_e)\n",
-    "\n",
-    "    in_df,  out_df  = df.loc[m_in,  selected], df.loc[m_out, selected]\n",
-    "    in_rf,  out_rf  = df.loc[m_in,  rf_col],   df.loc[m_out, rf_col]\n",
-    "\n",
-    "    # ---- drop funds with any NaNs in either window ------------------\n",
-    "    good = [f for f in selected\n",
-    "            if in_df[f].notna().all() and out_df[f].notna().all()]\n",
-    "    dropped = list(set(selected) - set(good))\n",
-    "    if dropped:\n",
-    "        logging.warning(\"Dropped funds: %s\", dropped)\n",
-    "\n",
-    "    selected = good\n",
-    "    # >>>> new guard: kick out any accidental index columns\n",
-    "    selected = [f for f in selected if f not in (indices_list or [])]\n",
-    "    # <<<<\n",
-    "\n",
-    "    in_df, out_df = in_df[selected], out_df[selected]\n",
-    "\n",
-    "    # rebuild weights\n",
-    "    if w_dict is None:                      # equal-weight path\n",
-    "        w_dict = {f: 1/len(selected) for f in selected}\n",
-    "    else:                                   # manual path → rescale\n",
-    "        pct   = {f: w_dict[f]*100 for f in selected}\n",
-    "        total = sum(pct.values())\n",
-    "        w_dict = {f: p/total for f, p in pct.items()}\n",
-    "    w_vec = np.array([w_dict[f] for f in selected])\n",
-    "\n",
-    "    # ---- scaling ----------------------------------------------------\n",
-    "    vols = in_df.apply(compute_volatility)\n",
-    "    scale = np.where(vols > 0, target_vol / vols, 1.0)\n",
-    "    in_sc  = (in_df * scale) - monthly_cost\n",
-    "    out_sc = (out_df * scale) - monthly_cost\n",
-    "    in_sc.clip(lower=-1, inplace=True)\n",
-    "    out_sc.clip(lower=-1, inplace=True)\n",
-    "\n",
-    "    # ---- stats ------------------------------------------------------\n",
-    "    rf_value = in_rf.mean() if hasattr(in_rf, \"mean\") else float(in_rf)\n",
-    "\n",
-    "    # Create a RiskStatsConfig for in-sample stats\n",
-    "    stats_cfg = RiskStatsConfig(risk_free=rf_value)\n",
-    "\n",
-    "    # Now compute stats for each scenario, always passing stats_cfg first\n",
-    "    in_stat = {\n",
-    "        f: _stats(in_sc[f], stats_cfg)\n",
-    "        for f in selected\n",
-    "    }\n",
-    "    out_rf_value = out_rf.mean() if hasattr(out_rf, \"mean\") else float(out_rf)\n",
-    "\n",
-    "    # Re‐use the same config, updating only the risk_free field\n",
-    "    stats_cfg.risk_free = out_rf_value\n",
-    "\n",
-    "    out_stat = {\n",
-    "        f: _stats(out_sc[f], stats_cfg)\n",
-    "        for f in selected\n",
-    "    }\n",
-    "\n",
-    "    ew_vec = np.full(len(selected), 1/len(selected))\n",
-    "    w_vec = np.full(len(selected), 1/len(selected))\n",
-    "\n",
-    "    in_ew_stats  = _stats(in_sc.dot(ew_vec),  stats_cfg)\n",
-    "    out_ew_stats = _stats(out_sc.dot(ew_vec), stats_cfg)\n",
-    "    in_user_stats  = _stats(in_sc.dot(w_vec),  stats_cfg)\n",
-    "    out_user_stats = _stats(out_sc.dot(w_vec), stats_cfg)\n",
-    "\n",
-    "    results = {\n",
-    "        \"selected_funds\": selected,\n",
-    "        \"indices_list\":   indices_list or [],\n",
-    "        \"fund_weights\":   w_dict,\n",
-    "        \"ew_weights\":     {f: 1/len(selected) for f in selected},\n",
-    "        \"in_sample_stats\":  in_stat,\n",
-    "        \"out_sample_stats\": out_stat,\n",
-    "        \"in_ew_stats\":     in_ew_stats,\n",
-    "        \"out_ew_stats\":    out_ew_stats,\n",
-    "        \"in_user_stats\":   in_user_stats,\n",
-    "        \"out_user_stats\":  out_user_stats,\n",
-    "        \"dropped\":         dropped,\n",
-    "    }\n",
-    "\n",
-    "    # ---- optional index stats ---------------------------------------\n",
-    "    if indices_list:\n",
-    "        idx_stats = {}\n",
-    "        for col in indices_list:\n",
-    "            idx_stats[col] = {\n",
-    "                \"in_sample\":  _stats(df.loc[m_in,  col], stats_cfg),\n",
-    "                \"out_sample\": _stats(df.loc[m_out, col], stats_cfg),\n",
-    "            }\n",
-    "        results[\"index_stats\"] = idx_stats\n",
-    "\n",
-    "    return results\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {
-    "id": "183dc5df"
-   },
-   "source": [
-    "## 5. Excel Export\n",
-    "Creates an Excel file with In-Sample, Out-of-Sample and Equal-weight and User-weight."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "8e2cce23",
-   "metadata": {
-    "id": "8e2cce23"
-   },
-   "outputs": [],
-   "source": [
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  5 · EXPORT  (NaN-safe, weight-format fix)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# ───────── 5 · EXPORT  (final, bug-free) ───────────────────────\n",
-    "# ───────── 5 · EXPORT  (self-healing index section) ───────────\n",
-    "# ───────── 5 · EXPORT  (final safe version) ───────────────────\n",
-    "\n",
-    "def export_to_excel(\n",
-    "    data: dict[str, pd.DataFrame],\n",
-    "    output_path: str,\n",
-    "    default_format: Optional[Callable] = None\n",
-    ") -> None:\n",
-    "    \"\"\"\n",
-    "    Exports each DataFrame in `data` to its own sheet in `output_path`.\n",
-    "    Applies a registered formatter for each category (sheet name).\n",
-    "    If no formatter is found, applies `default_format` if provided.\n",
-    "\n",
-    "    For the Summary sheet, data is written starting at row 5 to make room for custom headers.\n",
-    "    \"\"\"\n",
-    "    startrows = {\"summary\": 5}\n",
-    "    with pd.ExcelWriter(output_path, engine=\"xlsxwriter\") as writer:\n",
-    "        for category, df in data.items():\n",
-    "            startrow = startrows.get(category, 0)\n",
-    "            df.to_excel(writer, sheet_name=category, index=False, startrow=startrow)\n",
-    "            fn = FORMATTERS_EXCEL.get(category, default_format)\n",
-    "            if fn: fn(writer.sheets[category], writer.book)\n",
-    "    # Workbook is auto-saved and closed by the context manager\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {
-    "id": "ee8c2c6d"
-   },
-   "source": [
-    "## 6. Run Parameters, Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc. Also lets us use custom weights."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {
-    "id": "86794206"
-   },
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "e48de568-962e-4690-a6fc-be7a4ec0a3c6",
-   "metadata": {
-    "colab": {
-     "base_uri": "https://localhost:8080/",
-     "height": 896,
-     "referenced_widgets": [
-      "8face5cf545b40ceaf10b1506e754d71",
-      "db185d3992024056acfa2ffe419931d8",
-      "c459f2c677ff4bea8db916696b7b600e",
-      "170d05f5ba184c13bb39914b17257476",
-      "64045569d769471e92ac17aebf71022f",
-      "f83a99900b324015862cad100f5bfc0c",
-      "ee231bb4cb97454591e7a6774bb2f7bd",
-      "eceecb3f8a864d1eb15aab7d531e3cd1",
-      "75ad9c9f175f4960999958cd9f6d056a",
-      "e0d83789c4034d9ab9b3c2fa85870beb",
-      "ae753571f5814a65865abbdb10540373",
-      "125e415320644832a8be95b92713e257",
-      "8c053f4df9ff486f84b123eda524cbe7",
-      "d3bae0e7a2474ea4bdce0b0b9e413059",
-      "516389ac0f0042a0bbeab3bd64493997",
-      "e7dc4acbb2eb4a0e8c5112e4b2a85393",
-      "332172fad96e4be2857e530ba9df86c6",
-      "354bbc188daa4493967e2b143ceea510",
-      "6dc67c18884044ac811b3a256f69171e",
-      "d80f632f65c44c338a41d0b4e3dc5ea7",
-      "9a302560059a43338397161ea2ad37c7",
-      "a8d2ae4652394bb4b2a740097a4d7ea7",
-      "dbe1076d681040169eca1b570e2485e2",
-      "593aad971d274b90b56cecc15e09dc39",
-      "6418ed5196fd485cae29568a24bf60ae",
-      "d12e413cbeac41a39fd9b94479c1eca8",
-      "10e898df8a0e460b9f3e3a40b48f51f4",
-      "97212667726d480eb944e25ec32cfc25",
-      "6e75d93c40ea4c40b9162ab51e807d98",
-      "646d2e69e110438fa2feb8b60af24bb7",
-      "47ae7b5e18314a2596b33cc6c774942b",
-      "05a596b6c3864ddc931b3112153f12ab",
-      "8f3ec331c368446b8552a06238a12608",
-      "3814c0e0fa1c438e87df5b60a82dd3e4",
-      "6c7f140622534a6cab6133758aa7a936",
-      "5759bee9a2034ed3b9b4196e158b58eb",
-      "6e5e4fc36c674146a86dc3f8b6edbd7d",
-      "fa9ee776b338497e9385f3d1a8d02fff",
-      "32bac6722d6d47a6b5a88372e9e5d44e",
-      "dfbe93388b474442833b5e7b7efc1e5f",
-      "d13209a7e5c94f6585d47c2430fa7885",
-      "704f7526c3934eed85b653fb00714114",
-      "08882c12ccaa4d058bc554020c044559",
-      "1c01c7f8d62041198190f4bfbe21aff5",
-      "9ac98c85e0f147f8a191f6d32651d0cc",
-      "e00ed42085424c6f91fb07fb2d22ee62",
-      "818aa783706f4087a3754d39d861ced6",
-      "258e8504f9cc4be783ea207c43e56214",
-      "bedc16eeb19740bb9ee6e810bc9b7a71",
-      "2e2775bb4c6e4b98ba4706d90b24e042",
-      "b411a590b161465185dfd853a6dd95d6",
-      "a503b43ca679455f978c6903bdb598cf",
-      "70dfa008682a460aa02625a933b33606",
-      "514e5aafad0044cb9df9232ef0a4e264",
-      "367366f650c644d59791946a3c8d86d0",
-      "15de8a73c52642c598ad8baeb3609499",
-      "2e6724a498d54c73a8f594b19c6a3d20",
-      "09e8f8999ea1463a9d603da4f4f70b12",
-      "1da4518f46b84fc7b84d387c7e34f050",
-      "021e4dc72d814e5d8c42592b541b6723",
-      "97f4dce2a3874dafaeb0ba92775ae2a0",
-      "f5539db7aca6440e9c3dee43697c4fae",
-      "2e96cf393a754d279bcf02c66548f6dd",
-      "0b231b28c644443db3e659a17096f55c",
-      "62c2030d08cf4f1e91c9c9038f31b864",
-      "e5c317ba51ed45818d7d60cc4aaec11d",
-      "7e5dd5f9379a4104ad7965a34e569a7a",
-      "383dee58194446698cb8eb9df41b7778",
-      "72bdf8a1ccfa4d0985547020c90908a0",
-      "8a9b22cd239d43d191387ebc9e660ff8",
-      "86a9efbe68f5450685a4e8aa1c96e84e",
-      "38d3e511fdc14bcaa7b04d8583be18dc",
-      "8d9670b7900c40b8849f7e4629d50424",
-      "eed45853cf99427398e7b16f2cab9f8b",
-      "5363ac1b24b24811ae9c63b86dfbf359",
-      "74577bb60c55412d9c38960d7d865fd6",
-      "d37456fcb76f4acda7978257483bf2ad",
-      "d6710d2b4b0b4b02b5358d2d152fbad9",
-      "ca05ab87b3e040cbbf4016ae0671fc40",
-      "958a21d97fa546a2b314e2c988b43589",
-      "202010c9f8324e1493baa92d83ff9335",
-      "4a022a6055c34004b7a3aa671a168ee3",
-      "c9b1027aad95413c94835aef5ce74a5b",
-      "ae45af3a4d3d4fb8b1c2827585ed7f7f",
-      "574d70e37e6a449dbdd4365c2d86fda8",
-      "d9f6106f986b4ea49d957594d8d5c324",
-      "e8b9fd55c6094126b24ab2e7cffa4dc5",
-      "f5e355edbbc946b3b6e1ba36f839d45b",
-      "78906e475e9d4bda8b7e0c4ca4de577c",
-      "65dbf5a3b3a2406aa9f807b74dc5543b",
-      "269ab898c24e4cf697ad3dc2854a7215",
-      "ff9bd5c776a741248e4a64d445950c90",
-      "4b551eab21b34f488d743ea730a541d8",
-      "05b7cb98ce374c10828efb3d205fe4ff",
-      "6c1e290b8fdf4e31872f11e0c5438b5d",
-      "be7153ab36374e62a7d6a234dc1c973e",
-      "d22068b3d502469fa1631d698a3d3779",
-      "e02a002607844c6ba0249122b505b8f5",
-      "d807a3a60ca14ddda5fbec481049b6d4"
-     ]
-    },
-    "id": "e48de568-962e-4690-a6fc-be7a4ec0a3c6",
-    "outputId": "795bb6da-96a0-42e2-c760-7d516fd82610"
-   },
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "707a5f34098a499db0dbaf22783f7e2a",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<h4>1. Load data</h4>'), ToggleButtons(description='Source:', options=(('Local', 'l…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# ===============================================================\n",
-    "#            STREAMLINED ANALYSIS UI  (phase-2 clean)\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ---------- session store ----------\n",
-    "session = {\"df\": None, \"rf\": None, \"sel\": None, \"cweights\": None}\n",
-    "\n",
-    "# ---------- 1 · DATA LOAD ----------\n",
-    "src = widgets.ToggleButtons(\n",
-    "    options=[(\"Local\", \"local\"), (\"URL\", \"url\")],\n",
-    "    description=\"Source:\"\n",
-    ")\n",
-    "\n",
-    "chooser = FileChooser()\n",
-    "url_box = widgets.Text(placeholder=\"https://…/file.csv\", layout={\"width\":\"70%\"})\n",
-    "load_btn = widgets.Button(description=\"Load CSV\", button_style=\"success\")\n",
-    "load_out = widgets.Output()\n",
-    "\n",
-    "def _toggle_src(c):\n",
-    "    chooser.layout.display = \"block\" if c[\"new\"]==\"local\" else \"none\"\n",
-    "    url_box.layout.display  = \"block\" if c[\"new\"]==\"url\"   else \"none\"\n",
-    "src.observe(_toggle_src, names=\"value\"); _toggle_src({\"new\":src.value})\n",
-    "\n",
-    "def _load(_):\n",
-    "    with load_out:\n",
-    "        clear_output()\n",
-    "        try:\n",
-    "            path = chooser.selected if src.value==\"local\" else url_box.value.strip()\n",
-    "            if not path: raise ValueError(\"choose file / URL\")\n",
-    "            if src.value==\"url\" and not path.lower().endswith(\".csv\"):\n",
-    "                raise ValueError(\"URL must end with .csv\")\n",
-    "            df = load_csv(path)\n",
-    "            df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")  # single coercion\n",
-    "            rf = identify_risk_free_fund(df)\n",
-    "            session.update(df=df, rf=rf, sel=None, cweights=None)\n",
-    "            print(f\"✅ Loaded {len(df):,} rows × {df.shape[1]} cols | RF → {rf}\")\n",
-    "        except Exception as e:\n",
-    "            print(\"❌\", e); session[\"df\"]=None\n",
-    "load_btn.on_click(_load)\n",
-    "\n",
-    "# ---------- 2 · PARAMS ------------\n",
-    "index_cnt = widgets.BoundedIntText(0, min=0, max=10, description=\"# Indices:\")\n",
-    "in_start,in_end  = widgets.Text(\"2005-07\"), widgets.Text(\"2008-06\")\n",
-    "out_start,out_end= widgets.Text(\"2008-07\"), widgets.Text(\"2009-06\")\n",
-    "for w,lbl in [(in_start,\"In Start:\"),(in_end,\"In End:\"),\n",
-    "              (out_start,\"Out Start:\"),(out_end,\"Out End:\")]:\n",
-    "    w.description = lbl\n",
-    "target_vol   = widgets.FloatText(0.25,  description=\"Target Vol:\")\n",
-    "monthly_cost = widgets.FloatText(0.0033, description=\"Monthly Cost:\")\n",
-    "\n",
-    "# ---------- 3 · SELECTION ----------\n",
-    "mode_dd = widgets.Dropdown(\n",
-    "    options=[(\"All\", \"all\"), (\"Random\", \"random\"), (\"Manual\", \"manual\")],\n",
-    "    value=\"all\",\n",
-    "    description=\"Mode:\"\n",
-    ")\n",
-    "rand_n   = widgets.BoundedIntText(5, min=2, max=100, description=\"Sample N:\")\n",
-    "fund_table, total_lbl = widgets.VBox([]), widgets.Label(\"Total = 0 %\")\n",
-    "\n",
-    "def _toggle_sel(_=None):\n",
-    "    rand_n.layout.display  = \"block\" if mode_dd.value==\"random\" else \"none\"\n",
-    "    vis = \"block\" if mode_dd.value==\"manual\" else \"none\"\n",
-    "    fund_table.layout.display = total_lbl.layout.display = vis\n",
-    "mode_dd.observe(_toggle_sel, names=\"value\"); _toggle_sel()\n",
-    "\n",
-    "# ---------- helpers ---------------\n",
-    "def _eligible_pool():\n",
-    "    df, rf = session[\"df\"], session[\"rf\"]\n",
-    "    if df is None:\n",
-    "        print(\"⚠️ data not loaded\"); return []\n",
-    "\n",
-    "    # ---- date parse guard -----------------------------------\n",
-    "    try:\n",
-    "        in_s  = pd.to_datetime(in_start.value)+pd.offsets.MonthEnd(0)\n",
-    "        in_e  = pd.to_datetime(in_end.value)  +pd.offsets.MonthEnd(0)\n",
-    "        out_s = pd.to_datetime(out_start.value)+pd.offsets.MonthEnd(0)\n",
-    "        out_e = pd.to_datetime(out_end.value)  +pd.offsets.MonthEnd(0)\n",
-    "    except Exception:\n",
-    "        print(\"❌ invalid dates\"); return []\n",
-    "\n",
-    "    # ---- build indices (RIGHT-most idx_n non-RF columns) ----\n",
-    "    idx_n     = index_cnt.value\n",
-    "    data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-    "    non_rf    = [c for c in data_cols if c != rf]\n",
-    "    indices   = non_rf[-idx_n:] if idx_n else []          # <- fixed\n",
-    "    cand      = [c for c in data_cols if c not in indices]\n",
-    "\n",
-    "    # ---- run select_funds ----------------------------------\n",
-    "    elig = select_funds(\n",
-    "        df=df,\n",
-    "        rf_col=rf,\n",
-    "        fund_columns=cand,\n",
-    "        in_sdate=in_s,\n",
-    "        in_edate=in_e,\n",
-    "        out_sdate=out_s,\n",
-    "        out_edate=out_e,\n",
-    "        cfg=cfg,                     # ← Explicitly supply your config here\n",
-    "        selection_mode=\"all\",\n",
-    "    )\n",
-    "    # … diagnostics print unchanged …\n",
-    "    return elig\n",
-    "\n",
-    "def _build_manual(*_):\n",
-    "    if mode_dd.value!=\"manual\" or session[\"df\"] is None: return\n",
-    "    valid = _eligible_pool()\n",
-    "    print(\"DEBUG  eligible funds =\", len(valid))              # ← line 1\n",
-    "    print(\"DEBUG  list sample   →\", valid[:25], \"…\")           # ← line 2\n",
-    "    if not valid:\n",
-    "        print(\"❌ No eligible funds\"); return\n",
-    "    fund_table.children = []                # reset\n",
-    "\n",
-    "    def _update_total(*_):\n",
-    "        tot = sum(r.children[1].value for r in fund_table.children\n",
-    "                  if r.children[0].value)\n",
-    "        total_lbl.value = f\"Total = {tot} %\"\n",
-    "\n",
-    "    for f in valid:\n",
-    "        cb = widgets.Checkbox(description=f, layout={\"width\":\"200px\"})\n",
-    "        wt = widgets.BoundedIntText(0, min=0, max=100,\n",
-    "                                    layout={\"width\":\"60px\"}, disabled=True)\n",
-    "        def _toggle(ch, box=wt):           # single observer\n",
-    "            box.disabled = not ch[\"new\"]\n",
-    "            if box.disabled: box.value = 0\n",
-    "            _update_total()\n",
-    "        cb.observe(_toggle, names=\"value\")\n",
-    "        wt.observe(_update_total, names=\"value\")\n",
-    "        fund_table.children += (widgets.HBox([cb, wt]),)\n",
-    "    _update_total()\n",
-    "\n",
-    "mode_dd.observe(lambda ch: _build_manual() if ch[\"new\"]==\"manual\" else None,\n",
-    "                names=\"value\")\n",
-    "for w in (in_start,in_end,out_start,out_end): w.observe(_build_manual,names=\"value\")\n",
-    "\n",
-    "# ---------- 4 · RUN ---------------\n",
-    "run_btn = widgets.Button(description=\"Run Analysis\", button_style=\"success\")\n",
-    "run_out = widgets.Output(layout={\"border\":\"1px solid #999\",\n",
-    "                                 \"height\":\"340px\",\"overflow_y\":\"auto\"})\n",
-    "\n",
-    "def _run(_):\n",
-    "    with run_out:\n",
-    "        clear_output()\n",
-    "        df, rf = session[\"df\"], session[\"rf\"]\n",
-    "        if df is None: print(\"⚠️ Load data first\"); return\n",
-    "\n",
-    "        # indices (robust)\n",
-    "        idx_n     = index_cnt.value\n",
-    "        data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-    "        non_rf    = [c for c in data_cols if c != rf]\n",
-    "        indices   = non_rf[-idx_n:] if idx_n else []\n",
-    "\n",
-    "        # pool + selection\n",
-    "        pool = _eligible_pool()\n",
-    "        if not pool: print(\"❌ No eligible funds\"); return\n",
-    "        if mode_dd.value==\"all\":\n",
-    "            sel, custom = pool, None\n",
-    "        elif mode_dd.value==\"random\":\n",
-    "            if rand_n.value>len(pool): print(\"⚠️ Sample N too big\"); return\n",
-    "            sel, custom = list(np.random.choice(pool, rand_n.value, replace=False)), None\n",
-    "        else:\n",
-    "            sel, custom = [], {}\n",
-    "            if not fund_table.children: _build_manual()\n",
-    "            for row in fund_table.children:\n",
-    "                cb, wt = row.children\n",
-    "                if cb.value: sel.append(cb.description); custom[cb.description]=wt.value\n",
-    "            if sum(custom.values())!=100: print(\"⚠️ Weights ≠ 100\"); return\n",
-    "\n",
-    "        w_dict,w_vec = prepare_weights(sel, custom)\n",
-    "\n",
-    "        res = run_analysis(df, sel, w_vec, w_dict, rf,\n",
-    "                           in_start.value, in_end.value,\n",
-    "                           out_start.value, out_end.value,\n",
-    "                           target_vol.value, monthly_cost.value,\n",
-    "                           indices)\n",
-    "\n",
-    "        print(\"✅ analysis complete |\", len(sel), \"funds\")\n",
-    "        if res[\"dropped\"]:\n",
-    "            print(\"⚠️ Dropped:\", res[\"dropped\"])\n",
-    "        if indices: print(\"📊 Indices:\", indices)\n",
-    "\n",
-    "        fname=f\"IS_{in_start.value}_{out_start.value}.xlsx\"\n",
-    "        # register only the combined summary formatter\n",
-    "        make_summary_formatter(\n",
-    "            res,\n",
-    "            in_start.value,\n",
-    "            in_end.value,\n",
-    "            out_start.value,\n",
-    "            out_end.value\n",
-    "        )\n",
-    "\n",
-    "        # Build a minimal data dict with just the 'summary' sheet.\n",
-    "        # The formatter will populate all rows (portfolio, funds, spacer, indices).\n",
-    "        data = {\n",
-    "            \"summary\": pd.DataFrame()\n",
-    "        }\n",
-    "\n",
-    "        print(\"Sheets to write:\", list(data.keys()))\n",
-    "        print(\"Formatters:\", list(FORMATTERS_EXCEL.keys()))\n",
-    "\n",
-    "        # Export — this will call fmt_summary(ws, wb) on the 'summary' sheet.\n",
-    "        export_to_excel(data, fname)\n",
-    "        print(\"Workbook saved as\", fname)\n",
-    "\n",
-    "run_btn.on_click(_run)\n",
-    "\n",
-    "# ---------- DISPLAY --------------\n",
-    "display(widgets.VBox([\n",
-    "    widgets.HTML(\"<h4>1. Load data</h4>\"),\n",
-    "    src, chooser, url_box, load_btn, load_out,\n",
-    "    widgets.HTML(\"<hr><h4>2. Parameters</h4>\"),\n",
-    "    widgets.HBox([index_cnt]),\n",
-    "    widgets.HBox([in_start,in_end,out_start,out_end]),\n",
-    "    widgets.HBox([target_vol,monthly_cost]),\n",
-    "    widgets.HTML(\"<hr><h4>3. Fund selection</h4>\"),\n",
-    "    widgets.HBox([mode_dd,rand_n]),\n",
-    "    fund_table, total_lbl,\n",
-    "    widgets.HTML(\"<hr>\"),\n",
-    "    run_btn,\n",
-    "    run_out\n",
-    "]))\n"
-   ]
-  }
- ],
- "metadata": {
-  "colab": {
-   "provenance": []
-  },
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  },
-  "widgets": {
-   "application/vnd.jupyter.widget-state+json": {
-    "021e4dc72d814e5d8c42592b541b6723": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "SelectModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "SelectModel",
-      "_options_labels": [
-       "📁 ..",
-       "📁 sample_data",
-       "Vol_Adj_Trend_Analysis_1_3_TrEx.ipynb"
-      ],
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "SelectView",
-      "description": "",
-      "description_tooltip": null,
-      "disabled": false,
-      "index": null,
-      "layout": "IPY_MODEL_f5e355edbbc946b3b6e1ba36f839d45b",
-      "rows": 8,
-      "style": "IPY_MODEL_78906e475e9d4bda8b7e0c4ca4de577c"
-     }
-    },
-    "05a596b6c3864ddc931b3112153f12ab": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "05b7cb98ce374c10828efb3d205fe4ff": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_be7153ab36374e62a7d6a234dc1c973e",
-      "placeholder": "",
-      "style": "IPY_MODEL_d22068b3d502469fa1631d698a3d3779",
-      "value": "<span style=\"color:black;\">No selection</span>"
-     }
-    },
-    "08882c12ccaa4d058bc554020c044559": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "09e8f8999ea1463a9d603da4f4f70b12": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DropdownModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DropdownModel",
-      "_options_labels": [
-       "/content",
-       "/"
-      ],
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "DropdownView",
-      "description": "",
-      "description_tooltip": null,
-      "disabled": false,
-      "index": 0,
-      "layout": "IPY_MODEL_ae45af3a4d3d4fb8b1c2827585ed7f7f",
-      "style": "IPY_MODEL_574d70e37e6a449dbdd4365c2d86fda8"
-     }
-    },
-    "0b231b28c644443db3e659a17096f55c": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "BoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "BoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "BoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_05b7cb98ce374c10828efb3d205fe4ff"
-      ],
-      "layout": "IPY_MODEL_6c1e290b8fdf4e31872f11e0c5438b5d"
-     }
-    },
-    "10e898df8a0e460b9f3e3a40b48f51f4": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "500px"
-     }
-    },
-    "125e415320644832a8be95b92713e257": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_1c01c7f8d62041198190f4bfbe21aff5",
-      "placeholder": "​",
-      "style": "IPY_MODEL_9ac98c85e0f147f8a191f6d32651d0cc",
-      "value": "<hr><h4>3. Fund selection</h4>"
-     }
-    },
-    "15de8a73c52642c598ad8baeb3609499": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "170d05f5ba184c13bb39914b17257476": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "VBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "VBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "VBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_593aad971d274b90b56cecc15e09dc39",
-       "IPY_MODEL_6418ed5196fd485cae29568a24bf60ae",
-       "IPY_MODEL_d12e413cbeac41a39fd9b94479c1eca8"
-      ],
-      "layout": "IPY_MODEL_10e898df8a0e460b9f3e3a40b48f51f4"
-     }
-    },
-    "1c01c7f8d62041198190f4bfbe21aff5": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "1da4518f46b84fc7b84d387c7e34f050": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_d9f6106f986b4ea49d957594d8d5c324",
-      "placeholder": "output filename",
-      "style": "IPY_MODEL_e8b9fd55c6094126b24ab2e7cffa4dc5",
-      "value": ""
-     }
-    },
-    "202010c9f8324e1493baa92d83ff9335": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "258e8504f9cc4be783ea207c43e56214": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "269ab898c24e4cf697ad3dc2854a7215": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "button_color": null,
-      "font_weight": ""
-     }
-    },
-    "2e2775bb4c6e4b98ba4706d90b24e042": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "2e6724a498d54c73a8f594b19c6a3d20": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "2e96cf393a754d279bcf02c66548f6dd": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ButtonView",
-      "button_style": "",
-      "description": "Cancel",
-      "disabled": false,
-      "icon": "",
-      "layout": "IPY_MODEL_ff9bd5c776a741248e4a64d445950c90",
-      "style": "IPY_MODEL_4b551eab21b34f488d743ea730a541d8",
-      "tooltip": ""
-     }
-    },
-    "32bac6722d6d47a6b5a88372e9e5d44e": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "Out End:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_eed45853cf99427398e7b16f2cab9f8b",
-      "placeholder": "​",
-      "style": "IPY_MODEL_5363ac1b24b24811ae9c63b86dfbf359",
-      "value": "2009-06"
-     }
-    },
-    "332172fad96e4be2857e530ba9df86c6": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ButtonView",
-      "button_style": "success",
-      "description": "Run Analysis",
-      "disabled": false,
-      "icon": "",
-      "layout": "IPY_MODEL_514e5aafad0044cb9df9232ef0a4e264",
-      "style": "IPY_MODEL_367366f650c644d59791946a3c8d86d0",
-      "tooltip": ""
-     }
-    },
-    "354bbc188daa4493967e2b143ceea510": {
-     "model_module": "@jupyter-widgets/output",
-     "model_module_version": "1.0.0",
-     "model_name": "OutputModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/output",
-      "_model_module_version": "1.0.0",
-      "_model_name": "OutputModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/output",
-      "_view_module_version": "1.0.0",
-      "_view_name": "OutputView",
-      "layout": "IPY_MODEL_d807a3a60ca14ddda5fbec481049b6d4",
-      "msg_id": "",
-      "outputs": [
-       {
-        "name": "stdout",
-        "output_type": "stream",
-        "text": [
-         "✅ analysis complete | 15 funds\n",
-         "⚠️ Dropped: ['Crescent Management']\n",
-         "📊 Indices: ['EqualWeight_60', 'EqualWeight_40']\n"
-        ]
-       },
-       {
-        "ename": "TypeError",
-        "evalue": "make_portfolio_formatter() takes 2 positional arguments but 5 were given",
-        "output_type": "error",
-        "traceback": [
-         "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-         "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
-         "\u001b[0;32m<ipython-input-56-445aa7dfbbcf>\u001b[0m in \u001b[0;36m_run\u001b[0;34m(_)\u001b[0m\n\u001b[1;32m    257\u001b[0m         \u001b[0;31m# … build your summary_df, in_stat, out_stat, weights …\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    258\u001b[0m         \u001b[0mmake_summary_formatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msummary_df\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0min_start\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0min_end\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_start\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_end\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0min_stat\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_stat\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mw_dict\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 259\u001b[0;31m         \u001b[0mmake_portfolio_formatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mportfolio_df\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"in_ew_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"out_ew_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"in_user_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"out_user_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    260\u001b[0m         \u001b[0mmake_indices_formatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mindices_df\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"index_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    261\u001b[0m         \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Sheets to write:\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlist\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mkeys\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
-         "\u001b[0;31mTypeError\u001b[0m: make_portfolio_formatter() takes 2 positional arguments but 5 were given"
-        ]
-       }
-      ]
-     }
-    },
-    "367366f650c644d59791946a3c8d86d0": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "button_color": null,
-      "font_weight": ""
-     }
-    },
-    "3814c0e0fa1c438e87df5b60a82dd3e4": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "BoundedIntTextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "BoundedIntTextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "IntTextView",
-      "continuous_update": false,
-      "description": "# Indices:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_e5c317ba51ed45818d7d60cc4aaec11d",
-      "max": 10,
-      "min": 0,
-      "step": 1,
-      "style": "IPY_MODEL_7e5dd5f9379a4104ad7965a34e569a7a",
-      "value": 2
-     }
-    },
-    "383dee58194446698cb8eb9df41b7778": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "38d3e511fdc14bcaa7b04d8583be18dc": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "47ae7b5e18314a2596b33cc6c774942b": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "button_color": null,
-      "font_weight": ""
-     }
-    },
-    "4a022a6055c34004b7a3aa671a168ee3": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "block",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "4b551eab21b34f488d743ea730a541d8": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "button_color": null,
-      "font_weight": ""
-     }
-    },
-    "514e5aafad0044cb9df9232ef0a4e264": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "516389ac0f0042a0bbeab3bd64493997": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "LabelModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "LabelModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "LabelView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_2e2775bb4c6e4b98ba4706d90b24e042",
-      "placeholder": "​",
-      "style": "IPY_MODEL_b411a590b161465185dfd853a6dd95d6",
-      "value": "Total = 0 %"
-     }
-    },
-    "5363ac1b24b24811ae9c63b86dfbf359": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "574d70e37e6a449dbdd4365c2d86fda8": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "5759bee9a2034ed3b9b4196e158b58eb": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "In Start:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_383dee58194446698cb8eb9df41b7778",
-      "placeholder": "​",
-      "style": "IPY_MODEL_72bdf8a1ccfa4d0985547020c90908a0",
-      "value": "2005-07"
-     }
-    },
-    "593aad971d274b90b56cecc15e09dc39": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_15de8a73c52642c598ad8baeb3609499",
-      "placeholder": "​",
-      "style": "IPY_MODEL_2e6724a498d54c73a8f594b19c6a3d20",
-      "value": ""
-     }
-    },
-    "62c2030d08cf4f1e91c9c9038f31b864": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "auto"
-     }
-    },
-    "64045569d769471e92ac17aebf71022f": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_97212667726d480eb944e25ec32cfc25",
-      "placeholder": "https://…/file.csv",
-      "style": "IPY_MODEL_6e75d93c40ea4c40b9162ab51e807d98",
-      "value": "https://raw.githubusercontent.com/stranske/Trend_Model_Project/refs/heads/main/hedge_fund_returns_with_indexes.csv"
-     }
-    },
-    "6418ed5196fd485cae29568a24bf60ae": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "GridBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "GridBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "GridBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_09e8f8999ea1463a9d603da4f4f70b12",
-       "IPY_MODEL_1da4518f46b84fc7b84d387c7e34f050",
-       "IPY_MODEL_021e4dc72d814e5d8c42592b541b6723"
-      ],
-      "layout": "IPY_MODEL_97f4dce2a3874dafaeb0ba92775ae2a0"
-     }
-    },
-    "646d2e69e110438fa2feb8b60af24bb7": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "65dbf5a3b3a2406aa9f807b74dc5543b": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": "6em",
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "6em"
-     }
-    },
-    "6c1e290b8fdf4e31872f11e0c5438b5d": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": "auto",
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "6c7f140622534a6cab6133758aa7a936": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "6dc67c18884044ac811b3a256f69171e": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "6e5e4fc36c674146a86dc3f8b6edbd7d": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "In End:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_8a9b22cd239d43d191387ebc9e660ff8",
-      "placeholder": "​",
-      "style": "IPY_MODEL_86a9efbe68f5450685a4e8aa1c96e84e",
-      "value": "2008-06"
-     }
-    },
-    "6e75d93c40ea4c40b9162ab51e807d98": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "704f7526c3934eed85b653fb00714114": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "FloatTextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "FloatTextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "FloatTextView",
-      "continuous_update": false,
-      "description": "Monthly Cost:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_d6710d2b4b0b4b02b5358d2d152fbad9",
-      "step": null,
-      "style": "IPY_MODEL_ca05ab87b3e040cbbf4016ae0671fc40",
-      "value": 0.0033
-     }
-    },
-    "70dfa008682a460aa02625a933b33606": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "72bdf8a1ccfa4d0985547020c90908a0": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "74577bb60c55412d9c38960d7d865fd6": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "75ad9c9f175f4960999958cd9f6d056a": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_3814c0e0fa1c438e87df5b60a82dd3e4"
-      ],
-      "layout": "IPY_MODEL_6c7f140622534a6cab6133758aa7a936"
-     }
-    },
-    "78906e475e9d4bda8b7e0c4ca4de577c": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "7e5dd5f9379a4104ad7965a34e569a7a": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "818aa783706f4087a3754d39d861ced6": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "BoundedIntTextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "BoundedIntTextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "IntTextView",
-      "continuous_update": false,
-      "description": "Sample N:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_4a022a6055c34004b7a3aa671a168ee3",
-      "max": 100,
-      "min": 2,
-      "step": 1,
-      "style": "IPY_MODEL_c9b1027aad95413c94835aef5ce74a5b",
-      "value": 15
-     }
-    },
-    "86a9efbe68f5450685a4e8aa1c96e84e": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "8a9b22cd239d43d191387ebc9e660ff8": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "8c053f4df9ff486f84b123eda524cbe7": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_e00ed42085424c6f91fb07fb2d22ee62",
-       "IPY_MODEL_818aa783706f4087a3754d39d861ced6"
-      ],
-      "layout": "IPY_MODEL_258e8504f9cc4be783ea207c43e56214"
-     }
-    },
-    "8d9670b7900c40b8849f7e4629d50424": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "8f3ec331c368446b8552a06238a12608": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "8face5cf545b40ceaf10b1506e754d71": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "VBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "VBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "VBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_db185d3992024056acfa2ffe419931d8",
-       "IPY_MODEL_c459f2c677ff4bea8db916696b7b600e",
-       "IPY_MODEL_170d05f5ba184c13bb39914b17257476",
-       "IPY_MODEL_64045569d769471e92ac17aebf71022f",
-       "IPY_MODEL_f83a99900b324015862cad100f5bfc0c",
-       "IPY_MODEL_ee231bb4cb97454591e7a6774bb2f7bd",
-       "IPY_MODEL_eceecb3f8a864d1eb15aab7d531e3cd1",
-       "IPY_MODEL_75ad9c9f175f4960999958cd9f6d056a",
-       "IPY_MODEL_e0d83789c4034d9ab9b3c2fa85870beb",
-       "IPY_MODEL_ae753571f5814a65865abbdb10540373",
-       "IPY_MODEL_125e415320644832a8be95b92713e257",
-       "IPY_MODEL_8c053f4df9ff486f84b123eda524cbe7",
-       "IPY_MODEL_d3bae0e7a2474ea4bdce0b0b9e413059",
-       "IPY_MODEL_516389ac0f0042a0bbeab3bd64493997",
-       "IPY_MODEL_e7dc4acbb2eb4a0e8c5112e4b2a85393",
-       "IPY_MODEL_332172fad96e4be2857e530ba9df86c6",
-       "IPY_MODEL_354bbc188daa4493967e2b143ceea510"
-      ],
-      "layout": "IPY_MODEL_6dc67c18884044ac811b3a256f69171e"
-     }
-    },
-    "958a21d97fa546a2b314e2c988b43589": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "97212667726d480eb944e25ec32cfc25": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "block",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "70%"
-     }
-    },
-    "97f4dce2a3874dafaeb0ba92775ae2a0": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": "0px 0px",
-      "grid_row": null,
-      "grid_template_areas": "\n                    'pathlist filename'\n                    'dircontent dircontent'\n                    ",
-      "grid_template_columns": "60% 40%",
-      "grid_template_rows": "auto auto",
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "auto"
-     }
-    },
-    "9a302560059a43338397161ea2ad37c7": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "9ac98c85e0f147f8a191f6d32651d0cc": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "a503b43ca679455f978c6903bdb598cf": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "a8d2ae4652394bb4b2a740097a4d7ea7": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "ae45af3a4d3d4fb8b1c2827585ed7f7f": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": "pathlist",
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "auto"
-     }
-    },
-    "ae753571f5814a65865abbdb10540373": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_d13209a7e5c94f6585d47c2430fa7885",
-       "IPY_MODEL_704f7526c3934eed85b653fb00714114"
-      ],
-      "layout": "IPY_MODEL_08882c12ccaa4d058bc554020c044559"
-     }
-    },
-    "b411a590b161465185dfd853a6dd95d6": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "be7153ab36374e62a7d6a234dc1c973e": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": "0 0 0 1em",
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "bedc16eeb19740bb9ee6e810bc9b7a71": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "c459f2c677ff4bea8db916696b7b600e": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ToggleButtonsModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ToggleButtonsModel",
-      "_options_labels": [
-       "Local",
-       "URL"
-      ],
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ToggleButtonsView",
-      "button_style": "",
-      "description": "Source:",
-      "description_tooltip": null,
-      "disabled": false,
-      "icons": [],
-      "index": 1,
-      "layout": "IPY_MODEL_a8d2ae4652394bb4b2a740097a4d7ea7",
-      "style": "IPY_MODEL_dbe1076d681040169eca1b570e2485e2",
-      "tooltips": []
-     }
-    },
-    "c9b1027aad95413c94835aef5ce74a5b": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "ca05ab87b3e040cbbf4016ae0671fc40": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "d12e413cbeac41a39fd9b94479c1eca8": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_f5539db7aca6440e9c3dee43697c4fae",
-       "IPY_MODEL_2e96cf393a754d279bcf02c66548f6dd",
-       "IPY_MODEL_0b231b28c644443db3e659a17096f55c"
-      ],
-      "layout": "IPY_MODEL_62c2030d08cf4f1e91c9c9038f31b864"
-     }
-    },
-    "d13209a7e5c94f6585d47c2430fa7885": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "FloatTextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "FloatTextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "FloatTextView",
-      "continuous_update": false,
-      "description": "Target Vol:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_74577bb60c55412d9c38960d7d865fd6",
-      "step": null,
-      "style": "IPY_MODEL_d37456fcb76f4acda7978257483bf2ad",
-      "value": 0.25
-     }
-    },
-    "d22068b3d502469fa1631d698a3d3779": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "d37456fcb76f4acda7978257483bf2ad": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "d3bae0e7a2474ea4bdce0b0b9e413059": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "VBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "VBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "VBoxView",
-      "box_style": "",
-      "children": [],
-      "layout": "IPY_MODEL_bedc16eeb19740bb9ee6e810bc9b7a71"
-     }
-    },
-    "d6710d2b4b0b4b02b5358d2d152fbad9": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "d807a3a60ca14ddda5fbec481049b6d4": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": "1px solid #999",
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": "340px",
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": "auto",
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "d80f632f65c44c338a41d0b4e3dc5ea7": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "d9f6106f986b4ea49d957594d8d5c324": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": "filename",
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "auto"
-     }
-    },
-    "db185d3992024056acfa2ffe419931d8": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_d80f632f65c44c338a41d0b4e3dc5ea7",
-      "placeholder": "​",
-      "style": "IPY_MODEL_9a302560059a43338397161ea2ad37c7",
-      "value": "<h4>1. Load data</h4>"
-     }
-    },
-    "dbe1076d681040169eca1b570e2485e2": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ToggleButtonsStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ToggleButtonsStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "button_width": "",
-      "description_width": "",
-      "font_weight": ""
-     }
-    },
-    "dfbe93388b474442833b5e7b7efc1e5f": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "e00ed42085424c6f91fb07fb2d22ee62": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DropdownModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DropdownModel",
-      "_options_labels": [
-       "All",
-       "Random",
-       "Manual"
-      ],
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "DropdownView",
-      "description": "Mode:",
-      "description_tooltip": null,
-      "disabled": false,
-      "index": 1,
-      "layout": "IPY_MODEL_958a21d97fa546a2b314e2c988b43589",
-      "style": "IPY_MODEL_202010c9f8324e1493baa92d83ff9335"
-     }
-    },
-    "e02a002607844c6ba0249122b505b8f5": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "e0d83789c4034d9ab9b3c2fa85870beb": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HBoxModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HBoxModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HBoxView",
-      "box_style": "",
-      "children": [
-       "IPY_MODEL_5759bee9a2034ed3b9b4196e158b58eb",
-       "IPY_MODEL_6e5e4fc36c674146a86dc3f8b6edbd7d",
-       "IPY_MODEL_fa9ee776b338497e9385f3d1a8d02fff",
-       "IPY_MODEL_32bac6722d6d47a6b5a88372e9e5d44e"
-      ],
-      "layout": "IPY_MODEL_dfbe93388b474442833b5e7b7efc1e5f"
-     }
-    },
-    "e5c317ba51ed45818d7d60cc4aaec11d": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "e7dc4acbb2eb4a0e8c5112e4b2a85393": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_a503b43ca679455f978c6903bdb598cf",
-      "placeholder": "​",
-      "style": "IPY_MODEL_70dfa008682a460aa02625a933b33606",
-      "value": "<hr>"
-     }
-    },
-    "e8b9fd55c6094126b24ab2e7cffa4dc5": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "DescriptionStyleModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "DescriptionStyleModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "StyleView",
-      "description_width": ""
-     }
-    },
-    "eceecb3f8a864d1eb15aab7d531e3cd1": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "HTMLModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "HTMLModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "HTMLView",
-      "description": "",
-      "description_tooltip": null,
-      "layout": "IPY_MODEL_05a596b6c3864ddc931b3112153f12ab",
-      "placeholder": "​",
-      "style": "IPY_MODEL_8f3ec331c368446b8552a06238a12608",
-      "value": "<hr><h4>2. Parameters</h4>"
-     }
-    },
-    "ee231bb4cb97454591e7a6774bb2f7bd": {
-     "model_module": "@jupyter-widgets/output",
-     "model_module_version": "1.0.0",
-     "model_name": "OutputModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/output",
-      "_model_module_version": "1.0.0",
-      "_model_name": "OutputModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/output",
-      "_view_module_version": "1.0.0",
-      "_view_name": "OutputView",
-      "layout": "IPY_MODEL_e02a002607844c6ba0249122b505b8f5",
-      "msg_id": "",
-      "outputs": [
-       {
-        "name": "stdout",
-        "output_type": "stream",
-        "text": [
-         "✅ Loaded 312 rows × 104 cols | RF → Risk-Free Rate\n"
-        ]
-       },
-       {
-        "name": "stderr",
-        "output_type": "stream",
-        "text": [
-         "<ipython-input-56-445aa7dfbbcf>:33: UserWarning: Could not infer format, so each element will be parsed individually, falling back to `dateutil`. To ensure parsing is consistent and as-expected, please specify a format.\n",
-         "  df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")  # single coercion\n"
-        ]
-       }
-      ]
-     }
-    },
-    "eed45853cf99427398e7b16f2cab9f8b": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": null
-     }
-    },
-    "f5539db7aca6440e9c3dee43697c4fae": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ButtonView",
-      "button_style": "",
-      "description": "Select",
-      "disabled": false,
-      "icon": "",
-      "layout": "IPY_MODEL_65dbf5a3b3a2406aa9f807b74dc5543b",
-      "style": "IPY_MODEL_269ab898c24e4cf697ad3dc2854a7215",
-      "tooltip": ""
-     }
-    },
-    "f5e355edbbc946b3b6e1ba36f839d45b": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": null,
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": "dircontent",
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": null,
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "auto"
-     }
-    },
-    "f83a99900b324015862cad100f5bfc0c": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "ButtonModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "ButtonModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "ButtonView",
-      "button_style": "success",
-      "description": "Load CSV",
-      "disabled": false,
-      "icon": "",
-      "layout": "IPY_MODEL_646d2e69e110438fa2feb8b60af24bb7",
-      "style": "IPY_MODEL_47ae7b5e18314a2596b33cc6c774942b",
-      "tooltip": ""
-     }
-    },
-    "fa9ee776b338497e9385f3d1a8d02fff": {
-     "model_module": "@jupyter-widgets/controls",
-     "model_module_version": "1.5.0",
-     "model_name": "TextModel",
-     "state": {
-      "_dom_classes": [],
-      "_model_module": "@jupyter-widgets/controls",
-      "_model_module_version": "1.5.0",
-      "_model_name": "TextModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/controls",
-      "_view_module_version": "1.5.0",
-      "_view_name": "TextView",
-      "continuous_update": true,
-      "description": "Out Start:",
-      "description_tooltip": null,
-      "disabled": false,
-      "layout": "IPY_MODEL_38d3e511fdc14bcaa7b04d8583be18dc",
-      "placeholder": "​",
-      "style": "IPY_MODEL_8d9670b7900c40b8849f7e4629d50424",
-      "value": "2008-07"
-     }
-    },
-    "ff9bd5c776a741248e4a64d445950c90": {
-     "model_module": "@jupyter-widgets/base",
-     "model_module_version": "1.2.0",
-     "model_name": "LayoutModel",
-     "state": {
-      "_model_module": "@jupyter-widgets/base",
-      "_model_module_version": "1.2.0",
-      "_model_name": "LayoutModel",
-      "_view_count": null,
-      "_view_module": "@jupyter-widgets/base",
-      "_view_module_version": "1.2.0",
-      "_view_name": "LayoutView",
-      "align_content": null,
-      "align_items": null,
-      "align_self": null,
-      "border": null,
-      "bottom": null,
-      "display": "none",
-      "flex": null,
-      "flex_flow": null,
-      "grid_area": null,
-      "grid_auto_columns": null,
-      "grid_auto_flow": null,
-      "grid_auto_rows": null,
-      "grid_column": null,
-      "grid_gap": null,
-      "grid_row": null,
-      "grid_template_areas": null,
-      "grid_template_columns": null,
-      "grid_template_rows": null,
-      "height": null,
-      "justify_content": null,
-      "justify_items": null,
-      "left": null,
-      "margin": null,
-      "max_height": null,
-      "max_width": null,
-      "min_height": null,
-      "min_width": "6em",
-      "object_fit": null,
-      "object_position": null,
-      "order": null,
-      "overflow": null,
-      "overflow_x": null,
-      "overflow_y": null,
-      "padding": null,
-      "right": null,
-      "top": null,
-      "visibility": null,
-      "width": "6em"
-     }
-    }
-   }
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup-checkpoint.ipynb
deleted file mode 100644
index 652f6c3a4cb075844ac0488848254b6d961dbf9f..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup-checkpoint.ipynb
+++ /dev/null
@@ -1,1641 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 13,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 1. SETUP CELL ============\n",
-    "\n",
-    "import logging\n",
-    "import sys\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import os\n",
-    "import math\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import interact, interactive, VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from IPython.utils.capture import capture_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import datetime\n",
-    "import random\n",
-    "import warnings\n",
-    "\n",
-    "# If you need to install these packages on your environment, uncomment:\n",
-    "!{sys.executable} -m pip install --quiet ipywidgets openpyxl xlsxwriter\n",
-    "\n",
-    "# For exporting to Excel with styling\n",
-    "import xlsxwriter\n",
-    "\n",
-    "# Set up logging to console\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "logging.info(\"Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\")\n",
-    "\n",
-    "# (Optional) If widgets aren't enabled, run:\n",
-    "# !jupyter nbextension enable --py widgetsnbextension --sys-prefix\n",
-    "\n",
-    "print(\"Setup complete.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 14,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "5401c4292ef847f694e33f4e41766c91",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<b>Step 1: Choose your CSV</b><br><i>Remember:</i> If you included any index column…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify which column (after 'Date') is the risk-free rate by smallest stdev among columns.\n",
-    "    \"\"\"\n",
-    "    numeric_cols = df.columns[1:]  # skip the Date column\n",
-    "    stdevs = {}\n",
-    "    for col in numeric_cols:\n",
-    "        vals = df[col].dropna()\n",
-    "        if len(vals) > 0:\n",
-    "            stdevs[col] = vals.std()\n",
-    "        else:\n",
-    "            stdevs[col] = np.inf\n",
-    "\n",
-    "    rf_col = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "    return rf_col\n",
-    "\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 1) Helper to read a local CSV robustly (handles BOMs and minor parsing issues)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Try loading `path` as CSV in three ways:\n",
-    "    1. Default C engine\n",
-    "    2. BOM-stripped with the Python engine\n",
-    "    3. Skip bad lines with the Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception as e1:\n",
-    "        print(\"Default read_csv failed:\", e1)\n",
-    "\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception as e2:\n",
-    "        print(\"utf-8-sig + python engine failed:\", e2)\n",
-    "\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",    # for pandas ≥ 1.3\n",
-    "    )\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 2) Build the widgets\n",
-    "# ------------------------------------------------------------------------------\n",
-    "source_info = widgets.HTML(\n",
-    "    \"<b>Step 1: Choose your CSV</b><br>\"\n",
-    "    \"<i>Remember:</i> If you included any index columns (e.g. S&P 500, MSCI World, SG Trend), they \"\n",
-    "    \"must appear to the right of all fund columns in your sheet.\"\n",
-    ")\n",
-    "\n",
-    "\n",
-    "source_dropdown = widgets.Dropdown(\n",
-    "    options=['Local', 'GitHub'],\n",
-    "    value='Local',\n",
-    "    description='Data Source:',\n",
-    "    style={'description_width': '120px'}\n",
-    ")\n",
-    "\n",
-    "# FileChooser for Local mode\n",
-    "fc = FileChooser(os.getcwd())\n",
-    "fc.title = \"<b>Select local CSV file</b>\"\n",
-    "\n",
-    "# Text box for GitHub raw URL\n",
-    "github_text = widgets.Text(\n",
-    "    value=(\n",
-    "        \"https://raw.githubusercontent.com/stranske/Trend_Model_Project/\"\n",
-    "        \"main/data/TrendData.csv\"\n",
-    "    ),\n",
-    "    description=\"GitHub URL:\",\n",
-    "    layout=widgets.Layout(width=\"80%\"),\n",
-    ")\n",
-    "\n",
-    "# Ask how many index columns are on the far right\n",
-    "n_indices_widget = widgets.BoundedIntText(\n",
-    "    value=0,\n",
-    "    min=0,\n",
-    "    max=10,  # adjust if you expect more than 10 indices\n",
-    "    description='# Index cols:',\n",
-    "    style={'description_width': '120px'},\n",
-    "    tooltip=\"Enter the number of index columns at the far right of your CSV\"\n",
-    ")\n",
-    "\n",
-    "# Load button\n",
-    "load_button = widgets.Button(description=\"Load Data\", button_style=\"success\")\n",
-    "\n",
-    "# Output area for status and debug prints\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 3) Show/hide widgets depending on source selection\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_source_change(change):\n",
-    "    if change[\"new\"] == \"Local\":\n",
-    "        fc.layout.display = \"block\"\n",
-    "        github_text.layout.display = \"none\"\n",
-    "    else:\n",
-    "        fc.layout.display = \"none\"\n",
-    "        github_text.layout.display = \"block\"\n",
-    "\n",
-    "# Initially, GitHub textbox is hidden; FileChooser is visible\n",
-    "github_text.layout.display = \"none\"\n",
-    "fc.layout.display = \"block\"\n",
-    "\n",
-    "source_dropdown.observe(on_source_change, names=\"value\")\n",
-    "\n",
-    "ui_load = widgets.VBox([\n",
-    "    source_info,\n",
-    "    source_dropdown,\n",
-    "    fc,\n",
-    "    github_text,\n",
-    "    n_indices_widget,   # ← new widget here\n",
-    "    load_button,\n",
-    "    output_area\n",
-    "])\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 4) Callback for the Load button (auto-detect date format)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_load_clicked(_):\n",
-    "    global df, fund_cols, indices_list, rf_col            # declare df as global\n",
-    "    with output_area:\n",
-    "        output_area.clear_output()\n",
-    "        src_choice = source_dropdown.value\n",
-    "        n_indices = int(n_indices_widget.value)\n",
-    "\n",
-    "        # 4a) Load the DataFrame\n",
-    "        try:\n",
-    "            if src_choice == 'Local':\n",
-    "                local_path = fc.selected  # FileChooser’s selected path\n",
-    "                if not local_path or not os.path.exists(local_path):\n",
-    "                    print(f\"Error: Local file not found:\\n  {local_path}\")\n",
-    "                    return\n",
-    "                print(f\"Loading from local file:\\n  {local_path}\")\n",
-    "                df = pd.read_csv(local_path)\n",
-    "            else:\n",
-    "                github_url = github_text.value.strip()\n",
-    "                if not github_url:\n",
-    "                    print(\"Error: Please enter a valid GitHub raw URL.\")\n",
-    "                    return\n",
-    "                print(f\"Loading from GitHub URL:\\n  {github_url}\")\n",
-    "                df = pd.read_csv(github_url)\n",
-    "        except Exception as e:\n",
-    "            print(\"Failed to load CSV:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4b) Debug: print columns & a few rows\n",
-    "        print(\"Columns found in DataFrame:\", df.columns.tolist())\n",
-    "        display(df.head(3))\n",
-    "\n",
-    "        # 4c) Identify which column is the date\n",
-    "        date_col = None\n",
-    "        for candidate in [\"Date\", \"DATE\", \"date\"]:\n",
-    "            if candidate in df.columns:\n",
-    "                date_col = candidate\n",
-    "                break\n",
-    "\n",
-    "        if date_col is None:\n",
-    "            print(\"Error: No column named 'Date' / 'DATE' / 'date' found.\")\n",
-    "            print(\"Please check the column names above and adjust code accordingly.\")\n",
-    "            return\n",
-    "\n",
-    "        date_col = 'Date'\n",
-    "\n",
-    "        # 1) Show the first few raw date strings (un‐parsed) so we can inspect them\n",
-    "        raw_samples = df[date_col].dropna().astype(str).head(10).tolist()\n",
-    "        print(f\"Raw {date_col} samples (first 10 non‐null): {raw_samples!r}\")\n",
-    "\n",
-    "        # 2) Strip leading/trailing whitespace from every entry\n",
-    "        df[date_col] = df[date_col].astype(str).str.strip()\n",
-    "\n",
-    "        # 3) Now attempt strict \"%m/%d/%Y\" parsing\n",
-    "        parsed = pd.to_datetime(df[date_col], format=\"%m/%d/%Y\", errors=\"coerce\", infer_datetime_format=True)\n",
-    "        num_valid = parsed.notna().sum()\n",
-    "        print(f\"Number of rows matching '%m/%d/%Y' exactly: {num_valid} / {len(df)}\")\n",
-    "\n",
-    "        if num_valid > 0:\n",
-    "            df[date_col] = parsed\n",
-    "            print(f\"Parsing with '%m/%d/%Y' succeeded for {num_valid} rows.\")\n",
-    "        else:\n",
-    "            print(\n",
-    "                \"Warning: No rows matched '%m/%d/%Y'. \"\n",
-    "                \"Falling back to generic pd.to_datetime(...).\"\n",
-    "            )\n",
-    "            df[date_col] = pd.to_datetime(df[date_col], errors=\"coerce\")\n",
-    "\n",
-    "        # 5) Drop any rows where parsing still failed\n",
-    "        before_drop = len(df)\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        dropped = before_drop - len(df)\n",
-    "        if dropped:\n",
-    "            print(f\"Dropped {dropped} rows where '{date_col}' could not be parsed.\")\n",
-    "        \n",
-    "        # 6) Sort and reset index\n",
-    "        df.sort_values(by=date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "        \n",
-    "        # 7) Show the final parsed dates\n",
-    "        print(f\"After parsing, first 3 {date_col} values:\")\n",
-    "        print(df[[date_col]].head(3))\n",
-    "        print(f\"Loaded {len(df)} rows successfully.\")\n",
-    "\n",
-    "\n",
-    "        # 4d) Identify risk-free column\n",
-    "        try:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            print(f\"Identified risk-free column as: '{rf_col}'\")\n",
-    "        except Exception as e:\n",
-    "            print(\"Error identifying risk-free column:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4f) Determine fund_cols vs indices_list based on n_indices\n",
-    "        all_cols = df.columns.tolist()\n",
-    "        # We assume “Date” and rf_col are present. Everything else is a candidate.\n",
-    "        if 'Date' not in all_cols or rf_col not in all_cols:\n",
-    "            print(\"Error: 'Date' or risk-free column not found in DataFrame columns.\")\n",
-    "            return\n",
-    "        \n",
-    "        # Build list of all columns except 'Date' and rf_col\n",
-    "        remaining = [c for c in all_cols if c not in ['Date', rf_col]]\n",
-    "        \n",
-    "        if n_indices > len(remaining):\n",
-    "            print(\n",
-    "                f\"Error: You asked for {n_indices} index columns, but only \"\n",
-    "                f\"{len(remaining)} columns remain after 'Date' and '{rf_col}'.\"\n",
-    "            )\n",
-    "            return\n",
-    "\n",
-    "        if n_indices > 0:\n",
-    "            indices_list = remaining[-n_indices:]\n",
-    "            fund_cols    = remaining[:-n_indices]\n",
-    "        else:\n",
-    "            indices_list = []\n",
-    "            fund_cols    = remaining[:]\n",
-    "        print(\"\\n>> Debug (post‐load): fund_cols =\", fund_cols)\n",
-    "        print(\">> Debug (post‐load): indices_list =\", indices_list, \"\\n\")\n",
-    "        \n",
-    "        # 2F) Print out what we found\n",
-    "        print(f\"Detected fund columns ({len(fund_cols)}): {fund_cols}\")\n",
-    "        print(f\"Detected index columns ({len(indices_list)}): {indices_list}\")\n",
-    "        print(\n",
-    "            \"Data loaded and classified successfully.\\n\"\n",
-    "            \"Proceed to Step 2 (Run Analysis).\"\n",
-    "        )\n",
-    "\n",
-    " \n",
-    "        # 8) Confirm that df is now in global scope\n",
-    "        print(\">> df defined with\", len(df), \"rows and columns:\", df.columns.tolist())\n",
-    "\n",
-    "# 5) Wire up and display the UI\n",
-    "load_button.on_click(on_load_clicked)\n",
-    "\n",
-    "\n",
-    "display(ui_load)\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 15,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Utility functions loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Check if a series (sorted chronologically) has >= threshold consecutive NaNs.\n",
-    "    Return True if such a gap exists, False otherwise.\n",
-    "    \"\"\"\n",
-    "    consecutive = 0\n",
-    "    for val in series:\n",
-    "        if pd.isna(val):\n",
-    "            consecutive += 1\n",
-    "        else:\n",
-    "            consecutive = 0\n",
-    "        if consecutive >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "\n",
-    "def annualize_return(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized (geometric) return from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    growth_factor = (1 + valid_rets).prod()\n",
-    "    n_months = len(valid_rets)\n",
-    "    if growth_factor <= 0:\n",
-    "        return -1.0\n",
-    "    ann_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    return ann_ret\n",
-    "\n",
-    "def annualize_volatility(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized stdev of monthly returns, i.e. stdev * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) < 2:\n",
-    "        return np.nan\n",
-    "    return valid_rets.std() * np.sqrt(12)\n",
-    "\n",
-    "def sharpe_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe ratio = (annual_excess_return) / (annual_excess_vol).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    ann_excess_vol = excess.std() * np.sqrt(12)\n",
-    "    if ann_excess_vol == 0:\n",
-    "        return np.nan\n",
-    "    return ann_excess_ret / ann_excess_vol\n",
-    "\n",
-    "def sortino_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino ratio = (annual_excess_return) / (annual_downside_stdev).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "\n",
-    "    negative_mask = excess < 0\n",
-    "    negative_returns = excess[negative_mask]\n",
-    "    if len(negative_returns) == 0:\n",
-    "        return np.inf  # no negative => infinite sortino\n",
-    "    downside_stdev = negative_returns.std() * np.sqrt(12)\n",
-    "    return ann_excess_ret / downside_stdev\n",
-    "\n",
-    "def max_drawdown(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Compute max drawdown from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    wealth_index = (1 + valid_rets).cumprod()\n",
-    "    rolling_max = wealth_index.cummax()\n",
-    "    dd_series = 1 - (wealth_index / rolling_max)\n",
-    "    return dd_series.max()\n",
-    "\n",
-    "def calc_portfolio_returns(weights, df_returns):\n",
-    "    \"\"\"\n",
-    "    Compute monthly portfolio returns (Series) as weighted sum of columns in df_returns.\n",
-    "    \"\"\"\n",
-    "    return (df_returns * weights).sum(axis=1)\n",
-    "\n",
-    "print(\"Utility functions loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "4f1619c9",
-   "metadata": {},
-   "source": [
-    "## 4. Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 16,
-   "id": "1e739b5c-2218-4653-97f8-e3cebe194183",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─────────────── Widget Setup + Callback ───────────────\n",
-    "\n",
-    "# ─── Phase 1: Date / Vol / Cost / Run Button ───\n",
-    "# ─── Phase 1: Date / Vol / Cost / Run Button ───\n",
-    "\n",
-    "in_sample_start     = widgets.Text(value='2005-07', description='In-Sample Start:')\n",
-    "in_sample_end       = widgets.Text(value='2008-06', description='In-Sample End:')\n",
-    "out_sample_start    = widgets.Text(value='2008-07', description='Out-Sample Start:')\n",
-    "out_sample_end      = widgets.Text(value='2009-06', description='Out-Sample End:')\n",
-    "\n",
-    "target_vol_widget   = widgets.FloatText(value=0.25, description='Target Vol:')\n",
-    "monthly_cost_widget = widgets.FloatText(value=0.0033, description='Monthly Cost:')\n",
-    "\n",
-    "run_button = widgets.Button(description='Run Analysis', button_style='success')\n",
-    "\n",
-    "# ← Replace any previous “output_area = widgets.Output()” with the block below:\n",
-    "output_area = widgets.Output(\n",
-    "    layout={\n",
-    "        'border': '1px solid gray',\n",
-    "        'height': '300px',\n",
-    "        'overflow_y': 'auto'   # optional: let it scroll if there’s too much text\n",
-    "    }\n",
-    ")\n",
-    "\n",
-    "# Pack only these into main_inputs for now—no display() yet.\n",
-    "main_inputs = widgets.VBox([\n",
-    "    in_sample_start,\n",
-    "    in_sample_end,\n",
-    "    out_sample_start,\n",
-    "    out_sample_end,\n",
-    "    target_vol_widget,\n",
-    "    monthly_cost_widget,\n",
-    "    run_button\n",
-    "])\n",
-    "\n",
-    "# ─── Phase 2: Build & Hide Mode / Random-Size / “Fund Table” placeholders ───\n",
-    "\n",
-    "# A) Mode dropdown (hidden initially)\n",
-    "selection_mode_widget = widgets.Dropdown(\n",
-    "    options=[('All Funds','all'), ('Random Sample','random'), ('Manual','manual')],\n",
-    "    value='all',\n",
-    "    description='Mode:'\n",
-    ")\n",
-    "selection_mode_widget.layout.display = 'none'\n",
-    "\n",
-    "# B) Random Sample Size field (hidden initially)\n",
-    "random_sample_size_widget = widgets.IntText(\n",
-    "    value=5, description='Sample Size:'\n",
-    ")\n",
-    "random_sample_size_widget.layout.display = 'none'\n",
-    "\n",
-    "# C) Placeholder containers for the Manual‐funds checkboxes & weights\n",
-    "fund_table_container = widgets.VBox([])   # we will populate it later\n",
-    "fund_table_container.layout.display = 'none'\n",
-    "\n",
-    "# D) Whenever Mode changes, show/hide “Sample Size” vs. “Fund Table”\n",
-    "def _on_mode_change(change):\n",
-    "    new_mode = change['new']\n",
-    "    if new_mode == 'random':\n",
-    "        random_sample_size_widget.layout.display = 'block'\n",
-    "        fund_table_container.layout.display   = 'none'\n",
-    "    elif new_mode == 'manual':\n",
-    "        random_sample_size_widget.layout.display = 'none'\n",
-    "        fund_table_container.layout.display   = 'block'\n",
-    "    else:  # 'all'\n",
-    "        random_sample_size_widget.layout.display = 'none'\n",
-    "        fund_table_container.layout.display   = 'none'\n",
-    "\n",
-    "selection_mode_widget.observe(_on_mode_change, names='value')\n",
-    "\n",
-    "# ─── Phase 3: Wire up “Run Analysis” + final display(...) ───\n",
-    "\n",
-    "phase_counter = {\"step\": 1}\n",
-    "\n",
-    "def on_run_clicked(b):\n",
-    "    with output_area:\n",
-    "        clear_output()\n",
-    "\n",
-    "        # 1) Read dates/vol/cost\n",
-    "        in_start_str     = in_sample_start.value.strip()\n",
-    "        in_end_str       = in_sample_end.value.strip()\n",
-    "        out_start_str    = out_sample_start.value.strip()\n",
-    "        out_end_str      = out_sample_end.value.strip()\n",
-    "        target_vol_val   = target_vol_widget.value\n",
-    "        monthly_cost_val = monthly_cost_widget.value\n",
-    "\n",
-    "        # 2) First click = reveal Mode dropdown + hide everything else\n",
-    "        if phase_counter[\"step\"] == 1:\n",
-    "            # Quick check: ensure date strings parse\n",
-    "            try:\n",
-    "                pd.to_datetime(in_start_str, format=\"%Y-%m\")\n",
-    "                pd.to_datetime(in_end_str,   format=\"%Y-%m\")\n",
-    "                pd.to_datetime(out_start_str, format=\"%Y-%m\")\n",
-    "                pd.to_datetime(out_end_str,   format=\"%Y-%m\")\n",
-    "            except Exception:\n",
-    "                print(\"❌ Invalid date formats. Please use YYYY-MM and click Run again.\")\n",
-    "                return\n",
-    "\n",
-    "            print(\"▶ Dates accepted. Now pick Mode (All / Random / Manual). \" \n",
-    "                  \"If Manual, you’ll then see the valid funds appear.\")\n",
-    "            selection_mode_widget.layout.display = 'block'\n",
-    "            phase_counter[\"step\"] = 2\n",
-    "            return\n",
-    "\n",
-    "        # 3) After first click, Mode is visible. If Mode changed to Manual, we need to\n",
-    "        #    build the fund_table with *only* those funds that pass the full‐history + no‐3-NA rule.\n",
-    "        if phase_counter[\"step\"] == 2:\n",
-    "            mode_val  = selection_mode_widget.value\n",
-    "            rnd_n_val = random_sample_size_widget.value if mode_val == 'random' else None\n",
-    "\n",
-    "            # If Manual mode is chosen, build fund_checkboxes & weight_boxes now:\n",
-    "            if mode_val == 'manual':\n",
-    "                # 3a) Determine which funds are “valid” for this date range.\n",
-    "                #     We reuse your existing `select_funds(...)` function, forcing selection_mode='all'.\n",
-    "                try:\n",
-    "                    in_sdate  = pd.to_datetime(in_start_str, format=\"%Y-%m\")\n",
-    "                    in_edate  = pd.to_datetime(in_end_str,   format=\"%Y-%m\") + pd.offsets.MonthEnd(0)\n",
-    "                    out_sdate = pd.to_datetime(out_start_str, format=\"%Y-%m\")\n",
-    "                    out_edate = pd.to_datetime(out_end_str,   format=\"%Y-%m\") + pd.offsets.MonthEnd(0)\n",
-    "                except Exception as e:\n",
-    "                    print(\"❌ Error parsing dates. Please re‐enter and click Run again.\")\n",
-    "                    return\n",
-    "\n",
-    "                # Build the “candidate fund_columns” list (exclude Date/rf/index columns)\n",
-    "                all_cols = [c for c in df.columns if c not in ['Date', identify_risk_free_fund(df)] + indices_list]\n",
-    "                # Call select_funds with selection_mode='all' to get the full list of valid funds.\n",
-    "                valid_funds = select_funds(\n",
-    "                    df,\n",
-    "                    identify_risk_free_fund(df),\n",
-    "                    fund_columns=all_cols,\n",
-    "                    in_sdate=in_sdate,\n",
-    "                    in_edate=in_edate,\n",
-    "                    out_sdate=out_sdate,\n",
-    "                    out_edate=out_edate,\n",
-    "                    selection_mode='all',\n",
-    "                    random_n=None\n",
-    "                )\n",
-    "\n",
-    "                if not valid_funds:\n",
-    "                    print(\"❌ No funds satisfy the full‐history & gap rules for these dates.\")\n",
-    "                    return\n",
-    "\n",
-    "                # 3b) Build a fresh table of checkboxes + IntText’s for valid_funds\n",
-    "                fund_table_rows = []\n",
-    "                fund_checkboxes = []\n",
-    "                weight_boxes    = []\n",
-    "\n",
-    "                for f in valid_funds:\n",
-    "                    cb = widgets.Checkbox(\n",
-    "                        value=False,\n",
-    "                        description=f,\n",
-    "                        layout=widgets.Layout(width='200px')\n",
-    "                    )\n",
-    "                    tb = widgets.BoundedIntText(\n",
-    "                        value=0,\n",
-    "                        min=0,\n",
-    "                        max=100,\n",
-    "                        step=1,\n",
-    "                        description=\"%\",          # user will type an integer percent\n",
-    "                        layout=widgets.Layout(width='160px')\n",
-    "                    )\n",
-    "                    tb.disabled = True  # only enabled when its checkbox is clicked\n",
-    "                    \n",
-    "                    fund_checkboxes.append(cb)\n",
-    "                    weight_boxes.append(tb)\n",
-    "\n",
-    "                    row = widgets.HBox([\n",
-    "                        cb,\n",
-    "                        weight_boxes[-1]\n",
-    "                    ], layout=widgets.Layout(margin=\"2px 0px\"))\n",
-    "                    fund_table_rows.append(row)\n",
-    "\n",
-    "                # Replace whatever was in fund_table_container with this new VBox\n",
-    "                fund_table_container.children = [widgets.VBox(fund_table_rows)]\n",
-    "                fund_table_container.layout.display = 'block'  # reveal it\n",
-    "\n",
-    "                # 3c) Wire up each checkbox so its weight box toggles on/off\n",
-    "                def _on_cb_change(change):\n",
-    "                    # ‘change.owner’ is the Checkbox that toggled\n",
-    "                    idx = fund_checkboxes.index(change.owner)\n",
-    "                    weight_boxes[idx].disabled = not change.new\n",
-    "\n",
-    "                for cb in fund_checkboxes:\n",
-    "                    cb.observe(_on_cb_change, names='value')\n",
-    "\n",
-    "            # Finally, show the random_sample_size_widget if needed\n",
-    "            if mode_val == 'random':\n",
-    "                random_sample_size_widget.layout.display = 'block'\n",
-    "\n",
-    "            print(\"▶ Now the Mode/sampling UI is visible. If Manual, pick funds + enter weights. Then click Run again.\")\n",
-    "            phase_counter[\"step\"] = 3\n",
-    "            return\n",
-    "\n",
-    "        # 4) After second click, everything (Mode + any Manual selections or random size) is set,\n",
-    "        #    so we can finally run `run_analysis(...)` for real:\n",
-    "        mode_val  = selection_mode_widget.value\n",
-    "        rnd_n_val = random_sample_size_widget.value if mode_val == 'random' else None\n",
-    "\n",
-    "        custom_weights = None\n",
-    "        if mode_val == 'manual':\n",
-    "            # Gather which checkboxes were checked, and read their weight_boxes\n",
-    "            selected = []\n",
-    "            weight_dict = {}\n",
-    "            # The fund_checkboxes + weight_boxes only exist if step>=2 and mode=='manual'.\n",
-    "            # We can grab them from fund_table_container.children.\n",
-    "            table_vbox = fund_table_container.children[0]   # the VBox we built above\n",
-    "            for row_hbox in table_vbox.children:\n",
-    "                cb, tb = row_hbox.children\n",
-    "                if cb.value:\n",
-    "                    selected.append(cb.description)\n",
-    "                    weight_dict[cb.description] = tb.value\n",
-    "\n",
-    "            total_w = sum(weight_dict.values())\n",
-    "            if not selected:\n",
-    "                print(\"⚠️ No funds checked—pick at least one fund.\")\n",
-    "                return\n",
-    "            if total_w != 100:\n",
-    "                print(f\"⚠️ Weights sum to {total_w}, but must be exactly 100. Fix and Run again.\")\n",
-    "                return\n",
-    "\n",
-    "            custom_weights = weight_dict\n",
-    "\n",
-    "        # 5) Now run the analysis for real\n",
-    "        print(\"▶ Running analysis with:\")\n",
-    "        print(f\"   In:   {in_start_str} → {in_end_str}\")\n",
-    "        print(f\"   Out:  {out_start_str} → {out_end_str}\")\n",
-    "        print(f\"   Vol:  {target_vol_val:.3%}, Cost: {monthly_cost_val:.3%}\")\n",
-    "        print(f\"   Mode: {mode_val}\" + (f\", Random N={rnd_n_val}\" if mode_val=='random' else \"\"))\n",
-    "        if mode_val == 'manual':\n",
-    "            print(f\"   Manual funds = {list(custom_weights.keys())}\")\n",
-    "            print(f\"   Weights = {custom_weights}\")\n",
-    "\n",
-    "        try:\n",
-    "            results = run_analysis(\n",
-    "                df,\n",
-    "                in_start=in_start_str,\n",
-    "                in_end=in_end_str,\n",
-    "                out_start=out_start_str,\n",
-    "                out_end=out_end_str,\n",
-    "                target_vol=target_vol_val,\n",
-    "                monthly_cost=monthly_cost_val,\n",
-    "                selection_mode=mode_val,\n",
-    "                random_n=rnd_n_val,\n",
-    "                custom_weights=custom_weights\n",
-    "            )\n",
-    "        except Exception as e:\n",
-    "            print(\"❌ Error inside run_analysis():\", e)\n",
-    "            return\n",
-    "\n",
-    "        if results is None or not results.get(\"selected_funds\"):\n",
-    "            print(\"❌ No valid funds remain after filtering.\")\n",
-    "            return\n",
-    "\n",
-    "        # 6) Print a brief summary & export to Excel\n",
-    "        sf = results[\"selected_funds\"]\n",
-    "        print(\"✅ Analysis complete:\")\n",
-    "        print(f\"   Funds selected: {len(sf)} → {sf}\")\n",
-    "        print(\"   Manual funds & weights:\")\n",
-    "        if custom_weights is not None:\n",
-    "            print(\"   Manual funds & weights:\")\n",
-    "            for f, w in custom_weights.items():\n",
-    "                print(f\"     • {f}: {w}%\")\n",
-    "        if \"in_ew_stats\" in results:\n",
-    "            ir, iv, isr, *_ = results[\"in_ew_stats\"]\n",
-    "            print(f\"   In‐Sample EW → R {ir*100:.2f}%, V {iv*100:.2f}%, S {isr:.2f}\")\n",
-    "        if \"out_ew_stats\" in results:\n",
-    "            or_, ov, osr, *_ = results[\"out_ew_stats\"]\n",
-    "            print(f\"   Out‐Sample EW → R {or_*100:.2f}%, V {ov*100:.2f}%, S {osr:.2f}\")\n",
-    "\n",
-    "        print(\">> about to write Excel with custom_weights =\", custom_weights)\n",
-    "\n",
-    "        # Add the filename\n",
-    "        global fname\n",
-    "        fname = f\"IS_{in_start_str}_{out_start_str}.xlsx\"\n",
-    "    \n",
-    "        export_to_excel(\n",
-    "            results, \n",
-    "            fname,\n",
-    "            in_start_str,   # e.g. \"2005-07\"\n",
-    "            in_end_str,     # e.g. \"2008-06\"\n",
-    "            out_start_str,  # e.g. \"2008-07\"\n",
-    "            out_end_str     # e.g. \"2009-06\"\n",
-    "        )\n",
-    "        print(f\"   Excel file created: IS_{in_start_str}_{out_start_str}.xlsx\")\n",
-    "        import inspect\n",
-    "        print(inspect.getsource(export_to_excel))\n",
-    "\n",
-    "\n",
-    "run_button.on_click(on_run_clicked)\n",
-    "\n",
-    "# ─── Finally, show everything (Phase 1 + Phase 2 placeholders + output area) ───\n",
-    "\n",
-    "master_vbox = widgets.VBox([\n",
-    "    main_inputs,\n",
-    "    selection_mode_widget,\n",
-    "    random_sample_size_widget,\n",
-    "    fund_table_container\n",
-    "])\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "## 5. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 17,
-   "id": "c5867ccd-a550-4849-a10b-a085f5fe26fd",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "select_funds (replaced) is ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def select_funds(\n",
-    "    df,                 # full DataFrame with datetime64 ‘Date’\n",
-    "    rf_col,             # name of risk‐free column\n",
-    "    fund_columns,       # list of candidate funds (should be your 27)\n",
-    "    in_sdate, in_edate, # pd.Timestamps for in‐sample window\n",
-    "    out_sdate, out_edate,# pd.Timestamps for out‐sample window\n",
-    "    selection_mode='all',\n",
-    "    random_n=8\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Start from fund_columns.  \n",
-    "    2) Filter out any that contain 'index' in name.  \n",
-    "    3) Keep only those with no NaN anywhere in both windows.  \n",
-    "    4) Keep only those with < 3 consecutive NaNs in each window.  \n",
-    "    5) Return based on selection_mode.\n",
-    "    \"\"\"\n",
-    "    # Step 1: base list\n",
-    "    candidates = fund_columns.copy()\n",
-    "    print(f\"DEBUG [select_funds]: initial candidates (n={len(candidates)}): {candidates}\")\n",
-    "\n",
-    "    # Step 2: drop any with “index” in name (case‐insensitive)\n",
-    "    no_index = [f for f in candidates if 'index' not in f.lower()]\n",
-    "    print(f\"DEBUG [select_funds]: after dropping 'index' (n={len(no_index)}): {no_index}\")\n",
-    "\n",
-    "    # Step 3: full‐history check (no NaN at all in each window)\n",
-    "    full_hist = []\n",
-    "    for f in no_index:\n",
-    "        in_sub  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)][f]\n",
-    "        out_sub = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        if in_sub.notna().all() and out_sub.notna().all():\n",
-    "            full_hist.append(f)\n",
-    "    print(f\"DEBUG [select_funds]: after full‐history check (n={len(full_hist)}): {full_hist}\")\n",
-    "\n",
-    "    # Step 4: no 3‐consecutive‐NaNs check\n",
-    "    after_run_check = []\n",
-    "    for f in full_hist:\n",
-    "        # In‐sample gap runs\n",
-    "        sub_in   = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "        isnan_in = sub_in.isna().astype(int)\n",
-    "        run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "        max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "\n",
-    "        # Out‐sample gap runs\n",
-    "        sub_out   = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        isnan_out = sub_out.isna().astype(int)\n",
-    "        run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "        max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "\n",
-    "        # Keep only if both max runs < 3\n",
-    "        if max_run_in < 3 and max_run_out < 3:\n",
-    "            after_run_check.append(f)\n",
-    "\n",
-    "    print(f\"DEBUG [select_funds]: after run‐length check (n={len(after_run_check)}): {after_run_check}\")\n",
-    "\n",
-    "    # Step 5: selection_mode\n",
-    "    if selection_mode == 'all':\n",
-    "        return after_run_check\n",
-    "\n",
-    "    if selection_mode == 'random':\n",
-    "        if len(after_run_check) <= random_n:\n",
-    "            warnings.warn(\n",
-    "                f\"Fewer valid funds ({len(after_run_check)}) than sample size ({random_n}). Returning all.\"\n",
-    "            )\n",
-    "            return after_run_check\n",
-    "        return random.sample(after_run_check, random_n)\n",
-    "\n",
-    "    # Manual fund selection\n",
-    "    \n",
-    "    return after_run_check\n",
-    "\n",
-    "print(\"select_funds (replaced) is ready.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 6. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 18,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "get_custom_weights function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    Returns dict {fund: weight_decimal}.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=f\"{fund}\",\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    \n",
-    "    confirm_button = widgets.Button(\n",
-    "        description='Confirm Weights',\n",
-    "        button_style='success'\n",
-    "    )\n",
-    "    error_label = widgets.Label(value='', layout=widgets.Layout(color='red'))\n",
-    "    \n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm_button, error_label])\n",
-    "    display(box)\n",
-    "    \n",
-    "    weights_container = {}\n",
-    "    \n",
-    "    def on_confirm_clicked(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_label.value = f\"Error: Weights sum to {total}, must be 100.\"\n",
-    "            weights_container.clear()\n",
-    "        else:\n",
-    "            for fund, wdg in weight_widgets.items():\n",
-    "                weights_container[fund] = wdg.value / 100.0\n",
-    "            error_label.value = \"Weights confirmed!\"\n",
-    "    \n",
-    "    confirm_button.on_click(on_confirm_clicked)\n",
-    "    return weights_container\n",
-    "\n",
-    "print(\"get_custom_weights function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 7. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 19,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "run_analysis (with checkpoints) is defined.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def run_analysis(\n",
-    "    df,\n",
-    "    in_start, in_end, out_start, out_end,\n",
-    "    target_vol, monthly_cost,\n",
-    "    selection_mode='all',\n",
-    "    random_n=8,\n",
-    "    custom_weights=None    # ← new argument\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Parse/validate date inputs\n",
-    "    2) Convert Date column if needed\n",
-    "    3) Identify rf_col\n",
-    "    4) Prepare in/out sample DataFrames\n",
-    "    5) CALL select_funds (with debug) and print checkpoints\n",
-    "    6) Compute scale_factors and wrap stats in try/except\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # —(1) Parse input dates (YYYY-MM) into actual month-end timestamps\n",
-    "    in_sdate  = pd.to_datetime(in_start + \"-01\", errors='coerce')\n",
-    "    in_edate  = pd.to_datetime(in_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "    out_sdate = pd.to_datetime(out_start + \"-01\", errors='coerce')\n",
-    "    out_edate = pd.to_datetime(out_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    # checkpoint A\n",
-    "    print(\"CHECKPOINT A: Dates parsed:\", in_sdate, in_edate, out_sdate, out_edate)\n",
-    "\n",
-    "    # —(2) Ensure 'Date' column is datetime64\n",
-    "    if not np.issubdtype(df['Date'].dtype, np.datetime64):\n",
-    "        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "        df.dropna(subset=['Date'], inplace=True)\n",
-    "        df.sort_values(by='Date', inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "    # checkpoint B\n",
-    "    print(\"CHECKPOINT B: Date column is datetime64, first dates:\",\n",
-    "          df['Date'].iloc[0], \"…\", df['Date'].iloc[-1])\n",
-    "\n",
-    "    # —(3) Identify risk-free column\n",
-    "    rf_col = identify_risk_free_fund(df)\n",
-    "    print(f\"INFO: Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "\n",
-    "    # —(4) Slice into in-sample & out-sample\n",
-    "    in_sample_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_sample_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "    in_sample_rf  = in_sample_df[rf_col]\n",
-    "    out_sample_rf = out_sample_df[rf_col]\n",
-    "\n",
-    "    print(f\"CHECKPOINT C: in_sample rows = {len(in_sample_df)}, out_sample rows = {len(out_sample_df)}\")\n",
-    "\n",
-    "    # —(5) Select funds (either “manual” or via select_funds)\n",
-    "    if selection_mode == 'manual' and custom_weights is not None:\n",
-    "        # In manual mode, we trust the user’s chosen tickers outright\n",
-    "        selected_funds = list(custom_weights.keys())\n",
-    "        print(f\"CHECKPOINT D (manual): using custom_weights keys → {selected_funds}\")\n",
-    "    else:\n",
-    "        all_fund_cols = fund_cols.copy()\n",
-    "        print(f\"CHECKPOINT D: about to call select_funds with {len(all_fund_cols)} candidates\")\n",
-    "\n",
-    "        selected_funds = select_funds(\n",
-    "            df,\n",
-    "            rf_col,\n",
-    "            fund_columns=all_fund_cols,\n",
-    "            in_sdate=in_sdate,\n",
-    "            in_edate=in_edate,\n",
-    "            out_sdate=out_sdate,\n",
-    "            out_edate=out_edate,\n",
-    "            selection_mode=selection_mode,\n",
-    "            random_n=random_n\n",
-    "        )\n",
-    "\n",
-    "    if len(selected_funds) == 0:\n",
-    "        logging.warning(\"No valid funds remain after filtering.\")\n",
-    "        print(\"Warning: No valid funds. Try adjusting your selection or data filters.\")\n",
-    "        return None\n",
-    "\n",
-    "    print(f\"CHECKPOINT E: select_funds returned {len(selected_funds)} funds → {selected_funds}\")\n",
-    "\n",
-    "    # indices_list must already exist as a global list of index columns\n",
-    "    in_sample_indices  = in_sample_df[indices_list].copy()\n",
-    "    out_sample_indices = out_sample_df[indices_list].copy()\n",
-    "\n",
-    "    # —(6) Compute scale_factors (based on in-sample volatility)\n",
-    "    scale_factors = {}\n",
-    "    for fund in selected_funds:\n",
-    "        fund_in_rets = in_sample_df[fund].dropna()\n",
-    "        current_vol  = annualize_volatility(fund_in_rets)\n",
-    "        if pd.isna(current_vol) or current_vol == 0:\n",
-    "            scale_factors[fund] = 1.0\n",
-    "        else:\n",
-    "            scale_factors[fund] = target_vol / current_vol\n",
-    "\n",
-    "    print(\"CHECKPOINT F: scale_factors computed (showing first 5):\",\n",
-    "          {f: scale_factors[f] for f in selected_funds[:5]})\n",
-    "\n",
-    "    # Pre-allocate DataFrames for scaled returns\n",
-    "    in_sample_scaled  = pd.DataFrame(index=in_sample_df.index, columns=selected_funds)\n",
-    "    out_sample_scaled = pd.DataFrame(index=out_sample_df.index, columns=selected_funds)\n",
-    "\n",
-    "    # ── Wrap everything from “scaling + stats” in a try/except ──\n",
-    "    try:\n",
-    "        # (6a) Scale returns (with monthly cost)\n",
-    "        for fund in selected_funds:\n",
-    "            sf     = scale_factors[fund]\n",
-    "            adj_in = in_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_in[adj_in < -1.0] = -1.0\n",
-    "            in_sample_scaled[fund] = adj_in\n",
-    "\n",
-    "            if not out_sample_df.empty:\n",
-    "                adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "                adj_out[adj_out < -1.0] = -1.0\n",
-    "                out_sample_scaled[fund] = adj_out\n",
-    "\n",
-    "        # (6b) Helper to compute per-series stats\n",
-    "        def compute_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            sr  = sharpe_ratio(series, rf_series)\n",
-    "            so  = sortino_ratio(series, rf_series)\n",
-    "            mdd = max_drawdown(series)\n",
-    "            return (r, v, sr, so, mdd)\n",
-    "\n",
-    "        # (6c) In-sample per-fund stats\n",
-    "        in_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "\n",
-    "        # (6d) Out-sample per-fund (vol-adjusted) stats\n",
-    "        out_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6e) Out-sample per-fund (raw) stats\n",
-    "        out_sample_stats_raw = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6f) Equal-weight portfolio returns\n",
-    "        ew_weight_dict = { f: 1.0/len(selected_funds) for f in selected_funds }\n",
-    "        ew_w           = np.array([ ew_weight_dict[f] for f in selected_funds ])\n",
-    "        in_ew_port      = calc_portfolio_returns(ew_w,       in_sample_scaled[selected_funds])\n",
-    "        out_ew_port     = calc_portfolio_returns(ew_w,       out_sample_scaled[selected_funds])\n",
-    "        out_ew_port_raw = calc_portfolio_returns(ew_w,       out_sample_df[selected_funds])\n",
-    "        \n",
-    "        in_ew_stats      = compute_stats(in_ew_port,      in_sample_rf)\n",
-    "        out_ew_stats     = compute_stats(out_ew_port,     out_sample_rf)\n",
-    "        out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6g) Index statistics (treat each index like “just another series”)\n",
-    "        in_index_stats  = {}\n",
-    "        out_index_stats = {}\n",
-    "        for idx in indices_list:\n",
-    "            in_index_stats[idx]  = compute_stats(in_sample_indices[idx],  in_sample_df[rf_col])\n",
-    "            out_index_stats[idx] = compute_stats(out_sample_indices[idx], out_sample_df[rf_col])\n",
-    "\n",
-    "        # (6h) “User-weight” portfolio\n",
-    "        if custom_weights is None:\n",
-    "            # If no manual weights → just reuse the same equal‐weight array\n",
-    "            user_weight_dict = ew_weight_dict.copy()\n",
-    "            # ← **IMPORTANT FIX**: define custom_w here for the equal-weight case\n",
-    "            custom_w = ew_w.copy()  \n",
-    "        else:\n",
-    "            # Manual weights passed → convert percentages to decimals\n",
-    "            user_weight_dict = { f: custom_weights[f] / 100.0 for f in selected_funds }\n",
-    "            custom_w         = np.array([ user_weight_dict[f] for f in selected_funds ])\n",
-    "\n",
-    "        # (6i) Compute “user-weighted” portfolio returns\n",
-    "        in_user_port      = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "        out_user_port     = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "        out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        # (6j) Compute their stats\n",
-    "        in_user_stats      = compute_stats(in_user_port,      in_sample_rf)\n",
-    "        out_user_stats     = compute_stats(out_user_port,     out_sample_rf)\n",
-    "        out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6k) Build the final results dict **(FIXED: removed duplicate 'fund_weights')**\n",
-    "        results = {\n",
-    "            'selected_funds':       selected_funds,\n",
-    "            'in_sample_scaled':     in_sample_scaled,\n",
-    "            'out_sample_scaled':    out_sample_scaled,\n",
-    "            'in_sample_stats':      in_sample_stats,\n",
-    "            'out_sample_stats':     out_sample_stats,\n",
-    "            'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "            'in_ew_stats':          in_ew_stats,\n",
-    "            'out_ew_stats':         out_ew_stats,\n",
-    "            'out_ew_stats_raw':     out_ew_stats_raw,\n",
-    "            'in_user_stats':        in_user_stats,\n",
-    "            'out_user_stats':       out_user_stats,\n",
-    "            'out_user_stats_raw':   out_user_stats_raw,\n",
-    "            'ew_weights':           ew_weight_dict,     # ← now returns equal-weight dict\n",
-    "            'fund_weights':         user_weight_dict,   # ← returns manual weights (or equal if none)\n",
-    "            'indices_list':         indices_list\n",
-    "        }\n",
-    "\n",
-    "    except Exception as e:\n",
-    "        print(\"ERROR inside stats-block:\", e)\n",
-    "        return None\n",
-    "\n",
-    "    # Everything succeeded\n",
-    "    return results\n",
-    "\n",
-    "\n",
-    "\n",
-    "print(\"run_analysis (with checkpoints) is defined.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 8. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 20,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "def export_to_excel(\n",
-    "    results_dict,\n",
-    "    output_filename,\n",
-    "    in_start_str,   # e.g. \"2005-07\"\n",
-    "    in_end_str,     # e.g. \"2008-06\"\n",
-    "    out_start_str,  # e.g. \"2008-07\"\n",
-    "    out_end_str     # e.g. \"2009-06\"\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1. Builds two tables per sheet:\n",
-    "       - First block = Equal-weight portfolio + individual funds\n",
-    "       - Second block = User-weight portfolio + individual funds (including ‘Weight’ column)\n",
-    "    2. Leaves one blank row between the two blocks.\n",
-    "    3. Appends an “Indices” block at the bottom of each sheet (In-Sample and Out-Sample).\n",
-    "\n",
-    "    Number formats used:\n",
-    "      • Weight              → integer (0–100, no % sign)\n",
-    "      • Return, Volatility, Max Drawdown → one‐decimal percent (e.g. “12.3%”)\n",
-    "      • Sharpe, Sortino     → two‐decimal decimal (e.g. “1.45”)\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # ────────────────────────────────────────────────────────────────────────────────────────\n",
-    "    # Unpack everything from results_dict\n",
-    "    selected_funds    = results_dict['selected_funds']\n",
-    "    indices_list      = results_dict['indices_list']\n",
-    "    fund_weights_dec  = results_dict['fund_weights']\n",
-    "\n",
-    "    in_stats_dict      = results_dict['in_sample_stats']\n",
-    "    out_stats_dict     = results_dict['out_sample_stats']\n",
-    "    out_stats_dict_raw = results_dict['out_sample_stats_raw']\n",
-    "\n",
-    "    in_ew_stats        = results_dict['in_ew_stats']\n",
-    "    out_ew_stats       = results_dict['out_ew_stats']\n",
-    "    out_ew_stats_raw   = results_dict['out_ew_stats_raw']\n",
-    "\n",
-    "    in_user_stats      = results_dict['in_user_stats']\n",
-    "    out_user_stats     = results_dict['out_user_stats']\n",
-    "    out_user_stats_raw = results_dict['out_user_stats_raw']\n",
-    "    # ────────────────────────────────────────────────────────────────────────────────────────\n",
-    "        \n",
-    "    # ─── (A) Build In‐Sample blocks ─────────────────────────────────────────────────────────\n",
-    "\n",
-    "    # 1) Equal‐Weight block (Fund + portfolio)\n",
-    "    in_eq_rows = []\n",
-    "    ir, iv, isr, iso, imdd = in_ew_stats\n",
-    "    in_eq_rows.append({\n",
-    "        'Fund':           'Equal-Weight Portfolio',\n",
-    "        'Weight':         100,       # 100% at the portfolio level (raw integer)\n",
-    "        'Return (%)':     ir,        # e.g. 0.3542 for 35.42%\n",
-    "        'Volatility (%)': iv,        # e.g. 0.0956 for 9.56%\n",
-    "        'Sharpe Ratio':   isr,       # e.g. 2.052\n",
-    "        'Sortino Ratio':  iso,       # e.g. 7.256\n",
-    "        'Max Drawdown (%)': imdd     # e.g. 0.034 for 3.4%\n",
-    "    })\n",
-    "    for f in selected_funds:\n",
-    "        fr, fv, fsr, fso, fmdd = in_stats_dict[f]\n",
-    "        w = fund_weights_dec.get(f, 1.0/len(selected_funds))\n",
-    "        in_eq_rows.append({\n",
-    "            'Fund':           f,\n",
-    "            'Weight':         int(round(w * 100)),   # e.g. w=0.25 → 25\n",
-    "            'Return (%)':     fr,        # e.g. 0.583 for 58.3%\n",
-    "            'Volatility (%)': fv,        # e.g. 0.25 for 25.0%\n",
-    "            'Sharpe Ratio':   fsr,       # e.g. 2.15\n",
-    "            'Sortino Ratio':  fso,       # e.g. 6.266\n",
-    "            'Max Drawdown (%)': fmdd     # e.g. 0.082 for 8.2%\n",
-    "        })\n",
-    "    in_eq_df = pd.DataFrame(in_eq_rows)\n",
-    "\n",
-    "    # 2) User‐Weight block\n",
-    "    in_user_rows = []\n",
-    "    uir, uiv, uisr, uiso, uimdd = in_user_stats\n",
-    "    in_user_rows.append({\n",
-    "        'Fund':           'User-Weight Portfolio',\n",
-    "        'Weight':         100,       # 100% at the portfolio level\n",
-    "        'Return (%)':     uir,\n",
-    "        'Volatility (%)': uiv,\n",
-    "        'Sharpe Ratio':   uisr,\n",
-    "        'Sortino Ratio':  uiso,\n",
-    "        'Max Drawdown (%)': uimdd\n",
-    "    })\n",
-    "    for f in selected_funds:\n",
-    "        fr, fv, fsr, fso, fmdd = in_stats_dict[f]\n",
-    "        w = fund_weights_dec.get(f, 1.0/len(selected_funds))\n",
-    "        in_user_rows.append({\n",
-    "            'Fund':           f,\n",
-    "            'Weight':         int(round(w * 100)),\n",
-    "            'Return (%)':     fr,\n",
-    "            'Volatility (%)': fv,\n",
-    "            'Sharpe Ratio':   fsr,\n",
-    "            'Sortino Ratio':  fso,\n",
-    "            'Max Drawdown (%)': fmdd\n",
-    "        })\n",
-    "    in_user_df = pd.DataFrame(in_user_rows)\n",
-    "    # ────────────────────────────────────────────────────────────────────────────────────────\n",
-    "\n",
-    "\n",
-    "    # ─── (B) Build Out‐Sample blocks ─────────────────────────────────────────────────────────\n",
-    "    # 1) Equal‐Weight block\n",
-    "    out_eq_rows = []\n",
-    "    or_, ov, osr, oso, omdd = out_ew_stats\n",
-    "    out_eq_rows.append({\n",
-    "        'Fund':           'Equal-Weight Portfolio',\n",
-    "        'Weight':         100,\n",
-    "        'Return (%)':     or_,\n",
-    "        'Volatility (%)': ov,\n",
-    "        'Sharpe Ratio':   osr,\n",
-    "        'Sortino Ratio':  oso,\n",
-    "        'Max Drawdown (%)': omdd\n",
-    "    })\n",
-    "    for f in selected_funds:\n",
-    "        fr, fv, fsr, fso, fmdd = out_stats_dict[f]\n",
-    "        w = fund_weights_dec.get(f, 1.0/len(selected_funds))\n",
-    "        out_eq_rows.append({\n",
-    "            'Fund':           f,\n",
-    "            'Weight':         int(round(w * 100)),\n",
-    "            'Return (%)':     fr,\n",
-    "            'Volatility (%)': fv,\n",
-    "            'Sharpe Ratio':   fsr,\n",
-    "            'Sortino Ratio':  fso,\n",
-    "            'Max Drawdown (%)': fmdd\n",
-    "        })\n",
-    "    out_eq_df = pd.DataFrame(out_eq_rows)\n",
-    "\n",
-    "    # 2) User‐Weight block\n",
-    "    out_user_rows = []\n",
-    "    our_, ouv, ousr, ouso, oumdd = out_user_stats\n",
-    "    out_user_rows.append({\n",
-    "        'Fund':           'User-Weight Portfolio',\n",
-    "        'Weight':         100,\n",
-    "        'Return (%)':     our_,\n",
-    "        'Volatility (%)': ouv,\n",
-    "        'Sharpe Ratio':   ousr,\n",
-    "        'Sortino Ratio':  ouso,\n",
-    "        'Max Drawdown (%)': oumdd\n",
-    "    })\n",
-    "    for f in selected_funds:\n",
-    "        fr, fv, fsr, fso, fmdd = out_stats_dict[f]\n",
-    "        w = fund_weights_dec.get(f, 1.0/len(selected_funds))\n",
-    "        out_user_rows.append({\n",
-    "            'Fund':           f,\n",
-    "            'Weight':         int(round(w * 100)),\n",
-    "            'Return (%)':     fr,\n",
-    "            'Volatility (%)': fv,\n",
-    "            'Sharpe Ratio':   fsr,\n",
-    "            'Sortino Ratio':  fso,\n",
-    "            'Max Drawdown (%)': fmdd\n",
-    "        })\n",
-    "    out_user_df = pd.DataFrame(out_user_rows)\n",
-    "    # ────────────────────────────────────────────────────────────────────────────────────────\n",
-    "\n",
-    "\n",
-    "    # ─── (C) Build “Indices (In‐Sample)” and “Indices (Out‐Sample)” DataFrames ─────────────\n",
-    "    in_s = pd.to_datetime(in_start_str + \"-01\")\n",
-    "    in_e = pd.to_datetime(in_end_str   + \"-01\") + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    index_in_rows = []\n",
-    "    for idx in indices_list:\n",
-    "        idx_series = df.loc[(df['Date'] >= in_s) & (df['Date'] <= in_e), idx]\n",
-    "        irx  = annualize_return(idx_series)\n",
-    "        ivx  = annualize_volatility(idx_series)\n",
-    "        rf_s = df.loc[(df['Date'] >= in_s) & (df['Date'] <= in_e),\n",
-    "                      identify_risk_free_fund(df)]\n",
-    "        isrx  = sharpe_ratio(idx_series, rf_s)\n",
-    "        isox  = sortino_ratio(idx_series, rf_s)\n",
-    "        imddx = max_drawdown(idx_series)\n",
-    "\n",
-    "        index_in_rows.append({\n",
-    "            'Index':           idx,\n",
-    "            'Return (%)':      irx,\n",
-    "            'Volatility (%)':  ivx,\n",
-    "            'Sharpe Ratio':    isrx,\n",
-    "            'Sortino Ratio':   isox,\n",
-    "            'Max Drawdown (%)': imddx\n",
-    "        })\n",
-    "    indices_in_df = pd.DataFrame(index_in_rows)\n",
-    "\n",
-    "    out_s = pd.to_datetime(out_start_str + \"-01\")\n",
-    "    out_e = pd.to_datetime(out_end_str   + \"-01\") + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    index_out_rows = []\n",
-    "    for idx in indices_list:\n",
-    "        idx_series = df.loc[(df['Date'] >= out_s) & (df['Date'] <= out_e), idx]\n",
-    "        irx  = annualize_return(idx_series)\n",
-    "        ivx  = annualize_volatility(idx_series)\n",
-    "        rf_o = df.loc[(df['Date'] >= out_s) & (df['Date'] <= out_e),\n",
-    "                      identify_risk_free_fund(df)]\n",
-    "        isrx  = sharpe_ratio(idx_series, rf_o)\n",
-    "        isox  = sortino_ratio(idx_series, rf_o)\n",
-    "        imddx = max_drawdown(idx_series)\n",
-    "\n",
-    "        index_out_rows.append({\n",
-    "            'Index':           idx,\n",
-    "            'Return (%)':      irx,\n",
-    "            'Volatility (%)':   ivx,\n",
-    "            'Sharpe Ratio':    isrx,\n",
-    "            'Sortino Ratio':  isox,\n",
-    "            'Max Drawdown (%)': imddx\n",
-    "        })\n",
-    "    indices_out_df = pd.DataFrame(index_out_rows)\n",
-    "    # ────────────────────────────────────────────────────────────────────────────────────────\n",
-    "\n",
-    "\n",
-    "    # ─── (D) Write everything to Excel ──────────────────────────────────────────────────────\n",
-    "    writer   = pd.ExcelWriter(fname, engine='xlsxwriter')\n",
-    "    workbook = writer.book\n",
-    "\n",
-    "    # Create the formats we need:\n",
-    "    int_fmt     = workbook.add_format({'num_format': '0'})     # integer (0–100)\n",
-    "    pct1_fmt    = workbook.add_format({'num_format': '0.0%'})  # one‐decimal percent\n",
-    "    dec2_fmt    = workbook.add_format({'num_format': '0.00'})  # two‐decimal float\n",
-    "    bold_fmt    = workbook.add_format({'bold': True})\n",
-    "\n",
-    "    # ─── In‐Sample Sheet ───────────────────────────────────────────────────────────────────\n",
-    "    sheet_in = f\"IS {in_start_str}-{in_end_str}\"\n",
-    "\n",
-    "    # >>> SANITY CHECK: show top few rows of in_eq_df immediately before to_excel()\n",
-    "    print(\">>> SANITY CHECK IN_EQ (first 5 rows):\")\n",
-    "    print(in_eq_df[['Fund','Weight','Return (%)','Volatility (%)','Sharpe Ratio','Sortino Ratio','Max Drawdown (%)']].head())\n",
-    "    # >>> /SANITY CHECK\n",
-    "    \n",
-    "    in_eq_df.to_excel(writer, sheet_name=sheet_in, startrow=0, index=False)\n",
-    "    in_user_df.to_excel(writer, sheet_name=sheet_in, startrow=len(in_eq_df) + 3, index=False)\n",
-    "\n",
-    "    ws_in = writer.sheets[sheet_in]\n",
-    "\n",
-    "    # (1) Column widths + formats for In‐Sample\n",
-    "    #     Columns:  0=Fund, 1=Weight, 2=Return (%), 3=Volatility (%),\n",
-    "    #               4=Sharpe Ratio, 5=Sortino Ratio, 6=Max Drawdown (%)\n",
-    "    ws_in.set_column(0, 0, 28)          # “Fund” column (wide)\n",
-    "    ws_in.set_column(1, 1, 12, int_fmt)     # “Weight” as integer (0–100)\n",
-    "    ws_in.set_column(2, 2, 15, pct1_fmt)     # “Return (%)” one‐decimal %\n",
-    "    ws_in.set_column(3, 3, 15, pct1_fmt)     # “Volatility (%)” one‐decimal %\n",
-    "    ws_in.set_column(4, 4, 15, dec2_fmt)     # “Sharpe Ratio” two decimals\n",
-    "    ws_in.set_column(5, 5, 15, dec2_fmt)     # “Sortino Ratio” two decimals\n",
-    "    ws_in.set_column(6, 6, 15, pct1_fmt)     # “Max Drawdown (%)” one‐decimal %\n",
-    "\n",
-    "    # (2) Bold the header rows for both tables\n",
-    "    for colx in range(in_eq_df.shape[1]):\n",
-    "        ws_in.write(0, colx, in_eq_df.columns[colx], bold_fmt)\n",
-    "    for colx in range(in_user_df.shape[1]):\n",
-    "        ws_in.write(len(in_eq_df) + 3, colx, in_user_df.columns[colx], bold_fmt)\n",
-    "\n",
-    "    # (3) Insert “Indices (In‐Sample)” block\n",
-    "    start_idx_in = len(in_eq_df) + len(in_user_df) + 6\n",
-    "    ws_in.write(start_idx_in - 1, 0, \"Indices (In-Sample):\", bold_fmt)\n",
-    "    indices_in_df.to_excel(\n",
-    "        writer,\n",
-    "        sheet_name=sheet_in,\n",
-    "        startrow=start_idx_in,\n",
-    "        index=False\n",
-    "    )\n",
-    "    # (4) Format the In‐Sample indices block (columns 0–5)\n",
-    "    ws_in.set_column(0, 0, 28)          # “Index” column\n",
-    "    ws_in.set_column(1, 1, 15, pct1_fmt)    # “Return (%)” one‐decimal %\n",
-    "    ws_in.set_column(2, 2, 15, pct1_fmt)    # “Volatility (%)” one‐decimal %\n",
-    "    ws_in.set_column(3, 3, 15, dec2_fmt)    # “Sharpe Ratio” two decimals\n",
-    "    ws_in.set_column(4, 4, 15, dec2_fmt)    # “Sortino Ratio” two decimals\n",
-    "    ws_in.set_column(5, 5, 15, pct1_fmt)    # “Max Drawdown (%)” one‐decimal %\n",
-    "\n",
-    "    # ─── Out‐Sample Sheet ──────────────────────────────────────────────────────────────────\n",
-    "    sheet_out = f\"OS {out_start_str}-{out_end_str}\"\n",
-    "    out_eq_df.to_excel(writer, sheet_name=sheet_out, startrow=0, index=False)\n",
-    "    out_user_df.to_excel(writer, sheet_name=sheet_out, startrow=len(out_eq_df) + 3, index=False)\n",
-    "\n",
-    "    ws_out = writer.sheets[sheet_out]\n",
-    "\n",
-    "    # (1) Column widths + formats for Out‐Sample\n",
-    "    ws_out.set_column(0, 0, 28)          # “Fund” column\n",
-    "    ws_out.set_column(1, 1, 12, int_fmt)     # “Weight” as integer\n",
-    "    ws_out.set_column(2, 2, 15, pct1_fmt)     # “Return (%)” one‐decimal %\n",
-    "    ws_out.set_column(3, 3, 15, pct1_fmt)     # “Volatility (%)” one‐decimal %\n",
-    "    ws_out.set_column(4, 4, 15, dec2_fmt)     # “Sharpe Ratio” two decimals\n",
-    "    ws_out.set_column(5, 5, 15, dec2_fmt)     # “Sortino Ratio” two decimals\n",
-    "    ws_out.set_column(6, 6, 15, pct1_fmt)     # “Max Drawdown (%)” one‐decimal %\n",
-    "\n",
-    "    # (2) Bold the header rows for both tables\n",
-    "    for colx in range(out_eq_df.shape[1]):\n",
-    "        ws_out.write(0, colx, out_eq_df.columns[colx], bold_fmt)\n",
-    "    for colx in range(out_user_df.shape[1]):\n",
-    "        ws_out.write(len(out_eq_df) + 3, colx, out_user_df.columns[colx], bold_fmt)\n",
-    "\n",
-    "    # (3) Insert “Indices (Out‐Sample)” block\n",
-    "    start_idx_out = len(out_eq_df) + len(out_user_df) + 6\n",
-    "    ws_out.write(start_idx_out - 1, 0, \"Indices (Out-Sample):\", bold_fmt)\n",
-    "    indices_out_df.to_excel(\n",
-    "        writer,\n",
-    "        sheet_name=sheet_out,\n",
-    "        startrow=start_idx_out,\n",
-    "        index=False\n",
-    "    )\n",
-    "    # (4) Format the Out‐Sample indices block (columns 0–5)\n",
-    "    ws_out.set_column(0, 0, 28)          # “Index” column\n",
-    "    ws_out.set_column(1, 1, 15, pct1_fmt)    # “Return (%)” one‐decimal %\n",
-    "    ws_out.set_column(2, 2, 15, pct1_fmt)    # “Volatility (%)” one‐decimal %\n",
-    "    ws_out.set_column(3, 3, 15, dec2_fmt)    # “Sharpe Ratio” two decimals\n",
-    "    ws_out.set_column(4, 4, 15, dec2_fmt)    # “Sortino Ratio” two decimals\n",
-    "    ws_out.set_column(5, 5, 15, pct1_fmt)    # “Max Drawdown (%)” one‐decimal %\n",
-    "\n",
-    "    # ─── Save & close ───────────────────────────────────────────────────────────────────────\n",
-    "    writer.close()\n",
-    "    import os, time\n",
-    "    print(\"→ Excel file path:\", os.path.abspath(output_filename))\n",
-    "    print(\"→ Last modified:\", time.ctime(os.path.getmtime(output_filename)))\n",
-    "    df_check = pd.read_excel(output_filename, sheet_name=f\"IS {in_start_str}-{in_end_str}\", nrows=5)\n",
-    "    print(df_check)\n",
-    "    \n",
-    "    logging.info(f\"Exported analysis to {output_filename} successfully.\")\n",
-    "    print(f\"Excel file created: {output_filename}\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Run Parameters"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 21,
-   "id": "9899f2e3-9c6e-4c38-b3eb-d07e8f871462",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "f3da85aee5a748cab2a22a0d7bee4978",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(VBox(children=(Text(value='2005-07', description='In-Sample Start:'), Text(value='2008-06', des…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "8a38a2403acd452780b892b0c45d05e0",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Output(layout=Layout(border_bottom='1px solid gray', border_left='1px solid gray', border_right='1px solid gra…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "display(master_vbox, output_area)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup2-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup2-checkpoint.ipynb
deleted file mode 100644
index 34bc3eaafca862e33790a1636d7c3048394ee41a..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup2-checkpoint.ipynb
+++ /dev/null
@@ -1,1511 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 1. SETUP CELL ============\n",
-    "\n",
-    "import logging\n",
-    "import sys\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import os\n",
-    "import math\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import interact, interactive, VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from IPython.utils.capture import capture_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import datetime\n",
-    "import random\n",
-    "import warnings\n",
-    "\n",
-    "# If you need to install these packages on your environment, uncomment:\n",
-    "!{sys.executable} -m pip install --quiet ipywidgets openpyxl xlsxwriter\n",
-    "\n",
-    "# For exporting to Excel with styling\n",
-    "import xlsxwriter\n",
-    "\n",
-    "# Set up logging to console\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "logging.info(\"Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\")\n",
-    "\n",
-    "# (Optional) If widgets aren't enabled, run:\n",
-    "# !jupyter nbextension enable --py widgetsnbextension --sys-prefix\n",
-    "\n",
-    "print(\"Setup complete.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "5bf498b63eaf4125ad868abb1511a638",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<b>Step 1: Choose your CSV</b><br><i>Remember:</i> If you included any index column…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify which column (after 'Date') is the risk-free rate by smallest stdev among columns.\n",
-    "    \"\"\"\n",
-    "    numeric_cols = df.columns[1:]  # skip the Date column\n",
-    "    stdevs = {}\n",
-    "    for col in numeric_cols:\n",
-    "        vals = df[col].dropna()\n",
-    "        if len(vals) > 0:\n",
-    "            stdevs[col] = vals.std()\n",
-    "        else:\n",
-    "            stdevs[col] = np.inf\n",
-    "\n",
-    "    rf_col = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "    return rf_col\n",
-    "\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 1) Helper to read a local CSV robustly (handles BOMs and minor parsing issues)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Try loading `path` as CSV in three ways:\n",
-    "    1. Default C engine\n",
-    "    2. BOM-stripped with the Python engine\n",
-    "    3. Skip bad lines with the Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception as e1:\n",
-    "        print(\"Default read_csv failed:\", e1)\n",
-    "\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception as e2:\n",
-    "        print(\"utf-8-sig + python engine failed:\", e2)\n",
-    "\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",    # for pandas ≥ 1.3\n",
-    "    )\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 2) Build the widgets\n",
-    "# ------------------------------------------------------------------------------\n",
-    "source_info = widgets.HTML(\n",
-    "    \"<b>Step 1: Choose your CSV</b><br>\"\n",
-    "    \"<i>Remember:</i> If you included any index columns (e.g. S&P 500, MSCI World, SG Trend), they \"\n",
-    "    \"must appear to the right of all fund columns in your sheet.\"\n",
-    ")\n",
-    "\n",
-    "\n",
-    "source_dropdown = widgets.Dropdown(\n",
-    "    options=['Local', 'GitHub'],\n",
-    "    value='Local',\n",
-    "    description='Data Source:',\n",
-    "    style={'description_width': '120px'}\n",
-    ")\n",
-    "\n",
-    "# FileChooser for Local mode\n",
-    "fc = FileChooser(os.getcwd())\n",
-    "fc.title = \"<b>Select local CSV file</b>\"\n",
-    "\n",
-    "# Text box for GitHub raw URL\n",
-    "github_text = widgets.Text(\n",
-    "    value=(\n",
-    "        \"https://raw.githubusercontent.com/stranske/Trend_Model_Project/\"\n",
-    "        \"main/data/TrendData.csv\"\n",
-    "    ),\n",
-    "    description=\"GitHub URL:\",\n",
-    "    layout=widgets.Layout(width=\"80%\"),\n",
-    ")\n",
-    "\n",
-    "# Ask how many index columns are on the far right\n",
-    "n_indices_widget = widgets.BoundedIntText(\n",
-    "    value=0,\n",
-    "    min=0,\n",
-    "    max=10,  # adjust if you expect more than 10 indices\n",
-    "    description='# Index cols:',\n",
-    "    style={'description_width': '120px'},\n",
-    "    tooltip=\"Enter the number of index columns at the far right of your CSV\"\n",
-    ")\n",
-    "\n",
-    "# Load button\n",
-    "load_button = widgets.Button(description=\"Load Data\", button_style=\"success\")\n",
-    "\n",
-    "# Output area for status and debug prints\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 3) Show/hide widgets depending on source selection\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_source_change(change):\n",
-    "    if change[\"new\"] == \"Local\":\n",
-    "        fc.layout.display = \"block\"\n",
-    "        github_text.layout.display = \"none\"\n",
-    "    else:\n",
-    "        fc.layout.display = \"none\"\n",
-    "        github_text.layout.display = \"block\"\n",
-    "\n",
-    "# Initially, GitHub textbox is hidden; FileChooser is visible\n",
-    "github_text.layout.display = \"none\"\n",
-    "fc.layout.display = \"block\"\n",
-    "\n",
-    "source_dropdown.observe(on_source_change, names=\"value\")\n",
-    "\n",
-    "ui_load = widgets.VBox([\n",
-    "    source_info,\n",
-    "    source_dropdown,\n",
-    "    fc,\n",
-    "    github_text,\n",
-    "    n_indices_widget,   # ← new widget here\n",
-    "    load_button,\n",
-    "    output_area\n",
-    "])\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 4) Callback for the Load button (auto-detect date format)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_load_clicked(_):\n",
-    "    global df, fund_cols, indices_list, rf_col            # declare df as global\n",
-    "    with output_area:\n",
-    "        output_area.clear_output()\n",
-    "        src_choice = source_dropdown.value\n",
-    "        n_indices = int(n_indices_widget.value)\n",
-    "\n",
-    "        # 4a) Load the DataFrame\n",
-    "        try:\n",
-    "            if src_choice == 'Local':\n",
-    "                local_path = fc.selected  # FileChooser’s selected path\n",
-    "                if not local_path or not os.path.exists(local_path):\n",
-    "                    print(f\"Error: Local file not found:\\n  {local_path}\")\n",
-    "                    return\n",
-    "                print(f\"Loading from local file:\\n  {local_path}\")\n",
-    "                df = pd.read_csv(local_path)\n",
-    "            else:\n",
-    "                github_url = github_text.value.strip()\n",
-    "                if not github_url:\n",
-    "                    print(\"Error: Please enter a valid GitHub raw URL.\")\n",
-    "                    return\n",
-    "                print(f\"Loading from GitHub URL:\\n  {github_url}\")\n",
-    "                df = pd.read_csv(github_url)\n",
-    "        except Exception as e:\n",
-    "            print(\"Failed to load CSV:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4b) Debug: print columns & a few rows\n",
-    "        print(\"Columns found in DataFrame:\", df.columns.tolist())\n",
-    "        display(df.head(3))\n",
-    "\n",
-    "        # 4c) Identify which column is the date\n",
-    "        date_col = None\n",
-    "        for candidate in [\"Date\", \"DATE\", \"date\"]:\n",
-    "            if candidate in df.columns:\n",
-    "                date_col = candidate\n",
-    "                break\n",
-    "\n",
-    "        if date_col is None:\n",
-    "            print(\"Error: No column named 'Date' / 'DATE' / 'date' found.\")\n",
-    "            print(\"Please check the column names above and adjust code accordingly.\")\n",
-    "            return\n",
-    "\n",
-    "        date_col = 'Date'\n",
-    "\n",
-    "        # 1) Show the first few raw date strings (un‐parsed) so we can inspect them\n",
-    "        raw_samples = df[date_col].dropna().astype(str).head(10).tolist()\n",
-    "        print(f\"Raw {date_col} samples (first 10 non‐null): {raw_samples!r}\")\n",
-    "\n",
-    "        # 2) Strip leading/trailing whitespace from every entry\n",
-    "        df[date_col] = df[date_col].astype(str).str.strip()\n",
-    "\n",
-    "        # 3) Now attempt strict \"%m/%d/%Y\" parsing\n",
-    "        parsed = pd.to_datetime(df[date_col], format=\"%m/%d/%Y\", errors=\"coerce\", infer_datetime_format=True)\n",
-    "        num_valid = parsed.notna().sum()\n",
-    "        print(f\"Number of rows matching '%m/%d/%Y' exactly: {num_valid} / {len(df)}\")\n",
-    "\n",
-    "        if num_valid > 0:\n",
-    "            df[date_col] = parsed\n",
-    "            print(f\"Parsing with '%m/%d/%Y' succeeded for {num_valid} rows.\")\n",
-    "        else:\n",
-    "            print(\n",
-    "                \"Warning: No rows matched '%m/%d/%Y'. \"\n",
-    "                \"Falling back to generic pd.to_datetime(...).\"\n",
-    "            )\n",
-    "            df[date_col] = pd.to_datetime(df[date_col], errors=\"coerce\")\n",
-    "\n",
-    "        # 5) Drop any rows where parsing still failed\n",
-    "        before_drop = len(df)\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        dropped = before_drop - len(df)\n",
-    "        if dropped:\n",
-    "            print(f\"Dropped {dropped} rows where '{date_col}' could not be parsed.\")\n",
-    "        \n",
-    "        # 6) Sort and reset index\n",
-    "        df.sort_values(by=date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "        \n",
-    "        # 7) Show the final parsed dates\n",
-    "        print(f\"After parsing, first 3 {date_col} values:\")\n",
-    "        print(df[[date_col]].head(3))\n",
-    "        print(f\"Loaded {len(df)} rows successfully.\")\n",
-    "\n",
-    "\n",
-    "        # 4d) Identify risk-free column\n",
-    "        try:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            print(f\"Identified risk-free column as: '{rf_col}'\")\n",
-    "        except Exception as e:\n",
-    "            print(\"Error identifying risk-free column:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4f) Determine fund_cols vs indices_list based on n_indices\n",
-    "        all_cols = df.columns.tolist()\n",
-    "        # We assume “Date” and rf_col are present. Everything else is a candidate.\n",
-    "        if 'Date' not in all_cols or rf_col not in all_cols:\n",
-    "            print(\"Error: 'Date' or risk-free column not found in DataFrame columns.\")\n",
-    "            return\n",
-    "        \n",
-    "        # Build list of all columns except 'Date' and rf_col\n",
-    "        remaining = [c for c in all_cols if c not in ['Date', rf_col]]\n",
-    "        \n",
-    "        if n_indices > len(remaining):\n",
-    "            print(\n",
-    "                f\"Error: You asked for {n_indices} index columns, but only \"\n",
-    "                f\"{len(remaining)} columns remain after 'Date' and '{rf_col}'.\"\n",
-    "            )\n",
-    "            return\n",
-    "\n",
-    "        if n_indices > 0:\n",
-    "            indices_list = remaining[-n_indices:]\n",
-    "            fund_cols    = remaining[:-n_indices]\n",
-    "        else:\n",
-    "            indices_list = []\n",
-    "            fund_cols    = remaining[:]\n",
-    "        print(\"\\n>> Debug (post‐load): fund_cols =\", fund_cols)\n",
-    "        print(\">> Debug (post‐load): indices_list =\", indices_list, \"\\n\")\n",
-    "        \n",
-    "        # 2F) Print out what we found\n",
-    "        print(f\"Detected fund columns ({len(fund_cols)}): {fund_cols}\")\n",
-    "        print(f\"Detected index columns ({len(indices_list)}): {indices_list}\")\n",
-    "        print(\n",
-    "            \"Data loaded and classified successfully.\\n\"\n",
-    "            \"Proceed to Step 2 (Run Analysis).\"\n",
-    "        )\n",
-    "\n",
-    " \n",
-    "        # 8) Confirm that df is now in global scope\n",
-    "        print(\">> df defined with\", len(df), \"rows and columns:\", df.columns.tolist())\n",
-    "\n",
-    "# 5) Wire up and display the UI\n",
-    "load_button.on_click(on_load_clicked)\n",
-    "\n",
-    "\n",
-    "display(ui_load)\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 17,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Utility functions loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Check if a series (sorted chronologically) has >= threshold consecutive NaNs.\n",
-    "    Return True if such a gap exists, False otherwise.\n",
-    "    \"\"\"\n",
-    "    consecutive = 0\n",
-    "    for val in series:\n",
-    "        if pd.isna(val):\n",
-    "            consecutive += 1\n",
-    "        else:\n",
-    "            consecutive = 0\n",
-    "        if consecutive >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "\n",
-    "def annualize_return(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized (geometric) return from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    growth_factor = (1 + valid_rets).prod()\n",
-    "    n_months = len(valid_rets)\n",
-    "    if growth_factor <= 0:\n",
-    "        return -1.0\n",
-    "    ann_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    return ann_ret\n",
-    "\n",
-    "def annualize_volatility(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized stdev of monthly returns, i.e. stdev * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) < 2:\n",
-    "        return np.nan\n",
-    "    return valid_rets.std() * np.sqrt(12)\n",
-    "\n",
-    "def sharpe_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe ratio = (annual_excess_return) / (annual_excess_vol).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    ann_excess_vol = excess.std() * np.sqrt(12)\n",
-    "    if ann_excess_vol == 0:\n",
-    "        return np.nan\n",
-    "    return ann_excess_ret / ann_excess_vol\n",
-    "\n",
-    "def sortino_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino ratio = (annual_excess_return) / (annual_downside_stdev).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "\n",
-    "    negative_mask = excess < 0\n",
-    "    negative_returns = excess[negative_mask]\n",
-    "    if len(negative_returns) == 0:\n",
-    "        return np.inf  # no negative => infinite sortino\n",
-    "    downside_stdev = negative_returns.std() * np.sqrt(12)\n",
-    "    return ann_excess_ret / downside_stdev\n",
-    "\n",
-    "def max_drawdown(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Compute max drawdown from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    wealth_index = (1 + valid_rets).cumprod()\n",
-    "    rolling_max = wealth_index.cummax()\n",
-    "    dd_series = 1 - (wealth_index / rolling_max)\n",
-    "    return dd_series.max()\n",
-    "\n",
-    "def calc_portfolio_returns(weights, df_returns):\n",
-    "    \"\"\"\n",
-    "    Compute monthly portfolio returns (Series) as weighted sum of columns in df_returns.\n",
-    "    \"\"\"\n",
-    "    return (df_returns * weights).sum(axis=1)\n",
-    "\n",
-    "print(\"Utility functions loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "4f1619c9",
-   "metadata": {},
-   "source": [
-    "## 4. Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 18,
-   "id": "1e739b5c-2218-4653-97f8-e3cebe194183",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─────────────── Widget Setup + Callback ───────────────\n",
-    "\n",
-    "# ─── Phase 1: Date / Vol / Cost / Run Button ───\n",
-    "# ─── Phase 1: Date / Vol / Cost / Run Button ───\n",
-    "\n",
-    "in_sample_start     = widgets.Text(value='2005-07', description='In-Sample Start:')\n",
-    "in_sample_end       = widgets.Text(value='2008-06', description='In-Sample End:')\n",
-    "out_sample_start    = widgets.Text(value='2008-07', description='Out-Sample Start:')\n",
-    "out_sample_end      = widgets.Text(value='2009-06', description='Out-Sample End:')\n",
-    "\n",
-    "target_vol_widget   = widgets.FloatText(value=0.25, description='Target Vol:')\n",
-    "monthly_cost_widget = widgets.FloatText(value=0.0033, description='Monthly Cost:')\n",
-    "\n",
-    "run_button = widgets.Button(description='Run Analysis', button_style='success')\n",
-    "\n",
-    "# ← Replace any previous “output_area = widgets.Output()” with the block below:\n",
-    "output_area = widgets.Output(\n",
-    "    layout={\n",
-    "        'border': '1px solid gray',\n",
-    "        'height': '300px',\n",
-    "        'overflow_y': 'auto'   # optional: let it scroll if there’s too much text\n",
-    "    }\n",
-    ")\n",
-    "\n",
-    "# Pack only these into main_inputs for now—no display() yet.\n",
-    "main_inputs = widgets.VBox([\n",
-    "    in_sample_start,\n",
-    "    in_sample_end,\n",
-    "    out_sample_start,\n",
-    "    out_sample_end,\n",
-    "    target_vol_widget,\n",
-    "    monthly_cost_widget,\n",
-    "    run_button\n",
-    "])\n",
-    "\n",
-    "# ─── Phase 2: Build & Hide Mode / Random-Size / “Fund Table” placeholders ───\n",
-    "\n",
-    "# A) Mode dropdown (hidden initially)\n",
-    "selection_mode_widget = widgets.Dropdown(\n",
-    "    options=[('All Funds','all'), ('Random Sample','random'), ('Manual','manual')],\n",
-    "    value='all',\n",
-    "    description='Mode:'\n",
-    ")\n",
-    "selection_mode_widget.layout.display = 'none'\n",
-    "\n",
-    "# B) Random Sample Size field (hidden initially)\n",
-    "random_sample_size_widget = widgets.IntText(\n",
-    "    value=5, description='Sample Size:'\n",
-    ")\n",
-    "random_sample_size_widget.layout.display = 'none'\n",
-    "\n",
-    "# C) Placeholder containers for the Manual‐funds checkboxes & weights\n",
-    "fund_table_container = widgets.VBox([])   # we will populate it later\n",
-    "fund_table_container.layout.display = 'none'\n",
-    "\n",
-    "# D) Whenever Mode changes, show/hide “Sample Size” vs. “Fund Table”\n",
-    "def _on_mode_change(change):\n",
-    "    new_mode = change['new']\n",
-    "    if new_mode == 'random':\n",
-    "        random_sample_size_widget.layout.display = 'block'\n",
-    "        fund_table_container.layout.display   = 'none'\n",
-    "    elif new_mode == 'manual':\n",
-    "        random_sample_size_widget.layout.display = 'none'\n",
-    "        fund_table_container.layout.display   = 'block'\n",
-    "    else:  # 'all'\n",
-    "        random_sample_size_widget.layout.display = 'none'\n",
-    "        fund_table_container.layout.display   = 'none'\n",
-    "\n",
-    "selection_mode_widget.observe(_on_mode_change, names='value')\n",
-    "\n",
-    "# ─── Phase 3: Wire up “Run Analysis” + final display(...) ───\n",
-    "\n",
-    "phase_counter = {\"step\": 1}\n",
-    "\n",
-    "def on_run_clicked(b):\n",
-    "    with output_area:\n",
-    "        clear_output()\n",
-    "\n",
-    "        # 1) Read dates/vol/cost\n",
-    "        in_start_str     = in_sample_start.value.strip()\n",
-    "        in_end_str       = in_sample_end.value.strip()\n",
-    "        out_start_str    = out_sample_start.value.strip()\n",
-    "        out_end_str      = out_sample_end.value.strip()\n",
-    "        target_vol_val   = target_vol_widget.value\n",
-    "        monthly_cost_val = monthly_cost_widget.value\n",
-    "\n",
-    "        # 2) First click = reveal Mode dropdown + hide everything else\n",
-    "        if phase_counter[\"step\"] == 1:\n",
-    "            # Quick check: ensure date strings parse\n",
-    "            try:\n",
-    "                pd.to_datetime(in_start_str, format=\"%Y-%m\")\n",
-    "                pd.to_datetime(in_end_str,   format=\"%Y-%m\")\n",
-    "                pd.to_datetime(out_start_str, format=\"%Y-%m\")\n",
-    "                pd.to_datetime(out_end_str,   format=\"%Y-%m\")\n",
-    "            except Exception:\n",
-    "                print(\"❌ Invalid date formats. Please use YYYY-MM and click Run again.\")\n",
-    "                return\n",
-    "\n",
-    "            print(\"▶ Dates accepted. Now pick Mode (All / Random / Manual). \" \n",
-    "                  \"If Manual, you’ll then see the valid funds appear.\")\n",
-    "            selection_mode_widget.layout.display = 'block'\n",
-    "            phase_counter[\"step\"] = 2\n",
-    "            return\n",
-    "\n",
-    "        # 3) After first click, Mode is visible. If Mode changed to Manual, we need to\n",
-    "        #    build the fund_table with *only* those funds that pass the full‐history + no‐3-NA rule.\n",
-    "        if phase_counter[\"step\"] == 2:\n",
-    "            mode_val  = selection_mode_widget.value\n",
-    "            rnd_n_val = random_sample_size_widget.value if mode_val == 'random' else None\n",
-    "\n",
-    "            # If Manual mode is chosen, build fund_checkboxes & weight_boxes now:\n",
-    "            if mode_val == 'manual':\n",
-    "                # 3a) Determine which funds are “valid” for this date range.\n",
-    "                #     We reuse your existing `select_funds(...)` function, forcing selection_mode='all'.\n",
-    "                try:\n",
-    "                    in_sdate  = pd.to_datetime(in_start_str, format=\"%Y-%m\")\n",
-    "                    in_edate  = pd.to_datetime(in_end_str,   format=\"%Y-%m\") + pd.offsets.MonthEnd(0)\n",
-    "                    out_sdate = pd.to_datetime(out_start_str, format=\"%Y-%m\")\n",
-    "                    out_edate = pd.to_datetime(out_end_str,   format=\"%Y-%m\") + pd.offsets.MonthEnd(0)\n",
-    "                except Exception as e:\n",
-    "                    print(\"❌ Error parsing dates. Please re‐enter and click Run again.\")\n",
-    "                    return\n",
-    "\n",
-    "                # Build the “candidate fund_columns” list (exclude Date/rf/index columns)\n",
-    "                all_cols = [c for c in df.columns if c not in ['Date', identify_risk_free_fund(df)] + indices_list]\n",
-    "                # Call select_funds with selection_mode='all' to get the full list of valid funds.\n",
-    "                valid_funds = select_funds(\n",
-    "                    df,\n",
-    "                    identify_risk_free_fund(df),\n",
-    "                    fund_columns=all_cols,\n",
-    "                    in_sdate=in_sdate,\n",
-    "                    in_edate=in_edate,\n",
-    "                    out_sdate=out_sdate,\n",
-    "                    out_edate=out_edate,\n",
-    "                    selection_mode='all',\n",
-    "                    random_n=None\n",
-    "                )\n",
-    "\n",
-    "                if not valid_funds:\n",
-    "                    print(\"❌ No funds satisfy the full‐history & gap rules for these dates.\")\n",
-    "                    return\n",
-    "\n",
-    "                # 3b) Build a fresh table of checkboxes + IntText’s for valid_funds\n",
-    "                fund_table_rows = []\n",
-    "                fund_checkboxes = []\n",
-    "                weight_boxes    = []\n",
-    "\n",
-    "                for f in valid_funds:\n",
-    "                    cb = widgets.Checkbox(\n",
-    "                        value=False,\n",
-    "                        description=f,\n",
-    "                        layout=widgets.Layout(width='200px')\n",
-    "                    )\n",
-    "                    tb = widgets.BoundedIntText(\n",
-    "                        value=0,\n",
-    "                        min=0,\n",
-    "                        max=100,\n",
-    "                        step=1,\n",
-    "                        description=\"%\",          # user will type an integer percent\n",
-    "                        layout=widgets.Layout(width='160px')\n",
-    "                    )\n",
-    "                    tb.disabled = True  # only enabled when its checkbox is clicked\n",
-    "                    \n",
-    "                    fund_checkboxes.append(cb)\n",
-    "                    weight_boxes.append(tb)\n",
-    "\n",
-    "                    row = widgets.HBox([\n",
-    "                        cb,\n",
-    "                        weight_boxes[-1]\n",
-    "                    ], layout=widgets.Layout(margin=\"2px 0px\"))\n",
-    "                    fund_table_rows.append(row)\n",
-    "\n",
-    "                # Replace whatever was in fund_table_container with this new VBox\n",
-    "                fund_table_container.children = [widgets.VBox(fund_table_rows)]\n",
-    "                fund_table_container.layout.display = 'block'  # reveal it\n",
-    "\n",
-    "                # 3c) Wire up each checkbox so its weight box toggles on/off\n",
-    "                def _on_cb_change(change):\n",
-    "                    # ‘change.owner’ is the Checkbox that toggled\n",
-    "                    idx = fund_checkboxes.index(change.owner)\n",
-    "                    weight_boxes[idx].disabled = not change.new\n",
-    "\n",
-    "                for cb in fund_checkboxes:\n",
-    "                    cb.observe(_on_cb_change, names='value')\n",
-    "\n",
-    "            # Finally, show the random_sample_size_widget if needed\n",
-    "            if mode_val == 'random':\n",
-    "                random_sample_size_widget.layout.display = 'block'\n",
-    "\n",
-    "            print(\"▶ Now the Mode/sampling UI is visible. If Manual, pick funds + enter weights. Then click Run again.\")\n",
-    "            phase_counter[\"step\"] = 3\n",
-    "            return\n",
-    "\n",
-    "        # 4) After second click, everything (Mode + any Manual selections or random size) is set,\n",
-    "        #    so we can finally run `run_analysis(...)` for real:\n",
-    "        mode_val  = selection_mode_widget.value\n",
-    "        rnd_n_val = random_sample_size_widget.value if mode_val == 'random' else None\n",
-    "\n",
-    "        custom_weights = None\n",
-    "        if mode_val == 'manual':\n",
-    "            # Gather which checkboxes were checked, and read their weight_boxes\n",
-    "            selected = []\n",
-    "            weight_dict = {}\n",
-    "            # The fund_checkboxes + weight_boxes only exist if step>=2 and mode=='manual'.\n",
-    "            # We can grab them from fund_table_container.children.\n",
-    "            table_vbox = fund_table_container.children[0]   # the VBox we built above\n",
-    "            for row_hbox in table_vbox.children:\n",
-    "                cb, tb = row_hbox.children\n",
-    "                if cb.value:\n",
-    "                    selected.append(cb.description)\n",
-    "                    weight_dict[cb.description] = tb.value\n",
-    "\n",
-    "            total_w = sum(weight_dict.values())\n",
-    "            if not selected:\n",
-    "                print(\"⚠️ No funds checked—pick at least one fund.\")\n",
-    "                return\n",
-    "            if total_w != 100:\n",
-    "                print(f\"⚠️ Weights sum to {total_w}, but must be exactly 100. Fix and Run again.\")\n",
-    "                return\n",
-    "\n",
-    "            custom_weights = weight_dict\n",
-    "\n",
-    "        # 5) Now run the analysis for real\n",
-    "        print(\"▶ Running analysis with:\")\n",
-    "        print(f\"   In:   {in_start_str} → {in_end_str}\")\n",
-    "        print(f\"   Out:  {out_start_str} → {out_end_str}\")\n",
-    "        print(f\"   Vol:  {target_vol_val:.3%}, Cost: {monthly_cost_val:.3%}\")\n",
-    "        print(f\"   Mode: {mode_val}\" + (f\", Random N={rnd_n_val}\" if mode_val=='random' else \"\"))\n",
-    "        if mode_val == 'manual':\n",
-    "            print(f\"   Manual funds = {list(custom_weights.keys())}\")\n",
-    "            print(f\"   Weights = {custom_weights}\")\n",
-    "\n",
-    "        try:\n",
-    "            results = run_analysis(\n",
-    "                df,\n",
-    "                in_start=in_start_str,\n",
-    "                in_end=in_end_str,\n",
-    "                out_start=out_start_str,\n",
-    "                out_end=out_end_str,\n",
-    "                target_vol=target_vol_val,\n",
-    "                monthly_cost=monthly_cost_val,\n",
-    "                selection_mode=mode_val,\n",
-    "                random_n=rnd_n_val,\n",
-    "                custom_weights=custom_weights\n",
-    "            )\n",
-    "        except Exception as e:\n",
-    "            print(\"❌ Error inside run_analysis():\", e)\n",
-    "            return\n",
-    "\n",
-    "        if results is None or not results.get(\"selected_funds\"):\n",
-    "            print(\"❌ No valid funds remain after filtering.\")\n",
-    "            return\n",
-    "\n",
-    "        # 6) Print a brief summary & export to Excel\n",
-    "        sf = results[\"selected_funds\"]\n",
-    "        print(\"✅ Analysis complete:\")\n",
-    "        print(f\"   Funds selected: {len(sf)} → {sf}\")\n",
-    "        print(\"   Manual funds & weights:\")\n",
-    "        if custom_weights is not None:\n",
-    "            print(\"   Manual funds & weights:\")\n",
-    "            for f, w in custom_weights.items():\n",
-    "                print(f\"     • {f}: {w}%\")\n",
-    "        if \"in_ew_stats\" in results:\n",
-    "            ir, iv, isr, *_ = results[\"in_ew_stats\"]\n",
-    "            print(f\"   In‐Sample EW → R {ir*100:.2f}%, V {iv*100:.2f}%, S {isr:.2f}\")\n",
-    "        if \"out_ew_stats\" in results:\n",
-    "            or_, ov, osr, *_ = results[\"out_ew_stats\"]\n",
-    "            print(f\"   Out‐Sample EW → R {or_*100:.2f}%, V {ov*100:.2f}%, S {osr:.2f}\")\n",
-    "\n",
-    "        print(\">> about to write Excel with custom_weights =\", custom_weights)\n",
-    "\n",
-    "        # Add the filename\n",
-    "        global fname\n",
-    "        fname = f\"IS_{in_start_str}_{out_start_str}.xlsx\"\n",
-    "    \n",
-    "        export_to_excel(\n",
-    "            results,\n",
-    "            df,            # your full DataFrame\n",
-    "            fname,         \n",
-    "            in_start_str,  \n",
-    "            in_end_str,    \n",
-    "            out_start_str, \n",
-    "            out_end_str    \n",
-    "        )\n",
-    "        print(f\"   Excel file created: IS_{in_start_str}_{out_start_str}.xlsx\")\n",
-    "        import inspect\n",
-    "        print(inspect.getsource(export_to_excel))\n",
-    "\n",
-    "\n",
-    "run_button.on_click(on_run_clicked)\n",
-    "\n",
-    "# ─── Finally, show everything (Phase 1 + Phase 2 placeholders + output area) ───\n",
-    "\n",
-    "master_vbox = widgets.VBox([\n",
-    "    main_inputs,\n",
-    "    selection_mode_widget,\n",
-    "    random_sample_size_widget,\n",
-    "    fund_table_container\n",
-    "])\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "## 5. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 19,
-   "id": "c5867ccd-a550-4849-a10b-a085f5fe26fd",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "select_funds (replaced) is ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def select_funds(\n",
-    "    df,                 # full DataFrame with datetime64 ‘Date’\n",
-    "    rf_col,             # name of risk‐free column\n",
-    "    fund_columns,       # list of candidate funds (should be your 27)\n",
-    "    in_sdate, in_edate, # pd.Timestamps for in‐sample window\n",
-    "    out_sdate, out_edate,# pd.Timestamps for out‐sample window\n",
-    "    selection_mode='all',\n",
-    "    random_n=8\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Start from fund_columns.  \n",
-    "    2) Filter out any that contain 'index' in name.  \n",
-    "    3) Keep only those with no NaN anywhere in both windows.  \n",
-    "    4) Keep only those with < 3 consecutive NaNs in each window.  \n",
-    "    5) Return based on selection_mode.\n",
-    "    \"\"\"\n",
-    "    # Step 1: base list\n",
-    "    candidates = fund_columns.copy()\n",
-    "    print(f\"DEBUG [select_funds]: initial candidates (n={len(candidates)}): {candidates}\")\n",
-    "\n",
-    "    # Step 2: drop any with “index” in name (case‐insensitive)\n",
-    "    no_index = [f for f in candidates if 'index' not in f.lower()]\n",
-    "    print(f\"DEBUG [select_funds]: after dropping 'index' (n={len(no_index)}): {no_index}\")\n",
-    "\n",
-    "    # Step 3: full‐history check (no NaN at all in each window)\n",
-    "    full_hist = []\n",
-    "    for f in no_index:\n",
-    "        in_sub  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)][f]\n",
-    "        out_sub = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        if in_sub.notna().all() and out_sub.notna().all():\n",
-    "            full_hist.append(f)\n",
-    "    print(f\"DEBUG [select_funds]: after full‐history check (n={len(full_hist)}): {full_hist}\")\n",
-    "\n",
-    "    # Step 4: no 3‐consecutive‐NaNs check\n",
-    "    after_run_check = []\n",
-    "    for f in full_hist:\n",
-    "        # In‐sample gap runs\n",
-    "        sub_in   = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "        isnan_in = sub_in.isna().astype(int)\n",
-    "        run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "        max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "\n",
-    "        # Out‐sample gap runs\n",
-    "        sub_out   = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        isnan_out = sub_out.isna().astype(int)\n",
-    "        run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "        max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "\n",
-    "        # Keep only if both max runs < 3\n",
-    "        if max_run_in < 3 and max_run_out < 3:\n",
-    "            after_run_check.append(f)\n",
-    "\n",
-    "    print(f\"DEBUG [select_funds]: after run‐length check (n={len(after_run_check)}): {after_run_check}\")\n",
-    "\n",
-    "    # Step 5: selection_mode\n",
-    "    if selection_mode == 'all':\n",
-    "        return after_run_check\n",
-    "\n",
-    "    if selection_mode == 'random':\n",
-    "        if len(after_run_check) <= random_n:\n",
-    "            warnings.warn(\n",
-    "                f\"Fewer valid funds ({len(after_run_check)}) than sample size ({random_n}). Returning all.\"\n",
-    "            )\n",
-    "            return after_run_check\n",
-    "        return random.sample(after_run_check, random_n)\n",
-    "\n",
-    "    # Manual fund selection\n",
-    "    \n",
-    "    return after_run_check\n",
-    "\n",
-    "print(\"select_funds (replaced) is ready.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 6. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 20,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "get_custom_weights function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    Returns dict {fund: weight_decimal}.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=f\"{fund}\",\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    \n",
-    "    confirm_button = widgets.Button(\n",
-    "        description='Confirm Weights',\n",
-    "        button_style='success'\n",
-    "    )\n",
-    "    error_label = widgets.Label(value='', layout=widgets.Layout(color='red'))\n",
-    "    \n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm_button, error_label])\n",
-    "    display(box)\n",
-    "    \n",
-    "    weights_container = {}\n",
-    "    \n",
-    "    def on_confirm_clicked(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_label.value = f\"Error: Weights sum to {total}, must be 100.\"\n",
-    "            weights_container.clear()\n",
-    "        else:\n",
-    "            for fund, wdg in weight_widgets.items():\n",
-    "                weights_container[fund] = wdg.value / 100.0\n",
-    "            error_label.value = \"Weights confirmed!\"\n",
-    "    \n",
-    "    confirm_button.on_click(on_confirm_clicked)\n",
-    "    return weights_container\n",
-    "\n",
-    "print(\"get_custom_weights function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 7. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 21,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "run_analysis (with checkpoints) is defined.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def run_analysis(\n",
-    "    df,\n",
-    "    in_start, in_end, out_start, out_end,\n",
-    "    target_vol, monthly_cost,\n",
-    "    selection_mode='all',\n",
-    "    random_n=8,\n",
-    "    custom_weights=None    # ← new argument\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Parse/validate date inputs\n",
-    "    2) Convert Date column if needed\n",
-    "    3) Identify rf_col\n",
-    "    4) Prepare in/out sample DataFrames\n",
-    "    5) CALL select_funds (with debug) and print checkpoints\n",
-    "    6) Compute scale_factors and wrap stats in try/except\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # —(1) Parse input dates (YYYY-MM) into actual month-end timestamps\n",
-    "    in_sdate  = pd.to_datetime(in_start + \"-01\", errors='coerce')\n",
-    "    in_edate  = pd.to_datetime(in_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "    out_sdate = pd.to_datetime(out_start + \"-01\", errors='coerce')\n",
-    "    out_edate = pd.to_datetime(out_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    # checkpoint A\n",
-    "    print(\"CHECKPOINT A: Dates parsed:\", in_sdate, in_edate, out_sdate, out_edate)\n",
-    "\n",
-    "    # —(2) Ensure 'Date' column is datetime64\n",
-    "    if not np.issubdtype(df['Date'].dtype, np.datetime64):\n",
-    "        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "        df.dropna(subset=['Date'], inplace=True)\n",
-    "        df.sort_values(by='Date', inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "    # checkpoint B\n",
-    "    print(\"CHECKPOINT B: Date column is datetime64, first dates:\",\n",
-    "          df['Date'].iloc[0], \"…\", df['Date'].iloc[-1])\n",
-    "\n",
-    "    # —(3) Identify risk-free column\n",
-    "    rf_col = identify_risk_free_fund(df)\n",
-    "    print(f\"INFO: Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "\n",
-    "    # —(4) Slice into in-sample & out-sample\n",
-    "    in_sample_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_sample_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "    in_sample_rf  = in_sample_df[rf_col]\n",
-    "    out_sample_rf = out_sample_df[rf_col]\n",
-    "\n",
-    "    print(f\"CHECKPOINT C: in_sample rows = {len(in_sample_df)}, out_sample rows = {len(out_sample_df)}\")\n",
-    "\n",
-    "    # —(5) Select funds (either “manual” or via select_funds)\n",
-    "    if selection_mode == 'manual' and custom_weights is not None:\n",
-    "        # In manual mode, we trust the user’s chosen tickers outright\n",
-    "        selected_funds = list(custom_weights.keys())\n",
-    "        print(f\"CHECKPOINT D (manual): using custom_weights keys → {selected_funds}\")\n",
-    "    else:\n",
-    "        all_fund_cols = fund_cols.copy()\n",
-    "        print(f\"CHECKPOINT D: about to call select_funds with {len(all_fund_cols)} candidates\")\n",
-    "\n",
-    "        selected_funds = select_funds(\n",
-    "            df,\n",
-    "            rf_col,\n",
-    "            fund_columns=all_fund_cols,\n",
-    "            in_sdate=in_sdate,\n",
-    "            in_edate=in_edate,\n",
-    "            out_sdate=out_sdate,\n",
-    "            out_edate=out_edate,\n",
-    "            selection_mode=selection_mode,\n",
-    "            random_n=random_n\n",
-    "        )\n",
-    "\n",
-    "    if len(selected_funds) == 0:\n",
-    "        logging.warning(\"No valid funds remain after filtering.\")\n",
-    "        print(\"Warning: No valid funds. Try adjusting your selection or data filters.\")\n",
-    "        return None\n",
-    "\n",
-    "    print(f\"CHECKPOINT E: select_funds returned {len(selected_funds)} funds → {selected_funds}\")\n",
-    "\n",
-    "    # indices_list must already exist as a global list of index columns\n",
-    "    in_sample_indices  = in_sample_df[indices_list].copy()\n",
-    "    out_sample_indices = out_sample_df[indices_list].copy()\n",
-    "\n",
-    "    # —(6) Compute scale_factors (based on in-sample volatility)\n",
-    "    scale_factors = {}\n",
-    "    for fund in selected_funds:\n",
-    "        fund_in_rets = in_sample_df[fund].dropna()\n",
-    "        current_vol  = annualize_volatility(fund_in_rets)\n",
-    "        if pd.isna(current_vol) or current_vol == 0:\n",
-    "            scale_factors[fund] = 1.0\n",
-    "        else:\n",
-    "            scale_factors[fund] = target_vol / current_vol\n",
-    "\n",
-    "    print(\"CHECKPOINT F: scale_factors computed (showing first 5):\",\n",
-    "          {f: scale_factors[f] for f in selected_funds[:5]})\n",
-    "\n",
-    "    # Pre-allocate DataFrames for scaled returns\n",
-    "    in_sample_scaled  = pd.DataFrame(index=in_sample_df.index, columns=selected_funds)\n",
-    "    out_sample_scaled = pd.DataFrame(index=out_sample_df.index, columns=selected_funds)\n",
-    "\n",
-    "    # ── Wrap everything from “scaling + stats” in a try/except ──\n",
-    "    try:\n",
-    "        # (6a) Scale returns (with monthly cost)\n",
-    "        for fund in selected_funds:\n",
-    "            sf     = scale_factors[fund]\n",
-    "            adj_in = in_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_in[adj_in < -1.0] = -1.0\n",
-    "            in_sample_scaled[fund] = adj_in\n",
-    "\n",
-    "            if not out_sample_df.empty:\n",
-    "                adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "                adj_out[adj_out < -1.0] = -1.0\n",
-    "                out_sample_scaled[fund] = adj_out\n",
-    "\n",
-    "        # (6b) Helper to compute per-series stats\n",
-    "        def compute_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            sr  = sharpe_ratio(series, rf_series)\n",
-    "            so  = sortino_ratio(series, rf_series)\n",
-    "            mdd = max_drawdown(series)\n",
-    "            return (r, v, sr, so, mdd)\n",
-    "\n",
-    "        # (6c) In-sample per-fund stats\n",
-    "        in_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "\n",
-    "        # (6d) Out-sample per-fund (vol-adjusted) stats\n",
-    "        out_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6e) Out-sample per-fund (raw) stats\n",
-    "        out_sample_stats_raw = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6f) Equal-weight portfolio returns\n",
-    "        ew_weight_dict = { f: 1.0/len(selected_funds) for f in selected_funds }\n",
-    "        ew_w           = np.array([ ew_weight_dict[f] for f in selected_funds ])\n",
-    "        in_ew_port      = calc_portfolio_returns(ew_w,       in_sample_scaled[selected_funds])\n",
-    "        out_ew_port     = calc_portfolio_returns(ew_w,       out_sample_scaled[selected_funds])\n",
-    "        out_ew_port_raw = calc_portfolio_returns(ew_w,       out_sample_df[selected_funds])\n",
-    "        \n",
-    "        in_ew_stats      = compute_stats(in_ew_port,      in_sample_rf)\n",
-    "        out_ew_stats     = compute_stats(out_ew_port,     out_sample_rf)\n",
-    "        out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6g) Index statistics (treat each index like “just another series”)\n",
-    "        in_index_stats  = {}\n",
-    "        out_index_stats = {}\n",
-    "        for idx in indices_list:\n",
-    "            in_index_stats[idx]  = compute_stats(in_sample_indices[idx],  in_sample_df[rf_col])\n",
-    "            out_index_stats[idx] = compute_stats(out_sample_indices[idx], out_sample_df[rf_col])\n",
-    "\n",
-    "        # (6h) “User-weight” portfolio\n",
-    "        if custom_weights is None:\n",
-    "            # If no manual weights → just reuse the same equal‐weight array\n",
-    "            user_weight_dict = ew_weight_dict.copy()\n",
-    "            # ← **IMPORTANT FIX**: define custom_w here for the equal-weight case\n",
-    "            custom_w = ew_w.copy()  \n",
-    "        else:\n",
-    "            # Manual weights passed → convert percentages to decimals\n",
-    "            user_weight_dict = { f: custom_weights[f] / 100.0 for f in selected_funds }\n",
-    "            custom_w         = np.array([ user_weight_dict[f] for f in selected_funds ])\n",
-    "\n",
-    "        # (6i) Compute “user-weighted” portfolio returns\n",
-    "        in_user_port      = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "        out_user_port     = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "        out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        # (6j) Compute their stats\n",
-    "        in_user_stats      = compute_stats(in_user_port,      in_sample_rf)\n",
-    "        out_user_stats     = compute_stats(out_user_port,     out_sample_rf)\n",
-    "        out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6k) Build the final results dict **(FIXED: removed duplicate 'fund_weights')**\n",
-    "        results = {\n",
-    "            'selected_funds':       selected_funds,\n",
-    "            'in_sample_scaled':     in_sample_scaled,\n",
-    "            'out_sample_scaled':    out_sample_scaled,\n",
-    "            'in_sample_stats':      in_sample_stats,\n",
-    "            'out_sample_stats':     out_sample_stats,\n",
-    "            'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "            'in_ew_stats':          in_ew_stats,\n",
-    "            'out_ew_stats':         out_ew_stats,\n",
-    "            'out_ew_stats_raw':     out_ew_stats_raw,\n",
-    "            'in_user_stats':        in_user_stats,\n",
-    "            'out_user_stats':       out_user_stats,\n",
-    "            'out_user_stats_raw':   out_user_stats_raw,\n",
-    "            'ew_weights':           ew_weight_dict,     # ← now returns equal-weight dict\n",
-    "            'fund_weights':         user_weight_dict,   # ← returns manual weights (or equal if none)\n",
-    "            'indices_list':         indices_list\n",
-    "        }\n",
-    "\n",
-    "    except Exception as e:\n",
-    "        print(\"ERROR inside stats-block:\", e)\n",
-    "        return None\n",
-    "\n",
-    "    # Everything succeeded\n",
-    "    return results\n",
-    "\n",
-    "\n",
-    "\n",
-    "print(\"run_analysis (with checkpoints) is defined.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 8. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 22,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─── Helper #1: build the equal- and user-weight DataFrames ────────────────────────────────\n",
-    "def make_portfolio_dfs(results, sample='in'):\n",
-    "    \"\"\"\n",
-    "    Returns (eq_df, user_df) for either 'in' or 'out' sample.\n",
-    "    \"\"\"\n",
-    "    # pick the right stats:\n",
-    "    stats_dict      = results[f'{sample}_sample_stats']\n",
-    "    ew_stats        = results[f'{sample}_ew_stats']\n",
-    "    user_stats      = results[f'{sample}_user_stats']\n",
-    "    fund_weights    = results['fund_weights']\n",
-    "    funds           = results['selected_funds']\n",
-    "\n",
-    "    def build_block(portf_label, stats, include_weights):\n",
-    "        rows = []\n",
-    "        # portfolio row\n",
-    "        r, v, sr, so, mdd = stats\n",
-    "        rows.append({\n",
-    "            'Fund': portf_label,\n",
-    "            'Weight': 100,\n",
-    "            'Return (%)': r,\n",
-    "            'Volatility (%)': v,\n",
-    "            'Sharpe Ratio': sr,\n",
-    "            'Sortino Ratio': so,\n",
-    "            'Max Drawdown (%)': mdd\n",
-    "        })\n",
-    "        # one‐row per fund\n",
-    "        for f in funds:\n",
-    "            r, v, sr, so, mdd = stats_dict[f]\n",
-    "            w = int(round(fund_weights[f] * 100)) if include_weights else None\n",
-    "            rows.append({\n",
-    "                'Fund': f,\n",
-    "                'Weight': w,\n",
-    "                'Return (%)': r,\n",
-    "                'Volatility (%)': v,\n",
-    "                'Sharpe Ratio': sr,\n",
-    "                'Sortino Ratio': so,\n",
-    "                'Max Drawdown (%)': mdd\n",
-    "            })\n",
-    "        return pd.DataFrame(rows)\n",
-    "\n",
-    "    eq_df   = build_block('Equal-Weight Portfolio', ew_stats,   True)\n",
-    "    user_df = build_block('User-Weight Portfolio', user_stats, True)\n",
-    "    return eq_df, user_df\n",
-    "\n",
-    "\n",
-    "# ─── Helper #2: build an indices table ─────────────────────────────────────────────────────\n",
-    "def make_indices_df(df, indices, start, end):\n",
-    "    \"\"\"\n",
-    "    Compute (Return, Vol, Sharpe, Sortino, MDD) for each index in [start, end],\n",
-    "    return a DataFrame with columns Index, Return (%), Volatility (%), …\n",
-    "    \"\"\"\n",
-    "    in_s, in_e = pd.to_datetime(start+'-01'), pd.to_datetime(end+'-01') + pd.offsets.MonthEnd(0)\n",
-    "    rows = []\n",
-    "    rf = identify_risk_free_fund(df)\n",
-    "    sub = df.set_index('Date').loc[in_s:in_e]\n",
-    "    for idx in indices:\n",
-    "        series = sub[idx]\n",
-    "        rf_ser = sub[rf]\n",
-    "        r  = annualize_return(series)\n",
-    "        v  = annualize_volatility(series)\n",
-    "        sr = sharpe_ratio(series, rf_ser)\n",
-    "        so = sortino_ratio(series, rf_ser)\n",
-    "        mdd = max_drawdown(series)\n",
-    "        rows.append({\n",
-    "            'Index': idx,\n",
-    "            'Return (%)': r,\n",
-    "            'Volatility (%)': v,\n",
-    "            'Sharpe Ratio': sr,\n",
-    "            'Sortino Ratio': so,\n",
-    "            'Max Drawdown (%)': mdd\n",
-    "        })\n",
-    "    return pd.DataFrame(rows)\n",
-    "\n",
-    "\n",
-    "# ─── Helper #3: write & format one sheet ──────────────────────────────────────────────────\n",
-    "# Apply uniform column widths & formats\n",
-    "    #   (col_idx, width, format_obj)\n",
-    "COLUMN_SPECS = [\n",
-    "    (0, 28, None),\n",
-    "    (1, 12, 'int'),\n",
-    "    (2, 15, 'pct1'),\n",
-    "    (3, 15, 'pct1'),\n",
-    "    (4, 15, 'dec2'),\n",
-    "    (5, 15, 'dec2'),\n",
-    "    (6, 15, 'pct1'),\n",
-    "]\n",
-    "\n",
-    "def build_formats(wb):\n",
-    "    return {\n",
-    "      'int':   wb.add_format({'num_format':'0'}),\n",
-    "      'pct1':  wb.add_format({'num_format':'0.0%'}),\n",
-    "      'dec2':  wb.add_format({'num_format':'0.00'}),\n",
-    "      'bold':  wb.add_format({'bold':True}),\n",
-    "    }\n",
-    "    \n",
-    "def write_portfolio_sheet(writer, sheet_name, eq_df, user_df, fmt):\n",
-    "    # Create & register the sheet\n",
-    "    ws = writer.book.add_worksheet(sheet_name)\n",
-    "    writer.sheets[sheet_name] = ws\n",
-    "\n",
-    "    # 1) Write the two tables with keyword-only args\n",
-    "    eq_df.to_excel(excel_writer=writer,\n",
-    "                   sheet_name=sheet_name,\n",
-    "                   startrow=0,\n",
-    "                   index=False)\n",
-    "    user_df.to_excel(excel_writer=writer,\n",
-    "                     sheet_name=sheet_name,\n",
-    "                     startrow=len(eq_df) + 3,\n",
-    "                     index=False)\n",
-    "\n",
-    "    for col_idx, width, fmt_key in COLUMN_SPECS:\n",
-    "        # if fmt_key is None, use no format; otherwise pull from fmt\n",
-    "        fmt_obj = fmt[fmt_key] if fmt_key else None\n",
-    "        ws.set_column(col_idx, col_idx, width, fmt_obj)\n",
-    "\n",
-    "    # Bold the headers\n",
-    "    bold = fmt['bold']\n",
-    "    for j, h in enumerate(eq_df.columns):\n",
-    "        ws.write(0, j, h, fmt['bold'])\n",
-    "    start = len(eq_df) + 3\n",
-    "    for j, h in enumerate(user_df.columns):\n",
-    "        ws.write(start, j, h, fmt['bold'])\n",
-    "\n",
-    "\n",
-    "def write_indices_block(writer, sheet_name, df_idx, start_row, fmt):\n",
-    "    ws   = writer.sheets[sheet_name]\n",
-    "    bold = fmt['bold']\n",
-    "\n",
-    "    # Title above the indices table\n",
-    "    ws.write(start_row - 1, 0, f\"Indices ({sheet_name}):\", bold)\n",
-    "\n",
-    "    # Insert a blank Weight column so alignment matches portfolio sheets\n",
-    "    df_idx.insert(1, 'Weight', [''] * len(df_idx))\n",
-    "\n",
-    "    # Write the DataFrame\n",
-    "    df_idx.to_excel(\n",
-    "        excel_writer=writer,\n",
-    "        sheet_name=sheet_name,\n",
-    "        startrow=start_row,\n",
-    "        index=False\n",
-    "    )\n",
-    "\n",
-    "    # Apply the shared COLUMN_SPECS (not a local col_specs)\n",
-    "    for col_idx, width, fmt_key in COLUMN_SPECS:\n",
-    "        fmt_obj = fmt[fmt_key] if fmt_key else None\n",
-    "        ws.set_column(col_idx, col_idx, width, fmt_obj)\n",
-    "\n",
-    "    # Bold the header row of the indices table\n",
-    "    for j, header in enumerate(df_idx.columns):\n",
-    "        ws.write(start_row, j, header, bold)\n",
-    "\n",
-    "def export_to_excel(results, df, output_filename,\n",
-    "                    in_start, in_end, out_start, out_end):\n",
-    "    writer  = pd.ExcelWriter(output_filename, engine='xlsxwriter')\n",
-    "    wb     = writer.book\n",
-    "    formats = build_formats(wb)\n",
-    "\n",
-    "    # 1) portfolio sheets\n",
-    "    in_eq,  in_user  = make_portfolio_dfs(results, sample='in')\n",
-    "    out_eq, out_user = make_portfolio_dfs(results, sample='out')\n",
-    "  \n",
-    "    # 2) indices sheets\n",
-    "    idx_in  = make_indices_df(df, results['indices_list'], in_start,  in_end)\n",
-    "    idx_out = make_indices_df(df, results['indices_list'], out_start, out_end)\n",
-    "    # compute where to start: right after user_df\n",
-    "    start_in  = len(in_eq)  + len(in_user)  + 6\n",
-    "    start_out = len(out_eq) + len(out_user) + 6\n",
-    "\n",
-    "    write_portfolio_sheet(writer, f\"IS {in_start}-{in_end}\", in_eq,  in_user,  formats)\n",
-    "    write_portfolio_sheet(writer, f\"OS {out_start}-{out_end}\", out_eq, out_user, formats)\n",
-    "    write_indices_block(writer, f\"IS {in_start}-{in_end}\", idx_in,  start_in,  formats)\n",
-    "    write_indices_block(writer, f\"OS {out_start}-{out_end}\", idx_out, start_out, formats)\n",
-    "\n",
-    "    writer.close()\n",
-    "\n",
-    "    logging.info(f\"Exported analysis to {output_filename} successfully.\")\n",
-    "    print(f\"Excel file created: {output_filename}\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Run Parameters"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 23,
-   "id": "9899f2e3-9c6e-4c38-b3eb-d07e8f871462",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "9e53a4b7abd14282a80c83593b3bbae7",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(VBox(children=(Text(value='2005-07', description='In-Sample Start:'), Text(value='2008-06', des…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "e1d638de00e4400ebe580978d5777460",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Output(layout=Layout(border_bottom='1px solid gray', border_left='1px solid gray', border_right='1px solid gra…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "display(master_vbox, output_area)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup3-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup3-checkpoint.ipynb
deleted file mode 100644
index 2dafc41875dc7e82514c17e0e46a1eee745172e1..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup3-checkpoint.ipynb
+++ /dev/null
@@ -1,1691 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 1. SETUP CELL ============\n",
-    "\n",
-    "import logging\n",
-    "import sys\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import os\n",
-    "import math\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import interact, interactive, VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from IPython.utils.capture import capture_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import datetime\n",
-    "import random\n",
-    "import warnings\n",
-    "\n",
-    "# If you need to install these packages on your environment, uncomment:\n",
-    "!{sys.executable} -m pip install --quiet ipywidgets openpyxl xlsxwriter\n",
-    "\n",
-    "# For exporting to Excel with styling\n",
-    "import xlsxwriter\n",
-    "\n",
-    "# Set up logging to console\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "logging.info(\"Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\")\n",
-    "\n",
-    "# (Optional) If widgets aren't enabled, run:\n",
-    "# !jupyter nbextension enable --py widgetsnbextension --sys-prefix\n",
-    "\n",
-    "print(\"Setup complete.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify which column (after 'Date') is the risk-free rate by smallest stdev among columns.\n",
-    "    \"\"\"\n",
-    "    numeric_cols = df.columns[1:]  # skip the Date column\n",
-    "    stdevs = {}\n",
-    "    for col in numeric_cols:\n",
-    "        vals = df[col].dropna()\n",
-    "        if len(vals) > 0:\n",
-    "            stdevs[col] = vals.std()\n",
-    "        else:\n",
-    "            stdevs[col] = np.inf\n",
-    "\n",
-    "    rf_col = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "    return rf_col\n",
-    "\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 1) Helper to read a local CSV robustly (handles BOMs and minor parsing issues)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Try loading `path` as CSV in three ways:\n",
-    "    1. Default C engine\n",
-    "    2. BOM-stripped with the Python engine\n",
-    "    3. Skip bad lines with the Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception as e1:\n",
-    "        print(\"Default read_csv failed:\", e1)\n",
-    "\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception as e2:\n",
-    "        print(\"utf-8-sig + python engine failed:\", e2)\n",
-    "\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",    # for pandas ≥ 1.3\n",
-    "    )\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 2) Build the widgets\n",
-    "# ------------------------------------------------------------------------------\n",
-    "source_info = widgets.HTML(\n",
-    "    \"<b>Step 1: Choose your CSV</b><br>\"\n",
-    "    \"<i>Remember:</i> If you included any index columns (e.g. S&P 500, MSCI World, SG Trend), they \"\n",
-    "    \"must appear to the right of all fund columns in your sheet.\"\n",
-    ")\n",
-    "\n",
-    "\n",
-    "source_dropdown = widgets.Dropdown(\n",
-    "    options=['Local', 'GitHub'],\n",
-    "    value='Local',\n",
-    "    description='Data Source:',\n",
-    "    style={'description_width': '120px'}\n",
-    ")\n",
-    "\n",
-    "# FileChooser for Local mode\n",
-    "fc = FileChooser(os.getcwd())\n",
-    "fc.title = \"<b>Select local CSV file</b>\"\n",
-    "\n",
-    "# Text box for GitHub raw URL\n",
-    "github_text = widgets.Text(\n",
-    "    value=(\n",
-    "        \"https://raw.githubusercontent.com/stranske/Trend_Model_Project/\"\n",
-    "        \"main/data/TrendData.csv\"\n",
-    "    ),\n",
-    "    description=\"GitHub URL:\",\n",
-    "    layout=widgets.Layout(width=\"80%\"),\n",
-    ")\n",
-    "\n",
-    "# Ask how many index columns are on the far right\n",
-    "n_indices_widget = widgets.BoundedIntText(\n",
-    "    value=0,\n",
-    "    min=0,\n",
-    "    max=10,  # adjust if you expect more than 10 indices\n",
-    "    description='# Index cols:',\n",
-    "    style={'description_width': '120px'},\n",
-    "    tooltip=\"Enter the number of index columns at the far right of your CSV\"\n",
-    ")\n",
-    "\n",
-    "# Load button\n",
-    "load_button = widgets.Button(description=\"Load Data\", button_style=\"success\")\n",
-    "\n",
-    "# Output area for status and debug prints\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 3) Show/hide widgets depending on source selection\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_source_change(change):\n",
-    "    if change[\"new\"] == \"Local\":\n",
-    "        fc.layout.display = \"block\"\n",
-    "        github_text.layout.display = \"none\"\n",
-    "    else:\n",
-    "        fc.layout.display = \"none\"\n",
-    "        github_text.layout.display = \"block\"\n",
-    "\n",
-    "# Initially, GitHub textbox is hidden; FileChooser is visible\n",
-    "github_text.layout.display = \"none\"\n",
-    "fc.layout.display = \"block\"\n",
-    "\n",
-    "source_dropdown.observe(on_source_change, names=\"value\")\n",
-    "\n",
-    "ui_load = widgets.VBox([\n",
-    "    source_info,\n",
-    "    source_dropdown,\n",
-    "    fc,\n",
-    "    github_text,\n",
-    "    n_indices_widget,   # ← new widget here\n",
-    "    load_button,\n",
-    "    output_area\n",
-    "])\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 4) Callback for the Load button (auto-detect date format)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_load_clicked(_):\n",
-    "    global df, fund_cols, indices_list, rf_col            # declare df as global\n",
-    "    with output_area:\n",
-    "        output_area.clear_output()\n",
-    "        src_choice = source_dropdown.value\n",
-    "        n_indices = int(n_indices_widget.value)\n",
-    "\n",
-    "        # 4a) Load the DataFrame\n",
-    "        try:\n",
-    "            if src_choice == 'Local':\n",
-    "                local_path = fc.selected  # FileChooser’s selected path\n",
-    "                if not local_path or not os.path.exists(local_path):\n",
-    "                    print(f\"Error: Local file not found:\\n  {local_path}\")\n",
-    "                    return\n",
-    "                print(f\"Loading from local file:\\n  {local_path}\")\n",
-    "                df = pd.read_csv(local_path)\n",
-    "            else:\n",
-    "                github_url = github_text.value.strip()\n",
-    "                if not github_url:\n",
-    "                    print(\"Error: Please enter a valid GitHub raw URL.\")\n",
-    "                    return\n",
-    "                print(f\"Loading from GitHub URL:\\n  {github_url}\")\n",
-    "                df = pd.read_csv(github_url)\n",
-    "        except Exception as e:\n",
-    "            print(\"Failed to load CSV:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4b) Debug: print columns & a few rows\n",
-    "        print(\"Columns found in DataFrame:\", df.columns.tolist())\n",
-    "        display(df.head(3))\n",
-    "\n",
-    "        # 4c) Identify which column is the date\n",
-    "        date_col = None\n",
-    "        for candidate in [\"Date\", \"DATE\", \"date\"]:\n",
-    "            if candidate in df.columns:\n",
-    "                date_col = candidate\n",
-    "                break\n",
-    "\n",
-    "        if date_col is None:\n",
-    "            print(\"Error: No column named 'Date' / 'DATE' / 'date' found.\")\n",
-    "            print(\"Please check the column names above and adjust code accordingly.\")\n",
-    "            return\n",
-    "\n",
-    "        date_col = 'Date'\n",
-    "\n",
-    "        # 1) Show the first few raw date strings (un‐parsed) so we can inspect them\n",
-    "        raw_samples = df[date_col].dropna().astype(str).head(10).tolist()\n",
-    "        print(f\"Raw {date_col} samples (first 10 non‐null): {raw_samples!r}\")\n",
-    "\n",
-    "        # 2) Strip leading/trailing whitespace from every entry\n",
-    "        df[date_col] = df[date_col].astype(str).str.strip()\n",
-    "\n",
-    "        # 3) Now attempt strict \"%m/%d/%Y\" parsing\n",
-    "        parsed = pd.to_datetime(df[date_col], format=\"%m/%d/%Y\", errors=\"coerce\", infer_datetime_format=True)\n",
-    "        num_valid = parsed.notna().sum()\n",
-    "        print(f\"Number of rows matching '%m/%d/%Y' exactly: {num_valid} / {len(df)}\")\n",
-    "\n",
-    "        if num_valid > 0:\n",
-    "            df[date_col] = parsed\n",
-    "            print(f\"Parsing with '%m/%d/%Y' succeeded for {num_valid} rows.\")\n",
-    "        else:\n",
-    "            print(\n",
-    "                \"Warning: No rows matched '%m/%d/%Y'. \"\n",
-    "                \"Falling back to generic pd.to_datetime(...).\"\n",
-    "            )\n",
-    "            df[date_col] = pd.to_datetime(df[date_col], errors=\"coerce\")\n",
-    "\n",
-    "        # 5) Drop any rows where parsing still failed\n",
-    "        before_drop = len(df)\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        dropped = before_drop - len(df)\n",
-    "        if dropped:\n",
-    "            print(f\"Dropped {dropped} rows where '{date_col}' could not be parsed.\")\n",
-    "        \n",
-    "        # 6) Sort and reset index\n",
-    "        df.sort_values(by=date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "        \n",
-    "        # 7) Show the final parsed dates\n",
-    "        print(f\"After parsing, first 3 {date_col} values:\")\n",
-    "        print(df[[date_col]].head(3))\n",
-    "        print(f\"Loaded {len(df)} rows successfully.\")\n",
-    "\n",
-    "\n",
-    "        # 4d) Identify risk-free column\n",
-    "        try:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            print(f\"Identified risk-free column as: '{rf_col}'\")\n",
-    "        except Exception as e:\n",
-    "            print(\"Error identifying risk-free column:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4f) Determine fund_cols vs indices_list based on n_indices\n",
-    "        all_cols = df.columns.tolist()\n",
-    "        # We assume “Date” and rf_col are present. Everything else is a candidate.\n",
-    "        if 'Date' not in all_cols or rf_col not in all_cols:\n",
-    "            print(\"Error: 'Date' or risk-free column not found in DataFrame columns.\")\n",
-    "            return\n",
-    "        \n",
-    "        # Build list of all columns except 'Date' and rf_col\n",
-    "        remaining = [c for c in all_cols if c not in ['Date', rf_col]]\n",
-    "        \n",
-    "        if n_indices > len(remaining):\n",
-    "            print(\n",
-    "                f\"Error: You asked for {n_indices} index columns, but only \"\n",
-    "                f\"{len(remaining)} columns remain after 'Date' and '{rf_col}'.\"\n",
-    "            )\n",
-    "            return\n",
-    "\n",
-    "        if n_indices > 0:\n",
-    "            indices_list = remaining[-n_indices:]\n",
-    "            fund_cols    = remaining[:-n_indices]\n",
-    "        else:\n",
-    "            indices_list = []\n",
-    "            fund_cols    = remaining[:]\n",
-    "        print(\"\\n>> Debug (post‐load): fund_cols =\", fund_cols)\n",
-    "        print(\">> Debug (post‐load): indices_list =\", indices_list, \"\\n\")\n",
-    "        \n",
-    "        # 2F) Print out what we found\n",
-    "        print(f\"Detected fund columns ({len(fund_cols)}): {fund_cols}\")\n",
-    "        print(f\"Detected index columns ({len(indices_list)}): {indices_list}\")\n",
-    "        print(\n",
-    "            \"Data loaded and classified successfully.\\n\"\n",
-    "            \"Proceed to Step 2 (Run Analysis).\"\n",
-    "        )\n",
-    "\n",
-    " \n",
-    "        # 8) Confirm that df is now in global scope\n",
-    "        print(\">> df defined with\", len(df), \"rows and columns:\", df.columns.tolist())\n",
-    "\n",
-    "# 5) Wire up and display the UI\n",
-    "\n",
-    "load_button.on_click(on_load_clicked)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Utility functions loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Check if a series (sorted chronologically) has >= threshold consecutive NaNs.\n",
-    "    Return True if such a gap exists, False otherwise.\n",
-    "    \"\"\"\n",
-    "    consecutive = 0\n",
-    "    for val in series:\n",
-    "        if pd.isna(val):\n",
-    "            consecutive += 1\n",
-    "        else:\n",
-    "            consecutive = 0\n",
-    "        if consecutive >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "\n",
-    "def annualize_return(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized (geometric) return from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    growth_factor = (1 + valid_rets).prod()\n",
-    "    n_months = len(valid_rets)\n",
-    "    if growth_factor <= 0:\n",
-    "        return -1.0\n",
-    "    ann_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    return ann_ret\n",
-    "\n",
-    "def annualize_volatility(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized stdev of monthly returns, i.e. stdev * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) < 2:\n",
-    "        return np.nan\n",
-    "    return valid_rets.std() * np.sqrt(12)\n",
-    "\n",
-    "def sharpe_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe ratio = (annual_excess_return) / (annual_excess_vol).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    ann_excess_vol = excess.std() * np.sqrt(12)\n",
-    "    if ann_excess_vol == 0:\n",
-    "        return np.nan\n",
-    "    return ann_excess_ret / ann_excess_vol\n",
-    "\n",
-    "def sortino_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino ratio = (annual_excess_return) / (annual_downside_stdev).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "\n",
-    "    negative_mask = excess < 0\n",
-    "    negative_returns = excess[negative_mask]\n",
-    "    if len(negative_returns) == 0:\n",
-    "        return np.inf  # no negative => infinite sortino\n",
-    "    downside_stdev = negative_returns.std() * np.sqrt(12)\n",
-    "    return ann_excess_ret / downside_stdev\n",
-    "\n",
-    "def max_drawdown(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Compute max drawdown from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    wealth_index = (1 + valid_rets).cumprod()\n",
-    "    rolling_max = wealth_index.cummax()\n",
-    "    dd_series = 1 - (wealth_index / rolling_max)\n",
-    "    return dd_series.max()\n",
-    "\n",
-    "def calc_portfolio_returns(weights, df_returns):\n",
-    "    \"\"\"\n",
-    "    Compute monthly portfolio returns (Series) as weighted sum of columns in df_returns.\n",
-    "    \"\"\"\n",
-    "    return (df_returns * weights).sum(axis=1)\n",
-    "\n",
-    "print(\"Utility functions loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "4f1619c9",
-   "metadata": {},
-   "source": [
-    "## 4. Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "1e739b5c-2218-4653-97f8-e3cebe194183",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─────────────── Widget Setup + Callback ───────────────\n",
-    "\n",
-    "# ─── Phase 1: Date / Vol / Cost / Run Button ───\n",
-    "# ─── Phase 1: Date / Vol / Cost / Run Button ───\n",
-    "\n",
-    "in_sample_start     = widgets.Text(value='2005-07', description='In-Sample Start:')\n",
-    "in_sample_end       = widgets.Text(value='2008-06', description='In-Sample End:')\n",
-    "out_sample_start    = widgets.Text(value='2008-07', description='Out-Sample Start:')\n",
-    "out_sample_end      = widgets.Text(value='2009-06', description='Out-Sample End:')\n",
-    "\n",
-    "target_vol_widget   = widgets.FloatText(value=0.25, description='Target Vol:')\n",
-    "monthly_cost_widget = widgets.FloatText(value=0.0033, description='Monthly Cost:')\n",
-    "\n",
-    "run_button = widgets.Button(description='Run Analysis', button_style='success')\n",
-    "\n",
-    "# ← Replace any previous “output_area = widgets.Output()” with the block below:\n",
-    "output_area = widgets.Output(\n",
-    "    layout={\n",
-    "        'border': '1px solid gray',\n",
-    "        'height': '300px',\n",
-    "        'overflow_y': 'auto'   # optional: let it scroll if there’s too much text\n",
-    "    }\n",
-    ")\n",
-    "\n",
-    "# Pack only these into main_inputs for now—no display() yet.\n",
-    "main_inputs = widgets.VBox([\n",
-    "    in_sample_start,\n",
-    "    in_sample_end,\n",
-    "    out_sample_start,\n",
-    "    out_sample_end,\n",
-    "    target_vol_widget,\n",
-    "    monthly_cost_widget,\n",
-    "    run_button\n",
-    "])\n",
-    "\n",
-    "# ─── Phase 2: Build & Hide Mode / Random-Size / “Fund Table” placeholders ───\n",
-    "\n",
-    "# A) Mode dropdown (hidden initially)\n",
-    "selection_mode_widget = widgets.Dropdown(\n",
-    "    options=[('All Funds','all'), ('Random Sample','random'), ('Manual','manual')],\n",
-    "    value='all',\n",
-    "    description='Mode:'\n",
-    ")\n",
-    "selection_mode_widget.layout.display = 'none'\n",
-    "\n",
-    "# B) Random Sample Size field (hidden initially)\n",
-    "random_sample_size_widget = widgets.IntText(\n",
-    "    value=5, description='Sample Size:'\n",
-    ")\n",
-    "random_sample_size_widget.layout.display = 'none'\n",
-    "\n",
-    "# C) Placeholder containers for the Manual‐funds checkboxes & weights\n",
-    "fund_table_container = widgets.VBox([])   # we will populate it later\n",
-    "fund_table_container.layout.display = 'none'\n",
-    "\n",
-    "# D) Whenever Mode changes, show/hide “Sample Size” vs. “Fund Table”\n",
-    "def _on_mode_change(change):\n",
-    "    new_mode = change['new']\n",
-    "    if new_mode == 'random':\n",
-    "        random_sample_size_widget.layout.display = 'block'\n",
-    "        fund_table_container.layout.display   = 'none'\n",
-    "    elif new_mode == 'manual':\n",
-    "        random_sample_size_widget.layout.display = 'none'\n",
-    "        fund_table_container.layout.display   = 'block'\n",
-    "    else:  # 'all'\n",
-    "        random_sample_size_widget.layout.display = 'none'\n",
-    "        fund_table_container.layout.display   = 'none'\n",
-    "\n",
-    "selection_mode_widget.observe(_on_mode_change, names='value')\n",
-    "\n",
-    "# ─── Phase 3: Wire up “Run Analysis” + final display(...) ───\n",
-    "\n",
-    "phase_counter = {\"step\": 1}\n",
-    "\n",
-    "def on_run_clicked(b):\n",
-    "    with output_area:\n",
-    "        clear_output()\n",
-    "\n",
-    "        # 1) Read dates/vol/cost\n",
-    "        in_start_str     = in_sample_start.value.strip()\n",
-    "        in_end_str       = in_sample_end.value.strip()\n",
-    "        out_start_str    = out_sample_start.value.strip()\n",
-    "        out_end_str      = out_sample_end.value.strip()\n",
-    "        target_vol_val   = target_vol_widget.value\n",
-    "        monthly_cost_val = monthly_cost_widget.value\n",
-    "\n",
-    "        # 2) First click = reveal Mode dropdown + hide everything else\n",
-    "        if phase_counter[\"step\"] == 1:\n",
-    "            # Quick check: ensure date strings parse\n",
-    "            try:\n",
-    "                pd.to_datetime(in_start_str, format=\"%Y-%m\")\n",
-    "                pd.to_datetime(in_end_str,   format=\"%Y-%m\")\n",
-    "                pd.to_datetime(out_start_str, format=\"%Y-%m\")\n",
-    "                pd.to_datetime(out_end_str,   format=\"%Y-%m\")\n",
-    "            except Exception:\n",
-    "                print(\"❌ Invalid date formats. Please use YYYY-MM and click Run again.\")\n",
-    "                return\n",
-    "\n",
-    "            print(\"▶ Dates accepted. Now pick Mode (All / Random / Manual). \" \n",
-    "                  \"If Manual, you’ll then see the valid funds appear.\")\n",
-    "            selection_mode_widget.layout.display = 'block'\n",
-    "            phase_counter[\"step\"] = 2\n",
-    "            return\n",
-    "\n",
-    "        # 3) After first click, Mode is visible. If Mode changed to Manual, we need to\n",
-    "        #    build the fund_table with *only* those funds that pass the full‐history + no‐3-NA rule.\n",
-    "        if phase_counter[\"step\"] == 2:\n",
-    "            mode_val  = selection_mode_widget.value\n",
-    "            rnd_n_val = random_sample_size_widget.value if mode_val == 'random' else None\n",
-    "\n",
-    "            # If Manual mode is chosen, build fund_checkboxes & weight_boxes now:\n",
-    "            if mode_val == 'manual':\n",
-    "                # 3a) Determine which funds are “valid” for this date range.\n",
-    "                #     We reuse your existing `select_funds(...)` function, forcing selection_mode='all'.\n",
-    "                try:\n",
-    "                    in_sdate  = pd.to_datetime(in_start_str, format=\"%Y-%m\")\n",
-    "                    in_edate  = pd.to_datetime(in_end_str,   format=\"%Y-%m\") + pd.offsets.MonthEnd(0)\n",
-    "                    out_sdate = pd.to_datetime(out_start_str, format=\"%Y-%m\")\n",
-    "                    out_edate = pd.to_datetime(out_end_str,   format=\"%Y-%m\") + pd.offsets.MonthEnd(0)\n",
-    "                except Exception as e:\n",
-    "                    print(\"❌ Error parsing dates. Please re‐enter and click Run again.\")\n",
-    "                    return\n",
-    "\n",
-    "                # Build the “candidate fund_columns” list (exclude Date/rf/index columns)\n",
-    "                all_cols = [c for c in df.columns if c not in ['Date', identify_risk_free_fund(df)] + indices_list]\n",
-    "                # Call select_funds with selection_mode='all' to get the full list of valid funds.\n",
-    "                valid_funds = select_funds(\n",
-    "                    df,\n",
-    "                    identify_risk_free_fund(df),\n",
-    "                    fund_columns=all_cols,\n",
-    "                    in_sdate=in_sdate,\n",
-    "                    in_edate=in_edate,\n",
-    "                    out_sdate=out_sdate,\n",
-    "                    out_edate=out_edate,\n",
-    "                    selection_mode='all',\n",
-    "                    random_n=None\n",
-    "                )\n",
-    "\n",
-    "                if not valid_funds:\n",
-    "                    print(\"❌ No funds satisfy the full‐history & gap rules for these dates.\")\n",
-    "                    return\n",
-    "\n",
-    "                # 3b) Build a fresh table of checkboxes + IntText’s for valid_funds\n",
-    "                fund_table_rows = []\n",
-    "                fund_checkboxes = []\n",
-    "                weight_boxes    = []\n",
-    "\n",
-    "                for f in valid_funds:\n",
-    "                    cb = widgets.Checkbox(\n",
-    "                        value=False,\n",
-    "                        description=f,\n",
-    "                        layout=widgets.Layout(width='200px')\n",
-    "                    )\n",
-    "                    tb = widgets.BoundedIntText(\n",
-    "                        value=0,\n",
-    "                        min=0,\n",
-    "                        max=100,\n",
-    "                        step=1,\n",
-    "                        description=\"%\",          # user will type an integer percent\n",
-    "                        layout=widgets.Layout(width='160px')\n",
-    "                    )\n",
-    "                    tb.disabled = True  # only enabled when its checkbox is clicked\n",
-    "                    \n",
-    "                    fund_checkboxes.append(cb)\n",
-    "                    weight_boxes.append(tb)\n",
-    "\n",
-    "                    row = widgets.HBox([\n",
-    "                        cb,\n",
-    "                        weight_boxes[-1]\n",
-    "                    ], layout=widgets.Layout(margin=\"2px 0px\"))\n",
-    "                    fund_table_rows.append(row)\n",
-    "\n",
-    "                # Replace whatever was in fund_table_container with this new VBox\n",
-    "                fund_table_container.children = [widgets.VBox(fund_table_rows)]\n",
-    "                fund_table_container.layout.display = 'block'  # reveal it\n",
-    "\n",
-    "                # 3c) Wire up each checkbox so its weight box toggles on/off\n",
-    "                def _on_cb_change(change):\n",
-    "                    # ‘change.owner’ is the Checkbox that toggled\n",
-    "                    idx = fund_checkboxes.index(change.owner)\n",
-    "                    weight_boxes[idx].disabled = not change.new\n",
-    "\n",
-    "                for cb in fund_checkboxes:\n",
-    "                    cb.observe(_on_cb_change, names='value')\n",
-    "\n",
-    "            # Finally, show the random_sample_size_widget if needed\n",
-    "            if mode_val == 'random':\n",
-    "                random_sample_size_widget.layout.display = 'block'\n",
-    "\n",
-    "            print(\"▶ Now the Mode/sampling UI is visible. If Manual, pick funds + enter weights. Then click Run again.\")\n",
-    "            phase_counter[\"step\"] = 3\n",
-    "            return\n",
-    "\n",
-    "        # 4) After second click, everything (Mode + any Manual selections or random size) is set,\n",
-    "        #    so we can finally run `run_analysis(...)` for real:\n",
-    "        mode_val  = selection_mode_widget.value\n",
-    "        rnd_n_val = random_sample_size_widget.value if mode_val == 'random' else None\n",
-    "\n",
-    "        custom_weights = None\n",
-    "        if mode_val == 'manual':\n",
-    "            # Gather which checkboxes were checked, and read their weight_boxes\n",
-    "            selected = []\n",
-    "            weight_dict = {}\n",
-    "            # The fund_checkboxes + weight_boxes only exist if step>=2 and mode=='manual'.\n",
-    "            # We can grab them from fund_table_container.children.\n",
-    "            table_vbox = fund_table_container.children[0]   # the VBox we built above\n",
-    "            for row_hbox in table_vbox.children:\n",
-    "                cb, tb = row_hbox.children\n",
-    "                if cb.value:\n",
-    "                    selected.append(cb.description)\n",
-    "                    weight_dict[cb.description] = tb.value\n",
-    "\n",
-    "            total_w = sum(weight_dict.values())\n",
-    "            if not selected:\n",
-    "                print(\"⚠️ No funds checked—pick at least one fund.\")\n",
-    "                return\n",
-    "            if total_w != 100:\n",
-    "                print(f\"⚠️ Weights sum to {total_w}, but must be exactly 100. Fix and Run again.\")\n",
-    "                return\n",
-    "\n",
-    "            custom_weights = weight_dict\n",
-    "\n",
-    "        # 5) Now run the analysis for real\n",
-    "        print(\"▶ Running analysis with:\")\n",
-    "        print(f\"   In:   {in_start_str} → {in_end_str}\")\n",
-    "        print(f\"   Out:  {out_start_str} → {out_end_str}\")\n",
-    "        print(f\"   Vol:  {target_vol_val:.3%}, Cost: {monthly_cost_val:.3%}\")\n",
-    "        print(f\"   Mode: {mode_val}\" + (f\", Random N={rnd_n_val}\" if mode_val=='random' else \"\"))\n",
-    "        if mode_val == 'manual':\n",
-    "            print(f\"   Manual funds = {list(custom_weights.keys())}\")\n",
-    "            print(f\"   Weights = {custom_weights}\")\n",
-    "\n",
-    "        try:\n",
-    "            results = run_analysis(\n",
-    "                df,\n",
-    "                in_start=in_start_str,\n",
-    "                in_end=in_end_str,\n",
-    "                out_start=out_start_str,\n",
-    "                out_end=out_end_str,\n",
-    "                target_vol=target_vol_val,\n",
-    "                monthly_cost=monthly_cost_val,\n",
-    "                selection_mode=mode_val,\n",
-    "                random_n=rnd_n_val,\n",
-    "                custom_weights=custom_weights\n",
-    "            )\n",
-    "        except Exception as e:\n",
-    "            print(\"❌ Error inside run_analysis():\", e)\n",
-    "            return\n",
-    "\n",
-    "        if results is None or not results.get(\"selected_funds\"):\n",
-    "            print(\"❌ No valid funds remain after filtering.\")\n",
-    "            return\n",
-    "\n",
-    "        # 6) Print a brief summary & export to Excel\n",
-    "        sf = results[\"selected_funds\"]\n",
-    "        print(\"✅ Analysis complete:\")\n",
-    "        print(f\"   Funds selected: {len(sf)} → {sf}\")\n",
-    "        print(\"   Manual funds & weights:\")\n",
-    "        if custom_weights is not None:\n",
-    "            print(\"   Manual funds & weights:\")\n",
-    "            for f, w in custom_weights.items():\n",
-    "                print(f\"     • {f}: {w}%\")\n",
-    "        if \"in_ew_stats\" in results:\n",
-    "            ir, iv, isr, *_ = results[\"in_ew_stats\"]\n",
-    "            print(f\"   In‐Sample EW → R {ir*100:.2f}%, V {iv*100:.2f}%, S {isr:.2f}\")\n",
-    "        if \"out_ew_stats\" in results:\n",
-    "            or_, ov, osr, *_ = results[\"out_ew_stats\"]\n",
-    "            print(f\"   Out‐Sample EW → R {or_*100:.2f}%, V {ov*100:.2f}%, S {osr:.2f}\")\n",
-    "\n",
-    "        print(\">> about to write Excel with custom_weights =\", custom_weights)\n",
-    "\n",
-    "        # Add the filename\n",
-    "        global fname\n",
-    "        fname = f\"IS_{in_start_str}_{out_start_str}.xlsx\"\n",
-    "    \n",
-    "        export_to_excel(\n",
-    "            results,\n",
-    "            df,            # your full DataFrame\n",
-    "            fname,         \n",
-    "            in_start_str,  \n",
-    "            in_end_str,    \n",
-    "            out_start_str, \n",
-    "            out_end_str    \n",
-    "        )\n",
-    "        print(f\"   Excel file created: IS_{in_start_str}_{out_start_str}.xlsx\")\n",
-    "        import inspect\n",
-    "        print(inspect.getsource(export_to_excel))\n",
-    "\n",
-    "\n",
-    "run_button.on_click(on_run_clicked)\n",
-    "\n",
-    "# ─── Finally, show everything (Phase 1 + Phase 2 placeholders + output area) ───\n",
-    "\n",
-    "master_vbox = widgets.VBox([\n",
-    "    main_inputs,\n",
-    "    selection_mode_widget,\n",
-    "    random_sample_size_widget,\n",
-    "    fund_table_container\n",
-    "])\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "## 5. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "c5867ccd-a550-4849-a10b-a085f5fe26fd",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "select_funds (replaced) is ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def select_funds(\n",
-    "    df,                 # full DataFrame with datetime64 ‘Date’\n",
-    "    rf_col,             # name of risk‐free column\n",
-    "    fund_columns,       # list of candidate funds (should be your 27)\n",
-    "    in_sdate, in_edate, # pd.Timestamps for in‐sample window\n",
-    "    out_sdate, out_edate,# pd.Timestamps for out‐sample window\n",
-    "    selection_mode='all',\n",
-    "    random_n=8\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Start from fund_columns.  \n",
-    "    2) Filter out any that contain 'index' in name.  \n",
-    "    3) Keep only those with no NaN anywhere in both windows.  \n",
-    "    4) Keep only those with < 3 consecutive NaNs in each window.  \n",
-    "    5) Return based on selection_mode.\n",
-    "    \"\"\"\n",
-    "    # Step 1: base list\n",
-    "    candidates = fund_columns.copy()\n",
-    "    print(f\"DEBUG [select_funds]: initial candidates (n={len(candidates)}): {candidates}\")\n",
-    "\n",
-    "    # Step 2: drop any with “index” in name (case‐insensitive)\n",
-    "    no_index = [f for f in candidates if 'index' not in f.lower()]\n",
-    "    print(f\"DEBUG [select_funds]: after dropping 'index' (n={len(no_index)}): {no_index}\")\n",
-    "\n",
-    "    # Step 3: full‐history check (no NaN at all in each window)\n",
-    "    full_hist = []\n",
-    "    for f in no_index:\n",
-    "        in_sub  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)][f]\n",
-    "        out_sub = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        if in_sub.notna().all() and out_sub.notna().all():\n",
-    "            full_hist.append(f)\n",
-    "    print(f\"DEBUG [select_funds]: after full‐history check (n={len(full_hist)}): {full_hist}\")\n",
-    "\n",
-    "    # Step 4: no 3‐consecutive‐NaNs check\n",
-    "    after_run_check = []\n",
-    "    for f in full_hist:\n",
-    "        # In‐sample gap runs\n",
-    "        sub_in   = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "        isnan_in = sub_in.isna().astype(int)\n",
-    "        run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "        max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "\n",
-    "        # Out‐sample gap runs\n",
-    "        sub_out   = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        isnan_out = sub_out.isna().astype(int)\n",
-    "        run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "        max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "\n",
-    "        # Keep only if both max runs < 3\n",
-    "        if max_run_in < 3 and max_run_out < 3:\n",
-    "            after_run_check.append(f)\n",
-    "\n",
-    "    print(f\"DEBUG [select_funds]: after run‐length check (n={len(after_run_check)}): {after_run_check}\")\n",
-    "\n",
-    "    # Step 5: selection_mode\n",
-    "    good = []\n",
-    "    for f in fund_cols:\n",
-    "        s_in  = df.set_index('Date').loc[in_s:in_e, f]\n",
-    "        s_out = df.set_index('Date').loc[out_s:out_e, f]\n",
-    "\n",
-    "        # 1–2 month gap fill\n",
-    "        s_in_f  = fill_short_gaps_with_zero(s_in)\n",
-    "        s_out_f = fill_short_gaps_with_zero(s_out)\n",
-    "\n",
-    "        # tests\n",
-    "        if (s_in_f.notna().all() and s_out_f.notna().all() and\n",
-    "            not consecutive_gaps(s_in) and\n",
-    "            not consecutive_gaps(s_out)):\n",
-    "            good.append(f)\n",
-    "\n",
-    "    if mode == 'random' and len(good) > random_n:\n",
-    "        good = random.sample(good, random_n)\n",
-    "\n",
-    "    logging.info(f\"select_funds → {len(good)} funds\")\n",
-    "    return good\n",
-    "\n",
-    "print(\"select_funds (replaced) is ready.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 6. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "get_custom_weights function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    Returns dict {fund: weight_decimal}.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=f\"{fund}\",\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    \n",
-    "    confirm_button = widgets.Button(\n",
-    "        description='Confirm Weights',\n",
-    "        button_style='success'\n",
-    "    )\n",
-    "    error_label = widgets.Label(value='', layout=widgets.Layout(color='red'))\n",
-    "    \n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm_button, error_label])\n",
-    "    display(box)\n",
-    "    \n",
-    "    weights_container = {}\n",
-    "    \n",
-    "    def on_confirm_clicked(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_label.value = f\"Error: Weights sum to {total}, must be 100.\"\n",
-    "            weights_container.clear()\n",
-    "        else:\n",
-    "            for fund, wdg in weight_widgets.items():\n",
-    "                weights_container[fund] = wdg.value / 100.0\n",
-    "            error_label.value = \"Weights confirmed!\"\n",
-    "    \n",
-    "    confirm_button.on_click(on_confirm_clicked)\n",
-    "    return weights_container\n",
-    "\n",
-    "print(\"get_custom_weights function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 7. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 7,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "run_analysis (with checkpoints) is defined.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def run_analysis(\n",
-    "    df,\n",
-    "    in_start, in_end, out_start, out_end,\n",
-    "    target_vol, monthly_cost,\n",
-    "    selection_mode='all',\n",
-    "    random_n=8,\n",
-    "    custom_weights=None    # ← new argument\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Parse/validate date inputs\n",
-    "    2) Convert Date column if needed\n",
-    "    3) Identify rf_col\n",
-    "    4) Prepare in/out sample DataFrames\n",
-    "    5) CALL select_funds (with debug) and print checkpoints\n",
-    "    6) Compute scale_factors and wrap stats in try/except\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # —(1) Parse input dates (YYYY-MM) into actual month-end timestamps\n",
-    "    in_sdate  = pd.to_datetime(in_start + \"-01\", errors='coerce')\n",
-    "    in_edate  = pd.to_datetime(in_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "    out_sdate = pd.to_datetime(out_start + \"-01\", errors='coerce')\n",
-    "    out_edate = pd.to_datetime(out_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    # checkpoint A\n",
-    "    print(\"CHECKPOINT A: Dates parsed:\", in_sdate, in_edate, out_sdate, out_edate)\n",
-    "\n",
-    "    # —(2) Ensure 'Date' column is datetime64\n",
-    "    if not np.issubdtype(df['Date'].dtype, np.datetime64):\n",
-    "        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "        df.dropna(subset=['Date'], inplace=True)\n",
-    "        df.sort_values(by='Date', inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "    # checkpoint B\n",
-    "    print(\"CHECKPOINT B: Date column is datetime64, first dates:\",\n",
-    "          df['Date'].iloc[0], \"…\", df['Date'].iloc[-1])\n",
-    "\n",
-    "    # —(3) Identify risk-free column\n",
-    "    rf_col = identify_risk_free_fund(df)\n",
-    "    print(f\"INFO: Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "\n",
-    "    # —(4) Slice into in-sample & out-sample\n",
-    "    in_sample_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_sample_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "    in_sample_rf  = in_sample_df[rf_col]\n",
-    "    out_sample_rf = out_sample_df[rf_col]\n",
-    "\n",
-    "    print(f\"CHECKPOINT C: in_sample rows = {len(in_sample_df)}, out_sample rows = {len(out_sample_df)}\")\n",
-    "\n",
-    "    # —(5) Select funds (either “manual” or via select_funds)\n",
-    "    if selection_mode == 'manual' and custom_weights is not None:\n",
-    "        # In manual mode, we trust the user’s chosen tickers outright\n",
-    "        selected_funds = list(custom_weights.keys())\n",
-    "        print(f\"CHECKPOINT D (manual): using custom_weights keys → {selected_funds}\")\n",
-    "    else:\n",
-    "        all_fund_cols = fund_cols.copy()\n",
-    "        print(f\"CHECKPOINT D: about to call select_funds with {len(all_fund_cols)} candidates\")\n",
-    "\n",
-    "        selected_funds = select_funds(\n",
-    "            df,\n",
-    "            rf_col,\n",
-    "            fund_columns=all_fund_cols,\n",
-    "            in_sdate=in_sdate,\n",
-    "            in_edate=in_edate,\n",
-    "            out_sdate=out_sdate,\n",
-    "            out_edate=out_edate,\n",
-    "            selection_mode=selection_mode,\n",
-    "            random_n=random_n\n",
-    "        )\n",
-    "\n",
-    "    if len(selected_funds) == 0:\n",
-    "        logging.warning(\"No valid funds remain after filtering.\")\n",
-    "        print(\"Warning: No valid funds. Try adjusting your selection or data filters.\")\n",
-    "        return None\n",
-    "\n",
-    "    print(f\"CHECKPOINT E: select_funds returned {len(selected_funds)} funds → {selected_funds}\")\n",
-    "\n",
-    "    # indices_list must already exist as a global list of index columns\n",
-    "    in_sample_indices  = in_sample_df[indices_list].copy()\n",
-    "    out_sample_indices = out_sample_df[indices_list].copy()\n",
-    "\n",
-    "    # —(6) Compute scale_factors (based on in-sample volatility)\n",
-    "    scale_factors = {}\n",
-    "    for fund in selected_funds:\n",
-    "        fund_in_rets = in_sample_df[fund].dropna()\n",
-    "        current_vol  = annualize_volatility(fund_in_rets)\n",
-    "        if pd.isna(current_vol) or current_vol == 0:\n",
-    "            scale_factors[fund] = 1.0\n",
-    "        else:\n",
-    "            scale_factors[fund] = target_vol / current_vol\n",
-    "\n",
-    "    print(\"CHECKPOINT F: scale_factors computed (showing first 5):\",\n",
-    "          {f: scale_factors[f] for f in selected_funds[:5]})\n",
-    "\n",
-    "    # Pre-allocate DataFrames for scaled returns\n",
-    "    in_sample_scaled  = pd.DataFrame(index=in_sample_df.index, columns=selected_funds)\n",
-    "    out_sample_scaled = pd.DataFrame(index=out_sample_df.index, columns=selected_funds)\n",
-    "\n",
-    "    # ── Wrap everything from “scaling + stats” in a try/except ──\n",
-    "    try:\n",
-    "        # (6a) Scale returns (with monthly cost)\n",
-    "        for fund in selected_funds:\n",
-    "            sf     = scale_factors[fund]\n",
-    "            adj_in = in_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_in[adj_in < -1.0] = -1.0\n",
-    "            in_sample_scaled[fund] = adj_in\n",
-    "\n",
-    "            if not out_sample_df.empty:\n",
-    "                adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "                adj_out[adj_out < -1.0] = -1.0\n",
-    "                out_sample_scaled[fund] = adj_out\n",
-    "\n",
-    "        # (6b) Helper to compute per-series stats\n",
-    "        def compute_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            sr  = sharpe_ratio(series, rf_series)\n",
-    "            so  = sortino_ratio(series, rf_series)\n",
-    "            mdd = max_drawdown(series)\n",
-    "            return (r, v, sr, so, mdd)\n",
-    "\n",
-    "        # (6c) In-sample per-fund stats\n",
-    "        in_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "\n",
-    "        # (6d) Out-sample per-fund (vol-adjusted) stats\n",
-    "        out_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6e) Out-sample per-fund (raw) stats\n",
-    "        out_sample_stats_raw = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6f) Equal-weight portfolio returns\n",
-    "        ew_weight_dict = { f: 1.0/len(selected_funds) for f in selected_funds }\n",
-    "        ew_w           = np.array([ ew_weight_dict[f] for f in selected_funds ])\n",
-    "        in_ew_port      = calc_portfolio_returns(ew_w,       in_sample_scaled[selected_funds])\n",
-    "        out_ew_port     = calc_portfolio_returns(ew_w,       out_sample_scaled[selected_funds])\n",
-    "        out_ew_port_raw = calc_portfolio_returns(ew_w,       out_sample_df[selected_funds])\n",
-    "        \n",
-    "        in_ew_stats      = compute_stats(in_ew_port,      in_sample_rf)\n",
-    "        out_ew_stats     = compute_stats(out_ew_port,     out_sample_rf)\n",
-    "        out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6g) Index statistics (treat each index like “just another series”)\n",
-    "        in_index_stats  = {}\n",
-    "        out_index_stats = {}\n",
-    "        for idx in indices_list:\n",
-    "            in_index_stats[idx]  = compute_stats(in_sample_indices[idx],  in_sample_df[rf_col])\n",
-    "            out_index_stats[idx] = compute_stats(out_sample_indices[idx], out_sample_df[rf_col])\n",
-    "\n",
-    "        # (6h) “User-weight” portfolio\n",
-    "        if custom_weights is None:\n",
-    "            # If no manual weights → just reuse the same equal‐weight array\n",
-    "            user_weight_dict = ew_weight_dict.copy()\n",
-    "            # ← **IMPORTANT FIX**: define custom_w here for the equal-weight case\n",
-    "            custom_w = ew_w.copy()  \n",
-    "        else:\n",
-    "            # Manual weights passed → convert percentages to decimals\n",
-    "            user_weight_dict = { f: custom_weights[f] / 100.0 for f in selected_funds }\n",
-    "            custom_w         = np.array([ user_weight_dict[f] for f in selected_funds ])\n",
-    "\n",
-    "        # (6i) Compute “user-weighted” portfolio returns\n",
-    "        in_user_port      = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "        out_user_port     = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "        out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        # (6j) Compute their stats\n",
-    "        in_user_stats      = compute_stats(in_user_port,      in_sample_rf)\n",
-    "        out_user_stats     = compute_stats(out_user_port,     out_sample_rf)\n",
-    "        out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6k) Build the final results dict **(FIXED: removed duplicate 'fund_weights')**\n",
-    "        results = {\n",
-    "            'selected_funds':       selected_funds,\n",
-    "            'in_sample_scaled':     in_sample_scaled,\n",
-    "            'out_sample_scaled':    out_sample_scaled,\n",
-    "            'in_sample_stats':      in_sample_stats,\n",
-    "            'out_sample_stats':     out_sample_stats,\n",
-    "            'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "            'in_ew_stats':          in_ew_stats,\n",
-    "            'out_ew_stats':         out_ew_stats,\n",
-    "            'out_ew_stats_raw':     out_ew_stats_raw,\n",
-    "            'in_user_stats':        in_user_stats,\n",
-    "            'out_user_stats':       out_user_stats,\n",
-    "            'out_user_stats_raw':   out_user_stats_raw,\n",
-    "            'ew_weights':           ew_weight_dict,     # ← now returns equal-weight dict\n",
-    "            'fund_weights':         user_weight_dict,   # ← returns manual weights (or equal if none)\n",
-    "            'indices_list':         indices_list\n",
-    "        }\n",
-    "\n",
-    "    except Exception as e:\n",
-    "        print(\"ERROR inside stats-block:\", e)\n",
-    "        return None\n",
-    "\n",
-    "    # Everything succeeded\n",
-    "    return results\n",
-    "\n",
-    "\n",
-    "\n",
-    "print(\"run_analysis (with checkpoints) is defined.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 8. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 8,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─── Helper #1: build the equal- and user-weight DataFrames ────────────────────────────────\n",
-    "def make_portfolio_dfs(results, sample='in'):\n",
-    "    \"\"\"\n",
-    "    Returns (eq_df, user_df) for either 'in' or 'out' sample.\n",
-    "    \"\"\"\n",
-    "    # pick the right stats:\n",
-    "    stats_dict      = results[f'{sample}_sample_stats']\n",
-    "    ew_stats        = results[f'{sample}_ew_stats']\n",
-    "    user_stats      = results[f'{sample}_user_stats']\n",
-    "    fund_weights    = results['fund_weights']\n",
-    "    funds           = results['selected_funds']\n",
-    "\n",
-    "    def build_block(portf_label, stats, include_weights):\n",
-    "        rows = []\n",
-    "        # portfolio row\n",
-    "        r, v, sr, so, mdd = stats\n",
-    "        rows.append({\n",
-    "            'Fund': portf_label,\n",
-    "            'Weight': 100,\n",
-    "            'Return (%)': r,\n",
-    "            'Volatility (%)': v,\n",
-    "            'Sharpe Ratio': sr,\n",
-    "            'Sortino Ratio': so,\n",
-    "            'Max Drawdown (%)': mdd\n",
-    "        })\n",
-    "        # one‐row per fund\n",
-    "        for f in funds:\n",
-    "            r, v, sr, so, mdd = stats_dict[f]\n",
-    "            w = int(round(fund_weights[f] * 100)) if include_weights else None\n",
-    "            rows.append({\n",
-    "                'Fund': f,\n",
-    "                'Weight': w,\n",
-    "                'Return (%)': r,\n",
-    "                'Volatility (%)': v,\n",
-    "                'Sharpe Ratio': sr,\n",
-    "                'Sortino Ratio': so,\n",
-    "                'Max Drawdown (%)': mdd\n",
-    "            })\n",
-    "        return pd.DataFrame(rows)\n",
-    "\n",
-    "    eq_df   = build_block('Equal-Weight Portfolio', ew_stats,   True)\n",
-    "    user_df = build_block('User-Weight Portfolio', user_stats, True)\n",
-    "    return eq_df, user_df\n",
-    "\n",
-    "\n",
-    "# ─── Helper #2: build an indices table ─────────────────────────────────────────────────────\n",
-    "def make_indices_df(df, indices, start, end):\n",
-    "    \"\"\"\n",
-    "    Compute (Return, Vol, Sharpe, Sortino, MDD) for each index in [start, end],\n",
-    "    return a DataFrame with columns Index, Return (%), Volatility (%), …\n",
-    "    \"\"\"\n",
-    "    in_s, in_e = pd.to_datetime(start+'-01'), pd.to_datetime(end+'-01') + pd.offsets.MonthEnd(0)\n",
-    "    rows = []\n",
-    "    rf = identify_risk_free_fund(df)\n",
-    "    sub = df.set_index('Date').loc[in_s:in_e]\n",
-    "    for idx in indices:\n",
-    "        series = sub[idx]\n",
-    "        rf_ser = sub[rf]\n",
-    "        r  = annualize_return(series)\n",
-    "        v  = annualize_volatility(series)\n",
-    "        sr = sharpe_ratio(series, rf_ser)\n",
-    "        so = sortino_ratio(series, rf_ser)\n",
-    "        mdd = max_drawdown(series)\n",
-    "        rows.append({\n",
-    "            'Index': idx,\n",
-    "            'Return (%)': r,\n",
-    "            'Volatility (%)': v,\n",
-    "            'Sharpe Ratio': sr,\n",
-    "            'Sortino Ratio': so,\n",
-    "            'Max Drawdown (%)': mdd\n",
-    "        })\n",
-    "    return pd.DataFrame(rows)\n",
-    "\n",
-    "\n",
-    "# ─── Helper #3: write & format one sheet ──────────────────────────────────────────────────\n",
-    "# Apply uniform column widths & formats\n",
-    "    #   (col_idx, width, format_obj)\n",
-    "COLUMN_SPECS = [\n",
-    "    (0, 28, None),\n",
-    "    (1, 12, 'int'),\n",
-    "    (2, 15, 'pct1'),\n",
-    "    (3, 15, 'pct1'),\n",
-    "    (4, 15, 'dec2'),\n",
-    "    (5, 15, 'dec2'),\n",
-    "    (6, 15, 'pct1'),\n",
-    "]\n",
-    "\n",
-    "def build_formats(wb):\n",
-    "    return {\n",
-    "      'int':   wb.add_format({'num_format':'0'}),\n",
-    "      'pct1':  wb.add_format({'num_format':'0.0%'}),\n",
-    "      'dec2':  wb.add_format({'num_format':'0.00'}),\n",
-    "      'bold':  wb.add_format({'bold':True}),\n",
-    "    }\n",
-    "    \n",
-    "def write_portfolio_sheet(writer, sheet_name, eq_df, user_df, fmt):\n",
-    "    # Create & register the sheet\n",
-    "    ws = writer.book.add_worksheet(sheet_name)\n",
-    "    writer.sheets[sheet_name] = ws\n",
-    "\n",
-    "    # 1) Write the two tables with keyword-only args\n",
-    "    eq_df.to_excel(excel_writer=writer,\n",
-    "                   sheet_name=sheet_name,\n",
-    "                   startrow=0,\n",
-    "                   index=False)\n",
-    "    user_df.to_excel(excel_writer=writer,\n",
-    "                     sheet_name=sheet_name,\n",
-    "                     startrow=len(eq_df) + 3,\n",
-    "                     index=False)\n",
-    "\n",
-    "    for col_idx, width, fmt_key in COLUMN_SPECS:\n",
-    "        # if fmt_key is None, use no format; otherwise pull from fmt\n",
-    "        fmt_obj = fmt[fmt_key] if fmt_key else None\n",
-    "        ws.set_column(col_idx, col_idx, width, fmt_obj)\n",
-    "\n",
-    "    # Bold the headers\n",
-    "    bold = fmt['bold']\n",
-    "    for j, h in enumerate(eq_df.columns):\n",
-    "        ws.write(0, j, h, fmt['bold'])\n",
-    "    start = len(eq_df) + 3\n",
-    "    for j, h in enumerate(user_df.columns):\n",
-    "        ws.write(start, j, h, fmt['bold'])\n",
-    "\n",
-    "\n",
-    "def write_indices_block(writer, sheet_name, df_idx, start_row, fmt):\n",
-    "    \"\"\"\n",
-    "    Write the indices block to the given sheet at start_row\n",
-    "    \"\"\"\n",
-    "    # Grab the worksheet from the writer\n",
-    "    ws = writer.sheets[sheet_name]\n",
-    "    bold_fmt = fmt['bold']\n",
-    "\n",
-    "    # Label\n",
-    "    ws.write(start_row - 1, 0, f\"Indices ({sheet_name}):\", bold_fmt)\n",
-    "\n",
-    "    # Dump the DataFrame\n",
-    "    df_idx.to_excel(\n",
-    "        excel_writer=writer,\n",
-    "        sheet_name=sheet_name,\n",
-    "        startrow=start_row,\n",
-    "        index=False\n",
-    "    )\n",
-    "\n",
-    "    # Apply the same COLUMN_SPECS formats as the portfolio tables\n",
-    "    for col_idx, width, fmt_key in COLUMN_SPECS:\n",
-    "        fmt_obj = fmt.get(fmt_key) if fmt_key else None\n",
-    "        ws.set_column(col_idx, col_idx, width, fmt_obj)\n",
-    "\n",
-    "    # Bold the header row of the indices table\n",
-    "    ws.set_row(start_row, None, bold_fmt)\n",
-    "\n",
-    "def export_to_excel(results, df, output_filename,\n",
-    "                    in_start, in_end, out_start, out_end):\n",
-    "    writer  = pd.ExcelWriter(output_filename, engine='xlsxwriter')\n",
-    "    wb     = writer.book\n",
-    "    formats = build_formats(wb)\n",
-    "\n",
-    "    # 1) portfolio sheets\n",
-    "    in_eq,  in_user  = make_portfolio_dfs(results, sample='in')\n",
-    "    out_eq, out_user = make_portfolio_dfs(results, sample='out')\n",
-    "  \n",
-    "    # 2) indices sheets\n",
-    "    idx_in  = make_indices_df(df, results['indices_list'], in_start,  in_end)\n",
-    "    idx_out = make_indices_df(df, results['indices_list'], out_start, out_end)\n",
-    "    # compute where to start: right after user_df\n",
-    "    start_in  = len(in_eq)  + len(in_user)  + 6\n",
-    "    start_out = len(out_eq) + len(out_user) + 6\n",
-    "\n",
-    "    write_portfolio_sheet(writer, f\"IS {in_start}-{in_end}\", in_eq,  in_user,  formats)\n",
-    "    write_portfolio_sheet(writer, f\"OS {out_start}-{out_end}\", out_eq, out_user, formats)\n",
-    "    write_indices_block(writer, f\"IS {in_start}-{in_end}\", idx_in,  start_in,  formats)\n",
-    "    write_indices_block(writer, f\"OS {out_start}-{out_end}\", idx_out, start_out, formats)\n",
-    "\n",
-    "    writer.close()\n",
-    "\n",
-    "    logging.info(f\"Exported analysis to {output_filename} successfully.\")\n",
-    "    print(f\"Excel file created: {output_filename}\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Run Parameters"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 9,
-   "id": "9899f2e3-9c6e-4c38-b3eb-d07e8f871462",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "4f536a0d5f31460cbb23e3ab7e72220c",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Button(button_style='info', description='Configure Analysis', style=ButtonStyle())"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "4296e3d4477b4ac7b5b8dc850a5658be",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Output()"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "72f7d6cba4ee459887540830b0fbb29a",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Button(button_style='primary', description='Run Analysis', disabled=True, style=ButtonStyle())"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "59faaa8362894022ab2d08fb2d5b4235",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Output()"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# ──────────────────────────────────────────────────────────────\n",
-    "#  CONFIGURE  +  RUN   (single-page)  UI\n",
-    "# ──────────────────────────────────────────────────────────────\n",
-    "import ipywidgets as widgets\n",
-    "from ipyfilechooser import FileChooser\n",
-    "from IPython.display import display, clear_output\n",
-    "\n",
-    "# persistent scratch-pad\n",
-    "ui_state = {}\n",
-    "\n",
-    "# ── CSV loader widgets ─────────────────────────\n",
-    "src_toggle   = widgets.ToggleButtons(options=['Local', 'GitHub'],\n",
-    "                                     description='Source:')\n",
-    "fc           = FileChooser()                      # local picker\n",
-    "fc.title     = '<b>Select CSV</b>'\n",
-    "gh_url       = widgets.Text(value='', description='GitHub URL:')\n",
-    "load_btn     = widgets.Button(description='Load CSV',\n",
-    "                              button_style='success')\n",
-    "load_out     = widgets.Output()\n",
-    "\n",
-    "def _toggle_src(change):\n",
-    "    if change['new'] == 'Local':\n",
-    "        fc.layout.display = 'block' ; gh_url.layout.display = 'none'\n",
-    "    else:\n",
-    "        fc.layout.display = 'none'  ; gh_url.layout.display = 'block'\n",
-    "src_toggle.observe(_toggle_src, names='value')\n",
-    "gh_url.layout.display = 'none'      # start hidden\n",
-    "\n",
-    "# ── analysis-parameter widgets ─────────────────\n",
-    "mode_w   = widgets.ToggleButtons(options=['all','random','manual'],\n",
-    "                                 value='all', description='Mode:')\n",
-    "rand_w   = widgets.BoundedIntText(value=8,  min=1, max=100,\n",
-    "                                  description='Random N:')\n",
-    "idx_w    = widgets.BoundedIntText(value=0,  min=0, max=10,\n",
-    "                                  description='# Indices:')\n",
-    "\n",
-    "in_s  = widgets.Text(value='2005-07', description='In Start:')\n",
-    "in_e  = widgets.Text(value='2008-06', description='In End:')\n",
-    "out_s = widgets.Text(value='2008-07', description='Out Start:')\n",
-    "out_e = widgets.Text(value='2009-06', description='Out End:')\n",
-    "\n",
-    "# manual-weights placeholders (pop up only if needed)\n",
-    "weight_box = widgets.VBox([])\n",
-    "\n",
-    "# ── 1)  Configure step ─────────────────────────\n",
-    "config_btn   = widgets.Button(description='Configure Analysis',\n",
-    "                              button_style='info')\n",
-    "config_out   = widgets.Output()\n",
-    "\n",
-    "def _load_csv(_):\n",
-    "    \"\"\"Load CSV → ui_state['df'], ui_state['fund_cols'], ui_state['indices']\"\"\"\n",
-    "    load_out.clear_output()\n",
-    "    with load_out:\n",
-    "        try:\n",
-    "            if src_toggle.value == 'Local':\n",
-    "                path = fc.selected\n",
-    "                df = robust_read_csv(path)\n",
-    "                print(f'Loaded local file: {path}')\n",
-    "            else:\n",
-    "                url = gh_url.value.strip()\n",
-    "                df = robust_read_csv(url)\n",
-    "                print(f'Loaded GitHub file: {url}')\n",
-    "        except Exception as e:\n",
-    "            print('❌ CSV load failed:', e); return\n",
-    "\n",
-    "        # basic date parsing (same logic as notebook)\n",
-    "        date_col = next(c for c in df.columns if c.lower().startswith('date'))\n",
-    "        df[date_col] = pd.to_datetime(df[date_col], errors='coerce')\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        df.sort_values(date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "        rf = identify_risk_free_fund(df)\n",
-    "        cols = [c for c in df.columns if c not in [date_col, rf]]\n",
-    "        n_idx = idx_w.value\n",
-    "        indices = cols[-n_idx:] if 0 < n_idx <= len(cols) else []\n",
-    "        funds   = cols[:-n_idx]  if 0 < n_idx <= len(cols) else cols\n",
-    "\n",
-    "        print(f'🗂  {len(funds)} fund columns, {len(indices)} index columns.')\n",
-    "        ui_state.update(df=df,\n",
-    "                        date_col=date_col,\n",
-    "                        rf_col=rf,\n",
-    "                        fund_cols=funds,\n",
-    "                        indices_list=indices)\n",
-    "        # enable Run button once data is ready\n",
-    "        run_btn.disabled = False\n",
-    "\n",
-    "load_btn.on_click(_load_csv)\n",
-    "\n",
-    "def _config_click(_):\n",
-    "    config_out.clear_output()\n",
-    "    with config_out:\n",
-    "        display(widgets.HTML('<h3>Load CSV</h3>'),\n",
-    "                src_toggle, fc, gh_url, idx_w, load_btn, load_out,\n",
-    "                widgets.HTML('<hr style=\"height:1px\">'),\n",
-    "                widgets.HTML('<h3>Analysis Parameters</h3>'),\n",
-    "                HBox([mode_w, rand_w]),\n",
-    "                HBox([in_s, in_e, out_s, out_e]),\n",
-    "                weight_box)\n",
-    "        run_btn.disabled = True   # disabled until CSV successfully loads\n",
-    "config_btn.on_click(_config_click)\n",
-    "\n",
-    "# ── 2)  Run step ───────────────────────────────\n",
-    "run_btn   = widgets.Button(description='Run Analysis',\n",
-    "                           button_style='primary', disabled=True)\n",
-    "run_out   = widgets.Output()\n",
-    "\n",
-    "def _run_click(_):\n",
-    "    run_out.clear_output()\n",
-    "    with run_out:\n",
-    "        try:\n",
-    "            if 'df' not in ui_state:\n",
-    "                print('⚠️  Please load data first.'); return\n",
-    "\n",
-    "            # 1) read current widgets\n",
-    "            mode    = mode_w.value\n",
-    "            rand_n  = rand_w.value\n",
-    "            in1       = in_s.value.strip()\n",
-    "            in2       = in_e.value.strip()\n",
-    "            out1      = out_s.value.strip()\n",
-    "            out2      = out_e.value.strip()\n",
-    "\n",
-    "            # 2) manual weights (if needed)\n",
-    "            if mode=='manual' and 'custom_weights' not in ui_state:\n",
-    "                weight_box.children = [widgets.BoundedIntText(\n",
-    "                                           value=0,min=0,max=100,\n",
-    "                                           description=f'{f}:')\n",
-    "                                        for f in ui_state['fund_cols']]\n",
-    "                print('Enter weights (sum to 100) and click Run again.')\n",
-    "                return\n",
-    "            custom_w = {w.description[:-1]: w.value/100   # strip “:” at end\n",
-    "                        for w in weight_box.children} if mode=='manual' else {}\n",
-    "\n",
-    "            # 3) analysis\n",
-    "            globals()['fund_cols']   = ui_state['fund_cols']\n",
-    "            globals()['indices_list'] = ui_state['indices_list']\n",
-    "\n",
-    "            res = run_analysis(\n",
-    "                ui_state['df'],\n",
-    "                in1, in2,\n",
-    "                out1, out2,\n",
-    "                target_vol=0.05, monthly_cost=0.001,\n",
-    "                selection_mode=mode, random_n=rand_n,\n",
-    "                custom_weights=custom_w\n",
-    "            )\n",
-    "            if not res:\n",
-    "                print('❌ Analysis returned None (no valid funds?)'); return\n",
-    "\n",
-    "            res['indices_list'] = ui_state['indices_list']\n",
-    "            fname = f'Analysis_{in1}_{out1}.xlsx'\n",
-    "            export_to_excel(res, ui_state[\"df\"],\n",
-    "                            fname, in1,in2,out1,out2)\n",
-    "\n",
-    "            print('✅ Excel exported →', fname)\n",
-    "\n",
-    "        except Exception as ex:\n",
-    "            import traceback, textwrap\n",
-    "            print('🚨 Unhandled exception:\\n',\n",
-    "                  textwrap.indent(''.join(traceback.format_exc()), '    '))\n",
-    "\n",
-    "run_btn.on_click(_run_click)\n",
-    "\n",
-    "# ── Display the workflow UI ─────────────────────\n",
-    "display(config_btn, config_out, run_btn, run_out)\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup4-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup4-checkpoint.ipynb
deleted file mode 100644
index 876110c6b0f393dee8bb605ab5dc266267e56d1e..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup4-checkpoint.ipynb
+++ /dev/null
@@ -1,1708 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 1. SETUP CELL ============\n",
-    "\n",
-    "import logging\n",
-    "import sys\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import os\n",
-    "import math\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import interact, interactive, VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from IPython.utils.capture import capture_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import datetime\n",
-    "import random\n",
-    "import warnings\n",
-    "\n",
-    "# If you need to install these packages on your environment, uncomment:\n",
-    "!{sys.executable} -m pip install --quiet ipywidgets openpyxl xlsxwriter\n",
-    "\n",
-    "# For exporting to Excel with styling\n",
-    "import xlsxwriter\n",
-    "\n",
-    "# Set up logging to console\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "logging.info(\"Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\")\n",
-    "\n",
-    "# (Optional) If widgets aren't enabled, run:\n",
-    "# !jupyter nbextension enable --py widgetsnbextension --sys-prefix\n",
-    "\n",
-    "print(\"Setup complete.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify which column (after 'Date') is the risk-free rate by smallest stdev among columns.\n",
-    "    \"\"\"\n",
-    "    numeric_cols = df.columns[1:]  # skip the Date column\n",
-    "    stdevs = {}\n",
-    "    for col in numeric_cols:\n",
-    "        vals = df[col].dropna()\n",
-    "        if len(vals) > 0:\n",
-    "            stdevs[col] = vals.std()\n",
-    "        else:\n",
-    "            stdevs[col] = np.inf\n",
-    "\n",
-    "    rf_col = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "    return rf_col\n",
-    "\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 1) Helper to read a local CSV robustly (handles BOMs and minor parsing issues)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Try loading `path` as CSV in three ways:\n",
-    "    1. Default C engine\n",
-    "    2. BOM-stripped with the Python engine\n",
-    "    3. Skip bad lines with the Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception as e1:\n",
-    "        print(\"Default read_csv failed:\", e1)\n",
-    "\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception as e2:\n",
-    "        print(\"utf-8-sig + python engine failed:\", e2)\n",
-    "\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",    # for pandas ≥ 1.3\n",
-    "    )\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 2) Build the widgets\n",
-    "# ------------------------------------------------------------------------------\n",
-    "source_info = widgets.HTML(\n",
-    "    \"<b>Step 1: Choose your CSV</b><br>\"\n",
-    "    \"<i>Remember:</i> If you included any index columns (e.g. S&P 500, MSCI World, SG Trend), they \"\n",
-    "    \"must appear to the right of all fund columns in your sheet.\"\n",
-    ")\n",
-    "\n",
-    "\n",
-    "source_dropdown = widgets.Dropdown(\n",
-    "    options=['Local', 'GitHub'],\n",
-    "    value='Local',\n",
-    "    description='Data Source:',\n",
-    "    style={'description_width': '120px'}\n",
-    ")\n",
-    "\n",
-    "# FileChooser for Local mode\n",
-    "fc = FileChooser(os.getcwd())\n",
-    "fc.title = \"<b>Select local CSV file</b>\"\n",
-    "\n",
-    "# Text box for GitHub raw URL\n",
-    "github_text = widgets.Text(\n",
-    "    value=(\n",
-    "        \"https://raw.githubusercontent.com/stranske/Trend_Model_Project/\"\n",
-    "        \"main/data/TrendData.csv\"\n",
-    "    ),\n",
-    "    description=\"GitHub URL:\",\n",
-    "    layout=widgets.Layout(width=\"80%\"),\n",
-    ")\n",
-    "\n",
-    "# Ask how many index columns are on the far right\n",
-    "n_indices_widget = widgets.BoundedIntText(\n",
-    "    value=0,\n",
-    "    min=0,\n",
-    "    max=10,  # adjust if you expect more than 10 indices\n",
-    "    description='# Index cols:',\n",
-    "    style={'description_width': '120px'},\n",
-    "    tooltip=\"Enter the number of index columns at the far right of your CSV\"\n",
-    ")\n",
-    "\n",
-    "# Load button\n",
-    "load_button = widgets.Button(description=\"Load Data\", button_style=\"success\")\n",
-    "\n",
-    "# Output area for status and debug prints\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 3) Show/hide widgets depending on source selection\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_source_change(change):\n",
-    "    if change[\"new\"] == \"Local\":\n",
-    "        fc.layout.display = \"block\"\n",
-    "        github_text.layout.display = \"none\"\n",
-    "    else:\n",
-    "        fc.layout.display = \"none\"\n",
-    "        github_text.layout.display = \"block\"\n",
-    "\n",
-    "# Initially, GitHub textbox is hidden; FileChooser is visible\n",
-    "github_text.layout.display = \"none\"\n",
-    "fc.layout.display = \"block\"\n",
-    "\n",
-    "source_dropdown.observe(on_source_change, names=\"value\")\n",
-    "\n",
-    "ui_load = widgets.VBox([\n",
-    "    source_info,\n",
-    "    source_dropdown,\n",
-    "    fc,\n",
-    "    github_text,\n",
-    "    n_indices_widget,   # ← new widget here\n",
-    "    load_button,\n",
-    "    output_area\n",
-    "])\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 4) Callback for the Load button (auto-detect date format)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_load_clicked(_):\n",
-    "    global df, fund_cols, indices_list, rf_col            # declare df as global\n",
-    "    with output_area:\n",
-    "        output_area.clear_output()\n",
-    "        src_choice = source_dropdown.value\n",
-    "        n_indices = int(n_indices_widget.value)\n",
-    "\n",
-    "        # 4a) Load the DataFrame\n",
-    "        try:\n",
-    "            if src_choice == 'Local':\n",
-    "                local_path = fc.selected  # FileChooser’s selected path\n",
-    "                if not local_path or not os.path.exists(local_path):\n",
-    "                    print(f\"Error: Local file not found:\\n  {local_path}\")\n",
-    "                    return\n",
-    "                print(f\"Loading from local file:\\n  {local_path}\")\n",
-    "                df = pd.read_csv(local_path)\n",
-    "            else:\n",
-    "                github_url = github_text.value.strip()\n",
-    "                if not github_url:\n",
-    "                    print(\"Error: Please enter a valid GitHub raw URL.\")\n",
-    "                    return\n",
-    "                print(f\"Loading from GitHub URL:\\n  {github_url}\")\n",
-    "                df = pd.read_csv(github_url)\n",
-    "        except Exception as e:\n",
-    "            print(\"Failed to load CSV:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4b) Debug: print columns & a few rows\n",
-    "        print(\"Columns found in DataFrame:\", df.columns.tolist())\n",
-    "        display(df.head(3))\n",
-    "\n",
-    "        # 4c) Identify which column is the date\n",
-    "        date_col = None\n",
-    "        for candidate in [\"Date\", \"DATE\", \"date\"]:\n",
-    "            if candidate in df.columns:\n",
-    "                date_col = candidate\n",
-    "                break\n",
-    "\n",
-    "        if date_col is None:\n",
-    "            print(\"Error: No column named 'Date' / 'DATE' / 'date' found.\")\n",
-    "            print(\"Please check the column names above and adjust code accordingly.\")\n",
-    "            return\n",
-    "\n",
-    "        date_col = 'Date'\n",
-    "\n",
-    "        # 1) Show the first few raw date strings (un‐parsed) so we can inspect them\n",
-    "        raw_samples = df[date_col].dropna().astype(str).head(10).tolist()\n",
-    "        print(f\"Raw {date_col} samples (first 10 non‐null): {raw_samples!r}\")\n",
-    "\n",
-    "        # 2) Strip leading/trailing whitespace from every entry\n",
-    "        df[date_col] = df[date_col].astype(str).str.strip()\n",
-    "\n",
-    "        # 3) Now attempt strict \"%m/%d/%Y\" parsing\n",
-    "        parsed = pd.to_datetime(df[date_col], format=\"%m/%d/%Y\", errors=\"coerce\", infer_datetime_format=True)\n",
-    "        num_valid = parsed.notna().sum()\n",
-    "        print(f\"Number of rows matching '%m/%d/%Y' exactly: {num_valid} / {len(df)}\")\n",
-    "\n",
-    "        if num_valid > 0:\n",
-    "            df[date_col] = parsed\n",
-    "            print(f\"Parsing with '%m/%d/%Y' succeeded for {num_valid} rows.\")\n",
-    "        else:\n",
-    "            print(\n",
-    "                \"Warning: No rows matched '%m/%d/%Y'. \"\n",
-    "                \"Falling back to generic pd.to_datetime(...).\"\n",
-    "            )\n",
-    "            df[date_col] = pd.to_datetime(df[date_col], errors=\"coerce\")\n",
-    "\n",
-    "        # 5) Drop any rows where parsing still failed\n",
-    "        before_drop = len(df)\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        dropped = before_drop - len(df)\n",
-    "        if dropped:\n",
-    "            print(f\"Dropped {dropped} rows where '{date_col}' could not be parsed.\")\n",
-    "        \n",
-    "        # 6) Sort and reset index\n",
-    "        df.sort_values(by=date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "        \n",
-    "        # 7) Show the final parsed dates\n",
-    "        print(f\"After parsing, first 3 {date_col} values:\")\n",
-    "        print(df[[date_col]].head(3))\n",
-    "        print(f\"Loaded {len(df)} rows successfully.\")\n",
-    "\n",
-    "\n",
-    "        # 4d) Identify risk-free column\n",
-    "        try:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            print(f\"Identified risk-free column as: '{rf_col}'\")\n",
-    "        except Exception as e:\n",
-    "            print(\"Error identifying risk-free column:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4f) Determine fund_cols vs indices_list based on n_indices\n",
-    "        all_cols = df.columns.tolist()\n",
-    "        # We assume “Date” and rf_col are present. Everything else is a candidate.\n",
-    "        if 'Date' not in all_cols or rf_col not in all_cols:\n",
-    "            print(\"Error: 'Date' or risk-free column not found in DataFrame columns.\")\n",
-    "            return\n",
-    "        \n",
-    "        # Build list of all columns except 'Date' and rf_col\n",
-    "        remaining = [c for c in all_cols if c not in ['Date', rf_col]]\n",
-    "        \n",
-    "        if n_indices > len(remaining):\n",
-    "            print(\n",
-    "                f\"Error: You asked for {n_indices} index columns, but only \"\n",
-    "                f\"{len(remaining)} columns remain after 'Date' and '{rf_col}'.\"\n",
-    "            )\n",
-    "            return\n",
-    "\n",
-    "        if n_indices > 0:\n",
-    "            indices_list = remaining[-n_indices:]\n",
-    "            fund_cols    = remaining[:-n_indices]\n",
-    "        else:\n",
-    "            indices_list = []\n",
-    "            fund_cols    = remaining[:]\n",
-    "        print(\"\\n>> Debug (post‐load): fund_cols =\", fund_cols)\n",
-    "        print(\">> Debug (post‐load): indices_list =\", indices_list, \"\\n\")\n",
-    "        \n",
-    "        # 2F) Print out what we found\n",
-    "        print(f\"Detected fund columns ({len(fund_cols)}): {fund_cols}\")\n",
-    "        print(f\"Detected index columns ({len(indices_list)}): {indices_list}\")\n",
-    "        print(\n",
-    "            \"Data loaded and classified successfully.\\n\"\n",
-    "            \"Proceed to Step 2 (Run Analysis).\"\n",
-    "        )\n",
-    "\n",
-    " \n",
-    "        # 8) Confirm that df is now in global scope\n",
-    "        print(\">> df defined with\", len(df), \"rows and columns:\", df.columns.tolist())\n",
-    "\n",
-    "# 5) Wire up and display the UI\n",
-    "\n",
-    "load_button.on_click(on_load_clicked)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Utility functions loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Check if a series (sorted chronologically) has >= threshold consecutive NaNs.\n",
-    "    Return True if such a gap exists, False otherwise.\n",
-    "    \"\"\"\n",
-    "    consecutive = 0\n",
-    "    for val in series:\n",
-    "        if pd.isna(val):\n",
-    "            consecutive += 1\n",
-    "        else:\n",
-    "            consecutive = 0\n",
-    "        if consecutive >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "\n",
-    "def annualize_return(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized (geometric) return from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    growth_factor = (1 + valid_rets).prod()\n",
-    "    n_months = len(valid_rets)\n",
-    "    if growth_factor <= 0:\n",
-    "        return -1.0\n",
-    "    ann_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    return ann_ret\n",
-    "\n",
-    "def annualize_volatility(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized stdev of monthly returns, i.e. stdev * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) < 2:\n",
-    "        return np.nan\n",
-    "    return valid_rets.std() * np.sqrt(12)\n",
-    "\n",
-    "def sharpe_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe ratio = (annual_excess_return) / (annual_excess_vol).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    ann_excess_vol = excess.std() * np.sqrt(12)\n",
-    "    if ann_excess_vol == 0:\n",
-    "        return np.nan\n",
-    "    return ann_excess_ret / ann_excess_vol\n",
-    "\n",
-    "def sortino_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino ratio = (annual_excess_return) / (annual_downside_stdev).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "\n",
-    "    negative_mask = excess < 0\n",
-    "    negative_returns = excess[negative_mask]\n",
-    "    if len(negative_returns) == 0:\n",
-    "        return np.inf  # no negative => infinite sortino\n",
-    "    downside_stdev = negative_returns.std() * np.sqrt(12)\n",
-    "    return ann_excess_ret / downside_stdev\n",
-    "\n",
-    "def max_drawdown(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Compute max drawdown from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    wealth_index = (1 + valid_rets).cumprod()\n",
-    "    rolling_max = wealth_index.cummax()\n",
-    "    dd_series = 1 - (wealth_index / rolling_max)\n",
-    "    return dd_series.max()\n",
-    "\n",
-    "def calc_portfolio_returns(weights, df_returns):\n",
-    "    \"\"\"\n",
-    "    Compute monthly portfolio returns (Series) as weighted sum of columns in df_returns.\n",
-    "    \"\"\"\n",
-    "    return (df_returns * weights).sum(axis=1)\n",
-    "\n",
-    "print(\"Utility functions loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "4f1619c9",
-   "metadata": {},
-   "source": [
-    "## 4. Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "1e739b5c-2218-4653-97f8-e3cebe194183",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─────────────── Widget Setup + Callback ───────────────\n",
-    "\n",
-    "# ─── Phase 1: Date / Vol / Cost / Run Button ───\n",
-    "# ─── Phase 1: Date / Vol / Cost / Run Button ───\n",
-    "\n",
-    "in_sample_start     = widgets.Text(value='2005-07', description='In-Sample Start:')\n",
-    "in_sample_end       = widgets.Text(value='2008-06', description='In-Sample End:')\n",
-    "out_sample_start    = widgets.Text(value='2008-07', description='Out-Sample Start:')\n",
-    "out_sample_end      = widgets.Text(value='2009-06', description='Out-Sample End:')\n",
-    "\n",
-    "target_vol_widget   = widgets.FloatText(value=0.25, description='Target Vol:')\n",
-    "monthly_cost_widget = widgets.FloatText(value=0.0033, description='Monthly Cost:')\n",
-    "\n",
-    "run_button = widgets.Button(description='Run Analysis', button_style='success')\n",
-    "\n",
-    "# ← Replace any previous “output_area = widgets.Output()” with the block below:\n",
-    "output_area = widgets.Output(\n",
-    "    layout={\n",
-    "        'border': '1px solid gray',\n",
-    "        'height': '300px',\n",
-    "        'overflow_y': 'auto'   # optional: let it scroll if there’s too much text\n",
-    "    }\n",
-    ")\n",
-    "\n",
-    "# Pack only these into main_inputs for now—no display() yet.\n",
-    "main_inputs = widgets.VBox([\n",
-    "    in_sample_start,\n",
-    "    in_sample_end,\n",
-    "    out_sample_start,\n",
-    "    out_sample_end,\n",
-    "    target_vol_widget,\n",
-    "    monthly_cost_widget,\n",
-    "    run_button\n",
-    "])\n",
-    "\n",
-    "# ─── Phase 2: Build & Hide Mode / Random-Size / “Fund Table” placeholders ───\n",
-    "\n",
-    "# A) Mode dropdown (hidden initially)\n",
-    "selection_mode_widget = widgets.Dropdown(\n",
-    "    options=[('All Funds','all'), ('Random Sample','random'), ('Manual','manual')],\n",
-    "    value='all',\n",
-    "    description='Mode:'\n",
-    ")\n",
-    "selection_mode_widget.layout.display = 'none'\n",
-    "\n",
-    "# B) Random Sample Size field (hidden initially)\n",
-    "random_sample_size_widget = widgets.IntText(\n",
-    "    value=5, description='Sample Size:'\n",
-    ")\n",
-    "random_sample_size_widget.layout.display = 'none'\n",
-    "\n",
-    "# C) Placeholder containers for the Manual‐funds checkboxes & weights\n",
-    "fund_table_container = widgets.VBox([])   # we will populate it later\n",
-    "fund_table_container.layout.display = 'none'\n",
-    "\n",
-    "# D) Whenever Mode changes, show/hide “Sample Size” vs. “Fund Table”\n",
-    "def _on_mode_change(change):\n",
-    "    new_mode = change['new']\n",
-    "    if new_mode == 'random':\n",
-    "        random_sample_size_widget.layout.display = 'block'\n",
-    "        fund_table_container.layout.display   = 'none'\n",
-    "    elif new_mode == 'manual':\n",
-    "        random_sample_size_widget.layout.display = 'none'\n",
-    "        fund_table_container.layout.display   = 'block'\n",
-    "    else:  # 'all'\n",
-    "        random_sample_size_widget.layout.display = 'none'\n",
-    "        fund_table_container.layout.display   = 'none'\n",
-    "\n",
-    "selection_mode_widget.observe(_on_mode_change, names='value')\n",
-    "\n",
-    "# ─── Phase 3: Wire up “Run Analysis” + final display(...) ───\n",
-    "\n",
-    "phase_counter = {\"step\": 1}\n",
-    "\n",
-    "def on_run_clicked(b):\n",
-    "    with output_area:\n",
-    "        clear_output()\n",
-    "\n",
-    "        # 1) Read dates/vol/cost\n",
-    "        in_start_str     = in_sample_start.value.strip()\n",
-    "        in_end_str       = in_sample_end.value.strip()\n",
-    "        out_start_str    = out_sample_start.value.strip()\n",
-    "        out_end_str      = out_sample_end.value.strip()\n",
-    "        target_vol_val   = target_vol_widget.value\n",
-    "        monthly_cost_val = monthly_cost_widget.value\n",
-    "\n",
-    "        # 2) First click = reveal Mode dropdown + hide everything else\n",
-    "        if phase_counter[\"step\"] == 1:\n",
-    "            # Quick check: ensure date strings parse\n",
-    "            try:\n",
-    "                pd.to_datetime(in_start_str, format=\"%Y-%m\")\n",
-    "                pd.to_datetime(in_end_str,   format=\"%Y-%m\")\n",
-    "                pd.to_datetime(out_start_str, format=\"%Y-%m\")\n",
-    "                pd.to_datetime(out_end_str,   format=\"%Y-%m\")\n",
-    "            except Exception:\n",
-    "                print(\"❌ Invalid date formats. Please use YYYY-MM and click Run again.\")\n",
-    "                return\n",
-    "\n",
-    "            print(\"▶ Dates accepted. Now pick Mode (All / Random / Manual). \" \n",
-    "                  \"If Manual, you’ll then see the valid funds appear.\")\n",
-    "            selection_mode_widget.layout.display = 'block'\n",
-    "            phase_counter[\"step\"] = 2\n",
-    "            return\n",
-    "\n",
-    "        # 3) After first click, Mode is visible. If Mode changed to Manual, we need to\n",
-    "        #    build the fund_table with *only* those funds that pass the full‐history + no‐3-NA rule.\n",
-    "        if phase_counter[\"step\"] == 2:\n",
-    "            mode_val  = selection_mode_widget.value\n",
-    "            rnd_n_val = random_sample_size_widget.value if mode_val == 'random' else None\n",
-    "\n",
-    "            # If Manual mode is chosen, build fund_checkboxes & weight_boxes now:\n",
-    "            if mode_val == 'manual':\n",
-    "                # 3a) Determine which funds are “valid” for this date range.\n",
-    "                #     We reuse your existing `select_funds(...)` function, forcing selection_mode='all'.\n",
-    "                try:\n",
-    "                    in_sdate  = pd.to_datetime(in_start_str, format=\"%Y-%m\")\n",
-    "                    in_edate  = pd.to_datetime(in_end_str,   format=\"%Y-%m\") + pd.offsets.MonthEnd(0)\n",
-    "                    out_sdate = pd.to_datetime(out_start_str, format=\"%Y-%m\")\n",
-    "                    out_edate = pd.to_datetime(out_end_str,   format=\"%Y-%m\") + pd.offsets.MonthEnd(0)\n",
-    "                except Exception as e:\n",
-    "                    print(\"❌ Error parsing dates. Please re‐enter and click Run again.\")\n",
-    "                    return\n",
-    "\n",
-    "                # Build the “candidate fund_columns” list (exclude Date/rf/index columns)\n",
-    "                all_cols = [c for c in df.columns if c not in ['Date', identify_risk_free_fund(df)] + indices_list]\n",
-    "                # Call select_funds with selection_mode='all' to get the full list of valid funds.\n",
-    "                valid_funds = select_funds(\n",
-    "                    df,\n",
-    "                    identify_risk_free_fund(df),\n",
-    "                    fund_columns=all_cols,\n",
-    "                    in_sdate=in_sdate,\n",
-    "                    in_edate=in_edate,\n",
-    "                    out_sdate=out_sdate,\n",
-    "                    out_edate=out_edate,\n",
-    "                    selection_mode='all',\n",
-    "                    random_n=None\n",
-    "                )\n",
-    "\n",
-    "                if not valid_funds:\n",
-    "                    print(\"❌ No funds satisfy the full‐history & gap rules for these dates.\")\n",
-    "                    return\n",
-    "\n",
-    "                # 3b) Build a fresh table of checkboxes + IntText’s for valid_funds\n",
-    "                fund_table_rows = []\n",
-    "                fund_checkboxes = []\n",
-    "                weight_boxes    = []\n",
-    "\n",
-    "                for f in valid_funds:\n",
-    "                    cb = widgets.Checkbox(\n",
-    "                        value=False,\n",
-    "                        description=f,\n",
-    "                        layout=widgets.Layout(width='200px')\n",
-    "                    )\n",
-    "                    tb = widgets.BoundedIntText(\n",
-    "                        value=0,\n",
-    "                        min=0,\n",
-    "                        max=100,\n",
-    "                        step=1,\n",
-    "                        description=\"%\",          # user will type an integer percent\n",
-    "                        layout=widgets.Layout(width='160px')\n",
-    "                    )\n",
-    "                    tb.disabled = True  # only enabled when its checkbox is clicked\n",
-    "                    \n",
-    "                    fund_checkboxes.append(cb)\n",
-    "                    weight_boxes.append(tb)\n",
-    "\n",
-    "                    row = widgets.HBox([\n",
-    "                        cb,\n",
-    "                        weight_boxes[-1]\n",
-    "                    ], layout=widgets.Layout(margin=\"2px 0px\"))\n",
-    "                    fund_table_rows.append(row)\n",
-    "\n",
-    "                # Replace whatever was in fund_table_container with this new VBox\n",
-    "                fund_table_container.children = [widgets.VBox(fund_table_rows)]\n",
-    "                fund_table_container.layout.display = 'block'  # reveal it\n",
-    "\n",
-    "                # 3c) Wire up each checkbox so its weight box toggles on/off\n",
-    "                def _on_cb_change(change):\n",
-    "                    # ‘change.owner’ is the Checkbox that toggled\n",
-    "                    idx = fund_checkboxes.index(change.owner)\n",
-    "                    weight_boxes[idx].disabled = not change.new\n",
-    "\n",
-    "                for cb in fund_checkboxes:\n",
-    "                    cb.observe(_on_cb_change, names='value')\n",
-    "\n",
-    "            # Finally, show the random_sample_size_widget if needed\n",
-    "            if mode_val == 'random':\n",
-    "                random_sample_size_widget.layout.display = 'block'\n",
-    "\n",
-    "            print(\"▶ Now the Mode/sampling UI is visible. If Manual, pick funds + enter weights. Then click Run again.\")\n",
-    "            phase_counter[\"step\"] = 3\n",
-    "            return\n",
-    "\n",
-    "        # 4) After second click, everything (Mode + any Manual selections or random size) is set,\n",
-    "        #    so we can finally run `run_analysis(...)` for real:\n",
-    "        mode_val  = selection_mode_widget.value\n",
-    "        rnd_n_val = random_sample_size_widget.value if mode_val == 'random' else None\n",
-    "\n",
-    "        custom_weights = None\n",
-    "        if mode_val == 'manual':\n",
-    "            # Gather which checkboxes were checked, and read their weight_boxes\n",
-    "            selected = []\n",
-    "            weight_dict = {}\n",
-    "            # The fund_checkboxes + weight_boxes only exist if step>=2 and mode=='manual'.\n",
-    "            # We can grab them from fund_table_container.children.\n",
-    "            table_vbox = fund_table_container.children[0]   # the VBox we built above\n",
-    "            for row_hbox in table_vbox.children:\n",
-    "                cb, tb = row_hbox.children\n",
-    "                if cb.value:\n",
-    "                    selected.append(cb.description)\n",
-    "                    weight_dict[cb.description] = tb.value\n",
-    "\n",
-    "            total_w = sum(weight_dict.values())\n",
-    "            if not selected:\n",
-    "                print(\"⚠️ No funds checked—pick at least one fund.\")\n",
-    "                return\n",
-    "            if total_w != 100:\n",
-    "                print(f\"⚠️ Weights sum to {total_w}, but must be exactly 100. Fix and Run again.\")\n",
-    "                return\n",
-    "\n",
-    "            custom_weights = weight_dict\n",
-    "\n",
-    "        # 5) Now run the analysis for real\n",
-    "        print(\"▶ Running analysis with:\")\n",
-    "        print(f\"   In:   {in_start_str} → {in_end_str}\")\n",
-    "        print(f\"   Out:  {out_start_str} → {out_end_str}\")\n",
-    "        print(f\"   Vol:  {target_vol_val:.3%}, Cost: {monthly_cost_val:.3%}\")\n",
-    "        print(f\"   Mode: {mode_val}\" + (f\", Random N={rnd_n_val}\" if mode_val=='random' else \"\"))\n",
-    "        if mode_val == 'manual':\n",
-    "            print(f\"   Manual funds = {list(custom_weights.keys())}\")\n",
-    "            print(f\"   Weights = {custom_weights}\")\n",
-    "\n",
-    "        try:\n",
-    "            results = run_analysis(\n",
-    "                df,\n",
-    "                in_start=in_start_str,\n",
-    "                in_end=in_end_str,\n",
-    "                out_start=out_start_str,\n",
-    "                out_end=out_end_str,\n",
-    "                target_vol=target_vol_val,\n",
-    "                monthly_cost=monthly_cost_val,\n",
-    "                selection_mode=mode_val,\n",
-    "                random_n=rnd_n_val,\n",
-    "                custom_weights=custom_weights\n",
-    "            )\n",
-    "        except Exception as e:\n",
-    "            print(\"❌ Error inside run_analysis():\", e)\n",
-    "            return\n",
-    "\n",
-    "        if results is None or not results.get(\"selected_funds\"):\n",
-    "            print(\"❌ No valid funds remain after filtering.\")\n",
-    "            return\n",
-    "\n",
-    "        # 6) Print a brief summary & export to Excel\n",
-    "        sf = results[\"selected_funds\"]\n",
-    "        print(\"✅ Analysis complete:\")\n",
-    "        print(f\"   Funds selected: {len(sf)} → {sf}\")\n",
-    "        print(\"   Manual funds & weights:\")\n",
-    "        if custom_weights is not None:\n",
-    "            print(\"   Manual funds & weights:\")\n",
-    "            for f, w in custom_weights.items():\n",
-    "                print(f\"     • {f}: {w}%\")\n",
-    "        if \"in_ew_stats\" in results:\n",
-    "            ir, iv, isr, *_ = results[\"in_ew_stats\"]\n",
-    "            print(f\"   In‐Sample EW → R {ir*100:.2f}%, V {iv*100:.2f}%, S {isr:.2f}\")\n",
-    "        if \"out_ew_stats\" in results:\n",
-    "            or_, ov, osr, *_ = results[\"out_ew_stats\"]\n",
-    "            print(f\"   Out‐Sample EW → R {or_*100:.2f}%, V {ov*100:.2f}%, S {osr:.2f}\")\n",
-    "\n",
-    "        print(\">> about to write Excel with custom_weights =\", custom_weights)\n",
-    "\n",
-    "        # Add the filename\n",
-    "        global fname\n",
-    "        fname = f\"IS_{in_start_str}_{out_start_str}.xlsx\"\n",
-    "    \n",
-    "        export_to_excel(\n",
-    "            results,\n",
-    "            df,            # your full DataFrame\n",
-    "            fname,         \n",
-    "            in_start_str,  \n",
-    "            in_end_str,    \n",
-    "            out_start_str, \n",
-    "            out_end_str    \n",
-    "        )\n",
-    "        print(f\"   Excel file created: IS_{in_start_str}_{out_start_str}.xlsx\")\n",
-    "        import inspect\n",
-    "        print(inspect.getsource(export_to_excel))\n",
-    "\n",
-    "\n",
-    "run_button.on_click(on_run_clicked)\n",
-    "\n",
-    "# ─── Finally, show everything (Phase 1 + Phase 2 placeholders + output area) ───\n",
-    "\n",
-    "master_vbox = widgets.VBox([\n",
-    "    main_inputs,\n",
-    "    selection_mode_widget,\n",
-    "    random_sample_size_widget,\n",
-    "    fund_table_container\n",
-    "])\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "## 5. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "c5867ccd-a550-4849-a10b-a085f5fe26fd",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "select_funds (replaced) is ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# --- PATCH: clean select_funds() -------------------------------------------\n",
-    "def select_funds(\n",
-    "    df,                 # full DataFrame incl. 'Date'\n",
-    "    rf_col,             # risk-free column name\n",
-    "    fund_columns,       # candidate fund list\n",
-    "    in_sdate, in_edate, # in-sample bounds  (pd.Timestamp)\n",
-    "    out_sdate, out_edate,# out-sample bounds (pd.Timestamp)\n",
-    "    selection_mode=\"all\",\n",
-    "    random_n=8,\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Return a vetted list of fund tickers.\n",
-    "\n",
-    "    • Excludes names containing 'index'\n",
-    "    • Requires *no* NaN values inside either window\n",
-    "    • Requires < 3 consecutive NaNs inside either window\n",
-    "    • Supports selection_mode ∈ {\"all\", \"random\", \"manual\"}\n",
-    "    \"\"\"\n",
-    "    # --- 1) start from caller-supplied list  -------------------------------\n",
-    "    candidates = fund_columns.copy()\n",
-    "\n",
-    "    # --- 2) drop obvious indices ------------------------------------------\n",
-    "    not_index = [f for f in candidates if \"index\" not in f.lower()]\n",
-    "\n",
-    "    # --- 3) full-history test (no NaN in either window) --------------------\n",
-    "    full_hist = []\n",
-    "    for f in not_index:\n",
-    "        ins  = df.loc[(df[\"Date\"] >= in_sdate)  & (df[\"Date\"] <= in_edate),  f]\n",
-    "        outs = df.loc[(df[\"Date\"] >= out_sdate) & (df[\"Date\"] <= out_edate), f]\n",
-    "        if ins.notna().all() and outs.notna().all():\n",
-    "            full_hist.append(f)\n",
-    "\n",
-    "    # --- 4) max-run-length test (< 3 consecutive NaNs) ---------------------\n",
-    "    vetted = []\n",
-    "    for f in full_hist:\n",
-    "        # helper that returns longest NaN run length\n",
-    "        def _max_run(s):\n",
-    "            isn = s.isna().astype(int)\n",
-    "            return isn.groupby((isn == 0).cumsum()).sum().max()\n",
-    "        if _max_run(df.loc[(df[\"Date\"] >= in_sdate)  & (df[\"Date\"] <= in_edate),  f]) < 3 and \\\n",
-    "           _max_run(df.loc[(df[\"Date\"] >= out_sdate) & (df[\"Date\"] <= out_edate), f]) < 3:\n",
-    "            vetted.append(f)\n",
-    "\n",
-    "    # --- 5) final selection -----------------------------------------------\n",
-    "    if selection_mode == \"random\":\n",
-    "        k = min(random_n, len(vetted))\n",
-    "        vetted = random.sample(vetted, k)\n",
-    "    # selection_mode == \"manual\" just hands back the vetted list;\n",
-    "    # run_analysis (or the UI) decides what to do with it later.\n",
-    "\n",
-    "    logging.info(f\"select_funds → {len(vetted)} funds after all filters\")\n",
-    "    return vetted\n",
-    "# --------------------------------------------------------------------------\n",
-    "\n",
-    "print(\"select_funds (replaced) is ready.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 6. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "get_custom_weights function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    Returns dict {fund: weight_decimal}.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=f\"{fund}\",\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    \n",
-    "    confirm_button = widgets.Button(\n",
-    "        description='Confirm Weights',\n",
-    "        button_style='success'\n",
-    "    )\n",
-    "    error_label = widgets.Label(value='', layout=widgets.Layout(color='red'))\n",
-    "    \n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm_button, error_label])\n",
-    "    display(box)\n",
-    "    \n",
-    "    weights_container = {}\n",
-    "    \n",
-    "    def on_confirm_clicked(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_label.value = f\"Error: Weights sum to {total}, must be 100.\"\n",
-    "            weights_container.clear()\n",
-    "        else:\n",
-    "            for fund, wdg in weight_widgets.items():\n",
-    "                weights_container[fund] = wdg.value / 100.0\n",
-    "            error_label.value = \"Weights confirmed!\"\n",
-    "    \n",
-    "    confirm_button.on_click(on_confirm_clicked)\n",
-    "    return weights_container\n",
-    "\n",
-    "print(\"get_custom_weights function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 7. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 7,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "run_analysis (with checkpoints) is defined.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def run_analysis(\n",
-    "    df,\n",
-    "    in_start, in_end, out_start, out_end,\n",
-    "    target_vol, monthly_cost,\n",
-    "    selection_mode='all',\n",
-    "    random_n=8,\n",
-    "    custom_weights=None    # ← new argument\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Parse/validate date inputs\n",
-    "    2) Convert Date column if needed\n",
-    "    3) Identify rf_col\n",
-    "    4) Prepare in/out sample DataFrames\n",
-    "    5) CALL select_funds (with debug) and print checkpoints\n",
-    "    6) Compute scale_factors and wrap stats in try/except\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # —(1) Parse input dates (YYYY-MM) into actual month-end timestamps\n",
-    "    in_sdate  = pd.to_datetime(in_start + \"-01\", errors='coerce')\n",
-    "    in_edate  = pd.to_datetime(in_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "    out_sdate = pd.to_datetime(out_start + \"-01\", errors='coerce')\n",
-    "    out_edate = pd.to_datetime(out_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    # checkpoint A\n",
-    "    print(\"CHECKPOINT A: Dates parsed:\", in_sdate, in_edate, out_sdate, out_edate)\n",
-    "\n",
-    "    # —(2) Ensure 'Date' column is datetime64\n",
-    "    if not np.issubdtype(df['Date'].dtype, np.datetime64):\n",
-    "        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "        df.dropna(subset=['Date'], inplace=True)\n",
-    "        df.sort_values(by='Date', inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "    # checkpoint B\n",
-    "    print(\"CHECKPOINT B: Date column is datetime64, first dates:\",\n",
-    "          df['Date'].iloc[0], \"…\", df['Date'].iloc[-1])\n",
-    "\n",
-    "    # —(3) Identify risk-free column\n",
-    "    rf_col = identify_risk_free_fund(df)\n",
-    "    print(f\"INFO: Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "\n",
-    "    # —(4) Slice into in-sample & out-sample\n",
-    "    in_sample_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_sample_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "    in_sample_rf  = in_sample_df[rf_col]\n",
-    "    out_sample_rf = out_sample_df[rf_col]\n",
-    "\n",
-    "    print(f\"CHECKPOINT C: in_sample rows = {len(in_sample_df)}, out_sample rows = {len(out_sample_df)}\")\n",
-    "\n",
-    "    all_cols = [c for c in df.columns if c not in [\"Date\", rf_col]]\n",
-    "    if \"indices_list\" in globals():                 # optional, harmless if absent\n",
-    "        all_cols = [c for c in all_cols if c not in indices_list]\n",
-    "        \n",
-    "    # —(5) Select funds (either “manual” or via select_funds)\n",
-    "    if selection_mode == 'manual' and custom_weights is not None:\n",
-    "        # In manual mode, we trust the user’s chosen tickers outright\n",
-    "        selected_funds = list(custom_weights.keys())\n",
-    "        print(f\"CHECKPOINT D (manual): using custom_weights keys → {selected_funds}\")\n",
-    "    else:\n",
-    "        print(f\"CHECKPOINT D: about to call select_funds with {len(all_cols)} candidates\")\n",
-    "\n",
-    "        selected_funds = select_funds(\n",
-    "            df,\n",
-    "            rf_col,\n",
-    "            fund_columns=all_cols,\n",
-    "            in_sdate=in_sdate,\n",
-    "            in_edate=in_edate,\n",
-    "            out_sdate=out_sdate,\n",
-    "            out_edate=out_edate,\n",
-    "            selection_mode=selection_mode,\n",
-    "            random_n=random_n\n",
-    "        )\n",
-    "\n",
-    "    if len(selected_funds) == 0:\n",
-    "        logging.warning(\"No valid funds remain after filtering.\")\n",
-    "        print(\"Warning: No valid funds. Try adjusting your selection or data filters.\")\n",
-    "        return None\n",
-    "\n",
-    "    print(f\"CHECKPOINT E: select_funds returned {len(selected_funds)} funds → {selected_funds}\")\n",
-    "\n",
-    "    # indices_list must already exist as a global list of index columns\n",
-    "    in_sample_indices  = in_sample_df[indices_list].copy()\n",
-    "    out_sample_indices = out_sample_df[indices_list].copy()\n",
-    "\n",
-    "    # —(6) Compute scale_factors (based on in-sample volatility)\n",
-    "    scale_factors = {}\n",
-    "    for fund in selected_funds:\n",
-    "        fund_in_rets = in_sample_df[fund].dropna()\n",
-    "        current_vol  = annualize_volatility(fund_in_rets)\n",
-    "        if pd.isna(current_vol) or current_vol == 0:\n",
-    "            scale_factors[fund] = 1.0\n",
-    "        else:\n",
-    "            scale_factors[fund] = target_vol / current_vol\n",
-    "\n",
-    "    print(\"CHECKPOINT F: scale_factors computed (showing first 5):\",\n",
-    "          {f: scale_factors[f] for f in selected_funds[:5]})\n",
-    "\n",
-    "    # Pre-allocate DataFrames for scaled returns\n",
-    "    in_sample_scaled  = pd.DataFrame(index=in_sample_df.index, columns=selected_funds)\n",
-    "    out_sample_scaled = pd.DataFrame(index=out_sample_df.index, columns=selected_funds)\n",
-    "\n",
-    "    # ── Wrap everything from “scaling + stats” in a try/except ──\n",
-    "    try:\n",
-    "        # (6a) Scale returns (with monthly cost)\n",
-    "        for fund in selected_funds:\n",
-    "            sf     = scale_factors[fund]\n",
-    "            adj_in = in_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_in[adj_in < -1.0] = -1.0\n",
-    "            in_sample_scaled[fund] = adj_in\n",
-    "\n",
-    "            if not out_sample_df.empty:\n",
-    "                adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "                adj_out[adj_out < -1.0] = -1.0\n",
-    "                out_sample_scaled[fund] = adj_out\n",
-    "\n",
-    "        # (6b) Helper to compute per-series stats\n",
-    "        def compute_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            sr  = sharpe_ratio(series, rf_series)\n",
-    "            so  = sortino_ratio(series, rf_series)\n",
-    "            mdd = max_drawdown(series)\n",
-    "            return (r, v, sr, so, mdd)\n",
-    "\n",
-    "        # (6c) In-sample per-fund stats\n",
-    "        in_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "\n",
-    "        # (6d) Out-sample per-fund (vol-adjusted) stats\n",
-    "        out_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6e) Out-sample per-fund (raw) stats\n",
-    "        out_sample_stats_raw = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6f) Equal-weight portfolio returns\n",
-    "        ew_weight_dict = { f: 1.0/len(selected_funds) for f in selected_funds }\n",
-    "        ew_w           = np.array([ ew_weight_dict[f] for f in selected_funds ])\n",
-    "        in_ew_port      = calc_portfolio_returns(ew_w,       in_sample_scaled[selected_funds])\n",
-    "        out_ew_port     = calc_portfolio_returns(ew_w,       out_sample_scaled[selected_funds])\n",
-    "        out_ew_port_raw = calc_portfolio_returns(ew_w,       out_sample_df[selected_funds])\n",
-    "        \n",
-    "        in_ew_stats      = compute_stats(in_ew_port,      in_sample_rf)\n",
-    "        out_ew_stats     = compute_stats(out_ew_port,     out_sample_rf)\n",
-    "        out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6g) Index statistics (treat each index like “just another series”)\n",
-    "        in_index_stats  = {}\n",
-    "        out_index_stats = {}\n",
-    "        for idx in indices_list:\n",
-    "            in_index_stats[idx]  = compute_stats(in_sample_indices[idx],  in_sample_df[rf_col])\n",
-    "            out_index_stats[idx] = compute_stats(out_sample_indices[idx], out_sample_df[rf_col])\n",
-    "\n",
-    "        # (6h) “User-weight” portfolio\n",
-    "        if custom_weights is None:\n",
-    "            # If no manual weights → just reuse the same equal‐weight array\n",
-    "            user_weight_dict = ew_weight_dict.copy()\n",
-    "            # ← **IMPORTANT FIX**: define custom_w here for the equal-weight case\n",
-    "            custom_w = ew_w.copy()  \n",
-    "        else:\n",
-    "            # Manual weights passed → convert percentages to decimals\n",
-    "            user_weight_dict = { f: custom_weights[f] / 100.0 for f in selected_funds }\n",
-    "            custom_w         = np.array([ user_weight_dict[f] for f in selected_funds ])\n",
-    "\n",
-    "        # (6i) Compute “user-weighted” portfolio returns\n",
-    "        in_user_port      = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "        out_user_port     = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "        out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        # (6j) Compute their stats\n",
-    "        in_user_stats      = compute_stats(in_user_port,      in_sample_rf)\n",
-    "        out_user_stats     = compute_stats(out_user_port,     out_sample_rf)\n",
-    "        out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6k) Build the final results dict **(FIXED: removed duplicate 'fund_weights')**\n",
-    "        results = {\n",
-    "            'selected_funds':       selected_funds,\n",
-    "            'in_sample_scaled':     in_sample_scaled,\n",
-    "            'out_sample_scaled':    out_sample_scaled,\n",
-    "            'in_sample_stats':      in_sample_stats,\n",
-    "            'out_sample_stats':     out_sample_stats,\n",
-    "            'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "            'in_ew_stats':          in_ew_stats,\n",
-    "            'out_ew_stats':         out_ew_stats,\n",
-    "            'out_ew_stats_raw':     out_ew_stats_raw,\n",
-    "            'in_user_stats':        in_user_stats,\n",
-    "            'out_user_stats':       out_user_stats,\n",
-    "            'out_user_stats_raw':   out_user_stats_raw,\n",
-    "            'ew_weights':           ew_weight_dict,     # ← now returns equal-weight dict\n",
-    "            'fund_weights':         user_weight_dict,   # ← returns manual weights (or equal if none)\n",
-    "            'indices_list':         indices_list\n",
-    "        }\n",
-    "\n",
-    "    except Exception as e:\n",
-    "        print(\"ERROR inside stats-block:\", e)\n",
-    "        return None\n",
-    "\n",
-    "    # Everything succeeded\n",
-    "    return results\n",
-    "\n",
-    "\n",
-    "\n",
-    "print(\"run_analysis (with checkpoints) is defined.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 8. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 8,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─── Helper #1: build the equal- and user-weight DataFrames ────────────────────────────────\n",
-    "def make_portfolio_dfs(results, sample='in'):\n",
-    "    \"\"\"\n",
-    "    Returns (eq_df, user_df) for either 'in' or 'out' sample.\n",
-    "    \"\"\"\n",
-    "    # pick the right stats:\n",
-    "    stats_dict      = results[f'{sample}_sample_stats']\n",
-    "    ew_stats        = results[f'{sample}_ew_stats']\n",
-    "    user_stats      = results[f'{sample}_user_stats']\n",
-    "    fund_weights    = results['fund_weights']\n",
-    "    funds           = results['selected_funds']\n",
-    "\n",
-    "    def build_block(portf_label, stats, include_weights):\n",
-    "        rows = []\n",
-    "        # portfolio row\n",
-    "        r, v, sr, so, mdd = stats\n",
-    "        rows.append({\n",
-    "            'Fund': portf_label,\n",
-    "            'Weight': 100,\n",
-    "            'Return (%)': r,\n",
-    "            'Volatility (%)': v,\n",
-    "            'Sharpe Ratio': sr,\n",
-    "            'Sortino Ratio': so,\n",
-    "            'Max Drawdown (%)': mdd\n",
-    "        })\n",
-    "        # one‐row per fund\n",
-    "        for f in funds:\n",
-    "            r, v, sr, so, mdd = stats_dict[f]\n",
-    "            w = int(round(fund_weights[f] * 100)) if include_weights else None\n",
-    "            rows.append({\n",
-    "                'Fund': f,\n",
-    "                'Weight': w,\n",
-    "                'Return (%)': r,\n",
-    "                'Volatility (%)': v,\n",
-    "                'Sharpe Ratio': sr,\n",
-    "                'Sortino Ratio': so,\n",
-    "                'Max Drawdown (%)': mdd\n",
-    "            })\n",
-    "        return pd.DataFrame(rows)\n",
-    "\n",
-    "    eq_df   = build_block('Equal-Weight Portfolio', ew_stats,   True)\n",
-    "    user_df = build_block('User-Weight Portfolio', user_stats, True)\n",
-    "    return eq_df, user_df\n",
-    "\n",
-    "\n",
-    "# ─── Helper #2: build an indices table ─────────────────────────────────────────────────────\n",
-    "def make_indices_df(df, indices, start, end):\n",
-    "    \"\"\"\n",
-    "    Compute (Return, Vol, Sharpe, Sortino, MDD) for each index in [start, end],\n",
-    "    return a DataFrame with columns Index, Return (%), Volatility (%), …\n",
-    "    \"\"\"\n",
-    "    in_s, in_e = pd.to_datetime(start+'-01'), pd.to_datetime(end+'-01') + pd.offsets.MonthEnd(0)\n",
-    "    rows = []\n",
-    "    rf = identify_risk_free_fund(df)\n",
-    "    sub = df.set_index('Date').loc[in_s:in_e]\n",
-    "    for idx in indices:\n",
-    "        series = sub[idx]\n",
-    "        rf_ser = sub[rf]\n",
-    "        r  = annualize_return(series)\n",
-    "        v  = annualize_volatility(series)\n",
-    "        sr = sharpe_ratio(series, rf_ser)\n",
-    "        so = sortino_ratio(series, rf_ser)\n",
-    "        mdd = max_drawdown(series)\n",
-    "        rows.append({\n",
-    "            'Index': idx,\n",
-    "            'Return (%)': r,\n",
-    "            'Volatility (%)': v,\n",
-    "            'Sharpe Ratio': sr,\n",
-    "            'Sortino Ratio': so,\n",
-    "            'Max Drawdown (%)': mdd\n",
-    "        })\n",
-    "    return pd.DataFrame(rows)\n",
-    "\n",
-    "\n",
-    "# ─── Helper #3: write & format one sheet ──────────────────────────────────────────────────\n",
-    "# Apply uniform column widths & formats\n",
-    "    #   (col_idx, width, format_obj)\n",
-    "COLUMN_SPECS = [\n",
-    "    (0, 28, None),\n",
-    "    (1, 12, 'int'),\n",
-    "    (2, 15, 'pct1'),\n",
-    "    (3, 15, 'pct1'),\n",
-    "    (4, 15, 'dec2'),\n",
-    "    (5, 15, 'dec2'),\n",
-    "    (6, 15, 'pct1'),\n",
-    "]\n",
-    "\n",
-    "def build_formats(wb):\n",
-    "    return {\n",
-    "      'int':   wb.add_format({'num_format':'0'}),\n",
-    "      'pct1':  wb.add_format({'num_format':'0.0%'}),\n",
-    "      'dec2':  wb.add_format({'num_format':'0.00'}),\n",
-    "      'bold':  wb.add_format({'bold':True}),\n",
-    "    }\n",
-    "    \n",
-    "def write_portfolio_sheet(writer, sheet_name, eq_df, user_df, fmt):\n",
-    "    # Create & register the sheet\n",
-    "    ws = writer.book.add_worksheet(sheet_name)\n",
-    "    writer.sheets[sheet_name] = ws\n",
-    "\n",
-    "    # 1) Write the two tables with keyword-only args\n",
-    "    eq_df.to_excel(excel_writer=writer,\n",
-    "                   sheet_name=sheet_name,\n",
-    "                   startrow=0,\n",
-    "                   index=False)\n",
-    "    user_df.to_excel(excel_writer=writer,\n",
-    "                     sheet_name=sheet_name,\n",
-    "                     startrow=len(eq_df) + 3,\n",
-    "                     index=False)\n",
-    "\n",
-    "    for col_idx, width, fmt_key in COLUMN_SPECS:\n",
-    "        # if fmt_key is None, use no format; otherwise pull from fmt\n",
-    "        fmt_obj = fmt[fmt_key] if fmt_key else None\n",
-    "        ws.set_column(col_idx, col_idx, width, fmt_obj)\n",
-    "\n",
-    "    # Bold the headers\n",
-    "    bold = fmt['bold']\n",
-    "    for j, h in enumerate(eq_df.columns):\n",
-    "        ws.write(0, j, h, fmt['bold'])\n",
-    "    start = len(eq_df) + 3\n",
-    "    for j, h in enumerate(user_df.columns):\n",
-    "        ws.write(start, j, h, fmt['bold'])\n",
-    "\n",
-    "\n",
-    "def write_indices_block(writer, sheet_name, df_idx, start_row, fmt):\n",
-    "    \"\"\"\n",
-    "    Write the indices block to the given sheet at start_row\n",
-    "    \"\"\"\n",
-    "    # Grab the worksheet from the writer\n",
-    "    ws = writer.sheets[sheet_name]\n",
-    "    bold_fmt = fmt['bold']\n",
-    "\n",
-    "    # Label\n",
-    "    ws.write(start_row - 1, 0, f\"Indices ({sheet_name}):\", bold_fmt)\n",
-    "\n",
-    "    # Dump the DataFrame\n",
-    "    df_idx.to_excel(\n",
-    "        excel_writer=writer,\n",
-    "        sheet_name=sheet_name,\n",
-    "        startrow=start_row,\n",
-    "        index=False\n",
-    "    )\n",
-    "\n",
-    "    # Apply the same COLUMN_SPECS formats as the portfolio tables\n",
-    "    for col_idx, width, fmt_key in COLUMN_SPECS:\n",
-    "        fmt_obj = fmt.get(fmt_key) if fmt_key else None\n",
-    "        ws.set_column(col_idx, col_idx, width, fmt_obj)\n",
-    "\n",
-    "    # Bold the header row of the indices table\n",
-    "    ws.set_row(start_row, None, bold_fmt)\n",
-    "\n",
-    "def export_to_excel(results, df, output_filename,\n",
-    "                    in_start, in_end, out_start, out_end):\n",
-    "    writer  = pd.ExcelWriter(output_filename, engine='xlsxwriter')\n",
-    "    wb     = writer.book\n",
-    "    formats = build_formats(wb)\n",
-    "\n",
-    "    # 1) portfolio sheets\n",
-    "    in_eq,  in_user  = make_portfolio_dfs(results, sample='in')\n",
-    "    out_eq, out_user = make_portfolio_dfs(results, sample='out')\n",
-    "  \n",
-    "    # 2) indices sheets\n",
-    "    idx_in  = make_indices_df(df, results['indices_list'], in_start,  in_end)\n",
-    "    idx_out = make_indices_df(df, results['indices_list'], out_start, out_end)\n",
-    "    # compute where to start: right after user_df\n",
-    "    start_in  = len(in_eq)  + len(in_user)  + 6\n",
-    "    start_out = len(out_eq) + len(out_user) + 6\n",
-    "\n",
-    "    write_portfolio_sheet(writer, f\"IS {in_start}-{in_end}\", in_eq,  in_user,  formats)\n",
-    "    write_portfolio_sheet(writer, f\"OS {out_start}-{out_end}\", out_eq, out_user, formats)\n",
-    "    write_indices_block(writer, f\"IS {in_start}-{in_end}\", idx_in,  start_in,  formats)\n",
-    "    write_indices_block(writer, f\"OS {out_start}-{out_end}\", idx_out, start_out, formats)\n",
-    "\n",
-    "    writer.close()\n",
-    "\n",
-    "    logging.info(f\"Exported analysis to {output_filename} successfully.\")\n",
-    "    print(f\"Excel file created: {output_filename}\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Run Parameters"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 9,
-   "id": "9899f2e3-9c6e-4c38-b3eb-d07e8f871462",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "be1f83c049ef4ddf817bf285fc42b27d",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Button(button_style='info', description='Configure Analysis', style=ButtonStyle())"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "7613b92562504d2f8dc56f5287df27de",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Output()"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "4e0b8eed00384c17bdb494e5d0c6514c",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Button(button_style='primary', description='Run Analysis', disabled=True, style=ButtonStyle())"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "44f0a36bb34c4bd6aa60b81c7721d513",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Output()"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "if 'run_analysis' not in globals():\n",
-    "    raise RuntimeError(\"Run the function-definition cell first!\")\n",
-    "\n",
-    "# ──────────────────────────────────────────────────────────────\n",
-    "#  CONFIGURE  +  RUN   (single-page)  UI\n",
-    "# ──────────────────────────────────────────────────────────────\n",
-    "import ipywidgets as widgets\n",
-    "from ipyfilechooser import FileChooser\n",
-    "from IPython.display import display, clear_output\n",
-    "\n",
-    "# persistent scratch-pad\n",
-    "ui_state = {}\n",
-    "\n",
-    "# ── CSV loader widgets ─────────────────────────\n",
-    "src_toggle   = widgets.ToggleButtons(options=['Local', 'GitHub'],\n",
-    "                                     description='Source:')\n",
-    "fc           = FileChooser()                      # local picker\n",
-    "fc.title     = '<b>Select CSV</b>'\n",
-    "gh_url       = widgets.Text(value='', description='GitHub URL:')\n",
-    "load_btn     = widgets.Button(description='Load CSV',\n",
-    "                              button_style='success')\n",
-    "load_out     = widgets.Output()\n",
-    "\n",
-    "def _toggle_src(change):\n",
-    "    if change['new'] == 'Local':\n",
-    "        fc.layout.display = 'block' ; gh_url.layout.display = 'none'\n",
-    "    else:\n",
-    "        fc.layout.display = 'none'  ; gh_url.layout.display = 'block'\n",
-    "src_toggle.observe(_toggle_src, names='value')\n",
-    "gh_url.layout.display = 'none'      # start hidden\n",
-    "\n",
-    "# ── analysis-parameter widgets ─────────────────\n",
-    "mode_w   = widgets.ToggleButtons(options=['all','random','manual'],\n",
-    "                                 value='all', description='Mode:')\n",
-    "rand_w   = widgets.BoundedIntText(value=8,  min=1, max=100,\n",
-    "                                  description='Random N:')\n",
-    "idx_w    = widgets.BoundedIntText(value=0,  min=0, max=10,\n",
-    "                                  description='# Indices:')\n",
-    "\n",
-    "in_s  = widgets.Text(value='2005-07', description='In Start:')\n",
-    "in_e  = widgets.Text(value='2008-06', description='In End:')\n",
-    "out_s = widgets.Text(value='2008-07', description='Out Start:')\n",
-    "out_e = widgets.Text(value='2009-06', description='Out End:')\n",
-    "\n",
-    "# manual-weights placeholders (pop up only if needed)\n",
-    "weight_box = widgets.VBox([])\n",
-    "\n",
-    "# ── 1)  Configure step ─────────────────────────\n",
-    "config_btn   = widgets.Button(description='Configure Analysis',\n",
-    "                              button_style='info')\n",
-    "config_out   = widgets.Output()\n",
-    "\n",
-    "def _load_csv(_):\n",
-    "    \"\"\"Load CSV → ui_state['df'], ui_state['fund_cols'], ui_state['indices']\"\"\"\n",
-    "    load_out.clear_output()\n",
-    "    with load_out:\n",
-    "        try:\n",
-    "            if src_toggle.value == 'Local':\n",
-    "                path = fc.selected\n",
-    "                df = robust_read_csv(path)\n",
-    "                print(f'Loaded local file: {path}')\n",
-    "            else:\n",
-    "                url = gh_url.value.strip()\n",
-    "                df = robust_read_csv(url)\n",
-    "                print(f'Loaded GitHub file: {url}')\n",
-    "        except Exception as e:\n",
-    "            print('❌ CSV load failed:', e); return\n",
-    "\n",
-    "        # basic date parsing (same logic as notebook)\n",
-    "        date_col = next(c for c in df.columns if c.lower().startswith('date'))\n",
-    "        df[date_col] = pd.to_datetime(df[date_col], errors='coerce')\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        df.sort_values(date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "        rf = identify_risk_free_fund(df)\n",
-    "        cols = [c for c in df.columns if c not in [date_col, rf]]\n",
-    "        n_idx = idx_w.value\n",
-    "        indices = cols[-n_idx:] if 0 < n_idx <= len(cols) else []\n",
-    "        funds   = cols[:-n_idx]  if 0 < n_idx <= len(cols) else cols\n",
-    "\n",
-    "        print(f'🗂  {len(funds)} fund columns, {len(indices)} index columns.')\n",
-    "        ui_state.update(df=df,\n",
-    "                        date_col=date_col,\n",
-    "                        rf_col=rf,\n",
-    "                        fund_cols=funds,\n",
-    "                        indices_list=indices)\n",
-    "        # enable Run button once data is ready\n",
-    "        run_btn.disabled = False\n",
-    "\n",
-    "load_btn.on_click(_load_csv)\n",
-    "\n",
-    "def _config_click(_):\n",
-    "    config_out.clear_output()\n",
-    "    with config_out:\n",
-    "        display(widgets.HTML('<h3>Load CSV</h3>'),\n",
-    "                src_toggle, fc, gh_url, idx_w, load_btn, load_out,\n",
-    "                widgets.HTML('<hr style=\"height:1px\">'),\n",
-    "                widgets.HTML('<h3>Analysis Parameters</h3>'),\n",
-    "                HBox([mode_w, rand_w]),\n",
-    "                HBox([in_s, in_e, out_s, out_e]),\n",
-    "                weight_box)\n",
-    "        run_btn.disabled = True   # disabled until CSV successfully loads\n",
-    "config_btn.on_click(_config_click)\n",
-    "\n",
-    "# ── 2)  Run step ───────────────────────────────\n",
-    "run_btn   = widgets.Button(description='Run Analysis',\n",
-    "                           button_style='primary', disabled=True)\n",
-    "run_out   = widgets.Output()\n",
-    "\n",
-    "def _run_click(_):\n",
-    "    # Force-replace any older run_analysis still in memory\n",
-    "    from inspect import getsource\n",
-    "    if 'run_analysis' in globals() and 'df.set_index' not in getsource(run_analysis):\n",
-    "        del globals()['run_analysis']\n",
-    "        run_out.clear_output()\n",
-    "    with run_out:\n",
-    "        try:\n",
-    "            if 'df' not in ui_state:\n",
-    "                print('⚠️  Please load data first.'); return\n",
-    "\n",
-    "            # 1) read current widgets\n",
-    "            mode    = mode_w.value\n",
-    "            rand_n  = rand_w.value\n",
-    "            in1       = in_s.value.strip()\n",
-    "            in2       = in_e.value.strip()\n",
-    "            out1      = out_s.value.strip()\n",
-    "            out2      = out_e.value.strip()\n",
-    "\n",
-    "            # 2) manual weights (if needed)\n",
-    "            if mode=='manual' and 'custom_weights' not in ui_state:\n",
-    "                weight_box.children = [widgets.BoundedIntText(\n",
-    "                                           value=0,min=0,max=100,\n",
-    "                                           description=f'{f}:')\n",
-    "                                        for f in ui_state['fund_cols']]\n",
-    "                print('Enter weights (sum to 100) and click Run again.')\n",
-    "                return\n",
-    "            custom_w = {w.description[:-1]: w.value/100   # strip “:” at end\n",
-    "                        for w in weight_box.children} if mode=='manual' else {}\n",
-    "\n",
-    "            # 3) analysis\n",
-    "            globals()['fund_cols']   = ui_state['fund_cols']\n",
-    "            globals()['indices_list'] = ui_state['indices_list']\n",
-    "\n",
-    "            res = run_analysis(\n",
-    "                ui_state['df'],\n",
-    "                in1, in2,\n",
-    "                out1, out2,\n",
-    "                target_vol=0.05, monthly_cost=0.001,\n",
-    "                selection_mode=mode, random_n=rand_n,\n",
-    "                custom_weights=custom_w\n",
-    "            )\n",
-    "            if not res:\n",
-    "                print('❌ Analysis returned None (no valid funds?)'); return\n",
-    "\n",
-    "            res['indices_list'] = ui_state['indices_list']\n",
-    "            fname = f'Analysis_{in1}_{out1}.xlsx'\n",
-    "            export_to_excel(res, ui_state[\"df\"],\n",
-    "                            fname, in1,in2,out1,out2)\n",
-    "\n",
-    "            print('✅ Excel exported →', fname)\n",
-    "\n",
-    "        except Exception as ex:\n",
-    "            import traceback, textwrap\n",
-    "            print('🚨 Unhandled exception:\\n',\n",
-    "                  textwrap.indent(''.join(traceback.format_exc()), '    '))\n",
-    "\n",
-    "run_btn.on_click(_run_click)\n",
-    "\n",
-    "# ── Display the workflow UI ─────────────────────\n",
-    "display(config_btn, config_out, run_btn, run_out)\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 10,
-   "id": "54e73a07-ffb3-4811-8736-40663dd7938c",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "text/plain": [
-       "True"
-      ]
-     },
-     "execution_count": 10,
-     "metadata": {},
-     "output_type": "execute_result"
-    }
-   ],
-   "source": [
-    "'run_analysis' in globals()"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "4dbce8c7-d525-4067-b1e0-2d465ffccf51",
-   "metadata": {},
-   "outputs": [],
-   "source": []
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup5-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup5-checkpoint.ipynb
deleted file mode 100644
index a0f500ec25a84f421d31ec815a233ef93257572a..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup5-checkpoint.ipynb
+++ /dev/null
@@ -1,1351 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 1. SETUP CELL ============\n",
-    "\n",
-    "import logging\n",
-    "import sys\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import os\n",
-    "import math\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import interact, interactive, VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from IPython.utils.capture import capture_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import datetime\n",
-    "import random\n",
-    "import warnings\n",
-    "\n",
-    "# If you need to install these packages on your environment, uncomment:\n",
-    "!{sys.executable} -m pip install --quiet ipywidgets openpyxl xlsxwriter\n",
-    "\n",
-    "# For exporting to Excel with styling\n",
-    "import xlsxwriter\n",
-    "\n",
-    "# Set up logging to console\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "logging.info(\"Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\")\n",
-    "\n",
-    "# (Optional) If widgets aren't enabled, run:\n",
-    "# !jupyter nbextension enable --py widgetsnbextension --sys-prefix\n",
-    "\n",
-    "print(\"Setup complete.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify which column (after 'Date') is the risk-free rate by smallest stdev among columns.\n",
-    "    \"\"\"\n",
-    "    numeric_cols = df.columns[1:]  # skip the Date column\n",
-    "    stdevs = {}\n",
-    "    for col in numeric_cols:\n",
-    "        vals = df[col].dropna()\n",
-    "        if len(vals) > 0:\n",
-    "            stdevs[col] = vals.std()\n",
-    "        else:\n",
-    "            stdevs[col] = np.inf\n",
-    "\n",
-    "    rf_col = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "    return rf_col\n",
-    "\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 1) Helper to read a local CSV robustly (handles BOMs and minor parsing issues)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Try loading `path` as CSV in three ways:\n",
-    "    1. Default C engine\n",
-    "    2. BOM-stripped with the Python engine\n",
-    "    3. Skip bad lines with the Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception as e1:\n",
-    "        print(\"Default read_csv failed:\", e1)\n",
-    "\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception as e2:\n",
-    "        print(\"utf-8-sig + python engine failed:\", e2)\n",
-    "\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",    # for pandas ≥ 1.3\n",
-    "    )\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 2) Build the widgets\n",
-    "# ------------------------------------------------------------------------------\n",
-    "source_info = widgets.HTML(\n",
-    "    \"<b>Step 1: Choose your CSV</b><br>\"\n",
-    "    \"<i>Remember:</i> If you included any index columns (e.g. S&P 500, MSCI World, SG Trend), they \"\n",
-    "    \"must appear to the right of all fund columns in your sheet.\"\n",
-    ")\n",
-    "\n",
-    "\n",
-    "source_dropdown = widgets.Dropdown(\n",
-    "    options=['Local', 'GitHub'],\n",
-    "    value='Local',\n",
-    "    description='Data Source:',\n",
-    "    style={'description_width': '120px'}\n",
-    ")\n",
-    "\n",
-    "# FileChooser for Local mode\n",
-    "fc = FileChooser(os.getcwd())\n",
-    "fc.title = \"<b>Select local CSV file</b>\"\n",
-    "\n",
-    "# Text box for GitHub raw URL\n",
-    "github_text = widgets.Text(\n",
-    "    value=(\n",
-    "        \"https://raw.githubusercontent.com/stranske/Trend_Model_Project/\"\n",
-    "        \"main/data/TrendData.csv\"\n",
-    "    ),\n",
-    "    description=\"GitHub URL:\",\n",
-    "    layout=widgets.Layout(width=\"80%\"),\n",
-    ")\n",
-    "\n",
-    "# Ask how many index columns are on the far right\n",
-    "n_indices_widget = widgets.BoundedIntText(\n",
-    "    value=0,\n",
-    "    min=0,\n",
-    "    max=10,  # adjust if you expect more than 10 indices\n",
-    "    description='# Index cols:',\n",
-    "    style={'description_width': '120px'},\n",
-    "    tooltip=\"Enter the number of index columns at the far right of your CSV\"\n",
-    ")\n",
-    "\n",
-    "# Load button\n",
-    "load_button = widgets.Button(description=\"Load Data\", button_style=\"success\")\n",
-    "\n",
-    "# Output area for status and debug prints\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 3) Show/hide widgets depending on source selection\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_source_change(change):\n",
-    "    if change[\"new\"] == \"Local\":\n",
-    "        fc.layout.display = \"block\"\n",
-    "        github_text.layout.display = \"none\"\n",
-    "    else:\n",
-    "        fc.layout.display = \"none\"\n",
-    "        github_text.layout.display = \"block\"\n",
-    "\n",
-    "# Initially, GitHub textbox is hidden; FileChooser is visible\n",
-    "github_text.layout.display = \"none\"\n",
-    "fc.layout.display = \"block\"\n",
-    "\n",
-    "source_dropdown.observe(on_source_change, names=\"value\")\n",
-    "\n",
-    "ui_load = widgets.VBox([\n",
-    "    source_info,\n",
-    "    source_dropdown,\n",
-    "    fc,\n",
-    "    github_text,\n",
-    "    n_indices_widget,   # ← new widget here\n",
-    "    load_button,\n",
-    "    output_area\n",
-    "])\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 4) Callback for the Load button (auto-detect date format)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_load_clicked(_):\n",
-    "    global df, fund_cols, indices_list, rf_col            # declare df as global\n",
-    "    with output_area:\n",
-    "        output_area.clear_output()\n",
-    "        src_choice = source_dropdown.value\n",
-    "        n_indices = int(n_indices_widget.value)\n",
-    "\n",
-    "        # 4a) Load the DataFrame\n",
-    "        try:\n",
-    "            if src_choice == 'Local':\n",
-    "                local_path = fc.selected  # FileChooser’s selected path\n",
-    "                if not local_path or not os.path.exists(local_path):\n",
-    "                    print(f\"Error: Local file not found:\\n  {local_path}\")\n",
-    "                    return\n",
-    "                print(f\"Loading from local file:\\n  {local_path}\")\n",
-    "                df = pd.read_csv(local_path)\n",
-    "            else:\n",
-    "                github_url = github_text.value.strip()\n",
-    "                if not github_url:\n",
-    "                    print(\"Error: Please enter a valid GitHub raw URL.\")\n",
-    "                    return\n",
-    "                print(f\"Loading from GitHub URL:\\n  {github_url}\")\n",
-    "                df = pd.read_csv(github_url)\n",
-    "        except Exception as e:\n",
-    "            print(\"Failed to load CSV:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4b) Debug: print columns & a few rows\n",
-    "        print(\"Columns found in DataFrame:\", df.columns.tolist())\n",
-    "        display(df.head(3))\n",
-    "\n",
-    "        # 4c) Identify which column is the date\n",
-    "        date_col = None\n",
-    "        for candidate in [\"Date\", \"DATE\", \"date\"]:\n",
-    "            if candidate in df.columns:\n",
-    "                date_col = candidate\n",
-    "                break\n",
-    "\n",
-    "        if date_col is None:\n",
-    "            print(\"Error: No column named 'Date' / 'DATE' / 'date' found.\")\n",
-    "            print(\"Please check the column names above and adjust code accordingly.\")\n",
-    "            return\n",
-    "\n",
-    "        date_col = 'Date'\n",
-    "\n",
-    "        # 1) Show the first few raw date strings (un‐parsed) so we can inspect them\n",
-    "        raw_samples = df[date_col].dropna().astype(str).head(10).tolist()\n",
-    "        print(f\"Raw {date_col} samples (first 10 non‐null): {raw_samples!r}\")\n",
-    "\n",
-    "        # 2) Strip leading/trailing whitespace from every entry\n",
-    "        df[date_col] = df[date_col].astype(str).str.strip()\n",
-    "\n",
-    "        # 3) Now attempt strict \"%m/%d/%Y\" parsing\n",
-    "        parsed = pd.to_datetime(df[date_col], format=\"%m/%d/%Y\", errors=\"coerce\", infer_datetime_format=True)\n",
-    "        num_valid = parsed.notna().sum()\n",
-    "        print(f\"Number of rows matching '%m/%d/%Y' exactly: {num_valid} / {len(df)}\")\n",
-    "\n",
-    "        if num_valid > 0:\n",
-    "            df[date_col] = parsed\n",
-    "            print(f\"Parsing with '%m/%d/%Y' succeeded for {num_valid} rows.\")\n",
-    "        else:\n",
-    "            print(\n",
-    "                \"Warning: No rows matched '%m/%d/%Y'. \"\n",
-    "                \"Falling back to generic pd.to_datetime(...).\"\n",
-    "            )\n",
-    "            df[date_col] = pd.to_datetime(df[date_col], errors=\"coerce\")\n",
-    "\n",
-    "        # 5) Drop any rows where parsing still failed\n",
-    "        before_drop = len(df)\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        dropped = before_drop - len(df)\n",
-    "        if dropped:\n",
-    "            print(f\"Dropped {dropped} rows where '{date_col}' could not be parsed.\")\n",
-    "        \n",
-    "        # 6) Sort and reset index\n",
-    "        df.sort_values(by=date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "        \n",
-    "        # 7) Show the final parsed dates\n",
-    "        print(f\"After parsing, first 3 {date_col} values:\")\n",
-    "        print(df[[date_col]].head(3))\n",
-    "        print(f\"Loaded {len(df)} rows successfully.\")\n",
-    "\n",
-    "\n",
-    "        # 4d) Identify risk-free column\n",
-    "        try:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            print(f\"Identified risk-free column as: '{rf_col}'\")\n",
-    "        except Exception as e:\n",
-    "            print(\"Error identifying risk-free column:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4f) Determine fund_cols vs indices_list based on n_indices\n",
-    "        all_cols = df.columns.tolist()\n",
-    "        # We assume “Date” and rf_col are present. Everything else is a candidate.\n",
-    "        if 'Date' not in all_cols or rf_col not in all_cols:\n",
-    "            print(\"Error: 'Date' or risk-free column not found in DataFrame columns.\")\n",
-    "            return\n",
-    "        \n",
-    "        # Build list of all columns except 'Date' and rf_col\n",
-    "        remaining = [c for c in all_cols if c not in ['Date', rf_col]]\n",
-    "        \n",
-    "        if n_indices > len(remaining):\n",
-    "            print(\n",
-    "                f\"Error: You asked for {n_indices} index columns, but only \"\n",
-    "                f\"{len(remaining)} columns remain after 'Date' and '{rf_col}'.\"\n",
-    "            )\n",
-    "            return\n",
-    "\n",
-    "        if n_indices > 0:\n",
-    "            indices_list = remaining[-n_indices:]\n",
-    "            fund_cols    = remaining[:-n_indices]\n",
-    "        else:\n",
-    "            indices_list = []\n",
-    "            fund_cols    = remaining[:]\n",
-    "        print(\"\\n>> Debug (post‐load): fund_cols =\", fund_cols)\n",
-    "        print(\">> Debug (post‐load): indices_list =\", indices_list, \"\\n\")\n",
-    "        \n",
-    "        # 2F) Print out what we found\n",
-    "        print(f\"Detected fund columns ({len(fund_cols)}): {fund_cols}\")\n",
-    "        print(f\"Detected index columns ({len(indices_list)}): {indices_list}\")\n",
-    "        print(\n",
-    "            \"Data loaded and classified successfully.\\n\"\n",
-    "            \"Proceed to Step 2 (Run Analysis).\"\n",
-    "        )\n",
-    "\n",
-    " \n",
-    "        # 8) Confirm that df is now in global scope\n",
-    "        print(\">> df defined with\", len(df), \"rows and columns:\", df.columns.tolist())\n",
-    "\n",
-    "# 5) Wire up and display the UI\n",
-    "\n",
-    "load_button.on_click(on_load_clicked)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Utility functions loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Check if a series (sorted chronologically) has >= threshold consecutive NaNs.\n",
-    "    Return True if such a gap exists, False otherwise.\n",
-    "    \"\"\"\n",
-    "    consecutive = 0\n",
-    "    for val in series:\n",
-    "        if pd.isna(val):\n",
-    "            consecutive += 1\n",
-    "        else:\n",
-    "            consecutive = 0\n",
-    "        if consecutive >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "\n",
-    "def annualize_return(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized (geometric) return from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    growth_factor = (1 + valid_rets).prod()\n",
-    "    n_months = len(valid_rets)\n",
-    "    if growth_factor <= 0:\n",
-    "        return -1.0\n",
-    "    ann_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    return ann_ret\n",
-    "\n",
-    "def annualize_volatility(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized stdev of monthly returns, i.e. stdev * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) < 2:\n",
-    "        return np.nan\n",
-    "    return valid_rets.std() * np.sqrt(12)\n",
-    "\n",
-    "def sharpe_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe ratio = (annual_excess_return) / (annual_excess_vol).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    ann_excess_vol = excess.std() * np.sqrt(12)\n",
-    "    if ann_excess_vol == 0:\n",
-    "        return np.nan\n",
-    "    return ann_excess_ret / ann_excess_vol\n",
-    "\n",
-    "def sortino_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino ratio = (annual_excess_return) / (annual_downside_stdev).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "\n",
-    "    negative_mask = excess < 0\n",
-    "    negative_returns = excess[negative_mask]\n",
-    "    if len(negative_returns) == 0:\n",
-    "        return np.inf  # no negative => infinite sortino\n",
-    "    downside_stdev = negative_returns.std() * np.sqrt(12)\n",
-    "    return ann_excess_ret / downside_stdev\n",
-    "\n",
-    "def max_drawdown(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Compute max drawdown from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    wealth_index = (1 + valid_rets).cumprod()\n",
-    "    rolling_max = wealth_index.cummax()\n",
-    "    dd_series = 1 - (wealth_index / rolling_max)\n",
-    "    return dd_series.max()\n",
-    "\n",
-    "def calc_portfolio_returns(weights, df_returns):\n",
-    "    \"\"\"\n",
-    "    Compute monthly portfolio returns (Series) as weighted sum of columns in df_returns.\n",
-    "    \"\"\"\n",
-    "    return (df_returns * weights).sum(axis=1)\n",
-    "\n",
-    "print(\"Utility functions loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "#### 4. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "c5867ccd-a550-4849-a10b-a085f5fe26fd",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "select_funds (replaced) is ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# --- PATCH: clean select_funds() -------------------------------------------\n",
-    "def select_funds(\n",
-    "    df,                 # full DataFrame incl. 'Date'\n",
-    "    rf_col,             # risk-free column name\n",
-    "    fund_columns,       # candidate fund list\n",
-    "    in_sdate, in_edate, # in-sample bounds  (pd.Timestamp)\n",
-    "    out_sdate, out_edate,# out-sample bounds (pd.Timestamp)\n",
-    "    selection_mode=\"all\",\n",
-    "    random_n=8,\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Return a vetted list of fund tickers.\n",
-    "\n",
-    "    • Excludes names containing 'index'\n",
-    "    • Requires *no* NaN values inside either window\n",
-    "    • Requires < 3 consecutive NaNs inside either window\n",
-    "    • Supports selection_mode ∈ {\"all\", \"random\", \"manual\"}\n",
-    "    \"\"\"\n",
-    "    # --- 1) start from caller-supplied list  -------------------------------\n",
-    "    candidates = fund_columns.copy()\n",
-    "\n",
-    "    # --- 2) drop obvious indices ------------------------------------------\n",
-    "    not_index = [f for f in candidates if \"index\" not in f.lower()]\n",
-    "\n",
-    "    # --- 3) full-history test (no NaN in either window) --------------------\n",
-    "    full_hist = []\n",
-    "    for f in not_index:\n",
-    "        ins  = df.loc[(df[\"Date\"] >= in_sdate)  & (df[\"Date\"] <= in_edate),  f]\n",
-    "        outs = df.loc[(df[\"Date\"] >= out_sdate) & (df[\"Date\"] <= out_edate), f]\n",
-    "        if ins.notna().all() and outs.notna().all():\n",
-    "            full_hist.append(f)\n",
-    "\n",
-    "    # --- 4) max-run-length test (< 3 consecutive NaNs) ---------------------\n",
-    "    vetted = []\n",
-    "    for f in full_hist:\n",
-    "        # helper that returns longest NaN run length\n",
-    "        def _max_run(s):\n",
-    "            isn = s.isna().astype(int)\n",
-    "            return isn.groupby((isn == 0).cumsum()).sum().max()\n",
-    "        if _max_run(df.loc[(df[\"Date\"] >= in_sdate)  & (df[\"Date\"] <= in_edate),  f]) < 3 and \\\n",
-    "           _max_run(df.loc[(df[\"Date\"] >= out_sdate) & (df[\"Date\"] <= out_edate), f]) < 3:\n",
-    "            vetted.append(f)\n",
-    "\n",
-    "    # --- 5) final selection -----------------------------------------------\n",
-    "    if selection_mode == \"random\":\n",
-    "        k = min(random_n, len(vetted))\n",
-    "        vetted = random.sample(vetted, k)\n",
-    "    # selection_mode == \"manual\" just hands back the vetted list;\n",
-    "    # run_analysis (or the UI) decides what to do with it later.\n",
-    "\n",
-    "    logging.info(f\"select_funds → {len(vetted)} funds after all filters\")\n",
-    "    return vetted\n",
-    "# --------------------------------------------------------------------------\n",
-    "\n",
-    "print(\"select_funds (replaced) is ready.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 5. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "get_custom_weights function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    Returns dict {fund: weight_decimal}.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=f\"{fund}\",\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    \n",
-    "    confirm_button = widgets.Button(\n",
-    "        description='Confirm Weights',\n",
-    "        button_style='success'\n",
-    "    )\n",
-    "    error_label = widgets.Label(value='', layout=widgets.Layout(color='red'))\n",
-    "    \n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm_button, error_label])\n",
-    "    display(box)\n",
-    "    \n",
-    "    weights_container = {}\n",
-    "    \n",
-    "    def on_confirm_clicked(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_label.value = f\"Error: Weights sum to {total}, must be 100.\"\n",
-    "            weights_container.clear()\n",
-    "        else:\n",
-    "            for fund, wdg in weight_widgets.items():\n",
-    "                weights_container[fund] = wdg.value / 100.0\n",
-    "            error_label.value = \"Weights confirmed!\"\n",
-    "    \n",
-    "    confirm_button.on_click(on_confirm_clicked)\n",
-    "    return weights_container\n",
-    "\n",
-    "print(\"get_custom_weights function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 6. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "run_analysis (with checkpoints) is defined.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def run_analysis(\n",
-    "    df,\n",
-    "    in_start, in_end, out_start, out_end,\n",
-    "    target_vol, monthly_cost,\n",
-    "    selection_mode='all',\n",
-    "    random_n=8,\n",
-    "    custom_weights=None    # ← new argument\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Parse/validate date inputs\n",
-    "    2) Convert Date column if needed\n",
-    "    3) Identify rf_col\n",
-    "    4) Prepare in/out sample DataFrames\n",
-    "    5) CALL select_funds (with debug) and print checkpoints\n",
-    "    6) Compute scale_factors and wrap stats in try/except\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # —(1) Parse input dates (YYYY-MM) into actual month-end timestamps\n",
-    "    in_sdate  = pd.to_datetime(in_start + \"-01\", errors='coerce')\n",
-    "    in_edate  = pd.to_datetime(in_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "    out_sdate = pd.to_datetime(out_start + \"-01\", errors='coerce')\n",
-    "    out_edate = pd.to_datetime(out_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    # checkpoint A\n",
-    "    print(\"CHECKPOINT A: Dates parsed:\", in_sdate, in_edate, out_sdate, out_edate)\n",
-    "\n",
-    "    # —(2) Ensure 'Date' column is datetime64\n",
-    "    if not np.issubdtype(df['Date'].dtype, np.datetime64):\n",
-    "        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "        df.dropna(subset=['Date'], inplace=True)\n",
-    "        df.sort_values(by='Date', inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "    # checkpoint B\n",
-    "    print(\"CHECKPOINT B: Date column is datetime64, first dates:\",\n",
-    "          df['Date'].iloc[0], \"…\", df['Date'].iloc[-1])\n",
-    "\n",
-    "    # —(3) Identify risk-free column\n",
-    "    rf_col = identify_risk_free_fund(df)\n",
-    "    print(f\"INFO: Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "\n",
-    "    # —(4) Slice into in-sample & out-sample\n",
-    "    in_sample_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_sample_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "    in_sample_rf  = in_sample_df[rf_col]\n",
-    "    out_sample_rf = out_sample_df[rf_col]\n",
-    "\n",
-    "    print(f\"CHECKPOINT C: in_sample rows = {len(in_sample_df)}, out_sample rows = {len(out_sample_df)}\")\n",
-    "\n",
-    "    all_cols = [c for c in df.columns if c not in [\"Date\", rf_col]]\n",
-    "    if \"indices_list\" in globals():                 # optional, harmless if absent\n",
-    "        all_cols = [c for c in all_cols if c not in indices_list]\n",
-    "        \n",
-    "    # —(5) Select funds (either “manual” or via select_funds)\n",
-    "    if selection_mode == 'manual' and custom_weights is not None:\n",
-    "        # In manual mode, we trust the user’s chosen tickers outright\n",
-    "        selected_funds = list(custom_weights.keys())\n",
-    "        print(f\"CHECKPOINT D (manual): using custom_weights keys → {selected_funds}\")\n",
-    "    else:\n",
-    "        print(f\"CHECKPOINT D: about to call select_funds with {len(all_cols)} candidates\")\n",
-    "\n",
-    "        selected_funds = select_funds(\n",
-    "            df,\n",
-    "            rf_col,\n",
-    "            fund_columns=all_cols,\n",
-    "            in_sdate=in_sdate,\n",
-    "            in_edate=in_edate,\n",
-    "            out_sdate=out_sdate,\n",
-    "            out_edate=out_edate,\n",
-    "            selection_mode=selection_mode,\n",
-    "            random_n=random_n\n",
-    "        )\n",
-    "\n",
-    "    if len(selected_funds) == 0:\n",
-    "        logging.warning(\"No valid funds remain after filtering.\")\n",
-    "        print(\"Warning: No valid funds. Try adjusting your selection or data filters.\")\n",
-    "        return None\n",
-    "\n",
-    "    print(f\"CHECKPOINT E: select_funds returned {len(selected_funds)} funds → {selected_funds}\")\n",
-    "\n",
-    "    # indices_list must already exist as a global list of index columns\n",
-    "    in_sample_indices  = in_sample_df[indices_list].copy()\n",
-    "    out_sample_indices = out_sample_df[indices_list].copy()\n",
-    "\n",
-    "    # —(6) Compute scale_factors (based on in-sample volatility)\n",
-    "    scale_factors = {}\n",
-    "    for fund in selected_funds:\n",
-    "        fund_in_rets = in_sample_df[fund].dropna()\n",
-    "        current_vol  = annualize_volatility(fund_in_rets)\n",
-    "        if pd.isna(current_vol) or current_vol == 0:\n",
-    "            scale_factors[fund] = 1.0\n",
-    "        else:\n",
-    "            scale_factors[fund] = target_vol / current_vol\n",
-    "\n",
-    "    print(\"CHECKPOINT F: scale_factors computed (showing first 5):\",\n",
-    "          {f: scale_factors[f] for f in selected_funds[:5]})\n",
-    "\n",
-    "    # Pre-allocate DataFrames for scaled returns\n",
-    "    in_sample_scaled  = pd.DataFrame(index=in_sample_df.index, columns=selected_funds)\n",
-    "    out_sample_scaled = pd.DataFrame(index=out_sample_df.index, columns=selected_funds)\n",
-    "\n",
-    "    # ── Wrap everything from “scaling + stats” in a try/except ──\n",
-    "    try:\n",
-    "        # (6a) Scale returns (with monthly cost)\n",
-    "        for fund in selected_funds:\n",
-    "            sf     = scale_factors[fund]\n",
-    "            adj_in = in_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_in[adj_in < -1.0] = -1.0\n",
-    "            in_sample_scaled[fund] = adj_in\n",
-    "\n",
-    "            if not out_sample_df.empty:\n",
-    "                adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "                adj_out[adj_out < -1.0] = -1.0\n",
-    "                out_sample_scaled[fund] = adj_out\n",
-    "\n",
-    "        # (6b) Helper to compute per-series stats\n",
-    "        def compute_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            sr  = sharpe_ratio(series, rf_series)\n",
-    "            so  = sortino_ratio(series, rf_series)\n",
-    "            mdd = max_drawdown(series)\n",
-    "            return (r, v, sr, so, mdd)\n",
-    "\n",
-    "        # (6c) In-sample per-fund stats\n",
-    "        in_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "\n",
-    "        # (6d) Out-sample per-fund (vol-adjusted) stats\n",
-    "        out_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6e) Out-sample per-fund (raw) stats\n",
-    "        out_sample_stats_raw = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6f) Equal-weight portfolio returns\n",
-    "        ew_weight_dict = { f: 1.0/len(selected_funds) for f in selected_funds }\n",
-    "        ew_w           = np.array([ ew_weight_dict[f] for f in selected_funds ])\n",
-    "        in_ew_port      = calc_portfolio_returns(ew_w,       in_sample_scaled[selected_funds])\n",
-    "        out_ew_port     = calc_portfolio_returns(ew_w,       out_sample_scaled[selected_funds])\n",
-    "        out_ew_port_raw = calc_portfolio_returns(ew_w,       out_sample_df[selected_funds])\n",
-    "        \n",
-    "        in_ew_stats      = compute_stats(in_ew_port,      in_sample_rf)\n",
-    "        out_ew_stats     = compute_stats(out_ew_port,     out_sample_rf)\n",
-    "        out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6g) Index statistics (treat each index like “just another series”)\n",
-    "        in_index_stats  = {}\n",
-    "        out_index_stats = {}\n",
-    "        for idx in indices_list:\n",
-    "            in_index_stats[idx]  = compute_stats(in_sample_indices[idx],  in_sample_df[rf_col])\n",
-    "            out_index_stats[idx] = compute_stats(out_sample_indices[idx], out_sample_df[rf_col])\n",
-    "\n",
-    "        # (6h) “User-weight” portfolio\n",
-    "        if custom_weights is None:\n",
-    "            # If no manual weights → just reuse the same equal‐weight array\n",
-    "            user_weight_dict = ew_weight_dict.copy()\n",
-    "            # ← **IMPORTANT FIX**: define custom_w here for the equal-weight case\n",
-    "            custom_w = ew_w.copy()  \n",
-    "        else:\n",
-    "            # Manual weights passed → convert percentages to decimals\n",
-    "            user_weight_dict = { f: custom_weights[f] / 100.0 for f in selected_funds }\n",
-    "            custom_w         = np.array([ user_weight_dict[f] for f in selected_funds ])\n",
-    "\n",
-    "        # (6i) Compute “user-weighted” portfolio returns\n",
-    "        in_user_port      = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "        out_user_port     = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "        out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        # (6j) Compute their stats\n",
-    "        in_user_stats      = compute_stats(in_user_port,      in_sample_rf)\n",
-    "        out_user_stats     = compute_stats(out_user_port,     out_sample_rf)\n",
-    "        out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6k) Build the final results dict **(FIXED: removed duplicate 'fund_weights')**\n",
-    "        results = {\n",
-    "            'selected_funds':       selected_funds,\n",
-    "            'in_sample_scaled':     in_sample_scaled,\n",
-    "            'out_sample_scaled':    out_sample_scaled,\n",
-    "            'in_sample_stats':      in_sample_stats,\n",
-    "            'out_sample_stats':     out_sample_stats,\n",
-    "            'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "            'in_ew_stats':          in_ew_stats,\n",
-    "            'out_ew_stats':         out_ew_stats,\n",
-    "            'out_ew_stats_raw':     out_ew_stats_raw,\n",
-    "            'in_user_stats':        in_user_stats,\n",
-    "            'out_user_stats':       out_user_stats,\n",
-    "            'out_user_stats_raw':   out_user_stats_raw,\n",
-    "            'ew_weights':           ew_weight_dict,     # ← now returns equal-weight dict\n",
-    "            'fund_weights':         user_weight_dict,   # ← returns manual weights (or equal if none)\n",
-    "            'indices_list':         indices_list\n",
-    "        }\n",
-    "\n",
-    "    except Exception as e:\n",
-    "        print(\"ERROR inside stats-block:\", e)\n",
-    "        return None\n",
-    "\n",
-    "    # Everything succeeded\n",
-    "    return results\n",
-    "\n",
-    "\n",
-    "\n",
-    "print(\"run_analysis (with checkpoints) is defined.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 7. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 7,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─── Helper #1: build the equal- and user-weight DataFrames ────────────────────────────────\n",
-    "def make_portfolio_dfs(results, sample='in'):\n",
-    "    \"\"\"\n",
-    "    Returns (eq_df, user_df) for either 'in' or 'out' sample.\n",
-    "    \"\"\"\n",
-    "    # pick the right stats:\n",
-    "    stats_dict      = results[f'{sample}_sample_stats']\n",
-    "    ew_stats        = results[f'{sample}_ew_stats']\n",
-    "    user_stats      = results[f'{sample}_user_stats']\n",
-    "    fund_weights    = results['fund_weights']\n",
-    "    funds           = results['selected_funds']\n",
-    "\n",
-    "    def build_block(portf_label, stats, include_weights):\n",
-    "        rows = []\n",
-    "        # portfolio row\n",
-    "        r, v, sr, so, mdd = stats\n",
-    "        rows.append({\n",
-    "            'Fund': portf_label,\n",
-    "            'Weight': 100,\n",
-    "            'Return (%)': r,\n",
-    "            'Volatility (%)': v,\n",
-    "            'Sharpe Ratio': sr,\n",
-    "            'Sortino Ratio': so,\n",
-    "            'Max Drawdown (%)': mdd\n",
-    "        })\n",
-    "        # one‐row per fund\n",
-    "        for f in funds:\n",
-    "            r, v, sr, so, mdd = stats_dict[f]\n",
-    "            w = int(round(fund_weights[f] * 100)) if include_weights else None\n",
-    "            rows.append({\n",
-    "                'Fund': f,\n",
-    "                'Weight': w,\n",
-    "                'Return (%)': r,\n",
-    "                'Volatility (%)': v,\n",
-    "                'Sharpe Ratio': sr,\n",
-    "                'Sortino Ratio': so,\n",
-    "                'Max Drawdown (%)': mdd\n",
-    "            })\n",
-    "        return pd.DataFrame(rows)\n",
-    "\n",
-    "    eq_df   = build_block('Equal-Weight Portfolio', ew_stats,   True)\n",
-    "    user_df = build_block('User-Weight Portfolio', user_stats, True)\n",
-    "    return eq_df, user_df\n",
-    "\n",
-    "\n",
-    "# ─── Helper #2: build an indices table ─────────────────────────────────────────────────────\n",
-    "def make_indices_df(df, indices, start, end):\n",
-    "    \"\"\"\n",
-    "    Compute (Return, Vol, Sharpe, Sortino, MDD) for each index in [start, end],\n",
-    "    return a DataFrame with columns Index, Return (%), Volatility (%), …\n",
-    "    \"\"\"\n",
-    "    in_s, in_e = pd.to_datetime(start+'-01'), pd.to_datetime(end+'-01') + pd.offsets.MonthEnd(0)\n",
-    "    rows = []\n",
-    "    rf = identify_risk_free_fund(df)\n",
-    "    sub = df.set_index('Date').loc[in_s:in_e]\n",
-    "    for idx in indices:\n",
-    "        series = sub[idx]\n",
-    "        rf_ser = sub[rf]\n",
-    "        r  = annualize_return(series)\n",
-    "        v  = annualize_volatility(series)\n",
-    "        sr = sharpe_ratio(series, rf_ser)\n",
-    "        so = sortino_ratio(series, rf_ser)\n",
-    "        mdd = max_drawdown(series)\n",
-    "        rows.append({\n",
-    "            'Index': idx,\n",
-    "            'Return (%)': r,\n",
-    "            'Volatility (%)': v,\n",
-    "            'Sharpe Ratio': sr,\n",
-    "            'Sortino Ratio': so,\n",
-    "            'Max Drawdown (%)': mdd\n",
-    "        })\n",
-    "    return pd.DataFrame(rows)\n",
-    "\n",
-    "\n",
-    "# ─── Helper #3: write & format one sheet ──────────────────────────────────────────────────\n",
-    "# Apply uniform column widths & formats\n",
-    "    #   (col_idx, width, format_obj)\n",
-    "COLUMN_SPECS = [\n",
-    "    (0, 28, None),\n",
-    "    (1, 12, 'int'),\n",
-    "    (2, 15, 'pct1'),\n",
-    "    (3, 15, 'pct1'),\n",
-    "    (4, 15, 'dec2'),\n",
-    "    (5, 15, 'dec2'),\n",
-    "    (6, 15, 'pct1'),\n",
-    "]\n",
-    "\n",
-    "def build_formats(wb):\n",
-    "    return {\n",
-    "      'int':   wb.add_format({'num_format':'0'}),\n",
-    "      'pct1':  wb.add_format({'num_format':'0.0%'}),\n",
-    "      'dec2':  wb.add_format({'num_format':'0.00'}),\n",
-    "      'bold':  wb.add_format({'bold':True}),\n",
-    "    }\n",
-    "    \n",
-    "def write_portfolio_sheet(writer, sheet_name, eq_df, user_df, fmt):\n",
-    "    # Create & register the sheet\n",
-    "    ws = writer.book.add_worksheet(sheet_name)\n",
-    "    writer.sheets[sheet_name] = ws\n",
-    "\n",
-    "    # 1) Write the two tables with keyword-only args\n",
-    "    eq_df.to_excel(excel_writer=writer,\n",
-    "                   sheet_name=sheet_name,\n",
-    "                   startrow=0,\n",
-    "                   index=False)\n",
-    "    user_df.to_excel(excel_writer=writer,\n",
-    "                     sheet_name=sheet_name,\n",
-    "                     startrow=len(eq_df) + 3,\n",
-    "                     index=False)\n",
-    "\n",
-    "    for col_idx, width, fmt_key in COLUMN_SPECS:\n",
-    "        # if fmt_key is None, use no format; otherwise pull from fmt\n",
-    "        fmt_obj = fmt[fmt_key] if fmt_key else None\n",
-    "        ws.set_column(col_idx, col_idx, width, fmt_obj)\n",
-    "\n",
-    "    # Bold the headers\n",
-    "    bold = fmt['bold']\n",
-    "    for j, h in enumerate(eq_df.columns):\n",
-    "        ws.write(0, j, h, fmt['bold'])\n",
-    "    start = len(eq_df) + 3\n",
-    "    for j, h in enumerate(user_df.columns):\n",
-    "        ws.write(start, j, h, fmt['bold'])\n",
-    "\n",
-    "\n",
-    "def write_indices_block(writer, sheet_name, df_idx, start_row, fmt):\n",
-    "    \"\"\"\n",
-    "    Write the indices block to the given sheet at start_row\n",
-    "    \"\"\"\n",
-    "    # Grab the worksheet from the writer\n",
-    "    ws = writer.sheets[sheet_name]\n",
-    "    bold_fmt = fmt['bold']\n",
-    "\n",
-    "    # Label\n",
-    "    ws.write(start_row - 1, 0, f\"Indices ({sheet_name}):\", bold_fmt)\n",
-    "\n",
-    "    # Dump the DataFrame\n",
-    "    df_idx.to_excel(\n",
-    "        excel_writer=writer,\n",
-    "        sheet_name=sheet_name,\n",
-    "        startrow=start_row,\n",
-    "        index=False\n",
-    "    )\n",
-    "\n",
-    "    # Apply the same COLUMN_SPECS formats as the portfolio tables\n",
-    "    for col_idx, width, fmt_key in COLUMN_SPECS:\n",
-    "        fmt_obj = fmt.get(fmt_key) if fmt_key else None\n",
-    "        ws.set_column(col_idx, col_idx, width, fmt_obj)\n",
-    "\n",
-    "    # Bold the header row of the indices table\n",
-    "    ws.set_row(start_row, None, bold_fmt)\n",
-    "\n",
-    "def export_to_excel(results, df, output_filename,\n",
-    "                    in_start, in_end, out_start, out_end):\n",
-    "    writer  = pd.ExcelWriter(output_filename, engine='xlsxwriter')\n",
-    "    wb     = writer.book\n",
-    "    formats = build_formats(wb)\n",
-    "\n",
-    "    # 1) portfolio sheets\n",
-    "    in_eq,  in_user  = make_portfolio_dfs(results, sample='in')\n",
-    "    out_eq, out_user = make_portfolio_dfs(results, sample='out')\n",
-    "  \n",
-    "    # 2) indices sheets\n",
-    "    idx_in  = make_indices_df(df, results['indices_list'], in_start,  in_end)\n",
-    "    idx_out = make_indices_df(df, results['indices_list'], out_start, out_end)\n",
-    "    # compute where to start: right after user_df\n",
-    "    start_in  = len(in_eq)  + len(in_user)  + 6\n",
-    "    start_out = len(out_eq) + len(out_user) + 6\n",
-    "\n",
-    "    write_portfolio_sheet(writer, f\"IS {in_start}-{in_end}\", in_eq,  in_user,  formats)\n",
-    "    write_portfolio_sheet(writer, f\"OS {out_start}-{out_end}\", out_eq, out_user, formats)\n",
-    "    write_indices_block(writer, f\"IS {in_start}-{in_end}\", idx_in,  start_in,  formats)\n",
-    "    write_indices_block(writer, f\"OS {out_start}-{out_end}\", idx_out, start_out, formats)\n",
-    "\n",
-    "    writer.close()\n",
-    "\n",
-    "    logging.info(f\"Exported analysis to {output_filename} successfully.\")\n",
-    "    print(f\"Excel file created: {output_filename}\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Run Parameters,Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 14,
-   "id": "9899f2e3-9c6e-4c38-b3eb-d07e8f871462",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "07b2f5dc4f094ed7a18cfb712856a949",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HBox(children=(ToggleButtons(description='Source:', options=('Local', 'GitHub'), value='Local')…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# ===============================================================\n",
-    "#          SIMPLE, ALWAYS-VISIBLE “RUN ANALYSIS” UI\n",
-    "# ===============================================================\n",
-    "\n",
-    "import pandas as pd, ipywidgets as widgets, logging, inspect\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# 1) DATA SOURCE  (Local file OR raw-GitHub URL)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "source_toggle = widgets.ToggleButtons(options=['Local', 'GitHub'], description='Source:')\n",
-    "file_chooser   = FileChooser(title='Pick CSV')\n",
-    "url_box        = widgets.Text(description='Raw CSV URL:', layout={'width':'70%'})\n",
-    "csv_load_btn   = widgets.Button(description='Load CSV', button_style='success')\n",
-    "csv_status_out = widgets.Output()\n",
-    "\n",
-    "# Show only the relevant picker\n",
-    "def _on_source_change(c):\n",
-    "    file_chooser.layout.display = 'block' if c['new']=='Local' else 'none'\n",
-    "    url_box.layout.display      = 'block' if c['new']=='GitHub' else 'none'\n",
-    "source_toggle.observe(_on_source_change, names='value')\n",
-    "_on_source_change({'new': source_toggle.value})  # initialise visibilities\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# 2) BASIC PARAMS (visible immediately)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "index_cnt = widgets.BoundedIntText(value=0, min=0, max=10, step=1,\n",
-    "                                   description='# Index cols:')\n",
-    "\n",
-    "in_start = widgets.Text('2005-07', description='In Start:')\n",
-    "in_end   = widgets.Text('2008-06', description='In End:')\n",
-    "out_start= widgets.Text('2008-07', description='Out Start:')\n",
-    "out_end  = widgets.Text('2009-06', description='Out End:')\n",
-    "target_vol   = widgets.FloatText(0.25,  description='Target Vol:')\n",
-    "monthly_cost = widgets.FloatText(0.0033, description='Monthly Cost:')\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# 3) FUND-SELECTION MODE  (always visible)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "mode_dd   = widgets.Dropdown(\n",
-    "    options=[('All funds' , 'all'),\n",
-    "             ('Random sample', 'random'),\n",
-    "             ('Manual pick',   'manual')],\n",
-    "    value='all', description='Mode:')\n",
-    "rand_n    = widgets.IntText(5, description='Sample N:')\n",
-    "fund_table = widgets.VBox([])\n",
-    "\n",
-    "def _mode_visibility(c):\n",
-    "    m = c['new'] if isinstance(c, dict) else mode_dd.value\n",
-    "    rand_n.layout.display  = 'block' if m=='random' else 'none'\n",
-    "    fund_table.layout.display = 'block' if m=='manual' else 'none'\n",
-    "mode_dd.observe(_mode_visibility, names='value')\n",
-    "_mode_visibility(None)  # set initial visibilities\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# 4) RUN ANALYSIS BUTTON & OUTPUT\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "run_btn  = widgets.Button(description='Run Analysis', button_style='success')\n",
-    "output   = widgets.Output(layout={'border':'1px solid #999',\n",
-    "                                  'height':'320px', 'overflow_y':'auto'})\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# 5) GLOBALS to hold dataset between callbacks\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "df = None\n",
-    "indices_list = []\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# 6) LOAD CSV HANDLER\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "def _load_csv(b):\n",
-    "    global df\n",
-    "    with csv_status_out:\n",
-    "        clear_output()\n",
-    "        try:\n",
-    "            if source_toggle.value=='Local':\n",
-    "                if not file_chooser.selected:\n",
-    "                    print(\"⚠️ Please choose a file.\"); return\n",
-    "                df = pd.read_csv(file_chooser.selected)\n",
-    "            else:\n",
-    "                url = url_box.value.strip()\n",
-    "                if not url.lower().endswith('.csv'):\n",
-    "                    print(\"⚠️ Must end with .csv\"); return\n",
-    "                df = pd.read_csv(url)\n",
-    "        except Exception as e:\n",
-    "            print(\"❌ Load error:\", e); df=None; return\n",
-    "\n",
-    "        if 'Date' not in df.columns:\n",
-    "            print(\"❌ No 'Date' column found.\"); df=None; return\n",
-    "\n",
-    "        print(f\"✅ Loaded {len(df):,} rows × {df.shape[1]} cols.\"); display(df.head())\n",
-    "        index_cnt.max = max(0, len(df.columns)-1)   # update upper bound\n",
-    "\n",
-    "csv_load_btn.on_click(_load_csv)\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# 7) RUN ANALYSIS HANDLER\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "def _run_analysis(b):\n",
-    "    with output:\n",
-    "        clear_output()\n",
-    "        global indices_list\n",
-    "\n",
-    "        # 1. sanity checks\n",
-    "        if df is None:\n",
-    "            print(\"⚠️ Load a CSV first.\"); return\n",
-    "        try:\n",
-    "            for s in (in_start.value, in_end.value, out_start.value, out_end.value):\n",
-    "                pd.to_datetime(s, format='%Y-%m')\n",
-    "        except Exception:\n",
-    "            print(\"❌ Dates must be YYYY-MM.\"); return\n",
-    "\n",
-    "        # 2. set indices_list from count\n",
-    "        cnt = index_cnt.value\n",
-    "        non_date = [c for c in df.columns if c!='Date']\n",
-    "        if cnt > len(non_date):\n",
-    "            print(\"⚠️ Index count exceeds available columns.\"); return\n",
-    "        indices_list = non_date[:cnt]\n",
-    "\n",
-    "        # 3. manual-fund table build (only if needed)\n",
-    "        if mode_dd.value=='manual' and not fund_table.children:\n",
-    "            rf = identify_risk_free_fund(df)\n",
-    "            cand = [c for c in df.columns if c not in ['Date', rf] + indices_list]\n",
-    "            ins  = pd.to_datetime(in_start.value) + pd.offsets.MonthEnd(0)\n",
-    "            ine  = pd.to_datetime(in_end.value)   + pd.offsets.MonthEnd(0)\n",
-    "            ous  = pd.to_datetime(out_start.value)+ pd.offsets.MonthEnd(0)\n",
-    "            oue  = pd.to_datetime(out_end.value)  + pd.offsets.MonthEnd(0)\n",
-    "            valid = select_funds(df, rf, cand, ins, ine, ous, oue, 'all')\n",
-    "            if not valid:\n",
-    "                print(\"❌ No funds pass history / gap rules.\"); return\n",
-    "            fund_table.children = [\n",
-    "                widgets.HBox([\n",
-    "                    widgets.Checkbox(False, description=f,\n",
-    "                                     layout=widgets.Layout(width='200px')),\n",
-    "                    widgets.BoundedIntText(0, min=0, max=100, description='%',\n",
-    "                                           layout=widgets.Layout(width='110px'),\n",
-    "                                           disabled=True)\n",
-    "                ]) for f in valid\n",
-    "            ]\n",
-    "            # enable/disable IntText on checkbox toggle\n",
-    "            for row in fund_table.children:\n",
-    "                cb, wt = row.children\n",
-    "                cb.observe(lambda ch, wt=wt: setattr(wt,'disabled',not ch.new),\n",
-    "                           names='value')\n",
-    "            fund_table.layout.display = 'block'\n",
-    "            print(\"▶ Tick funds & enter weights, then click Run again.\")\n",
-    "            return\n",
-    "\n",
-    "        # 4. gather manual weights (if any)\n",
-    "        custom_w = None\n",
-    "        if mode_dd.value=='manual':\n",
-    "            weights = {row.children[0].description: row.children[1].value\n",
-    "                       for row in fund_table.children if row.children[0].value}\n",
-    "            if not weights:\n",
-    "                print(\"⚠️ Select at least one fund.\"); return\n",
-    "            if sum(weights.values())!=100:\n",
-    "                print(\"⚠️ Weights must sum to 100.\"); return\n",
-    "            custom_w = weights\n",
-    "\n",
-    "        # 5. RUN!\n",
-    "        try:\n",
-    "            res = run_analysis(\n",
-    "                df,\n",
-    "                in_start.value, in_end.value,\n",
-    "                out_start.value, out_end.value,\n",
-    "                target_vol.value, monthly_cost.value,\n",
-    "                selection_mode=mode_dd.value,\n",
-    "                random_n=rand_n.value if mode_dd.value=='random' else None,\n",
-    "                custom_weights=custom_w\n",
-    "            )\n",
-    "        except Exception as e:\n",
-    "            print(\"❌ run_analysis error:\", e); return\n",
-    "        if res is None:\n",
-    "            print(\"❌ Analysis returned no results.\"); return\n",
-    "\n",
-    "        print(\"✅ Complete. Funds:\", res['selected_funds'])\n",
-    "        fname = f\"IS_{in_start.value}_{out_start.value}.xlsx\"\n",
-    "        export_to_excel(res, df, fname, in_start.value, in_end.value,\n",
-    "                        out_start.value, out_end.value)\n",
-    "        print(\"Excel saved as\", fname)\n",
-    "\n",
-    "run_btn.on_click(_run_analysis)\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# 8) DISPLAY  (all core widgets visible immediately)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "display(widgets.VBox([\n",
-    "    widgets.HBox([source_toggle, url_box]),\n",
-    "    file_chooser,\n",
-    "    csv_load_btn,\n",
-    "    csv_status_out,\n",
-    "    widgets.HBox([index_cnt]),\n",
-    "    widgets.HTML(\"<hr>\"),\n",
-    "    widgets.HBox([in_start, in_end, out_start, out_end]),\n",
-    "    widgets.HBox([target_vol, monthly_cost]),\n",
-    "    widgets.HTML(\"<hr>\"),\n",
-    "    widgets.HBox([mode_dd, rand_n]),\n",
-    "    fund_table,\n",
-    "    run_btn,\n",
-    "    output\n",
-    "]))\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup6-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup6-checkpoint.ipynb
deleted file mode 100644
index 34d5896cd85b4f21f0c382ab329bdedd20efc7aa..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup6-checkpoint.ipynb
+++ /dev/null
@@ -1,1026 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Volatility-Scaling & Portfolio-Analysis notebook initialised.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ===============================================================\n",
-    "#      VOL-ADJ TREND ANALYSIS  –  SINGLE-FILE VERSION\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  0 · IMPORTS  (all in one place)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "import pandas as pd\n",
-    "import numpy as np\n",
-    "import xlsxwriter\n",
-    "import logging\n",
-    "from io import BytesIO\n",
-    "import ipywidgets as widgets\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "from typing import List, Dict, Optional\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  1 · CSV LOADER + RF DETECTOR\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "def load_csv(path: str) -> pd.DataFrame:\n",
-    "    df = pd.read_csv(path)\n",
-    "    if \"Date\" not in df.columns:\n",
-    "        raise ValueError(\"CSV must contain a 'Date' column.\")\n",
-    "    return df\n",
-    "\n",
-    "def identify_risk_free_fund(df: pd.DataFrame) -> str:\n",
-    "    returns = df.drop(columns=\"Date\", errors=\"ignore\")\n",
-    "    stdevs  = returns.std(skipna=True, ddof=0)\n",
-    "    return stdevs.idxmin()"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ============ 2 · DATA LOADING ============\n",
-    "\n",
-    "import pandas as pd\n",
-    "import ipywidgets as widgets\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import logging\n",
-    "\n",
-    "# ── helpers ────────────────────────────────────────────────────────\n",
-    "def load_csv(path_or_url: str) -> pd.DataFrame:\n",
-    "    \"\"\"Read a CSV with pandas. Let pandas raise if it fails.\"\"\"\n",
-    "    logging.info(\"Reading CSV: %s\", path_or_url)\n",
-    "    df = pd.read_csv(path_or_url, engine=\"python\")\n",
-    "    if \"Date\" not in df.columns:\n",
-    "        raise ValueError(\"No 'Date' column found.\")\n",
-    "    return df\n",
-    "\n",
-    "def identify_risk_free_fund(df: pd.DataFrame) -> str:\n",
-    "    \"\"\"Return column with the smallest stdev (ex-Date).\"\"\"\n",
-    "    target_cols = df.columns.drop(\"Date\")\n",
-    "    rf_col = (df[target_cols].std().idxmin())\n",
-    "    logging.info(\"Risk-free column = %s\", rf_col)\n",
-    "    return rf_col\n",
-    "\n",
-    "# ── minimal UI ─────────────────────────────────────────────────────\n",
-    "src_toggle  = widgets.ToggleButtons(\n",
-    "    options=[(\"Local file\", \"local\"), (\"GitHub raw URL\", \"url\")],\n",
-    "    description=\"Source:\"\n",
-    ")\n",
-    "file_picker = FileChooser(title=\"Pick .csv\")\n",
-    "url_box     = widgets.Text(description=\"Raw-URL:\", placeholder=\"https://…/file.csv\")\n",
-    "load_btn    = widgets.Button(description=\"Load\", button_style=\"success\")\n",
-    "status_out  = widgets.Output()\n",
-    "\n",
-    "def _toggle_src(change):\n",
-    "    mode = change[\"new\"]\n",
-    "    file_picker.layout.display = \"block\" if mode == \"local\" else \"none\"\n",
-    "    url_box.layout.display     = \"block\" if mode == \"url\"   else \"none\"\n",
-    "src_toggle.observe(_toggle_src, names=\"value\")\n",
-    "_toggle_src({\"new\": src_toggle.value})        # initialise visibilities\n",
-    "\n",
-    "session = {\"df\": None, \"rf_col\": None}        # lightweight global\n",
-    "\n",
-    "def _load_clicked(_):\n",
-    "    with status_out:\n",
-    "        clear_output()\n",
-    "        try:\n",
-    "            if src_toggle.value == \"local\":\n",
-    "                if not file_picker.selected:\n",
-    "                    print(\"⚠️ choose a file first\"); return\n",
-    "                path = file_picker.selected\n",
-    "            else:\n",
-    "                path = url_box.value.strip()\n",
-    "                if not path.lower().endswith(\".csv\"):\n",
-    "                    print(\"⚠️ URL must end with .csv\"); return\n",
-    "            df = load_csv(path)\n",
-    "            rf = identify_risk_free_fund(df)\n",
-    "            session[\"df\"], session[\"rf_col\"] = df, rf\n",
-    "            print(f\"✅ Loaded {len(df):,} rows × {df.shape[1]} cols\")\n",
-    "        except Exception as e:\n",
-    "            session[\"df\"] = None\n",
-    "            print(\"❌ Failed:\", e)\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Utility-function suite loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 3 · UTILITY FUNCTIONS ============\n",
-    "\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import logging\n",
-    "from typing import List, Dict, Optional\n",
-    "\n",
-    "M_PER_YEAR = 12   # monthly data\n",
-    "\n",
-    "# ── Basic statistics ────────────────────────────────────────────────────\n",
-    "def annualize_return(series: pd.Series) -> float:\n",
-    "    s = series.dropna()\n",
-    "    if s.empty: return np.nan\n",
-    "    geom = (1 + s).prod() ** (M_PER_YEAR / len(s)) - 1\n",
-    "    return geom\n",
-    "\n",
-    "def annualize_volatility(series: pd.Series) -> float:\n",
-    "    s = series.dropna()\n",
-    "    return s.std(ddof=0) * np.sqrt(M_PER_YEAR) if not s.empty else np.nan\n",
-    "\n",
-    "def sharpe_ratio(series: pd.Series, rf_series: pd.Series) -> float:\n",
-    "    excess = (series - rf_series).dropna()\n",
-    "    vol = annualize_volatility(excess)\n",
-    "    return annualize_return(excess) / vol if vol else np.nan\n",
-    "\n",
-    "def sortino_ratio(series: pd.Series, rf_series: pd.Series) -> float:\n",
-    "    excess = (series - rf_series).dropna()\n",
-    "    neg = excess[excess < 0]\n",
-    "    if neg.empty: return np.nan\n",
-    "    downside_dev = neg.std(ddof=0) * np.sqrt(M_PER_YEAR)\n",
-    "    return annualize_return(excess) / downside_dev if downside_dev else np.nan\n",
-    "\n",
-    "def max_drawdown(series: pd.Series) -> float:\n",
-    "    s = (1 + series).dropna().cumprod()\n",
-    "    peak = s.cummax()\n",
-    "    draw = (s / peak) - 1\n",
-    "    return draw.min() if not draw.empty else np.nan\n",
-    "\n",
-    "# ── Portfolio helpers ──────────────────────────────────────────────────\n",
-    "def calc_portfolio_returns(weights: np.ndarray,\n",
-    "                           df_returns: pd.DataFrame) -> pd.Series:\n",
-    "    \"\"\"Matrix dot product w/ alignment; assumes df already sorted & NaNs dropped.\"\"\"\n",
-    "    return df_returns.dot(weights)\n",
-    "\n",
-    "# ── Fund-selection helper ──────────────────────────────────────────────\n",
-    "def select_funds(df: pd.DataFrame,\n",
-    "                 rf_col: str,\n",
-    "                 fund_columns: List[str],\n",
-    "                 in_sdate: pd.Timestamp,\n",
-    "                 in_edate: pd.Timestamp,\n",
-    "                 out_sdate: pd.Timestamp,\n",
-    "                 out_edate: pd.Timestamp,\n",
-    "                 selection_mode: str = \"all\",\n",
-    "                 random_n: Optional[int] = None,\n",
-    "                 seed: Optional[int] = None) -> List[str]:\n",
-    "    \"\"\"\n",
-    "    production-grade fund selector.\n",
-    "      * full-history rule: non-NA for entire in + out windows\n",
-    "      * no >3 consecutive NA rule across full history\n",
-    "    \"\"\"\n",
-    "    rng = np.random.default_rng(seed)\n",
-    "    full_hist = []\n",
-    "\n",
-    "    mask_full = (df[\"Date\"] >= in_sdate) & (df[\"Date\"] <= out_edate)\n",
-    "    slice_df  = df.loc[mask_full, fund_columns]\n",
-    "\n",
-    "    for col in slice_df.columns:\n",
-    "        col_ser = slice_df[col]\n",
-    "        if col_ser.isna().any():\n",
-    "            # reject if >3 consecutive NAs\n",
-    "            if (col_ser.isna().astype(int).groupby(col_ser.notna().cumsum())\n",
-    "                .sum().max() > 3):\n",
-    "                continue\n",
-    "        full_hist.append(col)\n",
-    "\n",
-    "    if not full_hist:\n",
-    "        return []\n",
-    "\n",
-    "    if selection_mode == \"all\":\n",
-    "        return full_hist\n",
-    "    if selection_mode == \"random\":\n",
-    "        if random_n is None or random_n >= len(full_hist):\n",
-    "            return full_hist\n",
-    "        return list(rng.choice(full_hist, size=random_n, replace=False))\n",
-    "    raise ValueError(\"selection_mode must be 'all', 'random', or handled by caller.\")\n",
-    "\n",
-    "# ── compute_stats wrapper for reuse ────────────────────────────────────\n",
-    "def compute_stats(series: pd.Series, rf_series: pd.Series) -> tuple:\n",
-    "    \"\"\"Return (R, V, Sharpe, Sortino, MDD)\"\"\"\n",
-    "    return (\n",
-    "        annualize_return(series),\n",
-    "        annualize_volatility(series),\n",
-    "        sharpe_ratio(series, rf_series),\n",
-    "        sortino_ratio(series, rf_series),\n",
-    "        max_drawdown(series)\n",
-    "    )\n",
-    "\n",
-    "logging.info(\"Utility-function suite loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "#### 4. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "c5867ccd-a550-4849-a10b-a085f5fe26fd",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "#                 SELECT_FUNDS  (robust, period-based)\n",
-    "# ===============================================================\n",
-    "def select_funds(\n",
-    "        df: pd.DataFrame,\n",
-    "        rf_col: str,\n",
-    "        fund_columns: list[str],\n",
-    "        in_sdate, in_edate,        # str or Timestamp\n",
-    "        out_sdate, out_edate,\n",
-    "        selection_mode: str = \"all\",\n",
-    "        random_n: int | None = None\n",
-    "    ) -> list[str]:\n",
-    "    \"\"\"\n",
-    "    Return a list of funds that\n",
-    "      • have no more than 3 consecutive NaN MONTHS in their entire history, and\n",
-    "      • have at least one non-NaN value in every month inside both the\n",
-    "        in-sample and out-sample windows.\n",
-    "\n",
-    "    All comparisons are done at **month granularity** using Period('M'),\n",
-    "    so it is agnostic to which day of the month the data are recorded.\n",
-    "\n",
-    "    Parameters\n",
-    "    ----------\n",
-    "    df : DataFrame    – must contain a 'Date' column (any dtype).\n",
-    "    rf_col : str      – name of risk-free column (will be excluded).\n",
-    "    fund_columns : list[str] – candidate fund columns.\n",
-    "    in_sdate, in_edate, out_sdate, out_edate : str or Timestamp\n",
-    "        Window endpoints (inclusive).  Only month & year are used.\n",
-    "    selection_mode : {'all','random'}\n",
-    "    random_n : int    – number of random funds to return (if mode=='random').\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # ---- guarantee Date column is datetime -----------------------------\n",
-    "    if not pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        df = df.copy()\n",
-    "        df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "        df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "\n",
-    "    df[\"__Month\"] = df[\"Date\"].dt.to_period(\"M\")\n",
-    "\n",
-    "    # ---- convert bounds to Period --------------------------------------\n",
-    "    in_s,  in_e  = pd.Period(in_sdate,  \"M\"), pd.Period(in_edate,  \"M\")\n",
-    "    out_s, out_e = pd.Period(out_sdate, \"M\"), pd.Period(out_edate, \"M\")\n",
-    "\n",
-    "    must_have = list(pd.period_range(in_s,  in_e,  freq=\"M\")) + \\\n",
-    "                list(pd.period_range(out_s, out_e, freq=\"M\"))\n",
-    "\n",
-    "    eligible = []\n",
-    "    for f in fund_columns:\n",
-    "        s = df[[\"__Month\", f]]\n",
-    "        month_ok = s.groupby(\"__Month\")[f].apply(lambda col: col.notna().any())\n",
-    "\n",
-    "        # (1) full coverage in required months\n",
-    "        if not all(month_ok.get(m, False) for m in must_have):\n",
-    "            continue\n",
-    "\n",
-    "        # (2) ≤ 3 consecutive NaN months in entire history\n",
-    "        full = month_ok.reindex(pd.period_range(month_ok.index.min(),\n",
-    "                                                month_ok.index.max(), freq=\"M\"),\n",
-    "                                fill_value=False)\n",
-    "        gap_lengths = full.astype(int).groupby((~full).cumsum()).cumsum()\n",
-    "        if gap_lengths.where(~full, 0).max() > 3:\n",
-    "            continue\n",
-    "\n",
-    "        eligible.append(f)\n",
-    "\n",
-    "    # ---- selection modes -----------------------------------------------\n",
-    "    if selection_mode == \"all\" or random_n is None:\n",
-    "        return eligible\n",
-    "\n",
-    "    if selection_mode == \"random\":\n",
-    "        if random_n > len(eligible):\n",
-    "            raise ValueError(f\"Asked for {random_n} random funds but only \"\n",
-    "                             f\"{len(eligible)} are eligible.\")\n",
-    "        return list(np.random.choice(eligible, random_n, replace=False))\n",
-    "\n",
-    "    raise ValueError(f\"Unsupported selection_mode: {selection_mode}\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 5. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ============ 5 · CUSTOM WEIGHTS HELPERS ============\n",
-    "\n",
-    "import numpy as np\n",
-    "import logging\n",
-    "from typing import Dict, List, Tuple, Optional\n",
-    "\n",
-    "def validate_weights(weights: Dict[str, int | float],\n",
-    "                     fund_list: List[str]) -> None:\n",
-    "    \"\"\"\n",
-    "    Ensure keys match fund_list and values sum to 100 (percent integers).\n",
-    "    Raises ValueError on any issue.\n",
-    "    \"\"\"\n",
-    "    if set(weights) != set(fund_list):\n",
-    "        raise ValueError(\"Weight keys don’t match selected funds.\")\n",
-    "    total = sum(weights.values())\n",
-    "    if total != 100:\n",
-    "        raise ValueError(f\"Weights sum to {total} instead of 100 %.\")\n",
-    "\n",
-    "def prepare_weights(selected_funds: List[str],\n",
-    "                    custom_weights: Optional[Dict[str, int]]) -> Tuple[Dict[str, float], np.ndarray]:\n",
-    "    \"\"\"\n",
-    "    Convert user dictionary of integer % to:\n",
-    "      • dict of decimals\n",
-    "      • NumPy vector aligned to selected_funds\n",
-    "    If custom_weights is None, returns equal weights.\n",
-    "    \"\"\"\n",
-    "\n",
-    "    n = len(selected_funds)\n",
-    "    if custom_weights is None:\n",
-    "        equal = 1 / n\n",
-    "        dec_dict = {f: equal for f in selected_funds}\n",
-    "        vec = np.full(n, equal)\n",
-    "        logging.info(\"Equal weights applied (%d funds).\", n)\n",
-    "        return dec_dict, vec\n",
-    "\n",
-    "    # manual mode\n",
-    "    validate_weights(custom_weights, selected_funds)\n",
-    "    dec_dict = {f: pct / 100.0 for f, pct in custom_weights.items()}\n",
-    "    vec = np.array([dec_dict[f] for f in selected_funds])\n",
-    "    logging.info(\"Custom weights accepted.\")\n",
-    "    return dec_dict, vec\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 6. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "#                    ANALYSIS CORE  (run_analysis)\n",
-    "# ===============================================================\n",
-    "\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import logging\n",
-    "from typing import List, Dict, Optional\n",
-    "\n",
-    "M_PER_YEAR = 12  # months in a year (monthly data)\n",
-    "\n",
-    "# ------------------------------------------------------------------\n",
-    "#   stats helpers\n",
-    "# ------------------------------------------------------------------\n",
-    "def ann_return(s: pd.Series) -> float:\n",
-    "    s = s.dropna()\n",
-    "    return (1 + s).prod() ** (M_PER_YEAR / len(s)) - 1 if len(s) else np.nan\n",
-    "\n",
-    "def ann_vol(s: pd.Series) -> float:\n",
-    "    s = s.dropna()\n",
-    "    return s.std(ddof=0) * np.sqrt(M_PER_YEAR) if len(s) else np.nan\n",
-    "\n",
-    "def sharpe(s: pd.Series, rf: pd.Series) -> float:\n",
-    "    ex = (s - rf).dropna()\n",
-    "    v  = ann_vol(ex)\n",
-    "    return ann_return(ex) / v if v else np.nan\n",
-    "\n",
-    "def sortino(s: pd.Series, rf: pd.Series) -> float:\n",
-    "    ex  = (s - rf).dropna()\n",
-    "    neg = ex[ex < 0]\n",
-    "    down = neg.std(ddof=0) * np.sqrt(M_PER_YEAR) if len(neg) else np.nan\n",
-    "    return ann_return(ex) / down if down else np.nan\n",
-    "\n",
-    "def max_dd(s: pd.Series) -> float:\n",
-    "    nav = (1 + s).dropna().cumprod()\n",
-    "    return ((nav / nav.cummax()) - 1).min() if len(nav) else np.nan\n",
-    "\n",
-    "def stats_tuple(series: pd.Series, rf: pd.Series) -> tuple:\n",
-    "    \"\"\"(R, V, Sharpe, Sortino, MDD)\"\"\"\n",
-    "    return (ann_return(series),\n",
-    "            ann_vol(series),\n",
-    "            sharpe(series, rf),\n",
-    "            sortino(series, rf),\n",
-    "            max_dd(series))\n",
-    "\n",
-    "# ------------------------------------------------------------------\n",
-    "#   guarantee Date column dtype\n",
-    "# ------------------------------------------------------------------\n",
-    "def _ensure_datetime(df: pd.DataFrame) -> pd.DataFrame:\n",
-    "    if pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        return df\n",
-    "    df = df.copy()\n",
-    "    df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "    df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "    df.sort_values(\"Date\", inplace=True)\n",
-    "    return df\n",
-    "\n",
-    "# ------------------------------------------------------------------\n",
-    "#   MAIN FUNCTION\n",
-    "# ------------------------------------------------------------------\n",
-    "def run_analysis(df: pd.DataFrame,\n",
-    "                 selected_funds: List[str],\n",
-    "                 weight_vec: np.ndarray,\n",
-    "                 weight_dict: Dict[str, float],\n",
-    "                 rf_col: str,\n",
-    "                 in_start: str, in_end: str,\n",
-    "                 out_start: str, out_end: str,\n",
-    "                 target_vol: float = 0.25,\n",
-    "                 monthly_cost: float = 0.0033,\n",
-    "                 indices_list: Optional[List[str]] = None\n",
-    "                 ) -> Dict[str, object]:\n",
-    "    \"\"\"\n",
-    "    Compute per-fund and portfolio stats for the chosen windows.\n",
-    "    Drops any fund that contains *any* NaN in either window.\n",
-    "    \"\"\"\n",
-    "\n",
-    "    df = _ensure_datetime(df)\n",
-    "\n",
-    "    # ---- windows -------------------------------------------------------\n",
-    "    in_s  = pd.to_datetime(in_start)  + pd.offsets.MonthEnd(0)\n",
-    "    in_e  = pd.to_datetime(in_end)    + pd.offsets.MonthEnd(0)\n",
-    "    out_s = pd.to_datetime(out_start) + pd.offsets.MonthEnd(0)\n",
-    "    out_e = pd.to_datetime(out_end)   + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    mask_in, mask_out = (df[\"Date\"].between(in_s,  in_e),\n",
-    "                         df[\"Date\"].between(out_s, out_e))\n",
-    "\n",
-    "    in_df,  out_df  = df.loc[mask_in,  selected_funds], df.loc[mask_out, selected_funds]\n",
-    "    in_rf,  out_rf  = df.loc[mask_in,  rf_col],         df.loc[mask_out, rf_col]\n",
-    "\n",
-    "    # ---- drop incomplete funds ----------------------------------------\n",
-    "    good = [f for f in selected_funds\n",
-    "            if in_df[f].notna().all() and out_df[f].notna().all()]\n",
-    "    if not good:\n",
-    "        raise ValueError(\"No eligible funds after NaN filtering.\")\n",
-    "    if len(good) < len(selected_funds):\n",
-    "        logging.warning(\"Dropped funds with gaps: %s\", sorted(set(selected_funds)-set(good)))\n",
-    "        selected_funds = good\n",
-    "        in_df, out_df  = in_df[good], out_df[good]\n",
-    "        weight_dict    = {f: weight_dict.get(f, 1/len(good)) for f in good}\n",
-    "        weight_vec     = np.array([weight_dict[f] for f in good])\n",
-    "    ew_vec = np.full(len(selected_funds), 1/len(selected_funds))\n",
-    "\n",
-    "    # ---- scale to target vol ------------------------------------------\n",
-    "    scale = {f: target_vol / ann_vol(in_df[f]) if ann_vol(in_df[f]) else 1.0\n",
-    "             for f in selected_funds}\n",
-    "    in_scaled  = in_df.mul(scale).sub(monthly_cost).clip(lower=-1)\n",
-    "    out_scaled = out_df.mul(scale).sub(monthly_cost).clip(lower=-1)\n",
-    "\n",
-    "    # ---- per-fund stats -----------------------------------------------\n",
-    "    in_stats  = {f: stats_tuple(in_scaled[f],  in_rf)  for f in selected_funds}\n",
-    "    out_stats = {f: stats_tuple(out_scaled[f], out_rf) for f in selected_funds}\n",
-    "\n",
-    "    # ---- portfolio returns & stats ------------------------------------\n",
-    "    in_ew    = in_scaled.dot(ew_vec)\n",
-    "    out_ew   = out_scaled.dot(ew_vec)\n",
-    "    in_user  = in_scaled.dot(weight_vec)\n",
-    "    out_user = out_scaled.dot(weight_vec)\n",
-    "\n",
-    "    results = {\n",
-    "        \"selected_funds\":   selected_funds,\n",
-    "        \"indices_list\":     indices_list or [],\n",
-    "        \"fund_weights\":     weight_dict,\n",
-    "        \"ew_weights\":       {f: 1/len(selected_funds) for f in selected_funds},\n",
-    "        \"in_sample_stats\":  in_stats,\n",
-    "        \"out_sample_stats\": out_stats,\n",
-    "        \"in_ew_stats\":      stats_tuple(in_ew,  in_rf),\n",
-    "        \"out_ew_stats\":     stats_tuple(out_ew, out_rf),\n",
-    "        \"in_user_stats\":    stats_tuple(in_user,  in_rf),\n",
-    "        \"out_user_stats\":   stats_tuple(out_user, out_rf)\n",
-    "    }\n",
-    "\n",
-    "    # ---- optional index stats -----------------------------------------\n",
-    "    if indices_list:\n",
-    "        idx_stats = {}\n",
-    "        for idx in indices_list:\n",
-    "            idx_in  = df.loc[mask_in,  idx]\n",
-    "            idx_out = df.loc[mask_out, idx]\n",
-    "            idx_stats[idx] = {\n",
-    "                \"in_sample\":  stats_tuple(idx_in,  in_rf),\n",
-    "                \"out_sample\": stats_tuple(idx_out, out_rf)\n",
-    "            }\n",
-    "        results[\"index_stats\"] = idx_stats\n",
-    "\n",
-    "    logging.info(\"run_analysis complete: %d funds kept.\", len(selected_funds))\n",
-    "    return results\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 7. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 7,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ============ 7 · EXPORT TO EXCEL (weight-format fix) ============\n",
-    "\n",
-    "import xlsxwriter, numpy as np, pandas as pd\n",
-    "from io import BytesIO\n",
-    "import logging\n",
-    "\n",
-    "def export_to_excel(results: dict,\n",
-    "                    full_df: pd.DataFrame,\n",
-    "                    fname: str,\n",
-    "                    in_start: str, in_end: str,\n",
-    "                    out_start: str, out_end: str) -> None:\n",
-    "    \"\"\"\n",
-    "    Workbook writer.\n",
-    "    • Funds in indices_list are skipped.\n",
-    "    • Weight % shows:\n",
-    "        – whole integer if pct ≥ 1\n",
-    "        – two decimals if pct < 1 (e.g., 0.98 %)\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # ---------- helpers --------------------------------------------------\n",
-    "    def safe(v):          # NaN/inf → blank\n",
-    "        return \"\" if (pd.isna(v) or not np.isfinite(v)) else v\n",
-    "\n",
-    "    def ok(t1, t2):       # at least one finite metric\n",
-    "        return any(np.isfinite(x) for x in t1 + t2)\n",
-    "\n",
-    "    def pctify(t):\n",
-    "        r, v, s, so, m = t\n",
-    "        return [r*100, v*100, s, so, m*100]\n",
-    "\n",
-    "    indices_set = set(results.get(\"indices_list\", []))\n",
-    "\n",
-    "    # ---------- workbook -------------------------------------------------\n",
-    "    buf = BytesIO()\n",
-    "    wb  = xlsxwriter.Workbook(buf, {\"in_memory\": True})\n",
-    "    ws  = wb.add_worksheet(\"Summary\")\n",
-    "\n",
-    "    bold   = wb.add_format({\"bold\": True})\n",
-    "    int0   = wb.add_format({\"num_format\": \"0\"})\n",
-    "    num2   = wb.add_format({\"num_format\": \"0.00\"})\n",
-    "    red    = wb.add_format({\"num_format\": \"0.00\", \"font_color\": \"red\"})\n",
-    "\n",
-    "    # ---------- header ---------------------------------------------------\n",
-    "    ws.write(0, 0, \"Vol-Adj Trend Analysis\", bold)\n",
-    "    ws.write(1, 0, f\"In-Sample:  {in_start} → {in_end}\")\n",
-    "    ws.write(2, 0, f\"Out-Sample: {out_start} → {out_end}\")\n",
-    "\n",
-    "    row = 4\n",
-    "    ws.write(row, 0, \"Portfolio returns\", bold); row += 1\n",
-    "\n",
-    "    cols = [\"Name\", \"Weight %\",\n",
-    "            \"R (IN) %\", \"V (IN) %\", \"Sharpe (IN)\", \"Sortino (IN)\", \"MDD (IN) %\",\n",
-    "            \"R (OUT) %\", \"V (OUT) %\", \"Sharpe (OUT)\", \"Sortino (OUT)\", \"MDD (OUT) %\"]\n",
-    "    ws.write_row(row, 0, cols, bold); row += 1\n",
-    "\n",
-    "    # ---------- inner writer --------------------------------------------\n",
-    "    def write_row(r, name, wt_dec_or_blank, tin, tout, emph=False):\n",
-    "        ws.write(r, 0, name, bold if emph else None)\n",
-    "\n",
-    "        # Weight % column\n",
-    "        if wt_dec_or_blank == \"\":\n",
-    "            ws.write(r, 1, \"\")\n",
-    "        else:\n",
-    "            pct = wt_dec_or_blank*100 if wt_dec_or_blank <= 1 else wt_dec_or_blank\n",
-    "            fmt = int0 if pct >= 1 else num2\n",
-    "            ws.write(r, 1, pct, fmt)\n",
-    "\n",
-    "        vals = pctify(tin) + pctify(tout)\n",
-    "        fmts = [num2, num2, num2, num2, red,\n",
-    "                num2, num2, num2, num2, red]\n",
-    "        for c, (v, f) in enumerate(zip(vals, fmts), start=2):\n",
-    "            ws.write(r, c, safe(v), f)\n",
-    "\n",
-    "    # ---------- weights dicts -------------------------------------------\n",
-    "    ew_w = results.get(\"ew_weights\", {})\n",
-    "    uw_w = results.get(\"fund_weights\", {}) or ew_w\n",
-    "\n",
-    "    # ---------- portfolio rows ------------------------------------------\n",
-    "    write_row(row, \"Equal-Weight\", 1,\n",
-    "              results[\"in_ew_stats\"], results[\"out_ew_stats\"], True); row += 1\n",
-    "    write_row(row, \"User-Weight\",  1,\n",
-    "              results[\"in_user_stats\"], results[\"out_user_stats\"], True); row += 2\n",
-    "\n",
-    "    # ---------- fund rows (eligible only) -------------------------------\n",
-    "    ws.write(row, 0, \"Funds\", bold); row += 1\n",
-    "    kept = 0\n",
-    "    for f in results[\"selected_funds\"]:\n",
-    "        if f in indices_set:\n",
-    "            continue\n",
-    "        tin  = results[\"in_sample_stats\"][f]\n",
-    "        tout = results[\"out_sample_stats\"][f]\n",
-    "        if not ok(tin, tout):\n",
-    "            continue\n",
-    "        write_row(row, f, uw_w.get(f, 0), tin, tout)\n",
-    "        row += 1\n",
-    "        kept += 1\n",
-    "\n",
-    "    # ---------- index rows ----------------------------------------------\n",
-    "    if results.get(\"index_stats\"):\n",
-    "        ws.write(row, 0, \"INDEX\", bold); row += 1\n",
-    "        for idx, sd in results[\"index_stats\"].items():\n",
-    "            write_row(row, idx, \"\", sd[\"in_sample\"], sd[\"out_sample\"], True)\n",
-    "            row += 1\n",
-    "\n",
-    "    # ---------- raw data tab --------------------------------------------\n",
-    "    ws2 = wb.add_worksheet(\"Raw Data\")\n",
-    "    ws2.write_row(0, 0, full_df.columns.tolist(), bold)\n",
-    "    for r, (_, ser) in enumerate(full_df.iterrows(), start=1):\n",
-    "        ws2.write_row(\n",
-    "            r, 0,\n",
-    "            [d.strftime(\"%Y-%m-%d\") if isinstance(d, pd.Timestamp)\n",
-    "             else \"\" if (isinstance(d, (float, int)) and (pd.isna(d) or not np.isfinite(d)))\n",
-    "             else d\n",
-    "             for d in ser]\n",
-    "        )\n",
-    "\n",
-    "    wb.close()\n",
-    "    with open(fname, \"wb\") as f:\n",
-    "        f.write(buf.getvalue())\n",
-    "\n",
-    "    logging.info(\"Workbook saved → %s (funds written: %d)\", fname, kept)\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Run Parameters,Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 8,
-   "id": "e48de568-962e-4690-a6fc-be7a4ec0a3c6",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "c8f46d54607e4e5380538bb206bee5fc",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<h4>1. Load data</h4>'), ToggleButtons(description='Source:', options=(('Local file…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# ===============================================================\n",
-    "#              ONE-STOP ANALYSIS UI  (eligibility-synced)\n",
-    "# ===============================================================\n",
-    "\n",
-    "import pandas as pd, numpy as np, ipywidgets as widgets, logging\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "\n",
-    "# ───────── session dict ─────────\n",
-    "session = {\"df\": None, \"rf_col\": None,\n",
-    "           \"selected_funds\": None, \"custom_weights\": None}\n",
-    "\n",
-    "# ───────── 1 · DATA SOURCE ───────\n",
-    "src_toggle = widgets.ToggleButtons(\n",
-    "    options=[(\"Local file\", \"local\"), (\"GitHub raw URL\", \"url\")],\n",
-    "    description=\"Source:\"\n",
-    ")\n",
-    "file_chooser = FileChooser(title=\"Pick .csv\")\n",
-    "url_box  = widgets.Text(description=\"Raw-URL:\", placeholder=\"https://…/file.csv\")\n",
-    "load_btn = widgets.Button(description=\"Load CSV\", button_style=\"success\")\n",
-    "load_out = widgets.Output()\n",
-    "\n",
-    "def _show_src(ch):\n",
-    "    file_chooser.layout.display = \"block\" if ch[\"new\"] == \"local\" else \"none\"\n",
-    "    url_box.layout.display      = \"block\" if ch[\"new\"] == \"url\"   else \"none\"\n",
-    "src_toggle.observe(_show_src, names=\"value\")\n",
-    "_show_src({\"new\": src_toggle.value})\n",
-    "\n",
-    "def _load(_):\n",
-    "    with load_out:\n",
-    "        clear_output()\n",
-    "        try:\n",
-    "            path = file_chooser.selected if src_toggle.value==\"local\" else url_box.value.strip()\n",
-    "            if not path:  print(\"⚠️ choose file / URL\"); return\n",
-    "            if src_toggle.value==\"url\" and not path.lower().endswith(\".csv\"):\n",
-    "                print(\"⚠️ URL must end with .csv\"); return\n",
-    "            df = load_csv(path)                            # helper\n",
-    "            rf = identify_risk_free_fund(df)\n",
-    "            session.update(df=df, rf_col=rf,\n",
-    "                           selected_funds=None, custom_weights=None)\n",
-    "            print(f\"✅ Loaded {len(df):,} rows × {df.shape[1]} cols | RF → {rf}\")\n",
-    "        except Exception as e:\n",
-    "            session[\"df\"] = None\n",
-    "            print(\"❌\", e)\n",
-    "load_btn.on_click(_load)\n",
-    "\n",
-    "# ───────── 2 · PARAMETERS ─────────\n",
-    "index_cnt   = widgets.BoundedIntText(0, min=0, max=10, description=\"# Indices:\")\n",
-    "in_start    = widgets.Text(\"2005-07\", description=\"In Start:\")\n",
-    "in_end      = widgets.Text(\"2008-06\", description=\"In End:\")\n",
-    "out_start   = widgets.Text(\"2008-07\", description=\"Out Start:\")\n",
-    "out_end     = widgets.Text(\"2009-06\", description=\"Out End:\")\n",
-    "target_vol   = widgets.FloatText(0.25,  description=\"Target Vol:\")\n",
-    "monthly_cost = widgets.FloatText(0.0033, description=\"Monthly Cost:\")\n",
-    "\n",
-    "# ───────── 3 · FUND SELECTION ─────\n",
-    "mode_dd = widgets.Dropdown(\n",
-    "    options=[(\"All funds\", \"all\"),\n",
-    "             (\"Random sample\", \"random\"),\n",
-    "             (\"Manual pick\",   \"manual\")],\n",
-    "    value=\"all\", description=\"Mode:\"\n",
-    ")\n",
-    "rand_n      = widgets.BoundedIntText(5, min=2, max=100, description=\"Sample N:\")\n",
-    "fund_table  = widgets.VBox([])\n",
-    "total_lbl   = widgets.Label(\"Total = 0 %\")\n",
-    "\n",
-    "def _toggle_vis(_=None):\n",
-    "    rand_n.layout.display         = \"block\" if mode_dd.value == \"random\" else \"none\"\n",
-    "    show                           = \"block\" if mode_dd.value == \"manual\" else \"none\"\n",
-    "    fund_table.layout.display      = show\n",
-    "    total_lbl.layout.display       = show\n",
-    "mode_dd.observe(_toggle_vis, names=\"value\")\n",
-    "_toggle_vis()\n",
-    "\n",
-    "def _eligible_pool() -> list[str]:\n",
-    "    df, rf = session[\"df\"], session[\"rf_col\"]\n",
-    "    if df is None: return []\n",
-    "    cand = [c for c in df.columns if c not in [\"Date\", rf]]\n",
-    "    return select_funds(\n",
-    "        df, rf, cand,\n",
-    "        in_start.value + \"-01\", in_end.value + \"-01\",\n",
-    "        out_start.value + \"-01\", out_end.value + \"-01\",\n",
-    "        \"all\"\n",
-    "    )\n",
-    "\n",
-    "def _build_manual(*_):\n",
-    "    if mode_dd.value != \"manual\" or session[\"df\"] is None: return\n",
-    "    valid = _eligible_pool()\n",
-    "    rows, cbxs, wbx = [], [], []\n",
-    "    def _update_total(*_):\n",
-    "        total_lbl.value = f\"Total = {sum(w.value for c,w in zip(cbxs,wbx) if c.value)} %\"\n",
-    "    fund_table.children = []\n",
-    "    for f in valid:\n",
-    "        cb = widgets.Checkbox(description=f, layout=widgets.Layout(width=\"200px\"))\n",
-    "        wt = widgets.BoundedIntText(0, min=0, max=100,\n",
-    "                                    layout=widgets.Layout(width=\"60px\"), disabled=True)\n",
-    "        cb.observe(lambda ch, box=wt: (setattr(box,\"disabled\",not ch[\"new\"]), _update_total()),\n",
-    "                   names=\"value\")\n",
-    "        wt.observe(_update_total, names=\"value\")\n",
-    "        cbxs.append(cb); wbx.append(wt); rows.append(widgets.HBox([cb, wt]))\n",
-    "    fund_table.children = rows\n",
-    "    _update_total()\n",
-    "\n",
-    "# rebuild table when mode toggles to manual or dates change\n",
-    "mode_dd.observe(lambda ch: _build_manual() if ch[\"new\"]==\"manual\" else None,\n",
-    "                names=\"value\")\n",
-    "for w in (in_start, in_end, out_start, out_end):\n",
-    "    w.observe(_build_manual, names=\"value\")\n",
-    "\n",
-    "# ───────── 4 · RUN ANALYSIS ───────\n",
-    "run_btn = widgets.Button(description=\"Run Analysis\", button_style=\"success\")\n",
-    "run_out = widgets.Output(layout={\"border\":\"1px solid #999\",\n",
-    "                                 \"height\":\"340px\", \"overflow_y\":\"auto\"})\n",
-    "\n",
-    "def _run(_):\n",
-    "    with run_out:\n",
-    "        clear_output()\n",
-    "        df, rf = session[\"df\"], session[\"rf_col\"]\n",
-    "        if df is None:\n",
-    "            print(\"⚠️ Load data first\"); return\n",
-    "\n",
-    "        # validate dates\n",
-    "        try:\n",
-    "            _ = [pd.to_datetime(s+\"-01\", format=\"%Y-%m-%d\", errors=\"raise\")\n",
-    "                 for s in (in_start.value, in_end.value, out_start.value, out_end.value)]\n",
-    "        except Exception:\n",
-    "            print(\"❌ dates must be YYYY-MM\"); return\n",
-    "\n",
-    "        # indices list\n",
-    "        idx_n = index_cnt.value\n",
-    "        indices_list = df.columns.drop(\"Date\").to_list()[-idx_n:] if idx_n else []\n",
-    "\n",
-    "        # eligible pool for the current window\n",
-    "        valid = _eligible_pool()\n",
-    "        if not valid:\n",
-    "            print(\"❌ No eligible funds for this window.\"); return\n",
-    "\n",
-    "        # selection\n",
-    "        if mode_dd.value == \"all\":\n",
-    "            sel, custom_w = valid, None\n",
-    "\n",
-    "        elif mode_dd.value == \"random\":\n",
-    "            if rand_n.value > len(valid):\n",
-    "                print(f\"❌ Only {len(valid)} eligible funds; Sample N exceeds that.\"); return\n",
-    "            sel = list(np.random.choice(valid, rand_n.value, replace=False))\n",
-    "            custom_w = None\n",
-    "\n",
-    "        else:\n",
-    "            sel, custom_w = [], {}\n",
-    "            if not fund_table.children: _build_manual()\n",
-    "            for row in fund_table.children:\n",
-    "                cb, wt = row.children\n",
-    "                if cb.value:\n",
-    "                    sel.append(cb.description)\n",
-    "                    custom_w[cb.description] = wt.value\n",
-    "            if not sel:\n",
-    "                print(\"⚠️ Tick at least one fund.\"); return\n",
-    "            if sum(custom_w.values()) != 100:\n",
-    "                print(\"⚠️ Weights must sum to 100 %.\"); return\n",
-    "\n",
-    "        session.update(selected_funds=sel, custom_weights=custom_w)\n",
-    "\n",
-    "        # weights\n",
-    "        try:\n",
-    "            w_dict, w_vec = prepare_weights(sel, custom_w)\n",
-    "        except ValueError as e:\n",
-    "            print(\"❌\", e); return\n",
-    "\n",
-    "        # run analysis\n",
-    "        res = run_analysis(\n",
-    "            df, sel, w_vec, w_dict, rf,\n",
-    "            in_start.value, in_end.value,\n",
-    "            out_start.value, out_end.value,\n",
-    "            target_vol.value, monthly_cost.value,\n",
-    "            indices_list\n",
-    "        )\n",
-    "\n",
-    "        # export\n",
-    "        print(\"✅ analysis complete |\", len(sel), \"funds\")\n",
-    "        fname = f\"IS_{in_start.value}_{out_start.value}.xlsx\"\n",
-    "        export_to_excel(res, df, fname,\n",
-    "                        in_start.value, in_end.value,\n",
-    "                        out_start.value, out_end.value)\n",
-    "        print(\"Workbook saved as\", fname)\n",
-    "\n",
-    "run_btn.on_click(_run)\n",
-    "\n",
-    "# ───────── DISPLAY PANEL ─────────\n",
-    "display(widgets.VBox([\n",
-    "    widgets.HTML(\"<h4>1. Load data</h4>\"),\n",
-    "    src_toggle, file_chooser, url_box, load_btn, load_out,\n",
-    "    widgets.HTML(\"<hr><h4>2. Parameters</h4>\"),\n",
-    "    widgets.HBox([index_cnt]),\n",
-    "    widgets.HBox([in_start, in_end, out_start, out_end]),\n",
-    "    widgets.HBox([target_vol, monthly_cost]),\n",
-    "    widgets.HTML(\"<hr><h4>3. Fund selection</h4>\"),\n",
-    "    widgets.HBox([mode_dd, rand_n]),\n",
-    "    fund_table, total_lbl,\n",
-    "    widgets.HTML(\"<hr>\"),\n",
-    "    run_btn,\n",
-    "    run_out\n",
-    "]))\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "c08bead4-19fe-46d9-bf59-b060b6860e42",
-   "metadata": {},
-   "outputs": [],
-   "source": []
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup7-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup7-checkpoint.ipynb
deleted file mode 100644
index 3c1d0f9c563dc8b3c0165608d99f5038cf4ae7f4..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Cleanup7-checkpoint.ipynb
+++ /dev/null
@@ -1,735 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "raw",
-   "id": "074a66d9-dc7e-4ed7-bf04-3d86ee931295",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Imports, Data Loader and Rf Detector\n",
-    "2. Select fund (month period logic)\n",
-    "3. Weight prep\n",
-    "4. Core Stats + Run Analysis\n",
-    "5. Export\n",
-    "6. Widget /UI\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "#      VOL-ADJ TREND ANALYSIS  –  SINGLE-FILE VERSION\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  0 · IMPORTS  (all in one place)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "import pandas as pd\n",
-    "import numpy as np\n",
-    "import xlsxwriter\n",
-    "import logging\n",
-    "from io import BytesIO\n",
-    "import ipywidgets as widgets\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "from typing import List, Dict, Optional\n",
-    "\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  1 · CSV LOADER + RF DETECTOR\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "def load_csv(path: str) -> pd.DataFrame:\n",
-    "    df = pd.read_csv(path)\n",
-    "    if \"Date\" not in df.columns:\n",
-    "        raise ValueError(\"CSV must contain a 'Date' column.\")\n",
-    "    return df\n",
-    "\n",
-    "def identify_risk_free_fund(df: pd.DataFrame) -> str:\n",
-    "    returns = df.drop(columns=\"Date\", errors=\"ignore\")\n",
-    "    stdevs  = returns.std(skipna=True, ddof=0)\n",
-    "    return stdevs.idxmin()"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Select Funds"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "# 2 · SELECT_FUNDS  (restored ≤ 3-missing-months rule)\n",
-    "# ===============================================================\n",
-    "def select_funds(\n",
-    "        df: pd.DataFrame,\n",
-    "        rf_col: str,\n",
-    "        fund_columns: list[str],\n",
-    "        in_sdate, in_edate,\n",
-    "        out_sdate, out_edate,\n",
-    "        selection_mode: str = \"all\",\n",
-    "        random_n: int | None = None\n",
-    ") -> list[str]:\n",
-    "    \"\"\"\n",
-    "    Eligible funds:\n",
-    "      • ≤ 3 months missing inside combined in/out window\n",
-    "      • no run of > 6 consecutive NaN months inside that window\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # ---- single coercion --------------------------------------------\n",
-    "    if not pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        df = df.copy()\n",
-    "        df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "        df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "\n",
-    "    df[\"Month\"] = df[\"Date\"].dt.to_period(\"M\")\n",
-    "\n",
-    "    span = pd.period_range(pd.Period(in_sdate, \"M\"),\n",
-    "                           pd.Period(out_edate, \"M\"), freq=\"M\")\n",
-    "\n",
-    "    eligible = []\n",
-    "    for f in fund_columns:\n",
-    "        # monthly coverage mask over the analysis span\n",
-    "        m_ok = (df.groupby(\"Month\")[f]\n",
-    "                  .apply(lambda col: col.notna().any()))\n",
-    "        mask = m_ok.reindex(span, fill_value=False).to_numpy()\n",
-    "\n",
-    "        # ----- missing-month tolerance ≤ 3 ----------------------------\n",
-    "        if (~mask).sum() > 3:           # ← restored original tolerance\n",
-    "            continue\n",
-    "\n",
-    "        # ----- gap test  (run length > 6) -----------------------------\n",
-    "        gap = np.diff(np.flatnonzero(np.r_[True, mask, True])).max() - 1\n",
-    "        if gap > 6:\n",
-    "            continue\n",
-    "\n",
-    "        eligible.append(f)\n",
-    "\n",
-    "    # ---- selection modes --------------------------------------------\n",
-    "    if selection_mode == \"all\" or random_n is None:\n",
-    "        return eligible\n",
-    "    if selection_mode == \"random\":\n",
-    "        if random_n > len(eligible):\n",
-    "            raise ValueError(f\"Sample N {random_n} > eligible {len(eligible)}\")\n",
-    "        return list(np.random.choice(eligible, random_n, replace=False))\n",
-    "    raise ValueError(\"Unsupported selection_mode\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Weight Prep"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  3 · WEIGHT PREP\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "def prepare_weights(selected: list[str],\n",
-    "                    custom: Dict[str, int] | None) -> tuple[Dict[str, float], np.ndarray]:\n",
-    "    if not custom:\n",
-    "        w = {f: 1/len(selected) for f in selected}\n",
-    "    else:\n",
-    "        missing = [f for f in selected if f not in custom]\n",
-    "        if missing:\n",
-    "            raise ValueError(f\"Missing weights for {missing}\")\n",
-    "        w = {f: pct/100 for f, pct in custom.items()}\n",
-    "        if abs(sum(w.values()) - 1) > 1e-6:\n",
-    "            raise ValueError(\"Custom weights must sum to 100.\")\n",
-    "    vec = np.array([w[f] for f in selected])\n",
-    "    return w, vec"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 4. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Function definitions\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ===============================================================\n",
-    "# 4 · CORE STATS  +  RUN_ANALYSIS  (helpers included, weight fix)\n",
-    "# ===============================================================\n",
-    "\n",
-    "M_PER_YEAR = 12           # constant used across helpers\n",
-    "\n",
-    "# ---------- helpers --------------------------------------------\n",
-    "def _ensure_dt(df: pd.DataFrame) -> pd.DataFrame:\n",
-    "    \"\"\"Return a copy whose Date column is datetime64[ns].\"\"\"\n",
-    "    if pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "        return df\n",
-    "    df = df.copy()\n",
-    "    df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "    df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "    return df\n",
-    "\n",
-    "\n",
-    "def _ann_return(s: pd.Series) -> float:\n",
-    "    s = s.dropna()\n",
-    "    return (1 + s).prod() ** (M_PER_YEAR / len(s)) - 1 if len(s) else np.nan\n",
-    "\n",
-    "\n",
-    "def _ann_vol(s: pd.Series) -> float:\n",
-    "    s = s.dropna()\n",
-    "    return s.std(ddof=0) * np.sqrt(M_PER_YEAR) if len(s) else np.nan\n",
-    "\n",
-    "\n",
-    "def _sharpe(s: pd.Series, rf: pd.Series) -> float:\n",
-    "    ex = (s - rf).dropna()\n",
-    "    vol = _ann_vol(ex)\n",
-    "    return _ann_return(ex) / vol if vol else np.nan\n",
-    "\n",
-    "\n",
-    "def _sortino(s: pd.Series, rf: pd.Series) -> float:\n",
-    "    ex = (s - rf).dropna()\n",
-    "    neg = ex[ex < 0]\n",
-    "    dvol = neg.std(ddof=0) * np.sqrt(M_PER_YEAR) if len(neg) else np.nan\n",
-    "    return _ann_return(ex) / dvol if dvol else np.nan\n",
-    "\n",
-    "\n",
-    "def _max_dd(s: pd.Series) -> float:\n",
-    "    nav = (1 + s).dropna().cumprod()\n",
-    "    return ((nav / nav.cummax()) - 1).min() if len(nav) else np.nan\n",
-    "\n",
-    "\n",
-    "def _stats(series: pd.Series, rf_series: pd.Series) -> tuple[float, ...]:\n",
-    "    return (\n",
-    "        _ann_return(series),\n",
-    "        _ann_vol(series),\n",
-    "        _sharpe(series, rf_series),\n",
-    "        _sortino(series, rf_series),\n",
-    "        _max_dd(series),\n",
-    "    )\n",
-    "\n",
-    "\n",
-    "# ---------- main ------------------------------------------------\n",
-    "def run_analysis(\n",
-    "    df: pd.DataFrame,\n",
-    "    selected: list[str],\n",
-    "    w_vec: np.ndarray,\n",
-    "    w_dict: dict[str, float] | None,\n",
-    "    rf_col: str,\n",
-    "    in_start: str,\n",
-    "    in_end: str,\n",
-    "    out_start: str,\n",
-    "    out_end: str,\n",
-    "    target_vol: float = 0.25,\n",
-    "    monthly_cost: float = 0.0033,\n",
-    "    indices_list: Optional[list[str]] = None,\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Vectorised run_analysis with correct weight re-normalisation\n",
-    "    after funds are dropped.\n",
-    "    Returns the same keys used by the UI and export functions.\n",
-    "    \"\"\"\n",
-    "    df = _ensure_dt(df)\n",
-    "\n",
-    "    # ---- date masks --------------------------------------------------\n",
-    "    in_s = pd.to_datetime(in_start)  + pd.offsets.MonthEnd(0)\n",
-    "    in_e = pd.to_datetime(in_end)    + pd.offsets.MonthEnd(0)\n",
-    "    out_s= pd.to_datetime(out_start) + pd.offsets.MonthEnd(0)\n",
-    "    out_e= pd.to_datetime(out_end)   + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    m_in  = df[\"Date\"].between(in_s,  in_e)\n",
-    "    m_out = df[\"Date\"].between(out_s, out_e)\n",
-    "\n",
-    "    in_df,  out_df  = df.loc[m_in,  selected], df.loc[m_out, selected]\n",
-    "    in_rf,  out_rf  = df.loc[m_in,  rf_col],   df.loc[m_out, rf_col]\n",
-    "\n",
-    "    # ---- drop funds with any NaNs in either window ------------------\n",
-    "    good = [f for f in selected\n",
-    "            if in_df[f].notna().all() and out_df[f].notna().all()]\n",
-    "    dropped = list(set(selected) - set(good))\n",
-    "    if dropped:\n",
-    "        logging.warning(\"Dropped funds: %s\", dropped)\n",
-    "\n",
-    "    selected = good\n",
-    "    # >>>> new guard: kick out any accidental index columns\n",
-    "    selected = [f for f in selected if f not in (indices_list or [])]\n",
-    "    # <<<<\n",
-    "\n",
-    "    in_df, out_df = in_df[selected], out_df[selected]\n",
-    "\n",
-    "    # rebuild weights\n",
-    "    if w_dict is None:                      # equal-weight path\n",
-    "        w_dict = {f: 1/len(selected) for f in selected}\n",
-    "    else:                                   # manual path → rescale\n",
-    "        pct   = {f: w_dict[f]*100 for f in selected}\n",
-    "        total = sum(pct.values())\n",
-    "        w_dict = {f: p/total for f, p in pct.items()}\n",
-    "    w_vec = np.array([w_dict[f] for f in selected])\n",
-    "\n",
-    "    # ---- scaling ----------------------------------------------------\n",
-    "    vols = in_df.apply(_ann_vol)\n",
-    "    scale = np.where(vols > 0, target_vol / vols, 1.0)\n",
-    "    in_sc  = (in_df * scale) - monthly_cost\n",
-    "    out_sc = (out_df * scale) - monthly_cost\n",
-    "    in_sc.clip(lower=-1, inplace=True)\n",
-    "    out_sc.clip(lower=-1, inplace=True)\n",
-    "\n",
-    "    # ---- stats ------------------------------------------------------\n",
-    "    in_stat  = {f: _stats(in_sc[f],  in_rf) for f in selected}\n",
-    "    out_stat = {f: _stats(out_sc[f], out_rf) for f in selected}\n",
-    "\n",
-    "    ew_vec = np.full(len(selected), 1/len(selected))\n",
-    "\n",
-    "    results = {\n",
-    "        \"selected_funds\": selected,\n",
-    "        \"indices_list\":   indices_list or [],\n",
-    "        \"fund_weights\":   w_dict,\n",
-    "        \"ew_weights\":     {f: 1/len(selected) for f in selected},\n",
-    "        \"in_sample_stats\":  in_stat,\n",
-    "        \"out_sample_stats\": out_stat,\n",
-    "        \"in_ew_stats\":     _stats(in_sc.dot(ew_vec), in_rf),\n",
-    "        \"out_ew_stats\":    _stats(out_sc.dot(ew_vec), out_rf),\n",
-    "        \"in_user_stats\":   _stats(in_sc.dot(w_vec),  in_rf),\n",
-    "        \"out_user_stats\":  _stats(out_sc.dot(w_vec), out_rf),\n",
-    "        \"dropped\":         dropped,\n",
-    "    }\n",
-    "\n",
-    "    # ---- optional index stats ---------------------------------------\n",
-    "    if indices_list:\n",
-    "        idx_stats = {}\n",
-    "        for col in indices_list:\n",
-    "            idx_stats[col] = {\n",
-    "                \"in_sample\":  _stats(df.loc[m_in,  col], in_rf),\n",
-    "                \"out_sample\": _stats(df.loc[m_out, col], out_rf),\n",
-    "            }\n",
-    "        results[\"index_stats\"] = idx_stats\n",
-    "\n",
-    "    return results\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 5. Excel Export\n",
-    "Creates an Excel file with In-Sample, Out-of-Sample and Equal-weight and User-weight."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ───────────────────────────────────────────────────────────────\n",
-    "#  5 · EXPORT  (NaN-safe, weight-format fix)\n",
-    "# ───────────────────────────────────────────────────────────────\n",
-    "# ───────── 5 · EXPORT  (final, bug-free) ───────────────────────\n",
-    "# ───────── 5 · EXPORT  (self-healing index section) ───────────\n",
-    "# ───────── 5 · EXPORT  (final safe version) ───────────────────\n",
-    "def export_to_excel(results, full_df, fname,\n",
-    "                    in_start, in_end, out_start, out_end):\n",
-    "    \"\"\"\n",
-    "    Write summary & stats to an Excel workbook.\n",
-    "    Will compute index_stats on-the-fly if they were not pre-computed.\n",
-    "    \"\"\"\n",
-    "\n",
-    "    buf = BytesIO()\n",
-    "    wb  = xlsxwriter.Workbook(buf, {\"in_memory\": True})\n",
-    "    ws  = wb.add_worksheet(\"Summary\")\n",
-    "\n",
-    "    bold = wb.add_format({\"bold\": True})\n",
-    "    int0 = wb.add_format({\"num_format\": \"0\"})\n",
-    "    num2 = wb.add_format({\"num_format\": \"0.00\"})\n",
-    "    red  = wb.add_format({\"num_format\": \"0.00\", \"font_color\": \"red\"})\n",
-    "\n",
-    "    safe = lambda v: \"\" if (pd.isna(v) or not np.isfinite(v)) else v\n",
-    "    pct  = lambda t: [t[0]*100, t[1]*100, t[2], t[3], t[4]*100]\n",
-    "\n",
-    "    # ─── header rows ──────────────────────────────────────────\n",
-    "    ws.write_row(0, 0, [\"Vol-Adj Trend Analysis\"], bold)\n",
-    "    ws.write_row(1, 0, [f\"In:  {in_start} → {in_end}\"])\n",
-    "    ws.write_row(2, 0, [f\"Out: {out_start} → {out_end}\"])\n",
-    "\n",
-    "    hdr = [\"Name\", \"Weight %\",\n",
-    "           \"R (IN)%\", \"V (IN)%\", \"Sharpe\", \"Sortino\", \"MDD (IN)%\",\n",
-    "           \"R (OUT)%\", \"V (OUT)%\", \"Sharpe\", \"Sortino\", \"MDD (OUT)%\"]\n",
-    "    row = 4\n",
-    "    ws.write_row(row, 0, hdr, bold)\n",
-    "    row += 1\n",
-    "\n",
-    "    def wr(r, name, wt, tin, tout, b=False):\n",
-    "        ws.write(r, 0, name, bold if b else None)\n",
-    "        ws.write(r, 1,\n",
-    "                 wt*100 if wt != \"\" else \"\",\n",
-    "                 int0 if wt != \"\" else None)\n",
-    "        for c, (v, fm) in enumerate(zip(pct(tin)+pct(tout),\n",
-    "                                        [num2,num2,num2,num2,red]*2), start=2):\n",
-    "            ws.write(r, c, safe(v), fm)\n",
-    "\n",
-    "    # ─── portfolio rows ──────────────────────────────────────\n",
-    "    wr(row, \"Equal-Weight\", 1,\n",
-    "       results[\"in_ew_stats\"],  results[\"out_ew_stats\"], True); row += 1\n",
-    "    wr(row, \"User-Weight\",  1,\n",
-    "       results[\"in_user_stats\"], results[\"out_user_stats\"], True); row += 2\n",
-    "\n",
-    "    # ─── fund rows ───────────────────────────────────────────\n",
-    "    ws.write(row, 0, \"Funds\", bold); row += 1\n",
-    "    for f in results[\"selected_funds\"]:\n",
-    "        wr(row, f, results[\"fund_weights\"][f],\n",
-    "           results[\"in_sample_stats\"][f],\n",
-    "           results[\"out_sample_stats\"][f]); row += 1\n",
-    "\n",
-    "    # ─── index rows (compute if necessary) ───────────────────\n",
-    "    if results.get(\"indices_list\"):\n",
-    "        idx_stats = results.get(\"index_stats\")\n",
-    "        if not idx_stats:\n",
-    "            # build stats on the fly (coerce Date first)\n",
-    "            df = full_df.copy()\n",
-    "            if not pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-    "                df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-    "                df.dropna(subset=[\"Date\"], inplace=True)\n",
-    "\n",
-    "            rf = identify_risk_free_fund(df)\n",
-    "            in_s  = pd.to_datetime(in_start)  + pd.offsets.MonthEnd(0)\n",
-    "            in_e  = pd.to_datetime(in_end)    + pd.offsets.MonthEnd(0)\n",
-    "            out_s = pd.to_datetime(out_start) + pd.offsets.MonthEnd(0)\n",
-    "            out_e = pd.to_datetime(out_end)   + pd.offsets.MonthEnd(0)\n",
-    "            m_in  = df[\"Date\"].between(in_s,  in_e)\n",
-    "            m_out = df[\"Date\"].between(out_s, out_e)\n",
-    "\n",
-    "            idx_stats = {}\n",
-    "            for col in results[\"indices_list\"]:\n",
-    "                idx_stats[col] = {\n",
-    "                    \"in_sample\":  _stats(df.loc[m_in,  col],\n",
-    "                                         df.loc[m_in,  rf]),\n",
-    "                    \"out_sample\": _stats(df.loc[m_out, col],\n",
-    "                                         df.loc[m_out, rf])\n",
-    "                }\n",
-    "\n",
-    "        ws.write(row, 0, \"INDEX\", bold); row += 1\n",
-    "        for idx, sd in idx_stats.items():\n",
-    "            wr(row, idx, \"\",\n",
-    "               sd[\"in_sample\"], sd[\"out_sample\"], True)\n",
-    "            row += 1\n",
-    "\n",
-    "    # ─── save ────────────────────────────────────────────────\n",
-    "    wb.close()\n",
-    "    with open(fname, \"wb\") as f:\n",
-    "        f.write(buf.getvalue())\n",
-    "\n",
-    "    logging.info(\"Workbook saved → %s\", fname)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 6. Run Parameters,Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "e48de568-962e-4690-a6fc-be7a4ec0a3c6",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "076baa2700034b08bb004d00a617f239",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<h4>1. Load data</h4>'), ToggleButtons(description='Source:', options=(('Local', 'l…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# ===============================================================\n",
-    "#            STREAMLINED ANALYSIS UI  (phase-2 clean)\n",
-    "# ===============================================================\n",
-    "\n",
-    "# ---------- session store ----------\n",
-    "session = {\"df\": None, \"rf\": None, \"sel\": None, \"cweights\": None}\n",
-    "\n",
-    "# ---------- 1 · DATA LOAD ----------\n",
-    "src = widgets.ToggleButtons(\n",
-    "    options=[(\"Local\", \"local\"), (\"URL\", \"url\")],\n",
-    "    description=\"Source:\"\n",
-    ")\n",
-    "\n",
-    "chooser = FileChooser()\n",
-    "url_box = widgets.Text(placeholder=\"https://…/file.csv\", layout={\"width\":\"70%\"})\n",
-    "load_btn = widgets.Button(description=\"Load CSV\", button_style=\"success\")\n",
-    "load_out = widgets.Output()\n",
-    "\n",
-    "def _toggle_src(c):\n",
-    "    chooser.layout.display = \"block\" if c[\"new\"]==\"local\" else \"none\"\n",
-    "    url_box.layout.display  = \"block\" if c[\"new\"]==\"url\"   else \"none\"\n",
-    "src.observe(_toggle_src, names=\"value\"); _toggle_src({\"new\":src.value})\n",
-    "\n",
-    "def _load(_):\n",
-    "    with load_out:\n",
-    "        clear_output()\n",
-    "        try:\n",
-    "            path = chooser.selected if src.value==\"local\" else url_box.value.strip()\n",
-    "            if not path: raise ValueError(\"choose file / URL\")\n",
-    "            if src.value==\"url\" and not path.lower().endswith(\".csv\"):\n",
-    "                raise ValueError(\"URL must end with .csv\")\n",
-    "            df = load_csv(path)\n",
-    "            df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")  # single coercion\n",
-    "            rf = identify_risk_free_fund(df)\n",
-    "            session.update(df=df, rf=rf, sel=None, cweights=None)\n",
-    "            print(f\"✅ Loaded {len(df):,} rows × {df.shape[1]} cols | RF → {rf}\")\n",
-    "        except Exception as e:\n",
-    "            print(\"❌\", e); session[\"df\"]=None\n",
-    "load_btn.on_click(_load)\n",
-    "\n",
-    "# ---------- 2 · PARAMS ------------\n",
-    "index_cnt = widgets.BoundedIntText(0, min=0, max=10, description=\"# Indices:\")\n",
-    "in_start,in_end  = widgets.Text(\"2005-07\"), widgets.Text(\"2008-06\")\n",
-    "out_start,out_end= widgets.Text(\"2008-07\"), widgets.Text(\"2009-06\")\n",
-    "for w,lbl in [(in_start,\"In Start:\"),(in_end,\"In End:\"),\n",
-    "              (out_start,\"Out Start:\"),(out_end,\"Out End:\")]:\n",
-    "    w.description = lbl\n",
-    "target_vol   = widgets.FloatText(0.25,  description=\"Target Vol:\")\n",
-    "monthly_cost = widgets.FloatText(0.0033, description=\"Monthly Cost:\")\n",
-    "\n",
-    "# ---------- 3 · SELECTION ----------\n",
-    "mode_dd = widgets.Dropdown(\n",
-    "    options=[(\"All\", \"all\"), (\"Random\", \"random\"), (\"Manual\", \"manual\")],\n",
-    "    value=\"all\",\n",
-    "    description=\"Mode:\"\n",
-    ")\n",
-    "rand_n   = widgets.BoundedIntText(5, min=2, max=100, description=\"Sample N:\")\n",
-    "fund_table, total_lbl = widgets.VBox([]), widgets.Label(\"Total = 0 %\")\n",
-    "\n",
-    "def _toggle_sel(_=None):\n",
-    "    rand_n.layout.display  = \"block\" if mode_dd.value==\"random\" else \"none\"\n",
-    "    vis = \"block\" if mode_dd.value==\"manual\" else \"none\"\n",
-    "    fund_table.layout.display = total_lbl.layout.display = vis\n",
-    "mode_dd.observe(_toggle_sel, names=\"value\"); _toggle_sel()\n",
-    "\n",
-    "# ---------- helpers ---------------\n",
-    "def _eligible_pool():\n",
-    "    df, rf = session[\"df\"], session[\"rf\"]\n",
-    "    if df is None: \n",
-    "        print(\"⚠️ data not loaded\"); return []\n",
-    "\n",
-    "    # ---- date parse guard -----------------------------------\n",
-    "    try:\n",
-    "        in_s  = pd.to_datetime(in_start.value)+pd.offsets.MonthEnd(0)\n",
-    "        in_e  = pd.to_datetime(in_end.value)  +pd.offsets.MonthEnd(0)\n",
-    "        out_s = pd.to_datetime(out_start.value)+pd.offsets.MonthEnd(0)\n",
-    "        out_e = pd.to_datetime(out_end.value)  +pd.offsets.MonthEnd(0)\n",
-    "    except Exception:\n",
-    "        print(\"❌ invalid dates\"); return []\n",
-    "\n",
-    "    # ---- build indices (RIGHT-most idx_n non-RF columns) ----\n",
-    "    idx_n     = index_cnt.value\n",
-    "    data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-    "    non_rf    = [c for c in data_cols if c != rf]\n",
-    "    indices   = non_rf[-idx_n:] if idx_n else []          # <- fixed\n",
-    "    cand      = [c for c in data_cols if c not in indices]\n",
-    "\n",
-    "    # ---- run select_funds ----------------------------------\n",
-    "    elig = select_funds(df, rf, cand, in_s, in_e, out_s, out_e, \"all\")\n",
-    "    # … diagnostics print unchanged …\n",
-    "    return elig\n",
-    "\n",
-    "def _build_manual(*_):\n",
-    "    if mode_dd.value!=\"manual\" or session[\"df\"] is None: return\n",
-    "    valid = _eligible_pool()\n",
-    "    print(\"DEBUG  eligible funds =\", len(valid))              # ← line 1\n",
-    "    print(\"DEBUG  list sample   →\", valid[:25], \"…\")           # ← line 2\n",
-    "    if not valid:\n",
-    "        print(\"❌ No eligible funds\"); return \n",
-    "    fund_table.children = []                # reset\n",
-    "\n",
-    "    def _update_total(*_):\n",
-    "        tot = sum(r.children[1].value for r in fund_table.children\n",
-    "                  if r.children[0].value)\n",
-    "        total_lbl.value = f\"Total = {tot} %\"\n",
-    "\n",
-    "    for f in valid:\n",
-    "        cb = widgets.Checkbox(description=f, layout={\"width\":\"200px\"})\n",
-    "        wt = widgets.BoundedIntText(0, min=0, max=100,\n",
-    "                                    layout={\"width\":\"60px\"}, disabled=True)\n",
-    "        def _toggle(ch, box=wt):           # single observer\n",
-    "            box.disabled = not ch[\"new\"]\n",
-    "            if box.disabled: box.value = 0\n",
-    "            _update_total()\n",
-    "        cb.observe(_toggle, names=\"value\")\n",
-    "        wt.observe(_update_total, names=\"value\")\n",
-    "        fund_table.children += (widgets.HBox([cb, wt]),)\n",
-    "    _update_total()\n",
-    "\n",
-    "mode_dd.observe(lambda ch: _build_manual() if ch[\"new\"]==\"manual\" else None,\n",
-    "                names=\"value\")\n",
-    "for w in (in_start,in_end,out_start,out_end): w.observe(_build_manual,names=\"value\")\n",
-    "\n",
-    "# ---------- 4 · RUN ---------------\n",
-    "run_btn = widgets.Button(description=\"Run Analysis\", button_style=\"success\")\n",
-    "run_out = widgets.Output(layout={\"border\":\"1px solid #999\",\n",
-    "                                 \"height\":\"340px\",\"overflow_y\":\"auto\"})\n",
-    "\n",
-    "def _run(_):\n",
-    "    with run_out:\n",
-    "        clear_output()\n",
-    "        df, rf = session[\"df\"], session[\"rf\"]\n",
-    "        if df is None: print(\"⚠️ Load data first\"); return\n",
-    "\n",
-    "        # indices (robust)\n",
-    "        idx_n     = index_cnt.value\n",
-    "        data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-    "        non_rf    = [c for c in data_cols if c != rf]\n",
-    "        indices   = non_rf[-idx_n:] if idx_n else [] \n",
-    "\n",
-    "        # pool + selection\n",
-    "        pool = _eligible_pool()\n",
-    "        if not pool: print(\"❌ No eligible funds\"); return\n",
-    "        if mode_dd.value==\"all\":\n",
-    "            sel, custom = pool, None\n",
-    "        elif mode_dd.value==\"random\":\n",
-    "            if rand_n.value>len(pool): print(\"⚠️ Sample N too big\"); return\n",
-    "            sel, custom = list(np.random.choice(pool, rand_n.value, replace=False)), None\n",
-    "        else:\n",
-    "            sel, custom = [], {}\n",
-    "            if not fund_table.children: _build_manual()\n",
-    "            for row in fund_table.children:\n",
-    "                cb, wt = row.children\n",
-    "                if cb.value: sel.append(cb.description); custom[cb.description]=wt.value\n",
-    "            if sum(custom.values())!=100: print(\"⚠️ Weights ≠ 100\"); return\n",
-    "\n",
-    "        w_dict,w_vec = prepare_weights(sel, custom)\n",
-    "\n",
-    "        res = run_analysis(df, sel, w_vec, w_dict, rf,\n",
-    "                           in_start.value, in_end.value,\n",
-    "                           out_start.value, out_end.value,\n",
-    "                           target_vol.value, monthly_cost.value,\n",
-    "                           indices)\n",
-    "\n",
-    "        print(\"✅ analysis complete |\", len(sel), \"funds\")\n",
-    "        if res[\"dropped\"]:\n",
-    "            print(\"⚠️ Dropped:\", res[\"dropped\"])\n",
-    "        if indices: print(\"📊 Indices:\", indices)\n",
-    "\n",
-    "        fname=f\"IS_{in_start.value}_{out_start.value}.xlsx\"\n",
-    "        export_to_excel(res, df, fname,\n",
-    "                        in_start.value,in_end.value,\n",
-    "                        out_start.value,out_end.value)\n",
-    "        print(\"Workbook saved as\", fname)\n",
-    "\n",
-    "run_btn.on_click(_run)\n",
-    "\n",
-    "# ---------- DISPLAY --------------\n",
-    "display(widgets.VBox([\n",
-    "    widgets.HTML(\"<h4>1. Load data</h4>\"),\n",
-    "    src, chooser, url_box, load_btn, load_out,\n",
-    "    widgets.HTML(\"<hr><h4>2. Parameters</h4>\"),\n",
-    "    widgets.HBox([index_cnt]),\n",
-    "    widgets.HBox([in_start,in_end,out_start,out_end]),\n",
-    "    widgets.HBox([target_vol,monthly_cost]),\n",
-    "    widgets.HTML(\"<hr><h4>3. Fund selection</h4>\"),\n",
-    "    widgets.HBox([mode_dd,rand_n]),\n",
-    "    fund_table, total_lbl,\n",
-    "    widgets.HTML(\"<hr>\"),\n",
-    "    run_btn,\n",
-    "    run_out\n",
-    "]))\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "24b797fd-513c-42a7-b825-3fd5cae034be",
-   "metadata": {},
-   "outputs": [],
-   "source": []
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Debugging-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Debugging-checkpoint.ipynb
deleted file mode 100644
index 16d06906a5999e6ff097c31c9f99fef6c35ca4bb..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Debugging-checkpoint.ipynb
+++ /dev/null
@@ -1,1714 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "9ed15037-f989-4fff-9388-9cf03ea986aa",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "select_funds (replaced) is ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "import warnings, random\n",
-    "import pandas as pd\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "    \n",
-    "import warnings\n",
-    "import random\n",
-    "\n",
-    "def select_funds(\n",
-    "    df,                 # full DataFrame with datetime64 ‘Date’\n",
-    "    rf_col,             # name of risk‐free column\n",
-    "    fund_columns,       # list of candidate funds (should be your 27)\n",
-    "    in_sdate, in_edate, # pd.Timestamps for in‐sample window\n",
-    "    out_sdate, out_edate,# pd.Timestamps for out‐sample window\n",
-    "    selection_mode='all',\n",
-    "    random_n=5\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Start from fund_columns.  \n",
-    "    2) Filter out any that contain 'index' in name.  \n",
-    "    3) Keep only those with no NaN anywhere in both windows.  \n",
-    "    4) Keep only those with < 3 consecutive NaNs in each window.  \n",
-    "    5) Return based on selection_mode.\n",
-    "    \"\"\"\n",
-    "    # Step 1: base list\n",
-    "    candidates = fund_columns.copy()\n",
-    "    print(f\"DEBUG [select_funds]: initial candidates (n={len(candidates)}): {candidates}\")\n",
-    "\n",
-    "    # Step 2: drop any with “index” in name (case‐insensitive)\n",
-    "    no_index = [f for f in candidates if 'index' not in f.lower()]\n",
-    "    print(f\"DEBUG [select_funds]: after dropping 'index' (n={len(no_index)}): {no_index}\")\n",
-    "\n",
-    "    # Step 3: full‐history check (no NaN at all in each window)\n",
-    "    full_hist = []\n",
-    "    for f in no_index:\n",
-    "        in_sub  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)][f]\n",
-    "        out_sub = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        if in_sub.notna().all() and out_sub.notna().all():\n",
-    "            full_hist.append(f)\n",
-    "    print(f\"DEBUG [select_funds]: after full‐history check (n={len(full_hist)}): {full_hist}\")\n",
-    "\n",
-    "    # Step 4: no 3‐consecutive‐NaNs check\n",
-    "    after_run_check = []\n",
-    "    for f in full_hist:\n",
-    "        # In‐sample gap runs\n",
-    "        sub_in   = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "        isnan_in = sub_in.isna().astype(int)\n",
-    "        run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "        max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "\n",
-    "        # Out‐sample gap runs\n",
-    "        sub_out   = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        isnan_out = sub_out.isna().astype(int)\n",
-    "        run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "        max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "\n",
-    "        # Keep only if both max runs < 3\n",
-    "        if max_run_in < 3 and max_run_out < 3:\n",
-    "            after_run_check.append(f)\n",
-    "\n",
-    "    print(f\"DEBUG [select_funds]: after run‐length check (n={len(after_run_check)}): {after_run_check}\")\n",
-    "\n",
-    "    # Step 5: selection_mode\n",
-    "    if selection_mode == 'all':\n",
-    "        return after_run_check\n",
-    "\n",
-    "    if selection_mode == 'random':\n",
-    "        if len(after_run_check) <= random_n:\n",
-    "            warnings.warn(\n",
-    "                f\"Fewer valid funds ({len(after_run_check)}) than sample size ({random_n}). Returning all.\"\n",
-    "            )\n",
-    "            return after_run_check\n",
-    "        return random.sample(after_run_check, random_n)\n",
-    "\n",
-    "    # (Placeholder for manual widget selection, if you implement it later)\n",
-    "    return after_run_check\n",
-    "\n",
-    "print(\"select_funds (replaced) is ready.\")\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "d134577d-8bbf-4933-95f2-0d032ac87a48",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "\n",
-    "\n",
-    "import warnings, random\n",
-    "import pandas as pd\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "\n",
-    "def select_funds(\n",
-    "    df, rf_col, fund_columns,\n",
-    "    in_sdate, in_edate, out_sdate, out_edate,\n",
-    "    selection_mode, random_n\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    df             : DataFrame (with 'Date' as datetime64[ns])\n",
-    "    rf_col         : name of the risk-free column (string)\n",
-    "    fund_columns   : list of actual fund names (no Date, no rf_col, no indices)\n",
-    "    in_sdate       : pd.Timestamp for in-sample start (first day of month)\n",
-    "    in_edate       : pd.Timestamp for in-sample end (last day of month)\n",
-    "    out_sdate      : pd.Timestamp for out-sample start (first day of month)\n",
-    "    out_edate      : pd.Timestamp for out-sample end (last day of month)\n",
-    "    selection_mode : 'all' / 'random' / 'manual'\n",
-    "    random_n       : integer for random sampling if mode == 'random'\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # 1) Initial fund candidates\n",
-    "    all_fund_cols = fund_columns.copy()\n",
-    "    print(f\"DEBUG [select_funds]: initial candidates (n={len(all_fund_cols)}): {all_fund_cols}\")\n",
-    "\n",
-    "    # 2) Extract in‐sample & out‐sample DataFrames (just the Date + fund columns)\n",
-    "    in_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "\n",
-    "    # 3) For each fund, fill short gaps ≤2 months in both windows, then check for any remaining run ≥ 3\n",
-    "    funds_after_run_check = []\n",
-    "    for f in all_fund_cols:\n",
-    "        # 3a) Pull the in‐sample return series for this fund, indexed by Date\n",
-    "        ser_in = in_df.set_index('Date')[f]\n",
-    "\n",
-    "        # 3b) Fill any 1–2 consecutive NaNs → 0\n",
-    "        filled_in = fill_short_gaps_with_zero(ser_in)\n",
-    "\n",
-    "        # 3c) Check longest run of NaNs left in in‐sample\n",
-    "        mask_in = filled_in.isna().astype(int)\n",
-    "        run_len_in = (\n",
-    "            mask_in.groupby((mask_in == 0).cumsum())\n",
-    "                   .sum()\n",
-    "        )\n",
-    "        max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "\n",
-    "        # 3d) Do the same for out‐sample\n",
-    "        ser_out = out_df.set_index('Date')[f]\n",
-    "        filled_out = fill_short_gaps_with_zero(ser_out)\n",
-    "        mask_out = filled_out.isna().astype(int)\n",
-    "        run_len_out = (\n",
-    "            mask_out.groupby((mask_out == 0).cumsum())\n",
-    "                    .sum()\n",
-    "        )\n",
-    "        max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "\n",
-    "        # 3e) Print debug so you see if any fund truly has a run ≥3 inside the window\n",
-    "        print(f\"DEBUG [select_funds]: '{f}' max consecutive NaNs in in-sample = {max_run_in}\")\n",
-    "        print(f\"DEBUG [select_funds]: '{f}' max consecutive NaNs in out-sample = {max_run_out}\")\n",
-    "\n",
-    "        # 3f) Only keep the fund if BOTH windows have max_run < 3\n",
-    "        if (max_run_in < 3) and (max_run_out < 3):\n",
-    "            funds_after_run_check.append(f)\n",
-    "\n",
-    "    print(f\"DEBUG [select_funds]: after run‐length check (n={len(funds_after_run_check)}): {funds_after_run_check}\")\n",
-    "\n",
-    "    # 4) Apply selection_mode\n",
-    "    if selection_mode == 'all':\n",
-    "        return funds_after_run_check\n",
-    "\n",
-    "    if selection_mode == 'random':\n",
-    "        if len(funds_after_run_check) <= random_n:\n",
-    "            warnings.warn(\n",
-    "                f\"Fewer valid funds ({len(funds_after_run_check)}) than sample size ({random_n}). Returning all.\"\n",
-    "            )\n",
-    "            return funds_after_run_check\n",
-    "        return random.sample(funds_after_run_check, random_n)\n",
-    "\n",
-    "    # 5) Manual selection (widget) would be implemented here if desired.\n",
-    "    return funds_after_run_check\n",
-    "\n",
-    "print(\"select_funds (gap‐filled, windowed) is defined.\")\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "367bab83-272d-4e85-a416-335980903119",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "run_analysis (with checkpoints) is defined.\n"
-     ]
-    }
-   ],
-   "source": [
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import logging\n",
-    "\n",
-    "def run_analysis(\n",
-    "    df, in_start, in_end, out_start, out_end,\n",
-    "    target_vol, monthly_cost,\n",
-    "    selection_mode='all', random_n=5\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Parse/validate date inputs\n",
-    "    2) Convert Date column if needed\n",
-    "    3) Identify rf_col\n",
-    "    4) Prepare in/out sample DataFrames\n",
-    "    5) CALL select_funds (with debug) and print checkpoints\n",
-    "    6) Compute scale_factors and wrap stats in try/except\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # (1) Parse input dates\n",
-    "    in_sdate  = pd.to_datetime(in_start + \"-01\", errors='coerce')\n",
-    "    in_edate  = pd.to_datetime(in_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "    out_sdate = pd.to_datetime(out_start + \"-01\", errors='coerce')\n",
-    "    out_edate = pd.to_datetime(out_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    # checkpoint A\n",
-    "    print(\"CHECKPOINT A: Dates parsed:\", in_sdate, in_edate, out_sdate, out_edate)\n",
-    "\n",
-    "    # (2) Ensure Date is datetime64\n",
-    "    if not np.issubdtype(df['Date'].dtype, np.datetime64):\n",
-    "        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "        df.dropna(subset=['Date'], inplace=True)\n",
-    "        df.sort_values(by='Date', inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "    # checkpoint B\n",
-    "    print(\"CHECKPOINT B: Date column is datetime64, first dates:\", df['Date'].iloc[0], df['Date'].iloc[-1])\n",
-    "\n",
-    "    # (3) Identify risk-free column\n",
-    "    rf_col = identify_risk_free_fund(df)\n",
-    "    print(f\"INFO: Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "\n",
-    "    # (4) Build in-sample & out-sample slices\n",
-    "    in_sample_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_sample_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "    in_sample_rf  = in_sample_df[rf_col]\n",
-    "    out_sample_rf = out_sample_df[rf_col]\n",
-    "\n",
-    "    print(f\"CHECKPOINT C: in_sample rows = {len(in_sample_df)}, out_sample rows = {len(out_sample_df)}\")\n",
-    "\n",
-    "    # (5) Assemble fund_cols and call select_funds\n",
-    "    all_fund_cols = fund_cols.copy()\n",
-    "    print(f\"CHECKPOINT D: about to call select_funds with {len(all_fund_cols)} candidates\")\n",
-    "\n",
-    "    selected_funds = select_funds(\n",
-    "        df,\n",
-    "        rf_col,\n",
-    "        fund_columns=all_fund_cols,\n",
-    "        in_sdate=in_sdate,\n",
-    "        in_edate=in_edate,\n",
-    "        out_sdate=out_sdate,\n",
-    "        out_edate=out_edate,\n",
-    "        selection_mode=selection_mode,\n",
-    "        random_n=random_n\n",
-    "    )\n",
-    "\n",
-    "    print(f\"CHECKPOINT E: select_funds returned {len(selected_funds)} funds → {selected_funds}\")\n",
-    "\n",
-    "    if not selected_funds:\n",
-    "        print(\"No valid funds after select_funds. Exiting run_analysis.\")\n",
-    "        return None\n",
-    "\n",
-    "    # (6) Compute scale_factors BEFORE entering stats‐try/except\n",
-    "    scale_factors = {}\n",
-    "    for fund in selected_funds:\n",
-    "        fund_in_rets = in_sample_df[fund].dropna()\n",
-    "        current_vol  = annualize_volatility(fund_in_rets)\n",
-    "        if pd.isna(current_vol) or current_vol == 0:\n",
-    "            scale_factors[fund] = 1.0\n",
-    "        else:\n",
-    "            scale_factors[fund] = target_vol / current_vol\n",
-    "\n",
-    "    print(\"CHECKPOINT F: scale_factors computed (showing first 5):\", \n",
-    "          {f: scale_factors[f] for f in selected_funds[:5]})\n",
-    "\n",
-    "    # Pre-allocate DataFrames for scaled returns\n",
-    "    in_sample_scaled  = pd.DataFrame(index=in_sample_df.index, columns=selected_funds)\n",
-    "    out_sample_scaled = pd.DataFrame(index=out_sample_df.index, columns=selected_funds)\n",
-    "\n",
-    "    # ────── TRY/EXCEPT AROUND ONLY THE “STATS” PORTION ──────\n",
-    "    try:\n",
-    "        # Scale returns (with cost)\n",
-    "        for fund in selected_funds:\n",
-    "            sf = scale_factors[fund]\n",
-    "            adj_in  = in_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_in[adj_in < -1.0] = -1.0\n",
-    "            in_sample_scaled[fund] = adj_in\n",
-    "\n",
-    "            if not out_sample_df.empty:\n",
-    "                adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "                adj_out[adj_out < -1.0] = -1.0\n",
-    "                out_sample_scaled[fund] = adj_out\n",
-    "\n",
-    "        # Helper for stats\n",
-    "        def compute_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            sr  = sharpe_ratio(series, rf_series)\n",
-    "            so  = sortino_ratio(series, rf_series)\n",
-    "            mdd = max_drawdown(series)\n",
-    "            return (r, v, sr, so, mdd)\n",
-    "\n",
-    "        # In-sample per-fund stats\n",
-    "        in_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "\n",
-    "        # Out-sample per-fund (adjusted) stats\n",
-    "        out_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "\n",
-    "        # Out-sample per-fund (raw) stats\n",
-    "        out_sample_stats_raw = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "\n",
-    "        # Equal-weight portfolio\n",
-    "        ew_w = np.array([1.0/len(selected_funds)] * len(selected_funds))\n",
-    "        in_ew_port      = calc_portfolio_returns(ew_w, in_sample_scaled[selected_funds])\n",
-    "        out_ew_port     = calc_portfolio_returns(ew_w, out_sample_scaled[selected_funds])\n",
-    "        out_ew_port_raw = calc_portfolio_returns(ew_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        in_ew_stats      = compute_stats(in_ew_port, in_sample_rf)\n",
-    "        out_ew_stats     = compute_stats(out_ew_port, out_sample_rf)\n",
-    "        out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # User‐weight placeholder\n",
-    "        user_weight_dict = {f: 1.0/len(selected_funds) for f in selected_funds}\n",
-    "        custom_w = np.array([user_weight_dict[f] for f in selected_funds])\n",
-    "\n",
-    "        in_user_port      = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "        out_user_port     = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "        out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        in_user_stats      = compute_stats(in_user_port, in_sample_rf)\n",
-    "        out_user_stats     = compute_stats(out_user_port, out_sample_rf)\n",
-    "        out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "\n",
-    "        results = {\n",
-    "            'selected_funds':       selected_funds,\n",
-    "            'in_sample_scaled':     in_sample_scaled,\n",
-    "            'out_sample_scaled':    out_sample_scaled,\n",
-    "            'in_sample_stats':      in_sample_stats,\n",
-    "            'out_sample_stats':     out_sample_stats,\n",
-    "            'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "            'in_ew_stats':          in_ew_stats,\n",
-    "            'out_ew_stats':         out_ew_stats,\n",
-    "            'out_ew_stats_raw':     out_ew_stats_raw,\n",
-    "            'in_user_stats':        in_user_stats,\n",
-    "            'out_user_stats':       out_user_stats,\n",
-    "            'out_user_stats_raw':   out_user_stats_raw\n",
-    "        }\n",
-    "\n",
-    "    except Exception as e:\n",
-    "        print(\"ERROR inside stats-block:\", e)\n",
-    "        return None\n",
-    "\n",
-    "    # Everything succeeded\n",
-    "    return results\n",
-    "\n",
-    "print(\"run_analysis (with checkpoints) is defined.\")\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "c2cd88ee-a255-4282-b722-f34e34b95d36",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Run Analysis callback is now wired.\n"
-     ]
-    }
-   ],
-   "source": [
-    "from IPython.display import clear_output\n",
-    "from IPython.utils.capture import capture_output\n",
-    "\n",
-    "def on_apply_clicked(b):\n",
-    "    with output_area:\n",
-    "        clear_output()\n",
-    "        # 1) Read widget values\n",
-    "        in_start_val     = in_sample_start.value.strip()\n",
-    "        in_end_val       = in_sample_end.value.strip()\n",
-    "        out_start_val    = out_sample_start.value.strip()\n",
-    "        out_end_val      = out_sample_end.value.strip()\n",
-    "        target_vol_val   = target_vol_widget.value\n",
-    "        monthly_cost_val = monthly_cost_widget.value\n",
-    "        mode_val         = selection_mode_widget.value\n",
-    "        rnd_n_val        = random_sample_size_widget.value\n",
-    "\n",
-    "        # 2) Print parameter summary\n",
-    "        print(\"Running analysis with parameters:\")\n",
-    "        print(f\"  In-Sample:  {in_start_val} → {in_end_val}\")\n",
-    "        print(f\"  Out-Sample: {out_start_val} → {out_end_val}\")\n",
-    "        print(f\"  Target Volatility: {target_vol_val}\")\n",
-    "        print(f\"  Monthly Cost: {monthly_cost_val}\")\n",
-    "        print(f\"  Selection Mode: {mode_val}\")\n",
-    "        if mode_val == 'random':\n",
-    "            print(f\"  Random Sample Size: {rnd_n_val}\")\n",
-    "\n",
-    "        # 3) Capture everything printed by run_analysis (and select_funds)\n",
-    "        with capture_output() as cap:\n",
-    "            try:\n",
-    "                results = run_analysis(\n",
-    "                    df,\n",
-    "                    in_start=in_start_val,\n",
-    "                    in_end=in_end_val,\n",
-    "                    out_start=out_start_val,\n",
-    "                    out_end=out_end_val,\n",
-    "                    target_vol=target_vol_val,\n",
-    "                    monthly_cost=monthly_cost_val,\n",
-    "                    selection_mode=mode_val,\n",
-    "                    random_n=rnd_n_val\n",
-    "                )\n",
-    "            except Exception as e:\n",
-    "                print(\"Error inside run_analysis():\", e)\n",
-    "                return\n",
-    "\n",
-    "        # 4) Print the captured debug/info text\n",
-    "        print(cap.stdout)\n",
-    "\n",
-    "        # 5) If no funds survived, warn\n",
-    "        if results is None or ('selected_funds' in results and not results['selected_funds']):\n",
-    "            print(\"No valid funds remain after filtering. Check your date range or data.\")\n",
-    "            return\n",
-    "\n",
-    "        # 6) Summary\n",
-    "        print(\"Analysis complete. Summary:\")\n",
-    "        sf = results['selected_funds']\n",
-    "        if 'selected_funds' in results:\n",
-    "            print(f\"  Funds selected: {len(results['selected_funds'])}\")\n",
-    "        if 'in_ew_stats' in results:\n",
-    "            ir, iv, isr, _, _ = results['in_ew_stats']\n",
-    "            print(f\"  In-Sample EW → Return: {ir*100:.2f}%, Vol: {iv*100:.2f}%, Sharpe: {isr:.2f}\")\n",
-    "        if 'out_ew_stats' in results:\n",
-    "            or_, ov, osr, _, _ = results['out_ew_stats']\n",
-    "            print(f\"  Out-Sample EW → Return: {or_*100:.2f}%, Vol: {ov*100:.2f}%, Sharpe: {osr:.2f}\")\n",
-    "        print(f\"  Funds selected: {len(sf)} → {sf}\")\n",
-    "        \n",
-    "        export_to_excel(results, \"InteractiveOutput.xlsx\")\n",
-    "\n",
-    "\n",
-    "\n",
-    "# Wire the button once (after all definitions are loaded)\n",
-    "\n",
-    "print(\"Run Analysis callback is now wired.\")"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "67d5b060-852c-4755-aa9b-7b3f0919f5e8",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "    for fund in selected_funds:\n",
-    "        sf = scale_factors[fund]\n",
-    "        # In-sample\n",
-    "        adj_in = in_sample_df[fund] * sf - monthly_cost\n",
-    "        adj_in[adj_in < -1.0] = -1.0\n",
-    "        in_sample_scaled[fund] = adj_in\n",
-    "        \n",
-    "        # Out-of-sample\n",
-    "        if out_sample_df.shape[0] > 0:\n",
-    "            adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_out[adj_out < -1.0] = -1.0\n",
-    "            out_sample_scaled[fund] = adj_out\n",
-    "    \n",
-    "    # Helper function for stats\n",
-    "    def compute_stats(series, rf_series):\n",
-    "        r = annualize_return(series)\n",
-    "        v = annualize_volatility(series)\n",
-    "        sr = sharpe_ratio(series, rf_series)\n",
-    "        so = sortino_ratio(series, rf_series)\n",
-    "        mdd = max_drawdown(series)\n",
-    "        return (r, v, sr, so, mdd)\n",
-    "    \n",
-    "    in_sample_stats = {}\n",
-    "    for fund in selected_funds:\n",
-    "        in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "    \n",
-    "    out_sample_stats = {}\n",
-    "    for fund in selected_funds:\n",
-    "        out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "    \n",
-    "    out_sample_stats_raw = {}\n",
-    "    for fund in selected_funds:\n",
-    "        out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "    \n",
-    "    # Portfolio (equal-weight)\n",
-    "    ew_w = np.array([1.0/len(selected_funds)]*len(selected_funds))\n",
-    "    in_ew_port = calc_portfolio_returns(ew_w, in_sample_scaled[selected_funds])\n",
-    "    out_ew_port = calc_portfolio_returns(ew_w, out_sample_scaled[selected_funds])\n",
-    "    out_ew_port_raw = calc_portfolio_returns(ew_w, out_sample_df[selected_funds])\n",
-    "    \n",
-    "    in_ew_stats = compute_stats(in_ew_port, in_sample_rf)\n",
-    "    out_ew_stats = compute_stats(out_ew_port, out_sample_rf)\n",
-    "    out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "    \n",
-    "    # Portfolio (user-weighted) - placeholder\n",
-    "    user_weight_dict = {f: 1.0/len(selected_funds) for f in selected_funds}\n",
-    "    custom_w = np.array([user_weight_dict[f] for f in selected_funds])\n",
-    "    in_user_port = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "    out_user_port = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "    out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "    \n",
-    "    in_user_stats = compute_stats(in_user_port, in_sample_rf)\n",
-    "    out_user_stats = compute_stats(out_user_port, out_sample_rf)\n",
-    "    out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "    \n",
-    "    results = {\n",
-    "        'selected_funds': selected_funds,\n",
-    "        'in_sample_scaled': in_sample_scaled,\n",
-    "        'out_sample_scaled': out_sample_scaled,\n",
-    "        'in_sample_stats': in_sample_stats,\n",
-    "        'out_sample_stats': out_sample_stats,\n",
-    "        'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "        'in_ew_stats': in_ew_stats,\n",
-    "        'out_ew_stats': out_ew_stats,\n",
-    "        'out_ew_stats_raw': out_ew_stats_raw,\n",
-    "        'in_user_stats': in_user_stats,\n",
-    "        'out_user_stats': out_user_stats,\n",
-    "        'out_user_stats_raw': out_user_stats_raw"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 1. SETUP CELL ============\n",
-    "\n",
-    "import logging\n",
-    "import sys\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import os\n",
-    "import math\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import interact, interactive, VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import datetime\n",
-    "import random\n",
-    "import warnings\n",
-    "\n",
-    "# If you need to install these packages on your environment, uncomment:\n",
-    "!{sys.executable} -m pip install --quiet ipywidgets openpyxl xlsxwriter\n",
-    "\n",
-    "# For exporting to Excel with styling\n",
-    "import xlsxwriter\n",
-    "\n",
-    "# Set up logging to console\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "logging.info(\"Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\")\n",
-    "\n",
-    "# (Optional) If widgets aren't enabled, run:\n",
-    "# !jupyter nbextension enable --py widgetsnbextension --sys-prefix\n",
-    "\n",
-    "print(\"Setup complete.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "d7b324bc9ef84efb9c2a9af6361744d1",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<b>Step 1: Choose your CSV</b><br><i>Remember:</i> If you included any index column…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify which column (after 'Date') is the risk-free rate by smallest stdev among columns.\n",
-    "    \"\"\"\n",
-    "    numeric_cols = df.columns[1:]  # skip the Date column\n",
-    "    stdevs = {}\n",
-    "    for col in numeric_cols:\n",
-    "        vals = df[col].dropna()\n",
-    "        if len(vals) > 0:\n",
-    "            stdevs[col] = vals.std()\n",
-    "        else:\n",
-    "            stdevs[col] = np.inf\n",
-    "\n",
-    "    rf_col = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "    return rf_col\n",
-    "\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 1) Helper to read a local CSV robustly (handles BOMs and minor parsing issues)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Try loading `path` as CSV in three ways:\n",
-    "    1. Default C engine\n",
-    "    2. BOM-stripped with the Python engine\n",
-    "    3. Skip bad lines with the Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception as e1:\n",
-    "        print(\"Default read_csv failed:\", e1)\n",
-    "\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception as e2:\n",
-    "        print(\"utf-8-sig + python engine failed:\", e2)\n",
-    "\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",    # for pandas ≥ 1.3\n",
-    "    )\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 2) Build the widgets\n",
-    "# ------------------------------------------------------------------------------\n",
-    "source_info = widgets.HTML(\n",
-    "    \"<b>Step 1: Choose your CSV</b><br>\"\n",
-    "    \"<i>Remember:</i> If you included any index columns (e.g. S&P 500, MSCI World, SG Trend), they \"\n",
-    "    \"must appear to the right of all fund columns in your sheet.\"\n",
-    ")\n",
-    "\n",
-    "\n",
-    "source_dropdown = widgets.Dropdown(\n",
-    "    options=['Local', 'GitHub'],\n",
-    "    value='Local',\n",
-    "    description='Data Source:',\n",
-    "    style={'description_width': '120px'}\n",
-    ")\n",
-    "\n",
-    "# FileChooser for Local mode\n",
-    "fc = FileChooser(os.getcwd())\n",
-    "fc.title = \"<b>Select local CSV file</b>\"\n",
-    "\n",
-    "# Text box for GitHub raw URL\n",
-    "github_text = widgets.Text(\n",
-    "    value=(\n",
-    "        \"https://raw.githubusercontent.com/stranske/Trend_Model_Project/\"\n",
-    "        \"main/data/TrendData.csv\"\n",
-    "    ),\n",
-    "    description=\"GitHub URL:\",\n",
-    "    layout=widgets.Layout(width=\"80%\"),\n",
-    ")\n",
-    "\n",
-    "# Ask how many index columns are on the far right\n",
-    "n_indices_widget = widgets.BoundedIntText(\n",
-    "    value=0,\n",
-    "    min=0,\n",
-    "    max=10,  # adjust if you expect more than 10 indices\n",
-    "    description='# Index cols:',\n",
-    "    style={'description_width': '120px'},\n",
-    "    tooltip=\"Enter the number of index columns at the far right of your CSV\"\n",
-    ")\n",
-    "\n",
-    "# Load button\n",
-    "load_button = widgets.Button(description=\"Load Data\", button_style=\"success\")\n",
-    "\n",
-    "# Output area for status and debug prints\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 3) Show/hide widgets depending on source selection\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_source_change(change):\n",
-    "    if change[\"new\"] == \"Local\":\n",
-    "        fc.layout.display = \"block\"\n",
-    "        github_text.layout.display = \"none\"\n",
-    "    else:\n",
-    "        fc.layout.display = \"none\"\n",
-    "        github_text.layout.display = \"block\"\n",
-    "\n",
-    "# Initially, GitHub textbox is hidden; FileChooser is visible\n",
-    "github_text.layout.display = \"none\"\n",
-    "fc.layout.display = \"block\"\n",
-    "\n",
-    "source_dropdown.observe(on_source_change, names=\"value\")\n",
-    "\n",
-    "ui_load = widgets.VBox([\n",
-    "    source_info,\n",
-    "    source_dropdown,\n",
-    "    fc,\n",
-    "    github_text,\n",
-    "    n_indices_widget,   # ← new widget here\n",
-    "    load_button,\n",
-    "    output_area\n",
-    "])\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 4) Callback for the Load button (auto-detect date format)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_load_clicked(_):\n",
-    "    global df, fund_cols, indices_list, rf_col            # declare df as global\n",
-    "    with output_area:\n",
-    "        output_area.clear_output()\n",
-    "        src_choice = source_dropdown.value\n",
-    "        n_indices = int(n_indices_widget.value)\n",
-    "\n",
-    "        # 4a) Load the DataFrame\n",
-    "        try:\n",
-    "            if src_choice == 'Local':\n",
-    "                local_path = fc.selected  # FileChooser’s selected path\n",
-    "                if not local_path or not os.path.exists(local_path):\n",
-    "                    print(f\"Error: Local file not found:\\n  {local_path}\")\n",
-    "                    return\n",
-    "                print(f\"Loading from local file:\\n  {local_path}\")\n",
-    "                df = pd.read_csv(local_path)\n",
-    "            else:\n",
-    "                github_url = github_text.value.strip()\n",
-    "                if not github_url:\n",
-    "                    print(\"Error: Please enter a valid GitHub raw URL.\")\n",
-    "                    return\n",
-    "                print(f\"Loading from GitHub URL:\\n  {github_url}\")\n",
-    "                df = pd.read_csv(github_url)\n",
-    "        except Exception as e:\n",
-    "            print(\"Failed to load CSV:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4b) Debug: print columns & a few rows\n",
-    "        print(\"Columns found in DataFrame:\", df.columns.tolist())\n",
-    "        display(df.head(3))\n",
-    "\n",
-    "        # 4c) Identify which column is the date\n",
-    "        date_col = None\n",
-    "        for candidate in [\"Date\", \"DATE\", \"date\"]:\n",
-    "            if candidate in df.columns:\n",
-    "                date_col = candidate\n",
-    "                break\n",
-    "\n",
-    "        if date_col is None:\n",
-    "            print(\"Error: No column named 'Date' / 'DATE' / 'date' found.\")\n",
-    "            print(\"Please check the column names above and adjust code accordingly.\")\n",
-    "            return\n",
-    "\n",
-    "        date_col = 'Date'\n",
-    "\n",
-    "        # 1) Show the first few raw date strings (un‐parsed) so we can inspect them\n",
-    "        raw_samples = df[date_col].dropna().astype(str).head(10).tolist()\n",
-    "        print(f\"Raw {date_col} samples (first 10 non‐null): {raw_samples!r}\")\n",
-    "\n",
-    "        # 2) Strip leading/trailing whitespace from every entry\n",
-    "        df[date_col] = df[date_col].astype(str).str.strip()\n",
-    "\n",
-    "        # 3) Now attempt strict \"%m/%d/%Y\" parsing\n",
-    "        parsed = pd.to_datetime(df[date_col], format=\"%m/%d/%Y\", errors=\"coerce\", infer_datetime_format=True)\n",
-    "        num_valid = parsed.notna().sum()\n",
-    "        print(f\"Number of rows matching '%m/%d/%Y' exactly: {num_valid} / {len(df)}\")\n",
-    "\n",
-    "        if num_valid > 0:\n",
-    "            df[date_col] = parsed\n",
-    "            print(f\"Parsing with '%m/%d/%Y' succeeded for {num_valid} rows.\")\n",
-    "        else:\n",
-    "            print(\n",
-    "                \"Warning: No rows matched '%m/%d/%Y'. \"\n",
-    "                \"Falling back to generic pd.to_datetime(...).\"\n",
-    "            )\n",
-    "            df[date_col] = pd.to_datetime(df[date_col], errors=\"coerce\")\n",
-    "\n",
-    "        # 5) Drop any rows where parsing still failed\n",
-    "        before_drop = len(df)\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        dropped = before_drop - len(df)\n",
-    "        if dropped:\n",
-    "            print(f\"Dropped {dropped} rows where '{date_col}' could not be parsed.\")\n",
-    "        \n",
-    "        # 6) Sort and reset index\n",
-    "        df.sort_values(by=date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "        \n",
-    "        # 7) Show the final parsed dates\n",
-    "        print(f\"After parsing, first 3 {date_col} values:\")\n",
-    "        print(df[[date_col]].head(3))\n",
-    "        print(f\"Loaded {len(df)} rows successfully.\")\n",
-    "\n",
-    "\n",
-    "        # 4d) Identify risk-free column\n",
-    "        try:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            print(f\"Identified risk-free column as: '{rf_col}'\")\n",
-    "        except Exception as e:\n",
-    "            print(\"Error identifying risk-free column:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4f) Determine fund_cols vs indices_list based on n_indices\n",
-    "        all_cols = df.columns.tolist()\n",
-    "        # We assume “Date” and rf_col are present. Everything else is a candidate.\n",
-    "        if 'Date' not in all_cols or rf_col not in all_cols:\n",
-    "            print(\"Error: 'Date' or risk-free column not found in DataFrame columns.\")\n",
-    "            return\n",
-    "        \n",
-    "        # Build list of all columns except 'Date' and rf_col\n",
-    "        remaining = [c for c in all_cols if c not in ['Date', rf_col]]\n",
-    "        \n",
-    "        if n_indices > len(remaining):\n",
-    "            print(\n",
-    "                f\"Error: You asked for {n_indices} index columns, but only \"\n",
-    "                f\"{len(remaining)} columns remain after 'Date' and '{rf_col}'.\"\n",
-    "            )\n",
-    "            return\n",
-    "\n",
-    "        if n_indices > 0:\n",
-    "            indices_list = remaining[-n_indices:]\n",
-    "            fund_cols    = remaining[:-n_indices]\n",
-    "        else:\n",
-    "            indices_list = []\n",
-    "            fund_cols    = remaining[:]\n",
-    "        print(\"\\n>> Debug (post‐load): fund_cols =\", fund_cols)\n",
-    "        print(\">> Debug (post‐load): indices_list =\", indices_list, \"\\n\")\n",
-    "        \n",
-    "        # 2F) Print out what we found\n",
-    "        print(f\"Detected fund columns ({len(fund_cols)}): {fund_cols}\")\n",
-    "        print(f\"Detected index columns ({len(indices_list)}): {indices_list}\")\n",
-    "        print(\n",
-    "            \"Data loaded and classified successfully.\\n\"\n",
-    "            \"Proceed to Step 2 (Run Analysis).\"\n",
-    "        )\n",
-    "\n",
-    " \n",
-    "        # 8) Confirm that df is now in global scope\n",
-    "        print(\">> df defined with\", len(df), \"rows and columns:\", df.columns.tolist())\n",
-    "\n",
-    "\n",
-    "# 5) Wire up and display the UI\n",
-    "load_button.on_click(on_load_clicked)\n",
-    "\n",
-    "\n",
-    "display(ui_load)\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "982ef5a9-d579-4289-bb9c-59e1378e15d6",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "(1) Funds with absolutely no NaNs over both windows (count = 27):\n",
-      "['Quantum Capital', 'Quantum Group', 'Echo Strategies', 'Echo Group', 'Meridian Strategies', 'Axiom LP', 'Crescent Partners', 'Forge Advisors', 'Sentinel Global', 'Axiom Advisors', 'Vista Holdings', 'Sentinel Advisors', 'Crescent Group', 'Adaptive Holdings', 'Vista Capital', 'Forge Investments', 'Ascent Global', 'Vista Global', 'Forge Group', 'Axiom Holdings', 'Adaptive Global', 'Ascent Advisors', 'Quantum Advisors', 'Ascent Group', 'Quantum Holdings', 'Sentinel LP', 'Adaptive LP']\n",
-      "\n",
-      "None of the post‐full‐history funds has a run of ≥ 3 NaNs in either window.\n"
-     ]
-    }
-   ],
-   "source": [
-    "import pandas as pd\n",
-    "import numpy as np\n",
-    "\n",
-    "# ────────────── 1) Re‐compute in_sdate, in_edate, out_sdate, out_edate ──────────────\n",
-    "in_sdate  = pd.to_datetime(\"2005-07-01\", errors=\"coerce\")\n",
-    "in_edate  = pd.to_datetime(\"2008-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "out_sdate = pd.to_datetime(\"2008-07-01\", errors=\"coerce\")\n",
-    "out_edate = pd.to_datetime(\"2009-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "# ────────────── 2) Build the full‐history list (no NaNs anywhere in each window) ──────────────\n",
-    "#    We assume that 'rf_col' is already defined and holds the risk‐free column name.\n",
-    "#    We also assume that any index columns are in a list called 'indices_list'.\n",
-    "all_candidates = [\n",
-    "    c for c in df.columns \n",
-    "    if c not in [\"Date\", rf_col] + indices_list\n",
-    "]\n",
-    "\n",
-    "# (A) Select only those f where in‐sample AND out‐sample both have no NaNs anywhere:\n",
-    "post_full_history_funds = []\n",
-    "for f in all_candidates:\n",
-    "    in_sub  = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "    out_sub = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "    if in_sub.notna().all() and out_sub.notna().all():\n",
-    "        post_full_history_funds.append(f)\n",
-    "\n",
-    "print(f\"(1) Funds with absolutely no NaNs over both windows (count = {len(post_full_history_funds)}):\")\n",
-    "print(post_full_history_funds)\n",
-    "\n",
-    "\n",
-    "# ────────────── 3) Now run the “3+ consecutive NaNs” check only on that list ──────────────\n",
-    "flagged_exact = []  # will hold (fund_name, window_name, max_consecutive_nans)\n",
-    "for f in post_full_history_funds:\n",
-    "    # In‐sample gap‐runs\n",
-    "    sub_in   = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "    isnan_in = sub_in.isna().astype(int)\n",
-    "    run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "    max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "    if max_run_in >= 3:\n",
-    "        flagged_exact.append((f, \"in-sample\", int(max_run_in)))\n",
-    "\n",
-    "    # Out‐sample gap‐runs\n",
-    "    sub_out   = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "    isnan_out = sub_out.isna().astype(int)\n",
-    "    run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "    max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "    if max_run_out >= 3:\n",
-    "        flagged_exact.append((f, \"out-sample\", int(max_run_out)))\n",
-    "\n",
-    "\n",
-    "# ────────────── 4) Report results ──────────────\n",
-    "if flagged_exact:\n",
-    "    print(\"\\nFunds that actually *do* have 3+ consecutive NaNs inside one of the windows:\")\n",
-    "    for (fund_name, window_name, length) in flagged_exact:\n",
-    "        print(f\"  • {fund_name!r} → {length} consecutive NaNs in {window_name}\")\n",
-    "else:\n",
-    "    print(\"\\nNone of the post‐full‐history funds has a run of ≥ 3 NaNs in either window.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "767e697c-eeb3-4e0f-b29e-43597a05e177",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "import pandas as pd\n",
-    "\n",
-    "# ─────────── Define your date boundaries ───────────\n",
-    "in_sdate  = pd.to_datetime(\"2005-07-01\", errors=\"coerce\")\n",
-    "in_edate  = pd.to_datetime(\"2008-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "out_sdate = pd.to_datetime(\"2008-07-01\", errors=\"coerce\")\n",
-    "out_edate = pd.to_datetime(\"2009-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "# (Also ensure 'df' and 'fund_cols' are already defined above this cell.)\n",
-    "\n",
-    "flagged = []  # will hold (fund_name, window_name, max_consecutive_nans) tuples\n",
-    "\n",
-    "for f in fund_cols:\n",
-    "    # ─── In‐sample window check ───\n",
-    "    sub_in = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "    isnan_in = sub_in.isna().astype(int)                         # 1 where NaN, 0 otherwise\n",
-    "    # group by cumulative “not-NaN” runs to measure each NaN‐block length\n",
-    "    run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "    max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "    if max_run_in >= 3:\n",
-    "        flagged.append((f, 'in-sample', int(max_run_in)))\n",
-    "    \n",
-    "    # ─── Out‐sample window check ───\n",
-    "    sub_out = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "    isnan_out = sub_out.isna().astype(int)\n",
-    "    run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "    max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "    if max_run_out >= 3:\n",
-    "        flagged.append((f, 'out-sample', int(max_run_out)))\n",
-    "\n",
-    "# Finally, print any funds with ≥ 3 consecutive NaNs\n",
-    "if flagged:\n",
-    "    print(\"Funds with a 3+ consecutive‐NaN run inside one of the windows:\")\n",
-    "    for (fund_name, window_name, length) in flagged:\n",
-    "        print(f\"  • {fund_name!r} has {length} consecutive NaNs in the {window_name} window\")\n",
-    "else:\n",
-    "    print(\"All funds have at most 2 consecutive NaNs in both in‐sample and out‐sample windows.\")"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 7,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Utility functions loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Check if a series (sorted chronologically) has >= threshold consecutive NaNs.\n",
-    "    Return True if such a gap exists, False otherwise.\n",
-    "    \"\"\"\n",
-    "    consecutive = 0\n",
-    "    for val in series:\n",
-    "        if pd.isna(val):\n",
-    "            consecutive += 1\n",
-    "        else:\n",
-    "            consecutive = 0\n",
-    "        if consecutive >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series, max_short_gap=2):\n",
-    "    \"\"\"\n",
-    "    Replace missing values (NaN) with 0 if they appear in runs of <= max_short_gap.\n",
-    "    Longer runs remain NaN.\n",
-    "    \"\"\"\n",
-    "    filled = series.copy()\n",
-    "    n = len(series)\n",
-    "    i = 0\n",
-    "    while i < n:\n",
-    "        if pd.isna(filled[i]):\n",
-    "            run_start = i\n",
-    "            while i < n and pd.isna(filled[i]):\n",
-    "                i += 1\n",
-    "            run_end = i  # first non-NaN after run\n",
-    "            gap_length = run_end - run_start\n",
-    "            if gap_length <= max_short_gap:\n",
-    "                filled[run_start:run_end] = 0.0\n",
-    "        else:\n",
-    "            i += 1\n",
-    "    return filled\n",
-    "\n",
-    "\n",
-    "def annualize_return(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized (geometric) return from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    growth_factor = (1 + valid_rets).prod()\n",
-    "    n_months = len(valid_rets)\n",
-    "    if growth_factor <= 0:\n",
-    "        return -1.0\n",
-    "    ann_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    return ann_ret\n",
-    "\n",
-    "def annualize_volatility(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized stdev of monthly returns, i.e. stdev * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) < 2:\n",
-    "        return np.nan\n",
-    "    return valid_rets.std() * np.sqrt(12)\n",
-    "\n",
-    "def sharpe_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe ratio = (annual_excess_return) / (annual_excess_vol).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    ann_excess_vol = excess.std() * np.sqrt(12)\n",
-    "    if ann_excess_vol == 0:\n",
-    "        return np.nan\n",
-    "    return ann_excess_ret / ann_excess_vol\n",
-    "\n",
-    "def sortino_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino ratio = (annual_excess_return) / (annual_downside_stdev).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "\n",
-    "    negative_mask = excess < 0\n",
-    "    negative_returns = excess[negative_mask]\n",
-    "    if len(negative_returns) == 0:\n",
-    "        return np.inf  # no negative => infinite sortino\n",
-    "    downside_stdev = negative_returns.std() * np.sqrt(12)\n",
-    "    return ann_excess_ret / downside_stdev\n",
-    "\n",
-    "def max_drawdown(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Compute max drawdown from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    wealth_index = (1 + valid_rets).cumprod()\n",
-    "    rolling_max = wealth_index.cummax()\n",
-    "    dd_series = 1 - (wealth_index / rolling_max)\n",
-    "    return dd_series.max()\n",
-    "\n",
-    "def calc_portfolio_returns(weights, df_returns):\n",
-    "    \"\"\"\n",
-    "    Compute monthly portfolio returns (Series) as weighted sum of columns in df_returns.\n",
-    "    \"\"\"\n",
-    "    return (df_returns * weights).sum(axis=1)\n",
-    "\n",
-    "print(\"Utility functions loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "4f1619c9",
-   "metadata": {},
-   "source": [
-    "## 4. Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "## 5. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 8,
-   "id": "ffad994f",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─────────────── Widget Setup + Callback ───────────────\n",
-    "\n",
-    "# (A) Build widgets\n",
-    "in_sample_start = widgets.Text(value='2003-01', description='In-Sample Start:')\n",
-    "in_sample_end   = widgets.Text(value='2005-12', description='In-Sample End:')\n",
-    "out_sample_start= widgets.Text(value='2006-01', description='Out-Sample Start:')\n",
-    "out_sample_end  = widgets.Text(value='2010-12', description='Out-Sample End:')\n",
-    "\n",
-    "target_vol_widget   = widgets.FloatText(value=0.10,  description='Target Vol:')\n",
-    "monthly_cost_widget = widgets.FloatText(value=0.002, description='Monthly Cost:')\n",
-    "\n",
-    "selection_mode_widget = widgets.Dropdown(\n",
-    "    options=[('All Funds','all'), ('Random Sample','random'), ('Manual','manual')],\n",
-    "    value='all',\n",
-    "    description='Mode:'\n",
-    ")\n",
-    "random_sample_size_widget = widgets.IntText(value=5, description='Sample Size:')\n",
-    "\n",
-    "apply_button = widgets.Button(description='Run Analysis', button_style='success')\n",
-    "\n",
-    "ui_inputs = widgets.VBox([\n",
-    "    in_sample_start, in_sample_end,\n",
-    "    out_sample_start, out_sample_end,\n",
-    "    target_vol_widget, monthly_cost_widget,\n",
-    "    selection_mode_widget, random_sample_size_widget,\n",
-    "    apply_button\n",
-    "])\n",
-    "\n",
-    "output_area = widgets.Output()\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "8107d43e-d54e-4a9f-83c6-d6ffcc0a3c23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "\n",
-    "        # 6) Show a brief summary\n",
-    "        print(\"Analysis complete. Summary:\")\n",
-    "        sf = results['selected_funds']\n",
-    "        print(f\"  Funds selected: {len(sf)} → {sf}\")\n",
-    "        if 'selected_funds' in results:\n",
-    "            print(f\"  Funds selected: {len(results['selected_funds'])}\")\n",
-    "        if 'in_ew_stats' in results:\n",
-    "            ir, iv, isr, _, _ = results['in_ew_stats']\n",
-    "            print(f\"  In-Sample EW → Return: {ir*100:.2f}%, Vol: {iv*100:.2f}%, Sharpe: {isr:.2f}\")\n",
-    "        if 'out_ew_stats' in results:\n",
-    "            or_, ov, osr, _, _ = results['out_ew_stats']\n",
-    "            print(f\"  Out-Sample EW → Return: {or_*100:.2f}%, Vol: {ov*100:.2f}%, Sharpe: {osr:.2f}\")\n",
-    "        \n",
-    "\n",
-    "print(\"Widgets defined. Use 'display(ui_inputs)' in a cell to show them after other functions run\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 6. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 9,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "get_custom_weights function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    Returns dict {fund: weight_decimal}.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=f\"{fund}\",\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    \n",
-    "    confirm_button = widgets.Button(\n",
-    "        description='Confirm Weights',\n",
-    "        button_style='success'\n",
-    "    )\n",
-    "    error_label = widgets.Label(value='', layout=widgets.Layout(color='red'))\n",
-    "    \n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm_button, error_label])\n",
-    "    display(box)\n",
-    "    \n",
-    "    weights_container = {}\n",
-    "    \n",
-    "    def on_confirm_clicked(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_label.value = f\"Error: Weights sum to {total}, must be 100.\"\n",
-    "            weights_container.clear()\n",
-    "        else:\n",
-    "            for fund, wdg in weight_widgets.items():\n",
-    "                weights_container[fund] = wdg.value / 100.0\n",
-    "            error_label.value = \"Weights confirmed!\"\n",
-    "    \n",
-    "    confirm_button.on_click(on_confirm_clicked)\n",
-    "    return weights_container\n",
-    "\n",
-    "print(\"get_custom_weights function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 7. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 8. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 10,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "export_to_excel function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def export_to_excel(results_dict, output_filename=\"AnalysisOutput.xlsx\"):\n",
-    "    \"\"\"\n",
-    "    Create an Excel file with two tabs: In-Sample, Out-of-Sample.\n",
-    "    Each has two tables: (1) Equal-Weight, (2) User-Weighted.\n",
-    "    Columns for Return(%), Vol(%), Sharpe, Sortino, MaxDD(%).\n",
-    "    For OOS, also show 'before scaling' vs. 'after scaling' returns/vol.\n",
-    "    \"\"\"\n",
-    "    selected_funds = results_dict['selected_funds']\n",
-    "    in_sample_stats = results_dict['in_sample_stats']\n",
-    "    out_sample_stats_scaled = results_dict['out_sample_stats']\n",
-    "    out_sample_stats_raw = results_dict['out_sample_stats_raw']\n",
-    "\n",
-    "    in_ew_stats = results_dict['in_ew_stats']\n",
-    "    out_ew_stats_scaled = results_dict['out_ew_stats']\n",
-    "    out_ew_stats_raw = results_dict['out_ew_stats_raw']\n",
-    "\n",
-    "    in_user_stats = results_dict['in_user_stats']\n",
-    "    out_user_stats_scaled = results_dict['out_user_stats']\n",
-    "    out_user_stats_raw = results_dict['out_user_stats_raw']\n",
-    "\n",
-    "    # --- In-Sample DataFrames ---\n",
-    "    in_eq_data = []\n",
-    "    in_user_data = []\n",
-    "    for fund in selected_funds:\n",
-    "        r, v, s, so, mdd = in_sample_stats[fund]\n",
-    "        in_eq_data.append([fund, r, v, s, so, mdd])\n",
-    "        in_user_data.append([fund, r, v, s, so, mdd])\n",
-    "\n",
-    "    in_eq_data.append([\n",
-    "        'Equal-Weight Portfolio',\n",
-    "        in_ew_stats[0],\n",
-    "        in_ew_stats[1],\n",
-    "        in_ew_stats[2],\n",
-    "        in_ew_stats[3],\n",
-    "        in_ew_stats[4]\n",
-    "    ])\n",
-    "    in_user_data.append([\n",
-    "        'User-Weighted Portfolio',\n",
-    "        in_user_stats[0],\n",
-    "        in_user_stats[1],\n",
-    "        in_user_stats[2],\n",
-    "        in_user_stats[3],\n",
-    "        in_user_stats[4]\n",
-    "    ])\n",
-    "\n",
-    "    in_eq_df = pd.DataFrame(\n",
-    "        in_eq_data,\n",
-    "        columns=['Fund', 'Return (%)', 'Volatility (%)', 'Sharpe', 'Sortino', 'MaxDD (%)']\n",
-    "    )\n",
-    "    in_user_df = pd.DataFrame(\n",
-    "        in_user_data,\n",
-    "        columns=['Fund', 'Return (%)', 'Volatility (%)', 'Sharpe', 'Sortino', 'MaxDD (%)']\n",
-    "    )\n",
-    "\n",
-    "    # --- Out-of-Sample DataFrames ---\n",
-    "    # columns: [Fund, RetBefore(%), VolBefore(%), RetAfter(%), VolAfter(%), Sharpe(After), Sortino(After), MaxDD(After)(%)]\n",
-    "    out_eq_data = []\n",
-    "    out_user_data = []\n",
-    "\n",
-    "    for fund in selected_funds:\n",
-    "        r_raw, v_raw, _, _, _ = out_sample_stats_raw[fund]\n",
-    "        r_scaled, v_scaled, s_scaled, so_scaled, mdd_scaled = out_sample_stats_scaled[fund]\n",
-    "        out_eq_data.append([\n",
-    "            fund,\n",
-    "            r_raw,\n",
-    "            v_raw,\n",
-    "            r_scaled,\n",
-    "            v_scaled,\n",
-    "            s_scaled,\n",
-    "            so_scaled,\n",
-    "            mdd_scaled\n",
-    "        ])\n",
-    "        out_user_data.append([\n",
-    "            fund,\n",
-    "            r_raw,\n",
-    "            v_raw,\n",
-    "            r_scaled,\n",
-    "            v_scaled,\n",
-    "            s_scaled,\n",
-    "            so_scaled,\n",
-    "            mdd_scaled\n",
-    "        ])\n",
-    "\n",
-    "    r_ew_raw, v_ew_raw, _, _, _ = out_ew_stats_raw\n",
-    "    r_ew_scaled, v_ew_scaled, s_ew_scaled, so_ew_scaled, mdd_ew_scaled = out_ew_stats_scaled\n",
-    "    out_eq_data.append([\n",
-    "        'Equal-Weight Portfolio',\n",
-    "        r_ew_raw,\n",
-    "        v_ew_raw,\n",
-    "        r_ew_scaled,\n",
-    "        v_ew_scaled,\n",
-    "        s_ew_scaled,\n",
-    "        so_ew_scaled,\n",
-    "        mdd_ew_scaled\n",
-    "    ])\n",
-    "\n",
-    "    r_user_raw, v_user_raw, _, _, _ = out_user_stats_raw\n",
-    "    r_user_scaled, v_user_scaled, s_user_scaled, so_user_scaled, mdd_user_scaled = out_user_stats_scaled\n",
-    "    out_user_data.append([\n",
-    "        'User-Weighted Portfolio',\n",
-    "        r_user_raw,\n",
-    "        v_user_raw,\n",
-    "        r_user_scaled,\n",
-    "        v_user_scaled,\n",
-    "        s_user_scaled,\n",
-    "        so_user_scaled,\n",
-    "        mdd_user_scaled\n",
-    "    ])\n",
-    "\n",
-    "    out_eq_df = pd.DataFrame(\n",
-    "        out_eq_data,\n",
-    "        columns=['Fund', 'RetBefore(%)', 'VolBefore(%)', 'RetAfter(%)', 'VolAfter(%)', 'Sharpe(After)', 'Sortino(After)', 'MaxDD(After)(%)']\n",
-    "    )\n",
-    "    out_user_df = pd.DataFrame(\n",
-    "        out_user_data,\n",
-    "        columns=['Fund', 'RetBefore(%)', 'VolBefore(%)', 'RetAfter(%)', 'VolAfter(%)', 'Sharpe(After)', 'Sortino(After)', 'MaxDD(After)(%)']\n",
-    "    )\n",
-    "\n",
-    "    writer = pd.ExcelWriter(output_filename, engine='xlsxwriter')\n",
-    "\n",
-    "    # In-Sample Sheet\n",
-    "    in_eq_df.to_excel(writer, sheet_name='In-Sample', startrow=0, index=False)\n",
-    "    in_user_df.to_excel(writer, sheet_name='In-Sample', startrow=len(in_eq_df)+3, index=False)\n",
-    "\n",
-    "    # Out-of-Sample Sheet\n",
-    "    out_eq_df.to_excel(writer, sheet_name='Out-of-Sample', startrow=0, index=False)\n",
-    "    out_user_df.to_excel(writer, sheet_name='Out-of-Sample', startrow=len(out_eq_df)+3, index=False)\n",
-    "\n",
-    "    workbook = writer.book\n",
-    "    pct_format = workbook.add_format({'num_format': '0.0%'})\n",
-    "    decimal_format = workbook.add_format({'num_format': '0.00'})  # for non-percent columns\n",
-    "    bold_format = workbook.add_format({'bold': True})\n",
-    "\n",
-    "    # Format In-Sample\n",
-    "    in_sample_ws = writer.sheets['In-Sample']\n",
-    "    in_sample_ws.set_column(0, 0, 28)  # Fund column\n",
-    "    in_sample_ws.set_column(1, 2, 8, pct_format)\n",
-    "    in_sample_ws.set_column(3, 4, 8, decimal_format)\n",
-    "    in_sample_ws.set_column(5, 5, 8, pct_format)\n",
-    "    \n",
-    "    # Bold headers\n",
-    "    for colx in range(in_eq_df.shape[1]):\n",
-    "        in_sample_ws.write(0, colx, in_eq_df.columns[colx], bold_format)\n",
-    "    for colx in range(in_user_df.shape[1]):\n",
-    "        in_sample_ws.write(len(in_eq_df)+3, colx, in_user_df.columns[colx], bold_format)\n",
-    "\n",
-    "    # Format Out-of-Sample\n",
-    "    out_sample_ws = writer.sheets['Out-of-Sample']\n",
-    "    out_sample_ws.set_column(0, 0, 28)\n",
-    "    out_sample_ws.set_column(1, 7, 15, pct_format)\n",
-    "    for colx in range(out_eq_df.shape[1]):\n",
-    "        out_sample_ws.write(0, colx, out_eq_df.columns[colx], bold_format)\n",
-    "    for colx in range(out_user_df.shape[1]):\n",
-    "        out_sample_ws.write(len(out_eq_df)+3, colx, out_user_df.columns[colx], bold_format)\n",
-    "\n",
-    "    writer.close()\n",
-    "    logging.info(f\"Exported analysis to {output_filename} successfully.\")\n",
-    "    print(f\"Excel file created: {output_filename}\")\n",
-    "\n",
-    "print(\"export_to_excel function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Demo Run\n",
-    "The `demo_run()` function creates a small dummy dataset, runs the analysis, and exports the results to an Excel file."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "d89721c8",
-   "metadata": {
-    "collapsed": false,
-    "jupyter": {
-     "outputs_hidden": false
-    }
-   },
-   "outputs": [],
-   "source": [
-    "def demo_run():\n",
-    "    \"\"\"\n",
-    "    Create a small dummy dataset, run analysis, export results.\n",
-    "    \"\"\"\n",
-    "    # Create monthly date range\n",
-    "    rng = pd.date_range(start='2003-01-01', end='2010-12-01', freq='MS')\n",
-    "    df_demo = pd.DataFrame({'Date': rng})\n",
-    "\n",
-    "    np.random.seed(42)\n",
-    "    rf_values = np.random.normal(loc=0.002, scale=0.0001, size=len(rng))\n",
-    "    df_demo['RF'] = rf_values\n",
-    "\n",
-    "    # Random funds with missing data\n",
-    "    for i in range(1, 6):\n",
-    "        fund_name = f\"Fund_{i}\"\n",
-    "        mean_r = 0.01 * i / 10.0\n",
-    "        stdev_r = 0.02 * (i / 5.0)\n",
-    "        rets = np.random.normal(loc=mean_r, scale=stdev_r, size=len(rng))\n",
-    "\n",
-    "        # Introduce random short or long gaps\n",
-    "        if i == 3:\n",
-    "            missing_idx = np.random.choice(len(rng), 2, replace=False)\n",
-    "            for idx in missing_idx:\n",
-    "                rets[idx] = np.nan\n",
-    "        if i == 4:\n",
-    "            rets[10:13] = np.nan  # 3 consecutive -> exclude\n",
-    "\n",
-    "        df_demo[fund_name] = rets\n",
-    "\n",
-    "    # Shuffle rows to test sorting\n",
-    "    df_demo = df_demo.sample(frac=1).reset_index(drop=True)\n",
-    "\n",
-    " \n",
-    "    results = run_analysis(\n",
-    "        df_demo,\n",
-    "        in_start='2003-01', in_end='2005-12',\n",
-    "        out_start='2006-01', out_end='2010-12',\n",
-    "        target_vol=0.10,\n",
-    "        monthly_cost=0.002,\n",
-    "        selection_mode='all',\n",
-    "        random_n=2\n",
-    "    )\n",
-    "\n",
-    "    \n",
-    "    \n",
-    "    if results is not None:\n",
-    "        export_to_excel(results, \"DemoAnalysisOutput.xlsx\")\n",
-    "        print(\"Demo run complete.\")\n",
-    "\n",
-    "print(\"demo_run function ready. Call 'demo_run()' to test.\")"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 11,
-   "id": "d7b7c730-225c-4c69-9dbf-d1ec9971a26f",
-   "metadata": {
-    "scrolled": true
-   },
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "72d65155741c4205a9fd8566d9388150",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(Text(value='2003-01', description='In-Sample Start:'), Text(value='2005-12', description='In-Sa…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "86311365b69b4b95b6a83fc3ac7cde41",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Output()"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# (C) Wire the button and display\n",
-    "apply_button.on_click(on_apply_clicked)\n",
-    "display(ui_inputs, output_area)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Reconfig-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Reconfig-checkpoint.ipynb
deleted file mode 100644
index f620e4f53419a0c18f0efd4ee59ff5789db8e109..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Reconfig-checkpoint.ipynb
+++ /dev/null
@@ -1,1530 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "c2cd88ee-a255-4282-b722-f34e34b95d36",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Run Analysis callback is now wired.\n"
-     ]
-    }
-   ],
-   "source": [
-    "import pandas as pd\n",
-    "import numpy as np\n",
-    "\n",
-    "# ────────────── 1) Re‐compute in_sdate, in_edate, out_sdate, out_edate ──────────────\n",
-    "in_sdate  = pd.to_datetime(\"2005-07-01\", errors=\"coerce\")\n",
-    "in_edate  = pd.to_datetime(\"2008-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "out_sdate = pd.to_datetime(\"2008-07-01\", errors=\"coerce\")\n",
-    "out_edate = pd.to_datetime(\"2009-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "# ────────────── 2) Build the full‐history list (no NaNs anywhere in each window) ──────────────\n",
-    "#    We assume that 'rf_col' is already defined and holds the risk‐free column name.\n",
-    "#    We also assume that any index columns are in a list called 'indices_list'.\n",
-    "all_candidates = [\n",
-    "    c for c in df.columns \n",
-    "    if c not in [\"Date\", rf_col] + indices_list\n",
-    "]\n",
-    "\n",
-    "# (A) Select only those f where in‐sample AND out‐sample both have no NaNs anywhere:\n",
-    "post_full_history_funds = []\n",
-    "for f in all_candidates:\n",
-    "    in_sub  = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "    out_sub = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "    if in_sub.notna().all() and out_sub.notna().all():\n",
-    "        post_full_history_funds.append(f)\n",
-    "\n",
-    "print(f\"(1) Funds with absolutely no NaNs over both windows (count = {len(post_full_history_funds)}):\")\n",
-    "print(post_full_history_funds)\n",
-    "\n",
-    "\n",
-    "# ────────────── 3) Now run the “3+ consecutive NaNs” check only on that list ──────────────\n",
-    "flagged_exact = []  # will hold (fund_name, window_name, max_consecutive_nans)\n",
-    "for f in post_full_history_funds:\n",
-    "    # In‐sample gap‐runs\n",
-    "    sub_in   = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "    isnan_in = sub_in.isna().astype(int)\n",
-    "    run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "    max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "    if max_run_in >= 3:\n",
-    "        flagged_exact.append((f, \"in-sample\", int(max_run_in)))\n",
-    "\n",
-    "    # Out‐sample gap‐runs\n",
-    "    sub_out   = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "    isnan_out = sub_out.isna().astype(int)\n",
-    "    run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "    max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "    if max_run_out >= 3:\n",
-    "        flagged_exact.append((f, \"out-sample\", int(max_run_out)))\n",
-    "\n",
-    "\n",
-    "# ────────────── 4) Report results ──────────────\n",
-    "if flagged_exact:\n",
-    "    print(\"\\nFunds that actually *do* have 3+ consecutive NaNs inside one of the windows:\")\n",
-    "    for (fund_name, window_name, length) in flagged_exact:\n",
-    "        print(f\"  • {fund_name!r} → {length} consecutive NaNs in {window_name}\")\n",
-    "else:\n",
-    "    print(\"\\nNone of the post‐full‐history funds has a run of ≥ 3 NaNs in either window.\")\n",
-    "\n",
-    "import pandas as pd\n",
-    "\n",
-    "# ─────────── Define your date boundaries ───────────\n",
-    "in_sdate  = pd.to_datetime(\"2005-07-01\", errors=\"coerce\")\n",
-    "in_edate  = pd.to_datetime(\"2008-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "out_sdate = pd.to_datetime(\"2008-07-01\", errors=\"coerce\")\n",
-    "out_edate = pd.to_datetime(\"2009-06-01\", errors=\"coerce\") + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "# (Also ensure 'df' and 'fund_cols' are already defined above this cell.)\n",
-    "\n",
-    "flagged = []  # will hold (fund_name, window_name, max_consecutive_nans) tuples\n",
-    "\n",
-    "for f in fund_cols:\n",
-    "    # ─── In‐sample window check ───\n",
-    "    sub_in = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "    isnan_in = sub_in.isna().astype(int)                         # 1 where NaN, 0 otherwise\n",
-    "    # group by cumulative “not-NaN” runs to measure each NaN‐block length\n",
-    "    run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "    max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "    if max_run_in >= 3:\n",
-    "        flagged.append((f, 'in-sample', int(max_run_in)))\n",
-    "    \n",
-    "    # ─── Out‐sample window check ───\n",
-    "    sub_out = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "    isnan_out = sub_out.isna().astype(int)\n",
-    "    run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "    max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "    if max_run_out >= 3:\n",
-    "        flagged.append((f, 'out-sample', int(max_run_out)))\n",
-    "\n",
-    "# Finally, print any funds with ≥ 3 consecutive NaNs\n",
-    "if flagged:\n",
-    "    print(\"Funds with a 3+ consecutive‐NaN run inside one of the windows:\")\n",
-    "    for (fund_name, window_name, length) in flagged:\n",
-    "        print(f\"  • {fund_name!r} has {length} consecutive NaNs in the {window_name} window\")\n",
-    "else:\n",
-    "    print(\"All funds have at most 2 consecutive NaNs in both in‐sample and out‐sample windows.\")\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "67d5b060-852c-4755-aa9b-7b3f0919f5e8",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "    for fund in selected_funds:\n",
-    "        sf = scale_factors[fund]\n",
-    "        # In-sample\n",
-    "        adj_in = in_sample_df[fund] * sf - monthly_cost\n",
-    "        adj_in[adj_in < -1.0] = -1.0\n",
-    "        in_sample_scaled[fund] = adj_in\n",
-    "        \n",
-    "        # Out-of-sample\n",
-    "        if out_sample_df.shape[0] > 0:\n",
-    "            adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_out[adj_out < -1.0] = -1.0\n",
-    "            out_sample_scaled[fund] = adj_out\n",
-    "    \n",
-    "    # Helper function for stats\n",
-    "    def compute_stats(series, rf_series):\n",
-    "        r = annualize_return(series)\n",
-    "        v = annualize_volatility(series)\n",
-    "        sr = sharpe_ratio(series, rf_series)\n",
-    "        so = sortino_ratio(series, rf_series)\n",
-    "        mdd = max_drawdown(series)\n",
-    "        return (r, v, sr, so, mdd)\n",
-    "    \n",
-    "    in_sample_stats = {}\n",
-    "    for fund in selected_funds:\n",
-    "        in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "    \n",
-    "    out_sample_stats = {}\n",
-    "    for fund in selected_funds:\n",
-    "        out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "    \n",
-    "    out_sample_stats_raw = {}\n",
-    "    for fund in selected_funds:\n",
-    "        out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "    \n",
-    "    # Portfolio (equal-weight)\n",
-    "    ew_w = np.array([1.0/len(selected_funds)]*len(selected_funds))\n",
-    "    in_ew_port = calc_portfolio_returns(ew_w, in_sample_scaled[selected_funds])\n",
-    "    out_ew_port = calc_portfolio_returns(ew_w, out_sample_scaled[selected_funds])\n",
-    "    out_ew_port_raw = calc_portfolio_returns(ew_w, out_sample_df[selected_funds])\n",
-    "    \n",
-    "    in_ew_stats = compute_stats(in_ew_port, in_sample_rf)\n",
-    "    out_ew_stats = compute_stats(out_ew_port, out_sample_rf)\n",
-    "    out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "    \n",
-    "    # Portfolio (user-weighted) - placeholder\n",
-    "    user_weight_dict = {f: 1.0/len(selected_funds) for f in selected_funds}\n",
-    "    custom_w = np.array([user_weight_dict[f] for f in selected_funds])\n",
-    "    in_user_port = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "    out_user_port = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "    out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "    \n",
-    "    in_user_stats = compute_stats(in_user_port, in_sample_rf)\n",
-    "    out_user_stats = compute_stats(out_user_port, out_sample_rf)\n",
-    "    out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "    \n",
-    "    results = {\n",
-    "        'selected_funds': selected_funds,\n",
-    "        'in_sample_scaled': in_sample_scaled,\n",
-    "        'out_sample_scaled': out_sample_scaled,\n",
-    "        'in_sample_stats': in_sample_stats,\n",
-    "        'out_sample_stats': out_sample_stats,\n",
-    "        'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "        'in_ew_stats': in_ew_stats,\n",
-    "        'out_ew_stats': out_ew_stats,\n",
-    "        'out_ew_stats_raw': out_ew_stats_raw,\n",
-    "        'in_user_stats': in_user_stats,\n",
-    "        'out_user_stats': out_user_stats,\n",
-    "        'out_user_stats_raw': out_user_stats_raw"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 1. SETUP CELL ============\n",
-    "\n",
-    "import logging\n",
-    "import sys\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import os\n",
-    "import math\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import interact, interactive, VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from IPython.utils.capture import capture_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import datetime\n",
-    "import random\n",
-    "import warnings\n",
-    "\n",
-    "# If you need to install these packages on your environment, uncomment:\n",
-    "!{sys.executable} -m pip install --quiet ipywidgets openpyxl xlsxwriter\n",
-    "\n",
-    "# For exporting to Excel with styling\n",
-    "import xlsxwriter\n",
-    "\n",
-    "# Set up logging to console\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "logging.info(\"Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\")\n",
-    "\n",
-    "# (Optional) If widgets aren't enabled, run:\n",
-    "# !jupyter nbextension enable --py widgetsnbextension --sys-prefix\n",
-    "\n",
-    "print(\"Setup complete.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "ee3865b0da8c4d439e0f29fa3c122c10",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<b>Step 1: Choose your CSV</b><br><i>Remember:</i> If you included any index column…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify which column (after 'Date') is the risk-free rate by smallest stdev among columns.\n",
-    "    \"\"\"\n",
-    "    numeric_cols = df.columns[1:]  # skip the Date column\n",
-    "    stdevs = {}\n",
-    "    for col in numeric_cols:\n",
-    "        vals = df[col].dropna()\n",
-    "        if len(vals) > 0:\n",
-    "            stdevs[col] = vals.std()\n",
-    "        else:\n",
-    "            stdevs[col] = np.inf\n",
-    "\n",
-    "    rf_col = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "    return rf_col\n",
-    "\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 1) Helper to read a local CSV robustly (handles BOMs and minor parsing issues)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Try loading `path` as CSV in three ways:\n",
-    "    1. Default C engine\n",
-    "    2. BOM-stripped with the Python engine\n",
-    "    3. Skip bad lines with the Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception as e1:\n",
-    "        print(\"Default read_csv failed:\", e1)\n",
-    "\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception as e2:\n",
-    "        print(\"utf-8-sig + python engine failed:\", e2)\n",
-    "\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",    # for pandas ≥ 1.3\n",
-    "    )\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 2) Build the widgets\n",
-    "# ------------------------------------------------------------------------------\n",
-    "source_info = widgets.HTML(\n",
-    "    \"<b>Step 1: Choose your CSV</b><br>\"\n",
-    "    \"<i>Remember:</i> If you included any index columns (e.g. S&P 500, MSCI World, SG Trend), they \"\n",
-    "    \"must appear to the right of all fund columns in your sheet.\"\n",
-    ")\n",
-    "\n",
-    "\n",
-    "source_dropdown = widgets.Dropdown(\n",
-    "    options=['Local', 'GitHub'],\n",
-    "    value='Local',\n",
-    "    description='Data Source:',\n",
-    "    style={'description_width': '120px'}\n",
-    ")\n",
-    "\n",
-    "# FileChooser for Local mode\n",
-    "fc = FileChooser(os.getcwd())\n",
-    "fc.title = \"<b>Select local CSV file</b>\"\n",
-    "\n",
-    "# Text box for GitHub raw URL\n",
-    "github_text = widgets.Text(\n",
-    "    value=(\n",
-    "        \"https://raw.githubusercontent.com/stranske/Trend_Model_Project/\"\n",
-    "        \"main/data/TrendData.csv\"\n",
-    "    ),\n",
-    "    description=\"GitHub URL:\",\n",
-    "    layout=widgets.Layout(width=\"80%\"),\n",
-    ")\n",
-    "\n",
-    "# Ask how many index columns are on the far right\n",
-    "n_indices_widget = widgets.BoundedIntText(\n",
-    "    value=0,\n",
-    "    min=0,\n",
-    "    max=10,  # adjust if you expect more than 10 indices\n",
-    "    description='# Index cols:',\n",
-    "    style={'description_width': '120px'},\n",
-    "    tooltip=\"Enter the number of index columns at the far right of your CSV\"\n",
-    ")\n",
-    "\n",
-    "# Load button\n",
-    "load_button = widgets.Button(description=\"Load Data\", button_style=\"success\")\n",
-    "\n",
-    "# Output area for status and debug prints\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 3) Show/hide widgets depending on source selection\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_source_change(change):\n",
-    "    if change[\"new\"] == \"Local\":\n",
-    "        fc.layout.display = \"block\"\n",
-    "        github_text.layout.display = \"none\"\n",
-    "    else:\n",
-    "        fc.layout.display = \"none\"\n",
-    "        github_text.layout.display = \"block\"\n",
-    "\n",
-    "# Initially, GitHub textbox is hidden; FileChooser is visible\n",
-    "github_text.layout.display = \"none\"\n",
-    "fc.layout.display = \"block\"\n",
-    "\n",
-    "source_dropdown.observe(on_source_change, names=\"value\")\n",
-    "\n",
-    "ui_load = widgets.VBox([\n",
-    "    source_info,\n",
-    "    source_dropdown,\n",
-    "    fc,\n",
-    "    github_text,\n",
-    "    n_indices_widget,   # ← new widget here\n",
-    "    load_button,\n",
-    "    output_area\n",
-    "])\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 4) Callback for the Load button (auto-detect date format)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_load_clicked(_):\n",
-    "    global df, fund_cols, indices_list, rf_col            # declare df as global\n",
-    "    with output_area:\n",
-    "        output_area.clear_output()\n",
-    "        src_choice = source_dropdown.value\n",
-    "        n_indices = int(n_indices_widget.value)\n",
-    "\n",
-    "        # 4a) Load the DataFrame\n",
-    "        try:\n",
-    "            if src_choice == 'Local':\n",
-    "                local_path = fc.selected  # FileChooser’s selected path\n",
-    "                if not local_path or not os.path.exists(local_path):\n",
-    "                    print(f\"Error: Local file not found:\\n  {local_path}\")\n",
-    "                    return\n",
-    "                print(f\"Loading from local file:\\n  {local_path}\")\n",
-    "                df = pd.read_csv(local_path)\n",
-    "            else:\n",
-    "                github_url = github_text.value.strip()\n",
-    "                if not github_url:\n",
-    "                    print(\"Error: Please enter a valid GitHub raw URL.\")\n",
-    "                    return\n",
-    "                print(f\"Loading from GitHub URL:\\n  {github_url}\")\n",
-    "                df = pd.read_csv(github_url)\n",
-    "        except Exception as e:\n",
-    "            print(\"Failed to load CSV:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4b) Debug: print columns & a few rows\n",
-    "        print(\"Columns found in DataFrame:\", df.columns.tolist())\n",
-    "        display(df.head(3))\n",
-    "\n",
-    "        # 4c) Identify which column is the date\n",
-    "        date_col = None\n",
-    "        for candidate in [\"Date\", \"DATE\", \"date\"]:\n",
-    "            if candidate in df.columns:\n",
-    "                date_col = candidate\n",
-    "                break\n",
-    "\n",
-    "        if date_col is None:\n",
-    "            print(\"Error: No column named 'Date' / 'DATE' / 'date' found.\")\n",
-    "            print(\"Please check the column names above and adjust code accordingly.\")\n",
-    "            return\n",
-    "\n",
-    "        date_col = 'Date'\n",
-    "\n",
-    "        # 1) Show the first few raw date strings (un‐parsed) so we can inspect them\n",
-    "        raw_samples = df[date_col].dropna().astype(str).head(10).tolist()\n",
-    "        print(f\"Raw {date_col} samples (first 10 non‐null): {raw_samples!r}\")\n",
-    "\n",
-    "        # 2) Strip leading/trailing whitespace from every entry\n",
-    "        df[date_col] = df[date_col].astype(str).str.strip()\n",
-    "\n",
-    "        # 3) Now attempt strict \"%m/%d/%Y\" parsing\n",
-    "        parsed = pd.to_datetime(df[date_col], format=\"%m/%d/%Y\", errors=\"coerce\", infer_datetime_format=True)\n",
-    "        num_valid = parsed.notna().sum()\n",
-    "        print(f\"Number of rows matching '%m/%d/%Y' exactly: {num_valid} / {len(df)}\")\n",
-    "\n",
-    "        if num_valid > 0:\n",
-    "            df[date_col] = parsed\n",
-    "            print(f\"Parsing with '%m/%d/%Y' succeeded for {num_valid} rows.\")\n",
-    "        else:\n",
-    "            print(\n",
-    "                \"Warning: No rows matched '%m/%d/%Y'. \"\n",
-    "                \"Falling back to generic pd.to_datetime(...).\"\n",
-    "            )\n",
-    "            df[date_col] = pd.to_datetime(df[date_col], errors=\"coerce\")\n",
-    "\n",
-    "        # 5) Drop any rows where parsing still failed\n",
-    "        before_drop = len(df)\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        dropped = before_drop - len(df)\n",
-    "        if dropped:\n",
-    "            print(f\"Dropped {dropped} rows where '{date_col}' could not be parsed.\")\n",
-    "        \n",
-    "        # 6) Sort and reset index\n",
-    "        df.sort_values(by=date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "        \n",
-    "        # 7) Show the final parsed dates\n",
-    "        print(f\"After parsing, first 3 {date_col} values:\")\n",
-    "        print(df[[date_col]].head(3))\n",
-    "        print(f\"Loaded {len(df)} rows successfully.\")\n",
-    "\n",
-    "\n",
-    "        # 4d) Identify risk-free column\n",
-    "        try:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            print(f\"Identified risk-free column as: '{rf_col}'\")\n",
-    "        except Exception as e:\n",
-    "            print(\"Error identifying risk-free column:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4f) Determine fund_cols vs indices_list based on n_indices\n",
-    "        all_cols = df.columns.tolist()\n",
-    "        # We assume “Date” and rf_col are present. Everything else is a candidate.\n",
-    "        if 'Date' not in all_cols or rf_col not in all_cols:\n",
-    "            print(\"Error: 'Date' or risk-free column not found in DataFrame columns.\")\n",
-    "            return\n",
-    "        \n",
-    "        # Build list of all columns except 'Date' and rf_col\n",
-    "        remaining = [c for c in all_cols if c not in ['Date', rf_col]]\n",
-    "        \n",
-    "        if n_indices > len(remaining):\n",
-    "            print(\n",
-    "                f\"Error: You asked for {n_indices} index columns, but only \"\n",
-    "                f\"{len(remaining)} columns remain after 'Date' and '{rf_col}'.\"\n",
-    "            )\n",
-    "            return\n",
-    "\n",
-    "        if n_indices > 0:\n",
-    "            indices_list = remaining[-n_indices:]\n",
-    "            fund_cols    = remaining[:-n_indices]\n",
-    "        else:\n",
-    "            indices_list = []\n",
-    "            fund_cols    = remaining[:]\n",
-    "        print(\"\\n>> Debug (post‐load): fund_cols =\", fund_cols)\n",
-    "        print(\">> Debug (post‐load): indices_list =\", indices_list, \"\\n\")\n",
-    "        \n",
-    "        # 2F) Print out what we found\n",
-    "        print(f\"Detected fund columns ({len(fund_cols)}): {fund_cols}\")\n",
-    "        print(f\"Detected index columns ({len(indices_list)}): {indices_list}\")\n",
-    "        print(\n",
-    "            \"Data loaded and classified successfully.\\n\"\n",
-    "            \"Proceed to Step 2 (Run Analysis).\"\n",
-    "        )\n",
-    "\n",
-    " \n",
-    "        # 8) Confirm that df is now in global scope\n",
-    "        print(\">> df defined with\", len(df), \"rows and columns:\", df.columns.tolist())\n",
-    "\n",
-    "\n",
-    "# 5) Wire up and display the UI\n",
-    "load_button.on_click(on_load_clicked)\n",
-    "\n",
-    "\n",
-    "display(ui_load)\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Utility functions loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Check if a series (sorted chronologically) has >= threshold consecutive NaNs.\n",
-    "    Return True if such a gap exists, False otherwise.\n",
-    "    \"\"\"\n",
-    "    consecutive = 0\n",
-    "    for val in series:\n",
-    "        if pd.isna(val):\n",
-    "            consecutive += 1\n",
-    "        else:\n",
-    "            consecutive = 0\n",
-    "        if consecutive >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "\n",
-    "def annualize_return(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized (geometric) return from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    growth_factor = (1 + valid_rets).prod()\n",
-    "    n_months = len(valid_rets)\n",
-    "    if growth_factor <= 0:\n",
-    "        return -1.0\n",
-    "    ann_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    return ann_ret\n",
-    "\n",
-    "def annualize_volatility(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized stdev of monthly returns, i.e. stdev * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) < 2:\n",
-    "        return np.nan\n",
-    "    return valid_rets.std() * np.sqrt(12)\n",
-    "\n",
-    "def sharpe_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe ratio = (annual_excess_return) / (annual_excess_vol).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    ann_excess_vol = excess.std() * np.sqrt(12)\n",
-    "    if ann_excess_vol == 0:\n",
-    "        return np.nan\n",
-    "    return ann_excess_ret / ann_excess_vol\n",
-    "\n",
-    "def sortino_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino ratio = (annual_excess_return) / (annual_downside_stdev).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "\n",
-    "    negative_mask = excess < 0\n",
-    "    negative_returns = excess[negative_mask]\n",
-    "    if len(negative_returns) == 0:\n",
-    "        return np.inf  # no negative => infinite sortino\n",
-    "    downside_stdev = negative_returns.std() * np.sqrt(12)\n",
-    "    return ann_excess_ret / downside_stdev\n",
-    "\n",
-    "def max_drawdown(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Compute max drawdown from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    wealth_index = (1 + valid_rets).cumprod()\n",
-    "    rolling_max = wealth_index.cummax()\n",
-    "    dd_series = 1 - (wealth_index / rolling_max)\n",
-    "    return dd_series.max()\n",
-    "\n",
-    "def calc_portfolio_returns(weights, df_returns):\n",
-    "    \"\"\"\n",
-    "    Compute monthly portfolio returns (Series) as weighted sum of columns in df_returns.\n",
-    "    \"\"\"\n",
-    "    return (df_returns * weights).sum(axis=1)\n",
-    "\n",
-    "print(\"Utility functions loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "4f1619c9",
-   "metadata": {},
-   "source": [
-    "## 4. Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "1e739b5c-2218-4653-97f8-e3cebe194183",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Run Analysis callback is now wired.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ─────────────── Widget Setup + Callback ───────────────\n",
-    "\n",
-    "# (A) Build widgets\n",
-    "in_sample_start = widgets.Text(value='2003-01', description='In-Sample Start:')\n",
-    "in_sample_end   = widgets.Text(value='2005-12', description='In-Sample End:')\n",
-    "out_sample_start= widgets.Text(value='2006-01', description='Out-Sample Start:')\n",
-    "out_sample_end  = widgets.Text(value='2010-12', description='Out-Sample End:')\n",
-    "\n",
-    "target_vol_widget   = widgets.FloatText(value=0.10,  description='Target Vol:')\n",
-    "monthly_cost_widget = widgets.FloatText(value=0.002, description='Monthly Cost:')\n",
-    "\n",
-    "selection_mode_widget = widgets.Dropdown(\n",
-    "    options=[('All Funds','all'), ('Random Sample','random'), ('Manual','manual')],\n",
-    "    value='all',\n",
-    "    description='Mode:'\n",
-    ")\n",
-    "random_sample_size_widget = widgets.IntText(value=5, description='Sample Size:')\n",
-    "\n",
-    "apply_button = widgets.Button(description='Run Analysis', button_style='success')\n",
-    "\n",
-    "ui_inputs = widgets.VBox([\n",
-    "    in_sample_start, in_sample_end,\n",
-    "    out_sample_start, out_sample_end,\n",
-    "    target_vol_widget, monthly_cost_widget,\n",
-    "    selection_mode_widget, random_sample_size_widget,\n",
-    "    apply_button\n",
-    "])\n",
-    "\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "def on_apply_clicked(b):\n",
-    "    with output_area:\n",
-    "        clear_output()\n",
-    "        # 1) Read widget values\n",
-    "        in_start_val     = in_sample_start.value.strip()\n",
-    "        in_end_val       = in_sample_end.value.strip()\n",
-    "        out_start_val    = out_sample_start.value.strip()\n",
-    "        out_end_val      = out_sample_end.value.strip()\n",
-    "        target_vol_val   = target_vol_widget.value\n",
-    "        monthly_cost_val = monthly_cost_widget.value\n",
-    "        mode_val         = selection_mode_widget.value\n",
-    "        rnd_n_val        = random_sample_size_widget.value\n",
-    "\n",
-    "        # 2) Print parameter summary\n",
-    "        print(\"Running analysis with parameters:\")\n",
-    "        print(f\"  In-Sample:  {in_start_val} → {in_end_val}\")\n",
-    "        print(f\"  Out-Sample: {out_start_val} → {out_end_val}\")\n",
-    "        print(f\"  Target Volatility: {target_vol_val}\")\n",
-    "        print(f\"  Monthly Cost: {monthly_cost_val}\")\n",
-    "        print(f\"  Selection Mode: {mode_val}\")\n",
-    "        if mode_val == 'random':\n",
-    "            print(f\"  Random Sample Size: {rnd_n_val}\")\n",
-    "\n",
-    "        # 3) Capture everything printed by run_analysis (and select_funds)\n",
-    "        with capture_output() as cap:\n",
-    "            try:\n",
-    "                results = run_analysis(\n",
-    "                    df,\n",
-    "                    in_start=in_start_val,\n",
-    "                    in_end=in_end_val,\n",
-    "                    out_start=out_start_val,\n",
-    "                    out_end=out_end_val,\n",
-    "                    target_vol=target_vol_val,\n",
-    "                    monthly_cost=monthly_cost_val,\n",
-    "                    selection_mode=mode_val,\n",
-    "                    random_n=rnd_n_val\n",
-    "                )\n",
-    "            except Exception as e:\n",
-    "                print(\"Error inside run_analysis():\", e)\n",
-    "                return\n",
-    "\n",
-    "        # 4) Print the captured debug/info text\n",
-    "        print(cap.stdout)\n",
-    "\n",
-    "        # 5) If no funds survived, warn\n",
-    "        if results is None or ('selected_funds' in results and not results['selected_funds']):\n",
-    "            print(\"No valid funds remain after filtering. Check your date range or data.\")\n",
-    "            return\n",
-    "\n",
-    "        # 6) Summary\n",
-    "        print(\"Analysis complete. Summary:\")\n",
-    "        sf = results['selected_funds']\n",
-    "        if 'selected_funds' in results:\n",
-    "            print(f\"  Funds selected: {len(results['selected_funds'])}\")\n",
-    "        if 'in_ew_stats' in results:\n",
-    "            ir, iv, isr, _, _ = results['in_ew_stats']\n",
-    "            print(f\"  In-Sample EW → Return: {ir*100:.2f}%, Vol: {iv*100:.2f}%, Sharpe: {isr:.2f}\")\n",
-    "        if 'out_ew_stats' in results:\n",
-    "            or_, ov, osr, _, _ = results['out_ew_stats']\n",
-    "            print(f\"  Out-Sample EW → Return: {or_*100:.2f}%, Vol: {ov*100:.2f}%, Sharpe: {osr:.2f}\")\n",
-    "        print(f\"  Funds selected: {len(sf)} → {sf}\")\n",
-    "        \n",
-    "        export_to_excel(results, \"InteractiveOutput.xlsx\")\n",
-    "\n",
-    "\n",
-    "\n",
-    "# Wire the button once (after all definitions are loaded)\n",
-    "\n",
-    "print(\"Run Analysis callback is now wired.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "## 5. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "c5867ccd-a550-4849-a10b-a085f5fe26fd",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "select_funds (replaced) is ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def select_funds(\n",
-    "    df,                 # full DataFrame with datetime64 ‘Date’\n",
-    "    rf_col,             # name of risk‐free column\n",
-    "    fund_columns,       # list of candidate funds (should be your 27)\n",
-    "    in_sdate, in_edate, # pd.Timestamps for in‐sample window\n",
-    "    out_sdate, out_edate,# pd.Timestamps for out‐sample window\n",
-    "    selection_mode='all',\n",
-    "    random_n=5\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Start from fund_columns.  \n",
-    "    2) Filter out any that contain 'index' in name.  \n",
-    "    3) Keep only those with no NaN anywhere in both windows.  \n",
-    "    4) Keep only those with < 3 consecutive NaNs in each window.  \n",
-    "    5) Return based on selection_mode.\n",
-    "    \"\"\"\n",
-    "    # Step 1: base list\n",
-    "    candidates = fund_columns.copy()\n",
-    "    print(f\"DEBUG [select_funds]: initial candidates (n={len(candidates)}): {candidates}\")\n",
-    "\n",
-    "    # Step 2: drop any with “index” in name (case‐insensitive)\n",
-    "    no_index = [f for f in candidates if 'index' not in f.lower()]\n",
-    "    print(f\"DEBUG [select_funds]: after dropping 'index' (n={len(no_index)}): {no_index}\")\n",
-    "\n",
-    "    # Step 3: full‐history check (no NaN at all in each window)\n",
-    "    full_hist = []\n",
-    "    for f in no_index:\n",
-    "        in_sub  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)][f]\n",
-    "        out_sub = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        if in_sub.notna().all() and out_sub.notna().all():\n",
-    "            full_hist.append(f)\n",
-    "    print(f\"DEBUG [select_funds]: after full‐history check (n={len(full_hist)}): {full_hist}\")\n",
-    "\n",
-    "    # Step 4: no 3‐consecutive‐NaNs check\n",
-    "    after_run_check = []\n",
-    "    for f in full_hist:\n",
-    "        # In‐sample gap runs\n",
-    "        sub_in   = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "        isnan_in = sub_in.isna().astype(int)\n",
-    "        run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "        max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "\n",
-    "        # Out‐sample gap runs\n",
-    "        sub_out   = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        isnan_out = sub_out.isna().astype(int)\n",
-    "        run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "        max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "\n",
-    "        # Keep only if both max runs < 3\n",
-    "        if max_run_in < 3 and max_run_out < 3:\n",
-    "            after_run_check.append(f)\n",
-    "\n",
-    "    print(f\"DEBUG [select_funds]: after run‐length check (n={len(after_run_check)}): {after_run_check}\")\n",
-    "\n",
-    "    # Step 5: selection_mode\n",
-    "    if selection_mode == 'all':\n",
-    "        return after_run_check\n",
-    "\n",
-    "    if selection_mode == 'random':\n",
-    "        if len(after_run_check) <= random_n:\n",
-    "            warnings.warn(\n",
-    "                f\"Fewer valid funds ({len(after_run_check)}) than sample size ({random_n}). Returning all.\"\n",
-    "            )\n",
-    "            return after_run_check\n",
-    "        return random.sample(after_run_check, random_n)\n",
-    "\n",
-    "    # (Placeholder for manual widget selection, if you implement it later)\n",
-    "    return after_run_check\n",
-    "\n",
-    "print(\"select_funds (replaced) is ready.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 6. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "get_custom_weights function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    Returns dict {fund: weight_decimal}.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=f\"{fund}\",\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    \n",
-    "    confirm_button = widgets.Button(\n",
-    "        description='Confirm Weights',\n",
-    "        button_style='success'\n",
-    "    )\n",
-    "    error_label = widgets.Label(value='', layout=widgets.Layout(color='red'))\n",
-    "    \n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm_button, error_label])\n",
-    "    display(box)\n",
-    "    \n",
-    "    weights_container = {}\n",
-    "    \n",
-    "    def on_confirm_clicked(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_label.value = f\"Error: Weights sum to {total}, must be 100.\"\n",
-    "            weights_container.clear()\n",
-    "        else:\n",
-    "            for fund, wdg in weight_widgets.items():\n",
-    "                weights_container[fund] = wdg.value / 100.0\n",
-    "            error_label.value = \"Weights confirmed!\"\n",
-    "    \n",
-    "    confirm_button.on_click(on_confirm_clicked)\n",
-    "    return weights_container\n",
-    "\n",
-    "print(\"get_custom_weights function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 7. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 7,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "run_analysis (with checkpoints) is defined.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def run_analysis(\n",
-    "    df, in_start, in_end, out_start, out_end,\n",
-    "    target_vol, monthly_cost,\n",
-    "    selection_mode='all', random_n=5\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Parse/validate date inputs\n",
-    "    2) Convert Date column if needed\n",
-    "    3) Identify rf_col\n",
-    "    4) Prepare in/out sample DataFrames\n",
-    "    5) CALL select_funds (with debug) and print checkpoints\n",
-    "    6) Compute scale_factors and wrap stats in try/except\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # (1) Parse input dates\n",
-    "    in_sdate  = pd.to_datetime(in_start + \"-01\", errors='coerce')\n",
-    "    in_edate  = pd.to_datetime(in_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "    out_sdate = pd.to_datetime(out_start + \"-01\", errors='coerce')\n",
-    "    out_edate = pd.to_datetime(out_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    # checkpoint A\n",
-    "    print(\"CHECKPOINT A: Dates parsed:\", in_sdate, in_edate, out_sdate, out_edate)\n",
-    "\n",
-    "    # (2) Ensure Date is datetime64\n",
-    "    if not np.issubdtype(df['Date'].dtype, np.datetime64):\n",
-    "        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "        df.dropna(subset=['Date'], inplace=True)\n",
-    "        df.sort_values(by='Date', inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "    # checkpoint B\n",
-    "    print(\"CHECKPOINT B: Date column is datetime64, first dates:\", df['Date'].iloc[0], df['Date'].iloc[-1])\n",
-    "\n",
-    "    # (3) Identify risk-free column\n",
-    "    rf_col = identify_risk_free_fund(df)\n",
-    "    print(f\"INFO: Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "\n",
-    "    # (4) Build in-sample & out-sample slices\n",
-    "    in_sample_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_sample_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "    in_sample_rf  = in_sample_df[rf_col]\n",
-    "    out_sample_rf = out_sample_df[rf_col]\n",
-    "\n",
-    "    print(f\"CHECKPOINT C: in_sample rows = {len(in_sample_df)}, out_sample rows = {len(out_sample_df)}\")\n",
-    "\n",
-    "    # (5) Assemble fund_cols and call select_funds\n",
-    "    all_fund_cols = fund_cols.copy()\n",
-    "    print(f\"CHECKPOINT D: about to call select_funds with {len(all_fund_cols)} candidates\")\n",
-    "\n",
-    "    selected_funds = select_funds(\n",
-    "        df,\n",
-    "        rf_col,\n",
-    "        fund_columns=all_fund_cols,\n",
-    "        in_sdate=in_sdate,\n",
-    "        in_edate=in_edate,\n",
-    "        out_sdate=out_sdate,\n",
-    "        out_edate=out_edate,\n",
-    "        selection_mode=selection_mode,\n",
-    "        random_n=random_n\n",
-    "    )\n",
-    "\n",
-    "    print(f\"CHECKPOINT E: select_funds returned {len(selected_funds)} funds → {selected_funds}\")\n",
-    "\n",
-    "    if not selected_funds:\n",
-    "        print(\"No valid funds after select_funds. Exiting run_analysis.\")\n",
-    "        return None\n",
-    "\n",
-    "    # (6) Compute scale_factors BEFORE entering stats‐try/except\n",
-    "    scale_factors = {}\n",
-    "    for fund in selected_funds:\n",
-    "        fund_in_rets = in_sample_df[fund].dropna()\n",
-    "        current_vol  = annualize_volatility(fund_in_rets)\n",
-    "        if pd.isna(current_vol) or current_vol == 0:\n",
-    "            scale_factors[fund] = 1.0\n",
-    "        else:\n",
-    "            scale_factors[fund] = target_vol / current_vol\n",
-    "\n",
-    "    print(\"CHECKPOINT F: scale_factors computed (showing first 5):\", \n",
-    "          {f: scale_factors[f] for f in selected_funds[:5]})\n",
-    "\n",
-    "    # Pre-allocate DataFrames for scaled returns\n",
-    "    in_sample_scaled  = pd.DataFrame(index=in_sample_df.index, columns=selected_funds)\n",
-    "    out_sample_scaled = pd.DataFrame(index=out_sample_df.index, columns=selected_funds)\n",
-    "\n",
-    "    # ────── TRY/EXCEPT AROUND ONLY THE “STATS” PORTION ──────\n",
-    "    try:\n",
-    "        # Scale returns (with cost)\n",
-    "        for fund in selected_funds:\n",
-    "            sf = scale_factors[fund]\n",
-    "            adj_in  = in_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_in[adj_in < -1.0] = -1.0\n",
-    "            in_sample_scaled[fund] = adj_in\n",
-    "\n",
-    "            if not out_sample_df.empty:\n",
-    "                adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "                adj_out[adj_out < -1.0] = -1.0\n",
-    "                out_sample_scaled[fund] = adj_out\n",
-    "\n",
-    "        # Helper for stats\n",
-    "        def compute_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            sr  = sharpe_ratio(series, rf_series)\n",
-    "            so  = sortino_ratio(series, rf_series)\n",
-    "            mdd = max_drawdown(series)\n",
-    "            return (r, v, sr, so, mdd)\n",
-    "\n",
-    "        # In-sample per-fund stats\n",
-    "        in_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "\n",
-    "        # Out-sample per-fund (adjusted) stats\n",
-    "        out_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "\n",
-    "        # Out-sample per-fund (raw) stats\n",
-    "        out_sample_stats_raw = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "\n",
-    "        # Equal-weight portfolio\n",
-    "        ew_w = np.array([1.0/len(selected_funds)] * len(selected_funds))\n",
-    "        in_ew_port      = calc_portfolio_returns(ew_w, in_sample_scaled[selected_funds])\n",
-    "        out_ew_port     = calc_portfolio_returns(ew_w, out_sample_scaled[selected_funds])\n",
-    "        out_ew_port_raw = calc_portfolio_returns(ew_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        in_ew_stats      = compute_stats(in_ew_port, in_sample_rf)\n",
-    "        out_ew_stats     = compute_stats(out_ew_port, out_sample_rf)\n",
-    "        out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # User‐weight placeholder\n",
-    "        user_weight_dict = {f: 1.0/len(selected_funds) for f in selected_funds}\n",
-    "        custom_w = np.array([user_weight_dict[f] for f in selected_funds])\n",
-    "\n",
-    "        in_user_port      = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "        out_user_port     = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "        out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        in_user_stats      = compute_stats(in_user_port, in_sample_rf)\n",
-    "        out_user_stats     = compute_stats(out_user_port, out_sample_rf)\n",
-    "        out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "\n",
-    "        results = {\n",
-    "            'selected_funds':       selected_funds,\n",
-    "            'in_sample_scaled':     in_sample_scaled,\n",
-    "            'out_sample_scaled':    out_sample_scaled,\n",
-    "            'in_sample_stats':      in_sample_stats,\n",
-    "            'out_sample_stats':     out_sample_stats,\n",
-    "            'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "            'in_ew_stats':          in_ew_stats,\n",
-    "            'out_ew_stats':         out_ew_stats,\n",
-    "            'out_ew_stats_raw':     out_ew_stats_raw,\n",
-    "            'in_user_stats':        in_user_stats,\n",
-    "            'out_user_stats':       out_user_stats,\n",
-    "            'out_user_stats_raw':   out_user_stats_raw\n",
-    "        }\n",
-    "\n",
-    "    except Exception as e:\n",
-    "        print(\"ERROR inside stats-block:\", e)\n",
-    "        return None\n",
-    "\n",
-    "    # Everything succeeded\n",
-    "    return results\n",
-    "\n",
-    "print(\"run_analysis (with checkpoints) is defined.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 8. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 8,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "export_to_excel function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def export_to_excel(results_dict, output_filename=\"AnalysisOutput.xlsx\"):\n",
-    "    \"\"\"\n",
-    "    Create an Excel file with two tabs: In-Sample, Out-of-Sample.\n",
-    "    Each has two tables: (1) Equal-Weight, (2) User-Weighted.\n",
-    "    Columns for Return(%), Vol(%), Sharpe, Sortino, MaxDD(%).\n",
-    "    For OOS, also show 'before scaling' vs. 'after scaling' returns/vol.\n",
-    "    \"\"\"\n",
-    "    selected_funds = results_dict['selected_funds']\n",
-    "    in_sample_stats = results_dict['in_sample_stats']\n",
-    "    out_sample_stats_scaled = results_dict['out_sample_stats']\n",
-    "    out_sample_stats_raw = results_dict['out_sample_stats_raw']\n",
-    "\n",
-    "    in_ew_stats = results_dict['in_ew_stats']\n",
-    "    out_ew_stats_scaled = results_dict['out_ew_stats']\n",
-    "    out_ew_stats_raw = results_dict['out_ew_stats_raw']\n",
-    "\n",
-    "    in_user_stats = results_dict['in_user_stats']\n",
-    "    out_user_stats_scaled = results_dict['out_user_stats']\n",
-    "    out_user_stats_raw = results_dict['out_user_stats_raw']\n",
-    "\n",
-    "    # --- In-Sample DataFrames ---\n",
-    "    in_eq_data = []\n",
-    "    in_user_data = []\n",
-    "    for fund in selected_funds:\n",
-    "        r, v, s, so, mdd = in_sample_stats[fund]\n",
-    "        in_eq_data.append([fund, r, v, s, so, mdd])\n",
-    "        in_user_data.append([fund, r, v, s, so, mdd])\n",
-    "\n",
-    "    in_eq_data.append([\n",
-    "        'Equal-Weight Portfolio',\n",
-    "        in_ew_stats[0],\n",
-    "        in_ew_stats[1],\n",
-    "        in_ew_stats[2],\n",
-    "        in_ew_stats[3],\n",
-    "        in_ew_stats[4]\n",
-    "    ])\n",
-    "    in_user_data.append([\n",
-    "        'User-Weighted Portfolio',\n",
-    "        in_user_stats[0],\n",
-    "        in_user_stats[1],\n",
-    "        in_user_stats[2],\n",
-    "        in_user_stats[3],\n",
-    "        in_user_stats[4]\n",
-    "    ])\n",
-    "\n",
-    "    in_eq_df = pd.DataFrame(\n",
-    "        in_eq_data,\n",
-    "        columns=['Fund', 'Return (%)', 'Volatility (%)', 'Sharpe', 'Sortino', 'MaxDD (%)']\n",
-    "    )\n",
-    "    in_user_df = pd.DataFrame(\n",
-    "        in_user_data,\n",
-    "        columns=['Fund', 'Return (%)', 'Volatility (%)', 'Sharpe', 'Sortino', 'MaxDD (%)']\n",
-    "    )\n",
-    "\n",
-    "    # --- Out-of-Sample DataFrames ---\n",
-    "    # columns: [Fund, RetBefore(%), VolBefore(%), RetAfter(%), VolAfter(%), Sharpe(After), Sortino(After), MaxDD(After)(%)]\n",
-    "    out_eq_data = []\n",
-    "    out_user_data = []\n",
-    "\n",
-    "    for fund in selected_funds:\n",
-    "        r_raw, v_raw, _, _, _ = out_sample_stats_raw[fund]\n",
-    "        r_scaled, v_scaled, s_scaled, so_scaled, mdd_scaled = out_sample_stats_scaled[fund]\n",
-    "        out_eq_data.append([\n",
-    "            fund,\n",
-    "            r_raw,\n",
-    "            v_raw,\n",
-    "            r_scaled,\n",
-    "            v_scaled,\n",
-    "            s_scaled,\n",
-    "            so_scaled,\n",
-    "            mdd_scaled\n",
-    "        ])\n",
-    "        out_user_data.append([\n",
-    "            fund,\n",
-    "            r_raw,\n",
-    "            v_raw,\n",
-    "            r_scaled,\n",
-    "            v_scaled,\n",
-    "            s_scaled,\n",
-    "            so_scaled,\n",
-    "            mdd_scaled\n",
-    "        ])\n",
-    "\n",
-    "    r_ew_raw, v_ew_raw, _, _, _ = out_ew_stats_raw\n",
-    "    r_ew_scaled, v_ew_scaled, s_ew_scaled, so_ew_scaled, mdd_ew_scaled = out_ew_stats_scaled\n",
-    "    out_eq_data.append([\n",
-    "        'Equal-Weight Portfolio',\n",
-    "        r_ew_raw,\n",
-    "        v_ew_raw,\n",
-    "        r_ew_scaled,\n",
-    "        v_ew_scaled,\n",
-    "        s_ew_scaled,\n",
-    "        so_ew_scaled,\n",
-    "        mdd_ew_scaled\n",
-    "    ])\n",
-    "\n",
-    "    r_user_raw, v_user_raw, _, _, _ = out_user_stats_raw\n",
-    "    r_user_scaled, v_user_scaled, s_user_scaled, so_user_scaled, mdd_user_scaled = out_user_stats_scaled\n",
-    "    out_user_data.append([\n",
-    "        'User-Weighted Portfolio',\n",
-    "        r_user_raw,\n",
-    "        v_user_raw,\n",
-    "        r_user_scaled,\n",
-    "        v_user_scaled,\n",
-    "        s_user_scaled,\n",
-    "        so_user_scaled,\n",
-    "        mdd_user_scaled\n",
-    "    ])\n",
-    "\n",
-    "    out_eq_df = pd.DataFrame(\n",
-    "        out_eq_data,\n",
-    "        columns=['Fund', 'RetBefore(%)', 'VolBefore(%)', 'RetAfter(%)', 'VolAfter(%)', 'Sharpe(After)', 'Sortino(After)', 'MaxDD(After)(%)']\n",
-    "    )\n",
-    "    out_user_df = pd.DataFrame(\n",
-    "        out_user_data,\n",
-    "        columns=['Fund', 'RetBefore(%)', 'VolBefore(%)', 'RetAfter(%)', 'VolAfter(%)', 'Sharpe(After)', 'Sortino(After)', 'MaxDD(After)(%)']\n",
-    "    )\n",
-    "\n",
-    "    writer = pd.ExcelWriter(output_filename, engine='xlsxwriter')\n",
-    "\n",
-    "    # In-Sample Sheet\n",
-    "    in_eq_df.to_excel(writer, sheet_name='In-Sample', startrow=0, index=False)\n",
-    "    in_user_df.to_excel(writer, sheet_name='In-Sample', startrow=len(in_eq_df)+3, index=False)\n",
-    "\n",
-    "    # Out-of-Sample Sheet\n",
-    "    out_eq_df.to_excel(writer, sheet_name='Out-of-Sample', startrow=0, index=False)\n",
-    "    out_user_df.to_excel(writer, sheet_name='Out-of-Sample', startrow=len(out_eq_df)+3, index=False)\n",
-    "\n",
-    "    workbook = writer.book\n",
-    "    pct_format = workbook.add_format({'num_format': '0.0%'})\n",
-    "    decimal_format = workbook.add_format({'num_format': '0.00'})  # for non-percent columns\n",
-    "    bold_format = workbook.add_format({'bold': True})\n",
-    "\n",
-    "    # Format In-Sample\n",
-    "    in_sample_ws = writer.sheets['In-Sample']\n",
-    "    in_sample_ws.set_column(0, 0, 28)  # Fund column\n",
-    "    in_sample_ws.set_column(1, 2, 8, pct_format)\n",
-    "    in_sample_ws.set_column(3, 4, 8, decimal_format)\n",
-    "    in_sample_ws.set_column(5, 5, 8, pct_format)\n",
-    "    \n",
-    "    # Bold headers\n",
-    "    for colx in range(in_eq_df.shape[1]):\n",
-    "        in_sample_ws.write(0, colx, in_eq_df.columns[colx], bold_format)\n",
-    "    for colx in range(in_user_df.shape[1]):\n",
-    "        in_sample_ws.write(len(in_eq_df)+3, colx, in_user_df.columns[colx], bold_format)\n",
-    "\n",
-    "    # Format Out-of-Sample\n",
-    "    out_sample_ws = writer.sheets['Out-of-Sample']\n",
-    "    out_sample_ws.set_column(0, 0, 28)\n",
-    "    out_sample_ws.set_column(1, 7, 15, pct_format)\n",
-    "    for colx in range(out_eq_df.shape[1]):\n",
-    "        out_sample_ws.write(0, colx, out_eq_df.columns[colx], bold_format)\n",
-    "    for colx in range(out_user_df.shape[1]):\n",
-    "        out_sample_ws.write(len(out_eq_df)+3, colx, out_user_df.columns[colx], bold_format)\n",
-    "\n",
-    "    writer.close()\n",
-    "    logging.info(f\"Exported analysis to {output_filename} successfully.\")\n",
-    "    print(f\"Excel file created: {output_filename}\")\n",
-    "\n",
-    "print(\"export_to_excel function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Demo Run\n",
-    "The `demo_run()` function creates a small dummy dataset, runs the analysis, and exports the results to an Excel file."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "id": "d89721c8",
-   "metadata": {
-    "collapsed": false,
-    "jupyter": {
-     "outputs_hidden": false
-    }
-   },
-   "outputs": [],
-   "source": [
-    "def demo_run():\n",
-    "    \"\"\"\n",
-    "    Create a small dummy dataset, run analysis, export results.\n",
-    "    \"\"\"\n",
-    "    # Create monthly date range\n",
-    "    rng = pd.date_range(start='2003-01-01', end='2010-12-01', freq='MS')\n",
-    "    df_demo = pd.DataFrame({'Date': rng})\n",
-    "\n",
-    "    np.random.seed(42)\n",
-    "    rf_values = np.random.normal(loc=0.002, scale=0.0001, size=len(rng))\n",
-    "    df_demo['RF'] = rf_values\n",
-    "\n",
-    "    # Random funds with missing data\n",
-    "    for i in range(1, 6):\n",
-    "        fund_name = f\"Fund_{i}\"\n",
-    "        mean_r = 0.01 * i / 10.0\n",
-    "        stdev_r = 0.02 * (i / 5.0)\n",
-    "        rets = np.random.normal(loc=mean_r, scale=stdev_r, size=len(rng))\n",
-    "\n",
-    "        # Introduce random short or long gaps\n",
-    "        if i == 3:\n",
-    "            missing_idx = np.random.choice(len(rng), 2, replace=False)\n",
-    "            for idx in missing_idx:\n",
-    "                rets[idx] = np.nan\n",
-    "        if i == 4:\n",
-    "            rets[10:13] = np.nan  # 3 consecutive -> exclude\n",
-    "\n",
-    "        df_demo[fund_name] = rets\n",
-    "\n",
-    "    # Shuffle rows to test sorting\n",
-    "    df_demo = df_demo.sample(frac=1).reset_index(drop=True)\n",
-    "\n",
-    " \n",
-    "    results = run_analysis(\n",
-    "        df_demo,\n",
-    "        in_start='2003-01', in_end='2005-12',\n",
-    "        out_start='2006-01', out_end='2010-12',\n",
-    "        target_vol=0.10,\n",
-    "        monthly_cost=0.002,\n",
-    "        selection_mode='all',\n",
-    "        random_n=2\n",
-    "    )\n",
-    "\n",
-    "    \n",
-    "    \n",
-    "    if results is not None:\n",
-    "        export_to_excel(results, \"DemoAnalysisOutput.xlsx\")\n",
-    "        print(\"Demo run complete.\")\n",
-    "\n",
-    "print(\"demo_run function ready. Call 'demo_run()' to test.\")"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 9,
-   "id": "d7b7c730-225c-4c69-9dbf-d1ec9971a26f",
-   "metadata": {
-    "scrolled": true
-   },
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "43f1b2af803346d3a3d9ad27e1908058",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(Text(value='2003-01', description='In-Sample Start:'), Text(value='2005-12', description='In-Sa…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "cff25b90098d4e8091ff85dd5ac6eec6",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Output()"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# (C) Wire the button and display\n",
-    "apply_button.on_click(on_apply_clicked)\n",
-    "display(ui_inputs, output_area)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Stable-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Stable-checkpoint.ipynb
deleted file mode 100644
index 7314662f7858d0f143b6b30cff70fe187ad1f2cd..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_Stable-checkpoint.ipynb
+++ /dev/null
@@ -1,1514 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 1. SETUP CELL ============\n",
-    "\n",
-    "import logging\n",
-    "import sys\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import os\n",
-    "import math\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import interact, interactive, VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from IPython.utils.capture import capture_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "from io import BytesIO\n",
-    "import datetime\n",
-    "import random\n",
-    "import warnings\n",
-    "\n",
-    "# If you need to install these packages on your environment, uncomment:\n",
-    "!{sys.executable} -m pip install --quiet ipywidgets openpyxl xlsxwriter\n",
-    "\n",
-    "# For exporting to Excel with styling\n",
-    "import xlsxwriter\n",
-    "\n",
-    "# Set up logging to console\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "logging.info(\"Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\")\n",
-    "\n",
-    "# (Optional) If widgets aren't enabled, run:\n",
-    "# !jupyter nbextension enable --py widgetsnbextension --sys-prefix\n",
-    "\n",
-    "print(\"Setup complete.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify which column (after 'Date') is the risk-free rate by smallest stdev among columns.\n",
-    "    \"\"\"\n",
-    "    numeric_cols = df.columns[1:]  # skip the Date column\n",
-    "    stdevs = {}\n",
-    "    for col in numeric_cols:\n",
-    "        vals = df[col].dropna()\n",
-    "        if len(vals) > 0:\n",
-    "            stdevs[col] = vals.std()\n",
-    "        else:\n",
-    "            stdevs[col] = np.inf\n",
-    "\n",
-    "    rf_col = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "    return rf_col\n",
-    "\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 1) Helper to read a local CSV robustly (handles BOMs and minor parsing issues)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Try loading `path` as CSV in three ways:\n",
-    "    1. Default C engine\n",
-    "    2. BOM-stripped with the Python engine\n",
-    "    3. Skip bad lines with the Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception as e1:\n",
-    "        print(\"Default read_csv failed:\", e1)\n",
-    "\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception as e2:\n",
-    "        print(\"utf-8-sig + python engine failed:\", e2)\n",
-    "\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",    # for pandas ≥ 1.3\n",
-    "    )\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 2) Build the widgets\n",
-    "# ------------------------------------------------------------------------------\n",
-    "source_info = widgets.HTML(\n",
-    "    \"<b>Step 1: Choose your CSV</b><br>\"\n",
-    "    \"<i>Remember:</i> If you included any index columns (e.g. S&P 500, MSCI World, SG Trend), they \"\n",
-    "    \"must appear to the right of all fund columns in your sheet.\"\n",
-    ")\n",
-    "\n",
-    "\n",
-    "source_dropdown = widgets.Dropdown(\n",
-    "    options=['Local', 'GitHub'],\n",
-    "    value='Local',\n",
-    "    description='Data Source:',\n",
-    "    style={'description_width': '120px'}\n",
-    ")\n",
-    "\n",
-    "# FileChooser for Local mode\n",
-    "fc = FileChooser(os.getcwd())\n",
-    "fc.title = \"<b>Select local CSV file</b>\"\n",
-    "\n",
-    "# Text box for GitHub raw URL\n",
-    "github_text = widgets.Text(\n",
-    "    value=(\n",
-    "        \"https://raw.githubusercontent.com/stranske/Trend_Model_Project/\"\n",
-    "        \"main/data/TrendData.csv\"\n",
-    "    ),\n",
-    "    description=\"GitHub URL:\",\n",
-    "    layout=widgets.Layout(width=\"80%\"),\n",
-    ")\n",
-    "\n",
-    "# Ask how many index columns are on the far right\n",
-    "n_indices_widget = widgets.BoundedIntText(\n",
-    "    value=0,\n",
-    "    min=0,\n",
-    "    max=10,  # adjust if you expect more than 10 indices\n",
-    "    description='# Index cols:',\n",
-    "    style={'description_width': '120px'},\n",
-    "    tooltip=\"Enter the number of index columns at the far right of your CSV\"\n",
-    ")\n",
-    "\n",
-    "# Load button\n",
-    "load_button = widgets.Button(description=\"Load Data\", button_style=\"success\")\n",
-    "\n",
-    "# Output area for status and debug prints\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 3) Show/hide widgets depending on source selection\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_source_change(change):\n",
-    "    if change[\"new\"] == \"Local\":\n",
-    "        fc.layout.display = \"block\"\n",
-    "        github_text.layout.display = \"none\"\n",
-    "    else:\n",
-    "        fc.layout.display = \"none\"\n",
-    "        github_text.layout.display = \"block\"\n",
-    "\n",
-    "# Initially, GitHub textbox is hidden; FileChooser is visible\n",
-    "github_text.layout.display = \"none\"\n",
-    "fc.layout.display = \"block\"\n",
-    "\n",
-    "source_dropdown.observe(on_source_change, names=\"value\")\n",
-    "\n",
-    "ui_load = widgets.VBox([\n",
-    "    source_info,\n",
-    "    source_dropdown,\n",
-    "    fc,\n",
-    "    github_text,\n",
-    "    n_indices_widget,   # ← new widget here\n",
-    "    load_button,\n",
-    "    output_area\n",
-    "])\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 4) Callback for the Load button (auto-detect date format)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_load_clicked(_):\n",
-    "    global df, fund_cols, indices_list, rf_col            # declare df as global\n",
-    "    with output_area:\n",
-    "        output_area.clear_output()\n",
-    "        src_choice = source_dropdown.value\n",
-    "        n_indices = int(n_indices_widget.value)\n",
-    "\n",
-    "        # 4a) Load the DataFrame\n",
-    "        try:\n",
-    "            if src_choice == 'Local':\n",
-    "                local_path = fc.selected  # FileChooser’s selected path\n",
-    "                if not local_path or not os.path.exists(local_path):\n",
-    "                    print(f\"Error: Local file not found:\\n  {local_path}\")\n",
-    "                    return\n",
-    "                print(f\"Loading from local file:\\n  {local_path}\")\n",
-    "                df = pd.read_csv(local_path)\n",
-    "            else:\n",
-    "                github_url = github_text.value.strip()\n",
-    "                if not github_url:\n",
-    "                    print(\"Error: Please enter a valid GitHub raw URL.\")\n",
-    "                    return\n",
-    "                print(f\"Loading from GitHub URL:\\n  {github_url}\")\n",
-    "                df = pd.read_csv(github_url)\n",
-    "        except Exception as e:\n",
-    "            print(\"Failed to load CSV:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4b) Debug: print columns & a few rows\n",
-    "        print(\"Columns found in DataFrame:\", df.columns.tolist())\n",
-    "        display(df.head(3))\n",
-    "\n",
-    "        # 4c) Identify which column is the date\n",
-    "        date_col = None\n",
-    "        for candidate in [\"Date\", \"DATE\", \"date\"]:\n",
-    "            if candidate in df.columns:\n",
-    "                date_col = candidate\n",
-    "                break\n",
-    "\n",
-    "        if date_col is None:\n",
-    "            print(\"Error: No column named 'Date' / 'DATE' / 'date' found.\")\n",
-    "            print(\"Please check the column names above and adjust code accordingly.\")\n",
-    "            return\n",
-    "\n",
-    "        date_col = 'Date'\n",
-    "\n",
-    "        # 1) Show the first few raw date strings (un‐parsed) so we can inspect them\n",
-    "        raw_samples = df[date_col].dropna().astype(str).head(10).tolist()\n",
-    "        print(f\"Raw {date_col} samples (first 10 non‐null): {raw_samples!r}\")\n",
-    "\n",
-    "        # 2) Strip leading/trailing whitespace from every entry\n",
-    "        df[date_col] = df[date_col].astype(str).str.strip()\n",
-    "\n",
-    "        # 3) Now attempt strict \"%m/%d/%Y\" parsing\n",
-    "        parsed = pd.to_datetime(df[date_col], format=\"%m/%d/%Y\", errors=\"coerce\", infer_datetime_format=True)\n",
-    "        num_valid = parsed.notna().sum()\n",
-    "        print(f\"Number of rows matching '%m/%d/%Y' exactly: {num_valid} / {len(df)}\")\n",
-    "\n",
-    "        if num_valid > 0:\n",
-    "            df[date_col] = parsed\n",
-    "            print(f\"Parsing with '%m/%d/%Y' succeeded for {num_valid} rows.\")\n",
-    "        else:\n",
-    "            print(\n",
-    "                \"Warning: No rows matched '%m/%d/%Y'. \"\n",
-    "                \"Falling back to generic pd.to_datetime(...).\"\n",
-    "            )\n",
-    "            df[date_col] = pd.to_datetime(df[date_col], errors=\"coerce\")\n",
-    "\n",
-    "        # 5) Drop any rows where parsing still failed\n",
-    "        before_drop = len(df)\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        dropped = before_drop - len(df)\n",
-    "        if dropped:\n",
-    "            print(f\"Dropped {dropped} rows where '{date_col}' could not be parsed.\")\n",
-    "        \n",
-    "        # 6) Sort and reset index\n",
-    "        df.sort_values(by=date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "        \n",
-    "        # 7) Show the final parsed dates\n",
-    "        print(f\"After parsing, first 3 {date_col} values:\")\n",
-    "        print(df[[date_col]].head(3))\n",
-    "        print(f\"Loaded {len(df)} rows successfully.\")\n",
-    "\n",
-    "\n",
-    "        # 4d) Identify risk-free column\n",
-    "        try:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            print(f\"Identified risk-free column as: '{rf_col}'\")\n",
-    "        except Exception as e:\n",
-    "            print(\"Error identifying risk-free column:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4f) Determine fund_cols vs indices_list based on n_indices\n",
-    "        all_cols = df.columns.tolist()\n",
-    "        # We assume “Date” and rf_col are present. Everything else is a candidate.\n",
-    "        if 'Date' not in all_cols or rf_col not in all_cols:\n",
-    "            print(\"Error: 'Date' or risk-free column not found in DataFrame columns.\")\n",
-    "            return\n",
-    "        \n",
-    "        # Build list of all columns except 'Date' and rf_col\n",
-    "        remaining = [c for c in all_cols if c not in ['Date', rf_col]]\n",
-    "        \n",
-    "        if n_indices > len(remaining):\n",
-    "            print(\n",
-    "                f\"Error: You asked for {n_indices} index columns, but only \"\n",
-    "                f\"{len(remaining)} columns remain after 'Date' and '{rf_col}'.\"\n",
-    "            )\n",
-    "            return\n",
-    "\n",
-    "        if n_indices > 0:\n",
-    "            indices_list = remaining[-n_indices:]\n",
-    "            fund_cols    = remaining[:-n_indices]\n",
-    "        else:\n",
-    "            indices_list = []\n",
-    "            fund_cols    = remaining[:]\n",
-    "        print(\"\\n>> Debug (post‐load): fund_cols =\", fund_cols)\n",
-    "        print(\">> Debug (post‐load): indices_list =\", indices_list, \"\\n\")\n",
-    "        \n",
-    "        # 2F) Print out what we found\n",
-    "        print(f\"Detected fund columns ({len(fund_cols)}): {fund_cols}\")\n",
-    "        print(f\"Detected index columns ({len(indices_list)}): {indices_list}\")\n",
-    "        print(\n",
-    "            \"Data loaded and classified successfully.\\n\"\n",
-    "            \"Proceed to Step 2 (Run Analysis).\"\n",
-    "        )\n",
-    "\n",
-    " \n",
-    "        # 8) Confirm that df is now in global scope\n",
-    "        print(\">> df defined with\", len(df), \"rows and columns:\", df.columns.tolist())\n",
-    "\n",
-    "# 5) Wire up and display the UI\n",
-    "\n",
-    "load_button.on_click(on_load_clicked)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Utility functions loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Check if a series (sorted chronologically) has >= threshold consecutive NaNs.\n",
-    "    Return True if such a gap exists, False otherwise.\n",
-    "    \"\"\"\n",
-    "    consecutive = 0\n",
-    "    for val in series:\n",
-    "        if pd.isna(val):\n",
-    "            consecutive += 1\n",
-    "        else:\n",
-    "            consecutive = 0\n",
-    "        if consecutive >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "\n",
-    "def annualize_return(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized (geometric) return from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    growth_factor = (1 + valid_rets).prod()\n",
-    "    n_months = len(valid_rets)\n",
-    "    if growth_factor <= 0:\n",
-    "        return -1.0\n",
-    "    ann_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    return ann_ret\n",
-    "\n",
-    "def annualize_volatility(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized stdev of monthly returns, i.e. stdev * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) < 2:\n",
-    "        return np.nan\n",
-    "    return valid_rets.std() * np.sqrt(12)\n",
-    "\n",
-    "def sharpe_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe ratio = (annual_excess_return) / (annual_excess_vol).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    ann_excess_vol = excess.std() * np.sqrt(12)\n",
-    "    if ann_excess_vol == 0:\n",
-    "        return np.nan\n",
-    "    return ann_excess_ret / ann_excess_vol\n",
-    "\n",
-    "def sortino_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino ratio = (annual_excess_return) / (annual_downside_stdev).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "\n",
-    "    negative_mask = excess < 0\n",
-    "    negative_returns = excess[negative_mask]\n",
-    "    if len(negative_returns) == 0:\n",
-    "        return np.inf  # no negative => infinite sortino\n",
-    "    downside_stdev = negative_returns.std() * np.sqrt(12)\n",
-    "    return ann_excess_ret / downside_stdev\n",
-    "\n",
-    "def max_drawdown(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Compute max drawdown from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    wealth_index = (1 + valid_rets).cumprod()\n",
-    "    rolling_max = wealth_index.cummax()\n",
-    "    dd_series = 1 - (wealth_index / rolling_max)\n",
-    "    return dd_series.max()\n",
-    "\n",
-    "def calc_portfolio_returns(weights, df_returns):\n",
-    "    \"\"\"\n",
-    "    Compute monthly portfolio returns (Series) as weighted sum of columns in df_returns.\n",
-    "    \"\"\"\n",
-    "    return (df_returns * weights).sum(axis=1)\n",
-    "\n",
-    "print(\"Utility functions loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "#### 4. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "c5867ccd-a550-4849-a10b-a085f5fe26fd",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "select_funds (replaced) is ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# --- PATCH: clean select_funds() -------------------------------------------\n",
-    "def select_funds(\n",
-    "    df,                 # full DataFrame incl. 'Date'\n",
-    "    rf_col,             # risk-free column name\n",
-    "    fund_columns,       # candidate fund list\n",
-    "    in_sdate, in_edate, # in-sample bounds  (pd.Timestamp)\n",
-    "    out_sdate, out_edate,# out-sample bounds (pd.Timestamp)\n",
-    "    selection_mode=\"all\",\n",
-    "    random_n=8,\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    Return a vetted list of fund tickers.\n",
-    "\n",
-    "    • Excludes names containing 'index'\n",
-    "    • Requires *no* NaN values inside either window\n",
-    "    • Requires < 3 consecutive NaNs inside either window\n",
-    "    • Supports selection_mode ∈ {\"all\", \"random\", \"manual\"}\n",
-    "    \"\"\"\n",
-    "    # --- 1) start from caller-supplied list  -------------------------------\n",
-    "    candidates = fund_columns.copy()\n",
-    "\n",
-    "    # --- 2) drop obvious indices ------------------------------------------\n",
-    "    not_index = [f for f in candidates if \"index\" not in f.lower()]\n",
-    "\n",
-    "    # --- 3) full-history test (no NaN in either window) --------------------\n",
-    "    full_hist = []\n",
-    "    for f in not_index:\n",
-    "        ins  = df.loc[(df[\"Date\"] >= in_sdate)  & (df[\"Date\"] <= in_edate),  f]\n",
-    "        outs = df.loc[(df[\"Date\"] >= out_sdate) & (df[\"Date\"] <= out_edate), f]\n",
-    "        if ins.notna().all() and outs.notna().all():\n",
-    "            full_hist.append(f)\n",
-    "\n",
-    "    # --- 4) max-run-length test (< 3 consecutive NaNs) ---------------------\n",
-    "    vetted = []\n",
-    "    for f in full_hist:\n",
-    "        # helper that returns longest NaN run length\n",
-    "        def _max_run(s):\n",
-    "            isn = s.isna().astype(int)\n",
-    "            return isn.groupby((isn == 0).cumsum()).sum().max()\n",
-    "        if _max_run(df.loc[(df[\"Date\"] >= in_sdate)  & (df[\"Date\"] <= in_edate),  f]) < 3 and \\\n",
-    "           _max_run(df.loc[(df[\"Date\"] >= out_sdate) & (df[\"Date\"] <= out_edate), f]) < 3:\n",
-    "            vetted.append(f)\n",
-    "\n",
-    "    # --- 5) final selection -----------------------------------------------\n",
-    "    if selection_mode == \"random\":\n",
-    "        k = min(random_n, len(vetted))\n",
-    "        vetted = random.sample(vetted, k)\n",
-    "    # selection_mode == \"manual\" just hands back the vetted list;\n",
-    "    # run_analysis (or the UI) decides what to do with it later.\n",
-    "\n",
-    "    logging.info(f\"select_funds → {len(vetted)} funds after all filters\")\n",
-    "    return vetted\n",
-    "# --------------------------------------------------------------------------\n",
-    "\n",
-    "print(\"select_funds (replaced) is ready.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 5. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "get_custom_weights function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    Returns dict {fund: weight_decimal}.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=f\"{fund}\",\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    \n",
-    "    confirm_button = widgets.Button(\n",
-    "        description='Confirm Weights',\n",
-    "        button_style='success'\n",
-    "    )\n",
-    "    error_label = widgets.Label(value='', layout=widgets.Layout(color='red'))\n",
-    "    \n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm_button, error_label])\n",
-    "    display(box)\n",
-    "    \n",
-    "    weights_container = {}\n",
-    "    \n",
-    "    def on_confirm_clicked(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_label.value = f\"Error: Weights sum to {total}, must be 100.\"\n",
-    "            weights_container.clear()\n",
-    "        else:\n",
-    "            for fund, wdg in weight_widgets.items():\n",
-    "                weights_container[fund] = wdg.value / 100.0\n",
-    "            error_label.value = \"Weights confirmed!\"\n",
-    "    \n",
-    "    confirm_button.on_click(on_confirm_clicked)\n",
-    "    return weights_container\n",
-    "\n",
-    "print(\"get_custom_weights function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 6. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "run_analysis (with checkpoints) is defined.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def run_analysis(\n",
-    "    df,\n",
-    "    in_start, in_end, out_start, out_end,\n",
-    "    target_vol, monthly_cost,\n",
-    "    selection_mode='all',\n",
-    "    random_n=8,\n",
-    "    custom_weights=None    # ← new argument\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Parse/validate date inputs\n",
-    "    2) Convert Date column if needed\n",
-    "    3) Identify rf_col\n",
-    "    4) Prepare in/out sample DataFrames\n",
-    "    5) CALL select_funds (with debug) and print checkpoints\n",
-    "    6) Compute scale_factors and wrap stats in try/except\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # —(1) Parse input dates (YYYY-MM) into actual month-end timestamps\n",
-    "    in_sdate  = pd.to_datetime(in_start + \"-01\", errors='coerce')\n",
-    "    in_edate  = pd.to_datetime(in_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "    out_sdate = pd.to_datetime(out_start + \"-01\", errors='coerce')\n",
-    "    out_edate = pd.to_datetime(out_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    # checkpoint A\n",
-    "    print(\"CHECKPOINT A: Dates parsed:\", in_sdate, in_edate, out_sdate, out_edate)\n",
-    "\n",
-    "    # —(2) Ensure 'Date' column is datetime64\n",
-    "    if not np.issubdtype(df['Date'].dtype, np.datetime64):\n",
-    "        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "        df.dropna(subset=['Date'], inplace=True)\n",
-    "        df.sort_values(by='Date', inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "    # checkpoint B\n",
-    "    print(\"CHECKPOINT B: Date column is datetime64, first dates:\",\n",
-    "          df['Date'].iloc[0], \"…\", df['Date'].iloc[-1])\n",
-    "\n",
-    "    # —(3) Identify risk-free column\n",
-    "    rf_col = identify_risk_free_fund(df)\n",
-    "    print(f\"INFO: Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "\n",
-    "    # —(4) Slice into in-sample & out-sample\n",
-    "    in_sample_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_sample_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "    in_sample_rf  = in_sample_df[rf_col]\n",
-    "    out_sample_rf = out_sample_df[rf_col]\n",
-    "\n",
-    "    print(f\"CHECKPOINT C: in_sample rows = {len(in_sample_df)}, out_sample rows = {len(out_sample_df)}\")\n",
-    "\n",
-    "    all_cols = [c for c in df.columns if c not in [\"Date\", rf_col]]\n",
-    "    if \"indices_list\" in globals():                 # optional, harmless if absent\n",
-    "        all_cols = [c for c in all_cols if c not in indices_list]\n",
-    "        \n",
-    "    # —(5) Select funds (either “manual” or via select_funds)\n",
-    "    if selection_mode == 'manual' and custom_weights is not None:\n",
-    "        # In manual mode, we trust the user’s chosen tickers outright\n",
-    "        selected_funds = list(custom_weights.keys())\n",
-    "        print(f\"CHECKPOINT D (manual): using custom_weights keys → {selected_funds}\")\n",
-    "    else:\n",
-    "        print(f\"CHECKPOINT D: about to call select_funds with {len(all_cols)} candidates\")\n",
-    "\n",
-    "        selected_funds = select_funds(\n",
-    "            df,\n",
-    "            rf_col,\n",
-    "            fund_columns=all_cols,\n",
-    "            in_sdate=in_sdate,\n",
-    "            in_edate=in_edate,\n",
-    "            out_sdate=out_sdate,\n",
-    "            out_edate=out_edate,\n",
-    "            selection_mode=selection_mode,\n",
-    "            random_n=random_n\n",
-    "        )\n",
-    "\n",
-    "    if len(selected_funds) == 0:\n",
-    "        logging.warning(\"No valid funds remain after filtering.\")\n",
-    "        print(\"Warning: No valid funds. Try adjusting your selection or data filters.\")\n",
-    "        return None\n",
-    "\n",
-    "    print(f\"CHECKPOINT E: select_funds returned {len(selected_funds)} funds → {selected_funds}\")\n",
-    "\n",
-    "    # indices_list must already exist as a global list of index columns\n",
-    "    in_sample_indices  = in_sample_df[indices_list].copy()\n",
-    "    out_sample_indices = out_sample_df[indices_list].copy()\n",
-    "\n",
-    "    # —(6) Compute scale_factors (based on in-sample volatility)\n",
-    "    scale_factors = {}\n",
-    "    for fund in selected_funds:\n",
-    "        fund_in_rets = in_sample_df[fund].dropna()\n",
-    "        current_vol  = annualize_volatility(fund_in_rets)\n",
-    "        if pd.isna(current_vol) or current_vol == 0:\n",
-    "            scale_factors[fund] = 1.0\n",
-    "        else:\n",
-    "            scale_factors[fund] = target_vol / current_vol\n",
-    "\n",
-    "    print(\"CHECKPOINT F: scale_factors computed (showing first 5):\",\n",
-    "          {f: scale_factors[f] for f in selected_funds[:5]})\n",
-    "\n",
-    "    # Pre-allocate DataFrames for scaled returns\n",
-    "    in_sample_scaled  = pd.DataFrame(index=in_sample_df.index, columns=selected_funds)\n",
-    "    out_sample_scaled = pd.DataFrame(index=out_sample_df.index, columns=selected_funds)\n",
-    "\n",
-    "    # ── Wrap everything from “scaling + stats” in a try/except ──\n",
-    "    index_stats = {}\n",
-    "    try:\n",
-    "        # (6a) Scale returns (with monthly cost)\n",
-    "        for fund in selected_funds:\n",
-    "            sf     = scale_factors[fund]\n",
-    "            adj_in = in_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_in[adj_in < -1.0] = -1.0\n",
-    "            in_sample_scaled[fund] = adj_in\n",
-    "\n",
-    "            if not out_sample_df.empty:\n",
-    "                adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "                adj_out[adj_out < -1.0] = -1.0\n",
-    "                out_sample_scaled[fund] = adj_out\n",
-    "\n",
-    "        # (6b) Helper to compute per-series stats\n",
-    "        def compute_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            sr  = sharpe_ratio(series, rf_series)\n",
-    "            so  = sortino_ratio(series, rf_series)\n",
-    "            mdd = max_drawdown(series)\n",
-    "            return (r, v, sr, so, mdd)\n",
-    "\n",
-    "        # (6c) In-sample per-fund stats\n",
-    "        in_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "\n",
-    "        # (6d) Out-sample per-fund (vol-adjusted) stats\n",
-    "        out_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6e) Out-sample per-fund (raw) stats\n",
-    "        out_sample_stats_raw = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "\n",
-    "        # (6f) Equal-weight portfolio returns\n",
-    "        ew_weight_dict = { f: 1.0/len(selected_funds) for f in selected_funds }\n",
-    "        ew_w           = np.array([ ew_weight_dict[f] for f in selected_funds ])\n",
-    "        in_ew_port      = calc_portfolio_returns(ew_w,       in_sample_scaled[selected_funds])\n",
-    "        out_ew_port     = calc_portfolio_returns(ew_w,       out_sample_scaled[selected_funds])\n",
-    "        out_ew_port_raw = calc_portfolio_returns(ew_w,       out_sample_df[selected_funds])\n",
-    "        \n",
-    "        in_ew_stats      = compute_stats(in_ew_port,      in_sample_rf)\n",
-    "        out_ew_stats     = compute_stats(out_ew_port,     out_sample_rf)\n",
-    "        out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6g) Index statistics (treat each index like “just another series”)\n",
-    "        in_index_stats  = {}\n",
-    "        out_index_stats = {}\n",
-    "        for idx in indices_list:\n",
-    "            in_index_stats[idx]  = compute_stats(in_sample_indices[idx],  in_sample_df[rf_col])\n",
-    "            out_index_stats[idx] = compute_stats(out_sample_indices[idx], out_sample_df[rf_col])\n",
-    "\n",
-    "        # (6h) “User-weight” portfolio\n",
-    "        if custom_weights is None:\n",
-    "            # If no manual weights → just reuse the same equal‐weight array\n",
-    "            user_weight_dict = ew_weight_dict.copy()\n",
-    "            # ← **IMPORTANT FIX**: define custom_w here for the equal-weight case\n",
-    "            custom_w = ew_w.copy()  \n",
-    "        else:\n",
-    "            # Manual weights passed → convert percentages to decimals\n",
-    "            user_weight_dict = { f: custom_weights[f] / 100.0 for f in selected_funds }\n",
-    "            custom_w         = np.array([ user_weight_dict[f] for f in selected_funds ])\n",
-    "\n",
-    "        # (6i) Compute “user-weighted” portfolio returns\n",
-    "        in_user_port      = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "        out_user_port     = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "        out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        # (6j) Compute their stats\n",
-    "        in_user_stats      = compute_stats(in_user_port,      in_sample_rf)\n",
-    "        out_user_stats     = compute_stats(out_user_port,     out_sample_rf)\n",
-    "        out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # (6k) Index statistics (both in- and out-sample)\n",
-    "                # ── (6g)  INDEX STATISTICS  ────────────────────────────────────\n",
-    "        # Helper: same metrics you use for funds\n",
-    "        def basic_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            s   = sharpe_ratio(series, rf_series)\n",
-    "            return (r, v, s)\n",
-    "\n",
-    "        if indices_list:\n",
-    "            def basic_stats(series, rf):\n",
-    "                r = annualize_return(series)\n",
-    "                v = annualize_volatility(series)\n",
-    "                s = sharpe_ratio(series, rf)\n",
-    "                so = sortino_ratio(series, rf)\n",
-    "                mdd = max_drawdown(series)\n",
-    "                return (r, v, s, so, mdd)\n",
-    "\n",
-    "            for idx in indices_list:\n",
-    "                s_in  = in_sample_df[idx].dropna()\n",
-    "                s_out = out_sample_df[idx].dropna()\n",
-    "\n",
-    "                index_stats[idx] = {\n",
-    "                    \"in_sample\":  basic_stats(s_in,  in_sample_rf)  if not s_in.empty  else (np.nan,)*5,\n",
-    "                    \"out_sample\": basic_stats(s_out, out_sample_rf) if not s_out.empty else (np.nan,)*5\n",
-    "                }\n",
-    "\n",
-    "        # ── (6h)  BUILD FINAL RESULTS DICT  ────────────────────────────\n",
-    "        results = {\n",
-    "            \"selected_funds\":        selected_funds,\n",
-    "            \"in_sample_scaled\":      in_sample_scaled,\n",
-    "            \"out_sample_scaled\":     out_sample_scaled,\n",
-    "            \"in_sample_stats\":       in_sample_stats,\n",
-    "            \"out_sample_stats\":      out_sample_stats,\n",
-    "            \"out_sample_stats_raw\":  out_sample_stats_raw,\n",
-    "            \"in_ew_stats\":           in_ew_stats,\n",
-    "            \"out_ew_stats\":          out_ew_stats,\n",
-    "            \"out_ew_stats_raw\":      out_ew_stats_raw,\n",
-    "            \"in_user_stats\":         in_user_stats,\n",
-    "            \"out_user_stats\":        out_user_stats,\n",
-    "            \"out_user_stats_raw\":    out_user_stats_raw,\n",
-    "            \"ew_weights\":            ew_weight_dict,\n",
-    "            \"fund_weights\":          user_weight_dict,\n",
-    "            \"indices_list\":          indices_list,\n",
-    "            \"index_stats\":           index_stats          # ← new key\n",
-    "        }\n",
-    "\n",
-    "    except Exception as e:\n",
-    "        print(\"ERROR inside stats-block:\", e)\n",
-    "        return None\n",
-    "\n",
-    "    # Everything succeeded\n",
-    "    return results\n",
-    "\n",
-    "\n",
-    "\n",
-    "print(\"run_analysis (with checkpoints) is defined.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 7. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 10,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─── Helper #1: build the equal- and user-weight DataFrames ────────────────────────────────\n",
-    "def make_portfolio_dfs(results, sample='in'):\n",
-    "    \"\"\"\n",
-    "    Returns (eq_df, user_df) for either 'in' or 'out' sample.\n",
-    "    \"\"\"\n",
-    "    # pick the right stats:\n",
-    "    stats_dict      = results[f'{sample}_sample_stats']\n",
-    "    ew_stats        = results[f'{sample}_ew_stats']\n",
-    "    user_stats      = results[f'{sample}_user_stats']\n",
-    "    fund_weights    = results['fund_weights']\n",
-    "    funds           = results['selected_funds']\n",
-    "\n",
-    "    def build_block(portf_label, stats, include_weights):\n",
-    "        rows = []\n",
-    "        # portfolio row\n",
-    "        r, v, sr, so, mdd = stats\n",
-    "        rows.append({\n",
-    "            'Fund': portf_label,\n",
-    "            'Weight': 100,\n",
-    "            'Return (%)': r,\n",
-    "            'Volatility (%)': v,\n",
-    "            'Sharpe Ratio': sr,\n",
-    "            'Sortino Ratio': so,\n",
-    "            'Max Drawdown (%)': mdd\n",
-    "        })\n",
-    "        # one‐row per fund\n",
-    "        for f in funds:\n",
-    "            r, v, sr, so, mdd = stats_dict[f]\n",
-    "            w = int(round(fund_weights[f] * 100)) if include_weights else None\n",
-    "            rows.append({\n",
-    "                'Fund': f,\n",
-    "                'Weight': w,\n",
-    "                'Return (%)': r,\n",
-    "                'Volatility (%)': v,\n",
-    "                'Sharpe Ratio': sr,\n",
-    "                'Sortino Ratio': so,\n",
-    "                'Max Drawdown (%)': mdd\n",
-    "            })\n",
-    "        return pd.DataFrame(rows)\n",
-    "\n",
-    "    eq_df   = build_block('Equal-Weight Portfolio', ew_stats,   True)\n",
-    "    user_df = build_block('User-Weight Portfolio', user_stats, True)\n",
-    "    return eq_df, user_df\n",
-    "\n",
-    "\n",
-    "# ─── Helper #2: build an indices table ─────────────────────────────────────────────────────\n",
-    "def make_indices_df(df, indices, start, end):\n",
-    "    \"\"\"\n",
-    "    Compute (Return, Vol, Sharpe, Sortino, MDD) for each index in [start, end],\n",
-    "    return a DataFrame with columns Index, Return (%), Volatility (%), …\n",
-    "    \"\"\"\n",
-    "    in_s, in_e = pd.to_datetime(start+'-01'), pd.to_datetime(end+'-01') + pd.offsets.MonthEnd(0)\n",
-    "    rows = []\n",
-    "    rf = identify_risk_free_fund(df)\n",
-    "    sub = df.set_index('Date').loc[in_s:in_e]\n",
-    "    for idx in indices:\n",
-    "        series = sub[idx]\n",
-    "        rf_ser = sub[rf]\n",
-    "        r  = annualize_return(series)\n",
-    "        v  = annualize_volatility(series)\n",
-    "        sr = sharpe_ratio(series, rf_ser)\n",
-    "        so = sortino_ratio(series, rf_ser)\n",
-    "        mdd = max_drawdown(series)\n",
-    "        rows.append({\n",
-    "            'Index': idx,\n",
-    "            'Return (%)': r,\n",
-    "            'Volatility (%)': v,\n",
-    "            'Sharpe Ratio': sr,\n",
-    "            'Sortino Ratio': so,\n",
-    "            'Max Drawdown (%)': mdd\n",
-    "        })\n",
-    "    return pd.DataFrame(rows)\n",
-    "\n",
-    "\n",
-    "# ─── Helper #3: write & format one sheet ──────────────────────────────────────────────────\n",
-    "# Apply uniform column widths & formats\n",
-    "    #   (col_idx, width, format_obj)\n",
-    "COLUMN_SPECS = [\n",
-    "    (0, 28, None),\n",
-    "    (1, 12, 'int'),\n",
-    "    (2, 15, 'pct1'),\n",
-    "    (3, 15, 'pct1'),\n",
-    "    (4, 15, 'dec2'),\n",
-    "    (5, 15, 'dec2'),\n",
-    "    (6, 15, 'pct1'),\n",
-    "]\n",
-    "\n",
-    "def build_formats(wb):\n",
-    "    return {\n",
-    "      'int':   wb.add_format({'num_format':'0'}),\n",
-    "      'pct1':  wb.add_format({'num_format':'0.0%'}),\n",
-    "      'dec2':  wb.add_format({'num_format':'0.00'}),\n",
-    "      'bold':  wb.add_format({'bold':True}),\n",
-    "    }\n",
-    "    \n",
-    "def write_portfolio_sheet(writer, sheet_name, eq_df, user_df, fmt):\n",
-    "    # Create & register the sheet\n",
-    "    ws = writer.book.add_worksheet(sheet_name)\n",
-    "    writer.sheets[sheet_name] = ws\n",
-    "\n",
-    "    # 1) Write the two tables with keyword-only args\n",
-    "    eq_df.to_excel(excel_writer=writer,\n",
-    "                   sheet_name=sheet_name,\n",
-    "                   startrow=0,\n",
-    "                   index=False)\n",
-    "    user_df.to_excel(excel_writer=writer,\n",
-    "                     sheet_name=sheet_name,\n",
-    "                     startrow=len(eq_df) + 3,\n",
-    "                     index=False)\n",
-    "\n",
-    "    for col_idx, width, fmt_key in COLUMN_SPECS:\n",
-    "        # if fmt_key is None, use no format; otherwise pull from fmt\n",
-    "        fmt_obj = fmt[fmt_key] if fmt_key else None\n",
-    "        ws.set_column(col_idx, col_idx, width, fmt_obj)\n",
-    "\n",
-    "    # Bold the headers\n",
-    "    bold = fmt['bold']\n",
-    "    for j, h in enumerate(eq_df.columns):\n",
-    "        ws.write(0, j, h, fmt['bold'])\n",
-    "    start = len(eq_df) + 3\n",
-    "    for j, h in enumerate(user_df.columns):\n",
-    "        ws.write(start, j, h, fmt['bold'])\n",
-    "\n",
-    "\n",
-    "def write_indices_block(writer, sheet_name, df_idx, start_row, fmt):\n",
-    "    \"\"\"\n",
-    "    Write the indices block to the given sheet at start_row\n",
-    "    \"\"\"\n",
-    "    # Grab the worksheet from the writer\n",
-    "    ws = writer.sheets[sheet_name]\n",
-    "    bold_fmt = fmt['bold']\n",
-    "\n",
-    "    # Label\n",
-    "    ws.write(start_row - 1, 0, f\"Indices ({sheet_name}):\", bold_fmt)\n",
-    "\n",
-    "    # Dump the DataFrame\n",
-    "    df_idx.to_excel(\n",
-    "        excel_writer=writer,\n",
-    "        sheet_name=sheet_name,\n",
-    "        startrow=start_row,\n",
-    "        index=False\n",
-    "    )\n",
-    "\n",
-    "    # Apply the same COLUMN_SPECS formats as the portfolio tables\n",
-    "    for col_idx, width, fmt_key in COLUMN_SPECS:\n",
-    "        fmt_obj = fmt.get(fmt_key) if fmt_key else None\n",
-    "        ws.set_column(col_idx, col_idx, width, fmt_obj)\n",
-    "\n",
-    "    # Bold the header row of the indices table\n",
-    "    ws.set_row(start_row, None, bold_fmt)\n",
-    "\n",
-    "import xlsxwriter, numpy as np, pandas as pd\n",
-    "from io import BytesIO\n",
-    "from datetime import datetime\n",
-    "\n",
-    "import xlsxwriter, numpy as np, pandas as pd\n",
-    "from io import BytesIO\n",
-    "\n",
-    "import xlsxwriter, numpy as np, pandas as pd\n",
-    "from io import BytesIO\n",
-    "\n",
-    "import xlsxwriter, numpy as np, pandas as pd\n",
-    "from io import BytesIO\n",
-    "import logging\n",
-    "\n",
-    "import xlsxwriter, numpy as np, pandas as pd\n",
-    "from io import BytesIO\n",
-    "import logging\n",
-    "\n",
-    "import xlsxwriter, numpy as np, pandas as pd\n",
-    "from io import BytesIO\n",
-    "import logging\n",
-    "\n",
-    "def export_to_excel(results, full_df, fname,\n",
-    "                    in_start, in_end, out_start, out_end):\n",
-    "    \"\"\"\n",
-    "    Creates an Excel workbook with:\n",
-    "      • Portfolio rows first (Equal-Weight & User-Weight)\n",
-    "      • Fund rows incl. Weight %\n",
-    "      • Index rows (blank weight)\n",
-    "      • R, V, Sharpe, Sortino, MDD for IN & OUT\n",
-    "      • Raw Data tab (safe for NaN/∞)\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # ── 1) workbook / worksheet\n",
-    "    buf = BytesIO()\n",
-    "    wb  = xlsxwriter.Workbook(buf, {'in_memory': True})\n",
-    "    ws  = wb.add_worksheet(\"Summary\")\n",
-    "\n",
-    "    # formats\n",
-    "    bold     = wb.add_format({'bold': True})\n",
-    "    pct2     = wb.add_format({'num_format': '0.00%'})   # 2-dec %\n",
-    "    pct0     = wb.add_format({'num_format': '0%'})      # whole-number %\n",
-    "    num2     = wb.add_format({'num_format': '0.00'})\n",
-    "    redpct   = wb.add_format({'num_format': '0.00%', 'font_color': 'red'})\n",
-    "\n",
-    "    # ── 2) header\n",
-    "    ws.write(0, 0, \"Vol-Adj Trend Analysis\", bold)\n",
-    "    ws.write(1, 0, f\"In-Sample:  {in_start} → {in_end}\")\n",
-    "    ws.write(2, 0, f\"Out-Sample: {out_start} → {out_end}\")\n",
-    "\n",
-    "    row = 4\n",
-    "    ws.write(row, 0, \"Portfolio returns\", bold); row += 1\n",
-    "\n",
-    "    labels = [\"Name\", \"Weight %\",\n",
-    "              \"R (IN)\", \"V (IN)\", \"Sharpe (IN)\", \"Sortino (IN)\", \"MDD (IN)\",\n",
-    "              \"R (OUT)\", \"V (OUT)\", \"Sharpe (OUT)\", \"Sortino (OUT)\", \"MDD (OUT)\"]\n",
-    "    ws.write_row(row, 0, labels, bold); row += 1\n",
-    "\n",
-    "    # helper to write one stats row\n",
-    "    def write_stats(r, name, weight_dec_or_blank, tup_in, tup_out, bold_name=False):\n",
-    "        # Weight cell\n",
-    "        if weight_dec_or_blank == \"\":\n",
-    "            ws.write(r, 1, \"\")                    # index rows → blank\n",
-    "        else:\n",
-    "            wt_pct = weight_dec_or_blank if weight_dec_or_blank <= 1 else weight_dec_or_blank\n",
-    "            ws.write(r, 1, wt_pct, pct0)          # integer %\n",
-    "\n",
-    "        # Name\n",
-    "        ws.write(r, 0, name, bold if bold_name else None)\n",
-    "\n",
-    "        rin, vin, sin, soin, mddin   = tup_in\n",
-    "        rout, vout, sout, soout, mddout = tup_out\n",
-    "        data = [rin, vin, sin, soin, mddin,\n",
-    "                rout, vout, sout, soout, mddout]\n",
-    "        fmts = [pct2, pct2, num2, num2, redpct,\n",
-    "                pct2, pct2, num2, num2, redpct]\n",
-    "        for c, (v, f) in enumerate(zip(data, fmts), start=2):\n",
-    "            ws.write(r, c, v, f)\n",
-    "\n",
-    "    # convenience dicts\n",
-    "    ew_w = results.get(\"ew_weights\", {})   # already decimals (sum=1)\n",
-    "    uw_w = results.get(\"fund_weights\", {}) or ew_w  # manual or equal\n",
-    "\n",
-    "    # ── 3) portfolio rows (Weight column = 100 %)\n",
-    "    write_stats(row, \"Equal-Weight\", 1.0,\n",
-    "                results[\"in_ew_stats\"], results[\"out_ew_stats\"], True); row += 1\n",
-    "    write_stats(row, \"User-Weight\", 1.0,\n",
-    "                results[\"in_user_stats\"], results[\"out_user_stats\"], True); row += 2\n",
-    "\n",
-    "    # ── 4) fund rows\n",
-    "    ws.write(row, 0, \"Funds\", bold); row += 1\n",
-    "    for tkr in results[\"selected_funds\"]:\n",
-    "        write_stats(row, tkr, uw_w.get(tkr, 0),\n",
-    "                    results[\"in_sample_stats\"][tkr],\n",
-    "                    results[\"out_sample_stats\"][tkr])\n",
-    "        row += 1\n",
-    "\n",
-    "    # ── 5) index rows (blank weight)\n",
-    "    if results.get(\"index_stats\"):\n",
-    "        ws.write(row, 0, \"INDEX\", bold); row += 1\n",
-    "        for idx, sd in results[\"index_stats\"].items():\n",
-    "            write_stats(row, idx, \"\", sd[\"in_sample\"], sd[\"out_sample\"], True)\n",
-    "            row += 1\n",
-    "\n",
-    "    # ── 6) Raw Data tab (safe write)\n",
-    "    ws2 = wb.add_worksheet(\"Raw Data\")\n",
-    "    ws2.write_row(0, 0, full_df.columns.tolist(), bold)\n",
-    "    for r, (_, series) in enumerate(full_df.iterrows(), start=1):\n",
-    "        safe = []\n",
-    "        for v in series:\n",
-    "            if isinstance(v, pd.Timestamp):\n",
-    "                safe.append(v.strftime(\"%Y-%m-%d\"))\n",
-    "            elif isinstance(v, (float, int)) and (pd.isna(v) or not np.isfinite(v)):\n",
-    "                safe.append(\"\")\n",
-    "            else:\n",
-    "                safe.append(v)\n",
-    "        ws2.write_row(r, 0, safe)\n",
-    "\n",
-    "    # ── 7) save\n",
-    "    wb.close()\n",
-    "    with open(fname, \"wb\") as f:\n",
-    "        f.write(buf.getvalue())\n",
-    "\n",
-    "    logging.info(f\"Exported analysis to {fname}\")\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Run Parameters,Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 11,
-   "id": "71bbc2f7-0ce0-4f0b-bde3-5459ba587c54",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "45ac47c4201a488091ede7a71ffdfced",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HBox(children=(ToggleButtons(description='Source:', options=('Local', 'GitHub'), value='Local')…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "### ===============================================================\n",
-    "#                RUN ANALYSIS – COMPLETE UI (stable)\n",
-    "# ===============================================================\n",
-    "\n",
-    "import pandas as pd, numpy as np, ipywidgets as widgets\n",
-    "from IPython.display import display, clear_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "\n",
-    "# ── 1. DATA SOURCE ─────────────────────────────────────────────\n",
-    "source_toggle = widgets.ToggleButtons(options=['Local', 'GitHub'],\n",
-    "                                      description='Source:')\n",
-    "file_chooser  = FileChooser(title='Pick CSV')\n",
-    "url_box       = widgets.Text(description='Raw CSV URL:',\n",
-    "                             layout={'width': '70%'})\n",
-    "load_btn      = widgets.Button(description='Load CSV', button_style='success')\n",
-    "load_out      = widgets.Output()\n",
-    "\n",
-    "def _on_src(ch):\n",
-    "    file_chooser.layout.display = 'block' if ch['new'] == 'Local' else 'none'\n",
-    "    url_box.layout.display      = 'block' if ch['new'] == 'GitHub' else 'none'\n",
-    "source_toggle.observe(_on_src, names='value'); _on_src({'new': source_toggle.value})\n",
-    "\n",
-    "# ── 2. BASIC PARAMETERS ────────────────────────────────────────\n",
-    "index_cnt    = widgets.BoundedIntText(0, min=0, max=10, step=1,\n",
-    "                                      description='# Index cols (right-most):')\n",
-    "in_start     = widgets.Text('2005-07', description='In Start:')\n",
-    "in_end       = widgets.Text('2008-06', description='In End:')\n",
-    "out_start    = widgets.Text('2008-07', description='Out Start:')\n",
-    "out_end      = widgets.Text('2009-06', description='Out End:')\n",
-    "target_vol   = widgets.FloatText(0.25,  description='Target Vol:')\n",
-    "monthly_cost = widgets.FloatText(0.0033, description='Monthly Cost:')\n",
-    "\n",
-    "# ── 3. MODE & PLACEHOLDERS ─────────────────────────────────────\n",
-    "mode_dd = widgets.Dropdown(options=[('All funds', 'all'),\n",
-    "                                    ('Random sample', 'random'),\n",
-    "                                    ('Manual pick',  'manual')],\n",
-    "                           value='all', description='Mode:')\n",
-    "rand_n   = widgets.IntText(5, description='Sample N:')\n",
-    "fund_table = widgets.VBox([])\n",
-    "total_lbl  = widgets.Label('Total weight: 0 %')\n",
-    "\n",
-    "def _vis_mode(_=None):\n",
-    "    m = mode_dd.value\n",
-    "    rand_n.layout.display     = 'block' if m == 'random' else 'none'\n",
-    "    fund_table.layout.display = 'block' if m == 'manual' else 'none'\n",
-    "    total_lbl.layout.display  = 'block' if m == 'manual' else 'none'\n",
-    "mode_dd.observe(_vis_mode, names='value'); _vis_mode()\n",
-    "\n",
-    "# ── 4. RUN & OUTPUT ────────────────────────────────────────────\n",
-    "run_btn = widgets.Button(description='Run Analysis', button_style='success')\n",
-    "out_box = widgets.Output(layout={'border': '1px solid #999',\n",
-    "                                 'height': '320px', 'overflow_y': 'auto'})\n",
-    "\n",
-    "# ── 5. GLOBAL STATE ────────────────────────────────────────────\n",
-    "df = None\n",
-    "indices_list = []\n",
-    "table_built = False\n",
-    "\n",
-    "# ── 6. LOAD CSV HANDLER ────────────────────────────────────────\n",
-    "def _load(_):\n",
-    "    global df, table_built\n",
-    "    table_built = False\n",
-    "    with load_out:\n",
-    "        clear_output()\n",
-    "        try:\n",
-    "            if source_toggle.value == 'Local':\n",
-    "                if not file_chooser.selected:\n",
-    "                    print('⚠️ Pick a file first.'); return\n",
-    "                df = pd.read_csv(file_chooser.selected)\n",
-    "            else:\n",
-    "                raw = url_box.value.strip()\n",
-    "                if not raw.lower().endswith('.csv'):\n",
-    "                    print('⚠️ URL must end with .csv'); return\n",
-    "                df = pd.read_csv(raw)\n",
-    "        except Exception as e:\n",
-    "            print('❌ Load error:', e); df = None; return\n",
-    "        if 'Date' not in df.columns:\n",
-    "            print('❌ No “Date” column'); df = None; return\n",
-    "        print(f'✅ {len(df):,} rows × {df.shape[1]} cols'); display(df.head())\n",
-    "        index_cnt.max = max(0, len(df.columns) - 1)\n",
-    "load_btn.on_click(_load)\n",
-    "\n",
-    "# ── 7. RUN ANALYSIS HANDLER ────────────────────────────────────\n",
-    "def _run(_):\n",
-    "    global indices_list, table_built\n",
-    "    with out_box:\n",
-    "        clear_output()\n",
-    "\n",
-    "        # basic sanity\n",
-    "        if df is None:\n",
-    "            print('⚠️ Load data first'); return\n",
-    "        try:\n",
-    "            for s in (in_start.value, in_end.value, out_start.value, out_end.value):\n",
-    "                pd.to_datetime(s, format='%Y-%m')\n",
-    "        except Exception:\n",
-    "            print('❌ Dates must be YYYY-MM'); return\n",
-    "\n",
-    "        # build indices_list from right-most columns\n",
-    "        cnt = index_cnt.value\n",
-    "        non_date = [c for c in df.columns if c != 'Date']\n",
-    "        indices_list = non_date[-cnt:] if cnt else []\n",
-    "\n",
-    "        # ── build manual table once ────────────────────────────\n",
-    "        if mode_dd.value == 'manual' and not table_built:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            if not pd.api.types.is_datetime64_any_dtype(df['Date']):\n",
-    "                df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "\n",
-    "            candidates = [c for c in df.columns\n",
-    "                          if c not in ['Date', rf_col] + indices_list]\n",
-    "\n",
-    "            ins = pd.to_datetime(in_start.value) + pd.offsets.MonthEnd(0)\n",
-    "            ine = pd.to_datetime(in_end.value)   + pd.offsets.MonthEnd(0)\n",
-    "            ous = pd.to_datetime(out_start.value)+ pd.offsets.MonthEnd(0)\n",
-    "            oue = pd.to_datetime(out_end.value)  + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "            valid = select_funds(df, rf_col, candidates,\n",
-    "                                 ins, ine, ous, oue, 'all')\n",
-    "            if not valid:\n",
-    "                print('❌ No funds pass full-history / gap rules.'); return\n",
-    "\n",
-    "            rows = []\n",
-    "\n",
-    "            def _update_total(*_):\n",
-    "                tot = sum(r.children[1].value for r in rows\n",
-    "                          if r.children[0].value)\n",
-    "                total_lbl.value = f'Total weight: {tot} %'\n",
-    "\n",
-    "            for tkr in valid:\n",
-    "                cbx = widgets.Checkbox(\n",
-    "                    value=False,\n",
-    "                    description=tkr,\n",
-    "                    layout=widgets.Layout(width='200px')\n",
-    "                )\n",
-    "                wbx = widgets.BoundedIntText(\n",
-    "                    0, min=0, max=100, step=1,\n",
-    "                    layout=widgets.Layout(width='40px'),\n",
-    "                    disabled=True\n",
-    "                )\n",
-    "                def _toggle(ch, box=wbx):\n",
-    "                    box.disabled = not ch['new']\n",
-    "                    if box.disabled:\n",
-    "                        box.value = 0\n",
-    "                    _update_total()\n",
-    "\n",
-    "                cbx.observe(_toggle, names='value')\n",
-    "                wbx.observe(_update_total, names='value')\n",
-    "                rows.append(widgets.HBox([cbx, wbx],\n",
-    "                                         layout=widgets.Layout(margin='1px 0')))\n",
-    "\n",
-    "            index_lbl = widgets.HTML(\n",
-    "                f\"<b>Index columns (excluded):</b> {', '.join(indices_list) or 'None'}\"\n",
-    "            )\n",
-    "            fund_table.children = tuple(rows) + (total_lbl, index_lbl)\n",
-    "            _update_total()\n",
-    "\n",
-    "            table_built = True\n",
-    "            _vis_mode()\n",
-    "            print('▶ Tick funds & enter weights, then click Run again')\n",
-    "            return   # wait for second click\n",
-    "\n",
-    "        # ── gather manual weights ─────────────────────────────\n",
-    "        custom_w = None\n",
-    "        if mode_dd.value == 'manual':\n",
-    "            weights = {row.children[0].description: row.children[1].value\n",
-    "                       for row in fund_table.children[:-2]   # skip total & index lbl\n",
-    "                       if isinstance(row, widgets.HBox) and row.children[0].value}\n",
-    "            tot = sum(weights.values())\n",
-    "            if not weights:\n",
-    "                print('⚠️ Select at least one fund'); return\n",
-    "            if tot != 100:\n",
-    "                print(f'⚠️ Weights total {tot} %. Must equal 100 %.'); return\n",
-    "            custom_w = weights\n",
-    "\n",
-    "        # ── run analysis ──────────────────────────────────────\n",
-    "        print('▶ Running analysis …')\n",
-    "        try:\n",
-    "            res = run_analysis(\n",
-    "                df,\n",
-    "                in_start.value, in_end.value,\n",
-    "                out_start.value, out_end.value,\n",
-    "                target_vol.value, monthly_cost.value,\n",
-    "                selection_mode=mode_dd.value,\n",
-    "                random_n=rand_n.value if mode_dd.value == 'random' else None,\n",
-    "                custom_weights=custom_w\n",
-    "            )\n",
-    "        except Exception as e:\n",
-    "            print('❌ run_analysis error:', e); return\n",
-    "        if res is None:\n",
-    "            print('❌ No results'); return\n",
-    "\n",
-    "        print('✅ Done. Funds:', res['selected_funds'])\n",
-    "\n",
-    "        # ── Show weights (manual or equal) ────────────────────────────\n",
-    "        weights_dict = res.get(\"fund_weights\") or res.get(\"ew_weights\")\n",
-    "        if weights_dict:\n",
-    "            print(\"Weights:\")\n",
-    "            for f, w in weights_dict.items():\n",
-    "                pct = w if w <= 1 else w      # decimals → percent\n",
-    "                print(f\"   • {f}: {pct:.0f}%\")\n",
-    "        # ──────────────────────────────────────────────────────────────\n",
-    "\n",
-    "        # print index stats\n",
-    "        if \"index_stats\" in res and res[\"index_stats\"]:\n",
-    "            print(\"\\n📊  Index statistics (read-only):\")\n",
-    "            hdr = \"        IN-Sample                          |        OUT-Sample\"\n",
-    "            sub = \"R      V      S#     So     MDD            R      V      S#     So     MDD\"\n",
-    "            print(\"        \" + hdr)\n",
-    "            print(\"        \" + sub)\n",
-    "            for idx, sd in res[\"index_stats\"].items():\n",
-    "                rin,  vin,  sin,  soin,  mddin  = sd[\"in_sample\"]\n",
-    "                rout, vout, sout, soout, mddout = sd[\"out_sample\"]\n",
-    "                print(f\"   • {idx:12}: \"\n",
-    "                      f\"{rin:6.2f}% {vin:6.2f}% {sin:5.2f} {soin:6.2f} {mddin:6.2f}%   |  \"\n",
-    "                      f\"{rout:6.2f}% {vout:6.2f}% {sout:5.2f} {soout:6.2f} {mddout:6.2f}%\")\n",
-    "\n",
-    "        fname = f\"IS_{in_start.value}_{out_start.value}.xlsx\"\n",
-    "        export_to_excel(res, df, fname,\n",
-    "                        in_start.value, in_end.value,\n",
-    "                        out_start.value, out_end.value)\n",
-    "        print('Excel saved as', fname)\n",
-    "run_btn.on_click(_run)\n",
-    "\n",
-    "# ── 8. DISPLAY UI ─────────────────────────────────────────────\n",
-    "display(widgets.VBox([\n",
-    "    widgets.HBox([source_toggle, url_box]),\n",
-    "    file_chooser, load_btn, load_out,\n",
-    "    widgets.HBox([index_cnt]),\n",
-    "    widgets.HTML('<hr>'),\n",
-    "    widgets.HBox([in_start, in_end, out_start, out_end]),\n",
-    "    widgets.HBox([target_vol, monthly_cost]),\n",
-    "    widgets.HTML('<hr>'),\n",
-    "    widgets.HBox([mode_dd, rand_n]),\n",
-    "    fund_table, total_lbl,\n",
-    "    run_btn, out_box\n",
-    "]))\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_UserSelect-checkpoint.ipynb b/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_UserSelect-checkpoint.ipynb
deleted file mode 100644
index 9f805e18772e0e37dc05d96569c64bf2b0165c32..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/Vol_Adj_Trend_Analysis_UserSelect-checkpoint.ipynb
+++ /dev/null
@@ -1,1475 +0,0 @@
-{
- "cells": [
-  {
-   "cell_type": "markdown",
-   "id": "e4984b33",
-   "metadata": {},
-   "source": [
-    "# Volatility Scaling & Portfolio Analysis\n",
-    "\n",
-    "This notebook demonstrates how to:\n",
-    "1. Load and validate data.\n",
-    "2. Handle missing data (short vs. long gaps).\n",
-    "3. Adjust returns to a target volatility in-sample, then apply the same scaling out-of-sample.\n",
-    "4. Compute Sharpe, Sortino, Max Drawdown.\n",
-    "5. Provide multiple fund selection modes (all, random sample, manual).\n",
-    "6. Calculate portfolio results (equal-weight and custom-weight).\n",
-    "7. Output in-sample and out-of-sample results to Excel with formatting.\n",
-    "\n",
-    "**Note**: The manual fund selection and custom weights features are partially implemented. In a real interactive workflow, you would wire widget selections and weights into the final analysis."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 1,
-   "id": "30ea203f",
-   "metadata": {
-    "tags": []
-   },
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "INFO: Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\n",
-      "Setup complete.\n"
-     ]
-    }
-   ],
-   "source": [
-    "# ============ 1. SETUP CELL ============\n",
-    "\n",
-    "import logging\n",
-    "import sys\n",
-    "import numpy as np\n",
-    "import pandas as pd\n",
-    "import os\n",
-    "import math\n",
-    "import ipywidgets as widgets\n",
-    "from ipywidgets import interact, interactive, VBox, HBox\n",
-    "from IPython.display import display, clear_output\n",
-    "from IPython.utils.capture import capture_output\n",
-    "from ipyfilechooser import FileChooser\n",
-    "import datetime\n",
-    "import random\n",
-    "import warnings\n",
-    "\n",
-    "# If you need to install these packages on your environment, uncomment:\n",
-    "!{sys.executable} -m pip install --quiet ipywidgets openpyxl xlsxwriter\n",
-    "\n",
-    "# For exporting to Excel with styling\n",
-    "import xlsxwriter\n",
-    "\n",
-    "# Set up logging to console\n",
-    "logging.basicConfig(\n",
-    "    stream=sys.stdout,\n",
-    "    level=logging.INFO,\n",
-    "    format=\"%(levelname)s: %(message)s\"\n",
-    ")\n",
-    "\n",
-    "logging.info(\"Logging started. Volatility Scaling & Portfolio Analysis Notebook initialized.\")\n",
-    "\n",
-    "# (Optional) If widgets aren't enabled, run:\n",
-    "# !jupyter nbextension enable --py widgetsnbextension --sys-prefix\n",
-    "\n",
-    "print(\"Setup complete.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-   "metadata": {},
-   "source": [
-    "## 2. Data Loading\n",
-    "Here we create options to load a dataset from a local file or a GitHub repository."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 2,
-   "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-   "metadata": {},
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "488a1bb4ea9d42089315d7a8a5e7e231",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(HTML(value='<b>Step 1: Choose your CSV</b><br><i>Remember:</i> If you included any index column…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "def identify_risk_free_fund(df):\n",
-    "    \"\"\"\n",
-    "    Identify which column (after 'Date') is the risk-free rate by smallest stdev among columns.\n",
-    "    \"\"\"\n",
-    "    numeric_cols = df.columns[1:]  # skip the Date column\n",
-    "    stdevs = {}\n",
-    "    for col in numeric_cols:\n",
-    "        vals = df[col].dropna()\n",
-    "        if len(vals) > 0:\n",
-    "            stdevs[col] = vals.std()\n",
-    "        else:\n",
-    "            stdevs[col] = np.inf\n",
-    "\n",
-    "    rf_col = min(stdevs, key=stdevs.get)\n",
-    "    logging.info(f\"Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "    return rf_col\n",
-    "\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 1) Helper to read a local CSV robustly (handles BOMs and minor parsing issues)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def robust_read_csv(path):\n",
-    "    \"\"\"\n",
-    "    Try loading `path` as CSV in three ways:\n",
-    "    1. Default C engine\n",
-    "    2. BOM-stripped with the Python engine\n",
-    "    3. Skip bad lines with the Python engine\n",
-    "    \"\"\"\n",
-    "    try:\n",
-    "        return pd.read_csv(path)\n",
-    "    except Exception as e1:\n",
-    "        print(\"Default read_csv failed:\", e1)\n",
-    "\n",
-    "    try:\n",
-    "        return pd.read_csv(path, sep=\",\", encoding=\"utf-8-sig\", engine=\"python\")\n",
-    "    except Exception as e2:\n",
-    "        print(\"utf-8-sig + python engine failed:\", e2)\n",
-    "\n",
-    "    return pd.read_csv(\n",
-    "        path,\n",
-    "        sep=\",\",\n",
-    "        engine=\"python\",\n",
-    "        encoding=\"utf-8-sig\",\n",
-    "        skip_blank_lines=True,\n",
-    "        on_bad_lines=\"skip\",    # for pandas ≥ 1.3\n",
-    "    )\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 2) Build the widgets\n",
-    "# ------------------------------------------------------------------------------\n",
-    "source_info = widgets.HTML(\n",
-    "    \"<b>Step 1: Choose your CSV</b><br>\"\n",
-    "    \"<i>Remember:</i> If you included any index columns (e.g. S&P 500, MSCI World, SG Trend), they \"\n",
-    "    \"must appear to the right of all fund columns in your sheet.\"\n",
-    ")\n",
-    "\n",
-    "\n",
-    "source_dropdown = widgets.Dropdown(\n",
-    "    options=['Local', 'GitHub'],\n",
-    "    value='Local',\n",
-    "    description='Data Source:',\n",
-    "    style={'description_width': '120px'}\n",
-    ")\n",
-    "\n",
-    "# FileChooser for Local mode\n",
-    "fc = FileChooser(os.getcwd())\n",
-    "fc.title = \"<b>Select local CSV file</b>\"\n",
-    "\n",
-    "# Text box for GitHub raw URL\n",
-    "github_text = widgets.Text(\n",
-    "    value=(\n",
-    "        \"https://raw.githubusercontent.com/stranske/Trend_Model_Project/\"\n",
-    "        \"main/data/TrendData.csv\"\n",
-    "    ),\n",
-    "    description=\"GitHub URL:\",\n",
-    "    layout=widgets.Layout(width=\"80%\"),\n",
-    ")\n",
-    "\n",
-    "# Ask how many index columns are on the far right\n",
-    "n_indices_widget = widgets.BoundedIntText(\n",
-    "    value=0,\n",
-    "    min=0,\n",
-    "    max=10,  # adjust if you expect more than 10 indices\n",
-    "    description='# Index cols:',\n",
-    "    style={'description_width': '120px'},\n",
-    "    tooltip=\"Enter the number of index columns at the far right of your CSV\"\n",
-    ")\n",
-    "\n",
-    "# Load button\n",
-    "load_button = widgets.Button(description=\"Load Data\", button_style=\"success\")\n",
-    "\n",
-    "# Output area for status and debug prints\n",
-    "output_area = widgets.Output()\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 3) Show/hide widgets depending on source selection\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_source_change(change):\n",
-    "    if change[\"new\"] == \"Local\":\n",
-    "        fc.layout.display = \"block\"\n",
-    "        github_text.layout.display = \"none\"\n",
-    "    else:\n",
-    "        fc.layout.display = \"none\"\n",
-    "        github_text.layout.display = \"block\"\n",
-    "\n",
-    "# Initially, GitHub textbox is hidden; FileChooser is visible\n",
-    "github_text.layout.display = \"none\"\n",
-    "fc.layout.display = \"block\"\n",
-    "\n",
-    "source_dropdown.observe(on_source_change, names=\"value\")\n",
-    "\n",
-    "ui_load = widgets.VBox([\n",
-    "    source_info,\n",
-    "    source_dropdown,\n",
-    "    fc,\n",
-    "    github_text,\n",
-    "    n_indices_widget,   # ← new widget here\n",
-    "    load_button,\n",
-    "    output_area\n",
-    "])\n",
-    "\n",
-    "# ------------------------------------------------------------------------------\n",
-    "# 4) Callback for the Load button (auto-detect date format)\n",
-    "# ------------------------------------------------------------------------------\n",
-    "def on_load_clicked(_):\n",
-    "    global df, fund_cols, indices_list, rf_col            # declare df as global\n",
-    "    with output_area:\n",
-    "        output_area.clear_output()\n",
-    "        src_choice = source_dropdown.value\n",
-    "        n_indices = int(n_indices_widget.value)\n",
-    "\n",
-    "        # 4a) Load the DataFrame\n",
-    "        try:\n",
-    "            if src_choice == 'Local':\n",
-    "                local_path = fc.selected  # FileChooser’s selected path\n",
-    "                if not local_path or not os.path.exists(local_path):\n",
-    "                    print(f\"Error: Local file not found:\\n  {local_path}\")\n",
-    "                    return\n",
-    "                print(f\"Loading from local file:\\n  {local_path}\")\n",
-    "                df = pd.read_csv(local_path)\n",
-    "            else:\n",
-    "                github_url = github_text.value.strip()\n",
-    "                if not github_url:\n",
-    "                    print(\"Error: Please enter a valid GitHub raw URL.\")\n",
-    "                    return\n",
-    "                print(f\"Loading from GitHub URL:\\n  {github_url}\")\n",
-    "                df = pd.read_csv(github_url)\n",
-    "        except Exception as e:\n",
-    "            print(\"Failed to load CSV:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4b) Debug: print columns & a few rows\n",
-    "        print(\"Columns found in DataFrame:\", df.columns.tolist())\n",
-    "        display(df.head(3))\n",
-    "\n",
-    "        # 4c) Identify which column is the date\n",
-    "        date_col = None\n",
-    "        for candidate in [\"Date\", \"DATE\", \"date\"]:\n",
-    "            if candidate in df.columns:\n",
-    "                date_col = candidate\n",
-    "                break\n",
-    "\n",
-    "        if date_col is None:\n",
-    "            print(\"Error: No column named 'Date' / 'DATE' / 'date' found.\")\n",
-    "            print(\"Please check the column names above and adjust code accordingly.\")\n",
-    "            return\n",
-    "\n",
-    "        date_col = 'Date'\n",
-    "\n",
-    "        # 1) Show the first few raw date strings (un‐parsed) so we can inspect them\n",
-    "        raw_samples = df[date_col].dropna().astype(str).head(10).tolist()\n",
-    "        print(f\"Raw {date_col} samples (first 10 non‐null): {raw_samples!r}\")\n",
-    "\n",
-    "        # 2) Strip leading/trailing whitespace from every entry\n",
-    "        df[date_col] = df[date_col].astype(str).str.strip()\n",
-    "\n",
-    "        # 3) Now attempt strict \"%m/%d/%Y\" parsing\n",
-    "        parsed = pd.to_datetime(df[date_col], format=\"%m/%d/%Y\", errors=\"coerce\", infer_datetime_format=True)\n",
-    "        num_valid = parsed.notna().sum()\n",
-    "        print(f\"Number of rows matching '%m/%d/%Y' exactly: {num_valid} / {len(df)}\")\n",
-    "\n",
-    "        if num_valid > 0:\n",
-    "            df[date_col] = parsed\n",
-    "            print(f\"Parsing with '%m/%d/%Y' succeeded for {num_valid} rows.\")\n",
-    "        else:\n",
-    "            print(\n",
-    "                \"Warning: No rows matched '%m/%d/%Y'. \"\n",
-    "                \"Falling back to generic pd.to_datetime(...).\"\n",
-    "            )\n",
-    "            df[date_col] = pd.to_datetime(df[date_col], errors=\"coerce\")\n",
-    "\n",
-    "        # 5) Drop any rows where parsing still failed\n",
-    "        before_drop = len(df)\n",
-    "        df.dropna(subset=[date_col], inplace=True)\n",
-    "        dropped = before_drop - len(df)\n",
-    "        if dropped:\n",
-    "            print(f\"Dropped {dropped} rows where '{date_col}' could not be parsed.\")\n",
-    "        \n",
-    "        # 6) Sort and reset index\n",
-    "        df.sort_values(by=date_col, inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "        \n",
-    "        # 7) Show the final parsed dates\n",
-    "        print(f\"After parsing, first 3 {date_col} values:\")\n",
-    "        print(df[[date_col]].head(3))\n",
-    "        print(f\"Loaded {len(df)} rows successfully.\")\n",
-    "\n",
-    "\n",
-    "        # 4d) Identify risk-free column\n",
-    "        try:\n",
-    "            rf_col = identify_risk_free_fund(df)\n",
-    "            print(f\"Identified risk-free column as: '{rf_col}'\")\n",
-    "        except Exception as e:\n",
-    "            print(\"Error identifying risk-free column:\", e)\n",
-    "            return\n",
-    "\n",
-    "        # 4f) Determine fund_cols vs indices_list based on n_indices\n",
-    "        all_cols = df.columns.tolist()\n",
-    "        # We assume “Date” and rf_col are present. Everything else is a candidate.\n",
-    "        if 'Date' not in all_cols or rf_col not in all_cols:\n",
-    "            print(\"Error: 'Date' or risk-free column not found in DataFrame columns.\")\n",
-    "            return\n",
-    "        \n",
-    "        # Build list of all columns except 'Date' and rf_col\n",
-    "        remaining = [c for c in all_cols if c not in ['Date', rf_col]]\n",
-    "        \n",
-    "        if n_indices > len(remaining):\n",
-    "            print(\n",
-    "                f\"Error: You asked for {n_indices} index columns, but only \"\n",
-    "                f\"{len(remaining)} columns remain after 'Date' and '{rf_col}'.\"\n",
-    "            )\n",
-    "            return\n",
-    "\n",
-    "        if n_indices > 0:\n",
-    "            indices_list = remaining[-n_indices:]\n",
-    "            fund_cols    = remaining[:-n_indices]\n",
-    "        else:\n",
-    "            indices_list = []\n",
-    "            fund_cols    = remaining[:]\n",
-    "        print(\"\\n>> Debug (post‐load): fund_cols =\", fund_cols)\n",
-    "        print(\">> Debug (post‐load): indices_list =\", indices_list, \"\\n\")\n",
-    "        \n",
-    "        # 2F) Print out what we found\n",
-    "        print(f\"Detected fund columns ({len(fund_cols)}): {fund_cols}\")\n",
-    "        print(f\"Detected index columns ({len(indices_list)}): {indices_list}\")\n",
-    "        print(\n",
-    "            \"Data loaded and classified successfully.\\n\"\n",
-    "            \"Proceed to Step 2 (Run Analysis).\"\n",
-    "        )\n",
-    "\n",
-    " \n",
-    "        # 8) Confirm that df is now in global scope\n",
-    "        print(\">> df defined with\", len(df), \"rows and columns:\", df.columns.tolist())\n",
-    "\n",
-    "\n",
-    "# 5) Wire up and display the UI\n",
-    "load_button.on_click(on_load_clicked)\n",
-    "\n",
-    "\n",
-    "display(ui_load)\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ac53bc18",
-   "metadata": {},
-   "source": [
-    "## 3. Utility Functions\n",
-    "Here we define date parsing, consecutive gap checks, data filling, risk-free identification, return calculations, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 3,
-   "id": "59a9bf13",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "Utility functions loaded.\n"
-     ]
-    }
-   ],
-   "source": [
-    "\n",
-    "def consecutive_gaps(series, threshold=3):\n",
-    "    \"\"\"\n",
-    "    Check if a series (sorted chronologically) has >= threshold consecutive NaNs.\n",
-    "    Return True if such a gap exists, False otherwise.\n",
-    "    \"\"\"\n",
-    "    consecutive = 0\n",
-    "    for val in series:\n",
-    "        if pd.isna(val):\n",
-    "            consecutive += 1\n",
-    "        else:\n",
-    "            consecutive = 0\n",
-    "        if consecutive >= threshold:\n",
-    "            return True\n",
-    "    return False\n",
-    "\n",
-    "def fill_short_gaps_with_zero(series):\n",
-    "    \"\"\"\n",
-    "    Given a pandas Series indexed by Date (month‐ends), wherever there is\n",
-    "    a run of 1 or 2 consecutive NaNs, replace them with 0.0. If a run of 3\n",
-    "    or more NaNs appears, leave those NaNs intact.\n",
-    "    \"\"\"\n",
-    "    isnan = series.isna().astype(int)\n",
-    "    run_lengths = isnan.groupby((isnan == 0).cumsum()).transform('sum')\n",
-    "    filled = series.copy()\n",
-    "    mask_short = (isnan == 1) & (run_lengths <= 2)\n",
-    "    filled[mask_short] = 0.0\n",
-    "    return filled\n",
-    "\n",
-    "def annualize_return(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized (geometric) return from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    growth_factor = (1 + valid_rets).prod()\n",
-    "    n_months = len(valid_rets)\n",
-    "    if growth_factor <= 0:\n",
-    "        return -1.0\n",
-    "    ann_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    return ann_ret\n",
-    "\n",
-    "def annualize_volatility(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Annualized stdev of monthly returns, i.e. stdev * sqrt(12).\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) < 2:\n",
-    "        return np.nan\n",
-    "    return valid_rets.std() * np.sqrt(12)\n",
-    "\n",
-    "def sharpe_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sharpe ratio = (annual_excess_return) / (annual_excess_vol).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "    ann_excess_vol = excess.std() * np.sqrt(12)\n",
-    "    if ann_excess_vol == 0:\n",
-    "        return np.nan\n",
-    "    return ann_excess_ret / ann_excess_vol\n",
-    "\n",
-    "def sortino_ratio(monthly_returns, rf_series):\n",
-    "    \"\"\"\n",
-    "    Annualized Sortino ratio = (annual_excess_return) / (annual_downside_stdev).\n",
-    "    \"\"\"\n",
-    "    df = pd.DataFrame({'r': monthly_returns, 'rf': rf_series}).dropna()\n",
-    "    if len(df) < 2:\n",
-    "        return np.nan\n",
-    "    excess = df['r'] - df['rf']\n",
-    "\n",
-    "    growth_factor = (1 + excess).prod()\n",
-    "    n_months = len(excess)\n",
-    "    if growth_factor <= 0:\n",
-    "        return np.nan\n",
-    "    ann_excess_ret = growth_factor**(12.0 / n_months) - 1\n",
-    "\n",
-    "    negative_mask = excess < 0\n",
-    "    negative_returns = excess[negative_mask]\n",
-    "    if len(negative_returns) == 0:\n",
-    "        return np.inf  # no negative => infinite sortino\n",
-    "    downside_stdev = negative_returns.std() * np.sqrt(12)\n",
-    "    return ann_excess_ret / downside_stdev\n",
-    "\n",
-    "def max_drawdown(monthly_returns):\n",
-    "    \"\"\"\n",
-    "    Compute max drawdown from monthly returns in decimal form.\n",
-    "    \"\"\"\n",
-    "    valid_rets = monthly_returns.dropna()\n",
-    "    if len(valid_rets) == 0:\n",
-    "        return np.nan\n",
-    "    wealth_index = (1 + valid_rets).cumprod()\n",
-    "    rolling_max = wealth_index.cummax()\n",
-    "    dd_series = 1 - (wealth_index / rolling_max)\n",
-    "    return dd_series.max()\n",
-    "\n",
-    "def calc_portfolio_returns(weights, df_returns):\n",
-    "    \"\"\"\n",
-    "    Compute monthly portfolio returns (Series) as weighted sum of columns in df_returns.\n",
-    "    \"\"\"\n",
-    "    return (df_returns * weights).sum(axis=1)\n",
-    "\n",
-    "print(\"Utility functions loaded.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "4f1619c9",
-   "metadata": {},
-   "source": [
-    "## 4. Widgets & User Inputs\n",
-    "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 4,
-   "id": "1e739b5c-2218-4653-97f8-e3cebe194183",
-   "metadata": {},
-   "outputs": [],
-   "source": [
-    "# ─────────────── Widget Setup + Callback ───────────────\n",
-    "\n",
-    "# ─── Phase 1: Date / Vol / Cost / Run Button ───\n",
-    "# ─── Phase 1: Date / Vol / Cost / Run Button ───\n",
-    "\n",
-    "in_sample_start     = widgets.Text(value='2005-07', description='In-Sample Start:')\n",
-    "in_sample_end       = widgets.Text(value='2008-06', description='In-Sample End:')\n",
-    "out_sample_start    = widgets.Text(value='2008-07', description='Out-Sample Start:')\n",
-    "out_sample_end      = widgets.Text(value='2009-06', description='Out-Sample End:')\n",
-    "\n",
-    "target_vol_widget   = widgets.FloatText(value=0.25, description='Target Vol:')\n",
-    "monthly_cost_widget = widgets.FloatText(value=0.0033, description='Monthly Cost:')\n",
-    "\n",
-    "run_button = widgets.Button(description='Run Analysis', button_style='success')\n",
-    "\n",
-    "# ← Replace any previous “output_area = widgets.Output()” with the block below:\n",
-    "output_area = widgets.Output(\n",
-    "    layout={\n",
-    "        'border': '1px solid gray',\n",
-    "        'height': '300px',\n",
-    "        'overflow_y': 'auto'   # optional: let it scroll if there’s too much text\n",
-    "    }\n",
-    ")\n",
-    "\n",
-    "# Pack only these into main_inputs for now—no display() yet.\n",
-    "main_inputs = widgets.VBox([\n",
-    "    in_sample_start,\n",
-    "    in_sample_end,\n",
-    "    out_sample_start,\n",
-    "    out_sample_end,\n",
-    "    target_vol_widget,\n",
-    "    monthly_cost_widget,\n",
-    "    run_button\n",
-    "])\n",
-    "\n",
-    "# ─── Phase 2: Build & Hide Mode / Random-Size / “Fund Table” placeholders ───\n",
-    "\n",
-    "# A) Mode dropdown (hidden initially)\n",
-    "selection_mode_widget = widgets.Dropdown(\n",
-    "    options=[('All Funds','all'), ('Random Sample','random'), ('Manual','manual')],\n",
-    "    value='all',\n",
-    "    description='Mode:'\n",
-    ")\n",
-    "selection_mode_widget.layout.display = 'none'\n",
-    "\n",
-    "# B) Random Sample Size field (hidden initially)\n",
-    "random_sample_size_widget = widgets.IntText(\n",
-    "    value=5, description='Sample Size:'\n",
-    ")\n",
-    "random_sample_size_widget.layout.display = 'none'\n",
-    "\n",
-    "# C) Placeholder containers for the Manual‐funds checkboxes & weights\n",
-    "fund_table_container = widgets.VBox([])   # we will populate it later\n",
-    "fund_table_container.layout.display = 'none'\n",
-    "\n",
-    "# D) Whenever Mode changes, show/hide “Sample Size” vs. “Fund Table”\n",
-    "def _on_mode_change(change):\n",
-    "    new_mode = change['new']\n",
-    "    if new_mode == 'random':\n",
-    "        random_sample_size_widget.layout.display = 'block'\n",
-    "        fund_table_container.layout.display   = 'none'\n",
-    "    elif new_mode == 'manual':\n",
-    "        random_sample_size_widget.layout.display = 'none'\n",
-    "        fund_table_container.layout.display   = 'block'\n",
-    "    else:  # 'all'\n",
-    "        random_sample_size_widget.layout.display = 'none'\n",
-    "        fund_table_container.layout.display   = 'none'\n",
-    "\n",
-    "selection_mode_widget.observe(_on_mode_change, names='value')\n",
-    "\n",
-    "# ─── Phase 3: Wire up “Run Analysis” + final display(...) ───\n",
-    "\n",
-    "phase_counter = {\"step\": 1}\n",
-    "\n",
-    "def on_run_clicked(b):\n",
-    "    with output_area:\n",
-    "        clear_output()\n",
-    "\n",
-    "        # 1) Read dates/vol/cost\n",
-    "        in_start_val     = in_sample_start.value.strip()\n",
-    "        in_end_val       = in_sample_end.value.strip()\n",
-    "        out_start_val    = out_sample_start.value.strip()\n",
-    "        out_end_val      = out_sample_end.value.strip()\n",
-    "        target_vol_val   = target_vol_widget.value\n",
-    "        monthly_cost_val = monthly_cost_widget.value\n",
-    "\n",
-    "        # 2) First click = reveal Mode dropdown + hide everything else\n",
-    "        if phase_counter[\"step\"] == 1:\n",
-    "            # Quick check: ensure date strings parse\n",
-    "            try:\n",
-    "                pd.to_datetime(in_start_val, format=\"%Y-%m\")\n",
-    "                pd.to_datetime(in_end_val,   format=\"%Y-%m\")\n",
-    "                pd.to_datetime(out_start_val, format=\"%Y-%m\")\n",
-    "                pd.to_datetime(out_end_val,   format=\"%Y-%m\")\n",
-    "            except Exception:\n",
-    "                print(\"❌ Invalid date formats. Please use YYYY-MM and click Run again.\")\n",
-    "                return\n",
-    "\n",
-    "            print(\"▶ Dates accepted. Now pick Mode (All / Random / Manual). \" \n",
-    "                  \"If Manual, you’ll then see the valid funds appear.\")\n",
-    "            selection_mode_widget.layout.display = 'block'\n",
-    "            phase_counter[\"step\"] = 2\n",
-    "            return\n",
-    "\n",
-    "        # 3) After first click, Mode is visible. If Mode changed to Manual, we need to\n",
-    "        #    build the fund_table with *only* those funds that pass the full‐history + no‐3-NA rule.\n",
-    "        if phase_counter[\"step\"] == 2:\n",
-    "            mode_val  = selection_mode_widget.value\n",
-    "            rnd_n_val = random_sample_size_widget.value if mode_val == 'random' else None\n",
-    "\n",
-    "            # If Manual mode is chosen, build fund_checkboxes & weight_boxes now:\n",
-    "            if mode_val == 'manual':\n",
-    "                # 3a) Determine which funds are “valid” for this date range.\n",
-    "                #     We reuse your existing `select_funds(...)` function, forcing selection_mode='all'.\n",
-    "                try:\n",
-    "                    in_sdate  = pd.to_datetime(in_start_val, format=\"%Y-%m\")\n",
-    "                    in_edate  = pd.to_datetime(in_end_val,   format=\"%Y-%m\") + pd.offsets.MonthEnd(0)\n",
-    "                    out_sdate = pd.to_datetime(out_start_val, format=\"%Y-%m\")\n",
-    "                    out_edate = pd.to_datetime(out_end_val,   format=\"%Y-%m\") + pd.offsets.MonthEnd(0)\n",
-    "                except Exception as e:\n",
-    "                    print(\"❌ Error parsing dates. Please re‐enter and click Run again.\")\n",
-    "                    return\n",
-    "\n",
-    "                # Build the “candidate fund_columns” list (exclude Date/rf/index columns)\n",
-    "                all_cols = [c for c in df.columns if c not in ['Date', identify_risk_free_fund(df)] + indices_list]\n",
-    "                # Call select_funds with selection_mode='all' to get the full list of valid funds.\n",
-    "                valid_funds = select_funds(\n",
-    "                    df,\n",
-    "                    identify_risk_free_fund(df),\n",
-    "                    fund_columns=all_cols,\n",
-    "                    in_sdate=in_sdate,\n",
-    "                    in_edate=in_edate,\n",
-    "                    out_sdate=out_sdate,\n",
-    "                    out_edate=out_edate,\n",
-    "                    selection_mode='all',\n",
-    "                    random_n=None\n",
-    "                )\n",
-    "\n",
-    "                if not valid_funds:\n",
-    "                    print(\"❌ No funds satisfy the full‐history & gap rules for these dates.\")\n",
-    "                    return\n",
-    "\n",
-    "                # 3b) Build a fresh table of checkboxes + IntText’s for valid_funds\n",
-    "                fund_table_rows = []\n",
-    "                fund_checkboxes = []\n",
-    "                weight_boxes    = []\n",
-    "\n",
-    "                for f in valid_funds:\n",
-    "                    cb = widgets.Checkbox(\n",
-    "                        value=False,\n",
-    "                        description=f,\n",
-    "                        layout=widgets.Layout(width='200px')\n",
-    "                    )\n",
-    "                    tb = widgets.BoundedIntText(\n",
-    "                        value=0,\n",
-    "                        min=0,\n",
-    "                        max=100,\n",
-    "                        step=1,\n",
-    "                        description=\"%\",          # user will type an integer percent\n",
-    "                        layout=widgets.Layout(width='160px')\n",
-    "                    )\n",
-    "                    tb.disabled = True  # only enabled when its checkbox is clicked\n",
-    "                    \n",
-    "                    fund_checkboxes.append(cb)\n",
-    "                    weight_boxes.append(tb)\n",
-    "\n",
-    "                    row = widgets.HBox([\n",
-    "                        cb,\n",
-    "                        weight_boxes[-1]\n",
-    "                    ], layout=widgets.Layout(margin=\"2px 0px\"))\n",
-    "                    fund_table_rows.append(row)\n",
-    "\n",
-    "                # Replace whatever was in fund_table_container with this new VBox\n",
-    "                fund_table_container.children = [widgets.VBox(fund_table_rows)]\n",
-    "                fund_table_container.layout.display = 'block'  # reveal it\n",
-    "\n",
-    "                # 3c) Wire up each checkbox so its weight box toggles on/off\n",
-    "                def _on_cb_change(change):\n",
-    "                    # ‘change.owner’ is the Checkbox that toggled\n",
-    "                    idx = fund_checkboxes.index(change.owner)\n",
-    "                    weight_boxes[idx].disabled = not change.new\n",
-    "\n",
-    "                for cb in fund_checkboxes:\n",
-    "                    cb.observe(_on_cb_change, names='value')\n",
-    "\n",
-    "            # Finally, show the random_sample_size_widget if needed\n",
-    "            if mode_val == 'random':\n",
-    "                random_sample_size_widget.layout.display = 'block'\n",
-    "\n",
-    "            print(\"▶ Now the Mode/sampling UI is visible. If Manual, pick funds + enter weights. Then click Run again.\")\n",
-    "            phase_counter[\"step\"] = 3\n",
-    "            return\n",
-    "\n",
-    "        # 4) After second click, everything (Mode + any Manual selections or random size) is set,\n",
-    "        #    so we can finally run `run_analysis(...)` for real:\n",
-    "        mode_val  = selection_mode_widget.value\n",
-    "        rnd_n_val = random_sample_size_widget.value if mode_val == 'random' else None\n",
-    "\n",
-    "        custom_weights = None\n",
-    "        if mode_val == 'manual':\n",
-    "            # Gather which checkboxes were checked, and read their weight_boxes\n",
-    "            selected = []\n",
-    "            weight_dict = {}\n",
-    "            # The fund_checkboxes + weight_boxes only exist if step>=2 and mode=='manual'.\n",
-    "            # We can grab them from fund_table_container.children.\n",
-    "            table_vbox = fund_table_container.children[0]   # the VBox we built above\n",
-    "            for row_hbox in table_vbox.children:\n",
-    "                cb, tb = row_hbox.children\n",
-    "                if cb.value:\n",
-    "                    selected.append(cb.description)\n",
-    "                    weight_dict[cb.description] = tb.value\n",
-    "\n",
-    "            total_w = sum(weight_dict.values())\n",
-    "            if not selected:\n",
-    "                print(\"⚠️ No funds checked—pick at least one fund.\")\n",
-    "                return\n",
-    "            if total_w != 100:\n",
-    "                print(f\"⚠️ Weights sum to {total_w}, but must be exactly 100. Fix and Run again.\")\n",
-    "                return\n",
-    "\n",
-    "            custom_weights = weight_dict\n",
-    "\n",
-    "        # 5) Now run the analysis for real\n",
-    "        print(\"▶ Running analysis with:\")\n",
-    "        print(f\"   In:   {in_start_val} → {in_end_val}\")\n",
-    "        print(f\"   Out:  {out_start_val} → {out_end_val}\")\n",
-    "        print(f\"   Vol:  {target_vol_val:.3%}, Cost: {monthly_cost_val:.3%}\")\n",
-    "        print(f\"   Mode: {mode_val}\" + (f\", Random N={rnd_n_val}\" if mode_val=='random' else \"\"))\n",
-    "        if mode_val == 'manual':\n",
-    "            print(f\"   Manual funds = {list(custom_weights.keys())}\")\n",
-    "            print(f\"   Weights = {custom_weights}\")\n",
-    "\n",
-    "        try:\n",
-    "            results = run_analysis(\n",
-    "                df,\n",
-    "                in_start=in_start_val,\n",
-    "                in_end=in_end_val,\n",
-    "                out_start=out_start_val,\n",
-    "                out_end=out_end_val,\n",
-    "                target_vol=target_vol_val,\n",
-    "                monthly_cost=monthly_cost_val,\n",
-    "                selection_mode=mode_val,\n",
-    "                random_n=rnd_n_val,\n",
-    "                custom_weights=custom_weights\n",
-    "            )\n",
-    "        except Exception as e:\n",
-    "            print(\"❌ Error inside run_analysis():\", e)\n",
-    "            return\n",
-    "\n",
-    "        if results is None or not results.get(\"selected_funds\"):\n",
-    "            print(\"❌ No valid funds remain after filtering.\")\n",
-    "            return\n",
-    "\n",
-    "        # 6) Print a brief summary & export to Excel\n",
-    "        sf = results[\"selected_funds\"]\n",
-    "        print(\"✅ Analysis complete:\")\n",
-    "        print(f\"   Funds selected: {len(sf)} → {sf}\")\n",
-    "        if \"in_ew_stats\" in results:\n",
-    "            ir, iv, isr, *_ = results[\"in_ew_stats\"]\n",
-    "            print(f\"   In‐Sample EW → R {ir*100:.2f}%, V {iv*100:.2f}%, S {isr:.2f}\")\n",
-    "        if \"out_ew_stats\" in results:\n",
-    "            or_, ov, osr, *_ = results[\"out_ew_stats\"]\n",
-    "            print(f\"   Out‐Sample EW → R {or_*100:.2f}%, V {ov*100:.2f}%, S {osr:.2f}\")\n",
-    "\n",
-    "        export_to_excel(results, \"InteractiveOutput.xlsx\")\n",
-    "        print(\"   Excel file created: InteractiveOutput.xlsx\")\n",
-    "\n",
-    "\n",
-    "run_button.on_click(on_run_clicked)\n",
-    "\n",
-    "# ─── Finally, show everything (Phase 1 + Phase 2 placeholders + output area) ───\n",
-    "\n",
-    "master_vbox = widgets.VBox([\n",
-    "    main_inputs,\n",
-    "    selection_mode_widget,\n",
-    "    random_sample_size_widget,\n",
-    "    fund_table_container\n",
-    "])\n",
-    "\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "5e3eb165",
-   "metadata": {},
-   "source": [
-    "## 5. Fund Selection\n",
-    "Filters out columns that represent the risk-free rate or contain \"index\" in the name, then handles the selection mode (all, random, or manual)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 5,
-   "id": "c5867ccd-a550-4849-a10b-a085f5fe26fd",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "select_funds (replaced) is ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def select_funds(\n",
-    "    df,                 # full DataFrame with datetime64 ‘Date’\n",
-    "    rf_col,             # name of risk‐free column\n",
-    "    fund_columns,       # list of candidate funds (should be your 27)\n",
-    "    in_sdate, in_edate, # pd.Timestamps for in‐sample window\n",
-    "    out_sdate, out_edate,# pd.Timestamps for out‐sample window\n",
-    "    selection_mode='all',\n",
-    "    random_n=5\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Start from fund_columns.  \n",
-    "    2) Filter out any that contain 'index' in name.  \n",
-    "    3) Keep only those with no NaN anywhere in both windows.  \n",
-    "    4) Keep only those with < 3 consecutive NaNs in each window.  \n",
-    "    5) Return based on selection_mode.\n",
-    "    \"\"\"\n",
-    "    # Step 1: base list\n",
-    "    candidates = fund_columns.copy()\n",
-    "    print(f\"DEBUG [select_funds]: initial candidates (n={len(candidates)}): {candidates}\")\n",
-    "\n",
-    "    # Step 2: drop any with “index” in name (case‐insensitive)\n",
-    "    no_index = [f for f in candidates if 'index' not in f.lower()]\n",
-    "    print(f\"DEBUG [select_funds]: after dropping 'index' (n={len(no_index)}): {no_index}\")\n",
-    "\n",
-    "    # Step 3: full‐history check (no NaN at all in each window)\n",
-    "    full_hist = []\n",
-    "    for f in no_index:\n",
-    "        in_sub  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)][f]\n",
-    "        out_sub = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        if in_sub.notna().all() and out_sub.notna().all():\n",
-    "            full_hist.append(f)\n",
-    "    print(f\"DEBUG [select_funds]: after full‐history check (n={len(full_hist)}): {full_hist}\")\n",
-    "\n",
-    "    # Step 4: no 3‐consecutive‐NaNs check\n",
-    "    after_run_check = []\n",
-    "    for f in full_hist:\n",
-    "        # In‐sample gap runs\n",
-    "        sub_in   = df[(df['Date'] >= in_sdate) & (df['Date'] <= in_edate)][f]\n",
-    "        isnan_in = sub_in.isna().astype(int)\n",
-    "        run_len_in = isnan_in.groupby((isnan_in == 0).cumsum()).sum()\n",
-    "        max_run_in = run_len_in.max() if not run_len_in.empty else 0\n",
-    "\n",
-    "        # Out‐sample gap runs\n",
-    "        sub_out   = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)][f]\n",
-    "        isnan_out = sub_out.isna().astype(int)\n",
-    "        run_len_out = isnan_out.groupby((isnan_out == 0).cumsum()).sum()\n",
-    "        max_run_out = run_len_out.max() if not run_len_out.empty else 0\n",
-    "\n",
-    "        # Keep only if both max runs < 3\n",
-    "        if max_run_in < 3 and max_run_out < 3:\n",
-    "            after_run_check.append(f)\n",
-    "\n",
-    "    print(f\"DEBUG [select_funds]: after run‐length check (n={len(after_run_check)}): {after_run_check}\")\n",
-    "\n",
-    "    # Step 5: selection_mode\n",
-    "    if selection_mode == 'all':\n",
-    "        return after_run_check\n",
-    "\n",
-    "    if selection_mode == 'random':\n",
-    "        if len(after_run_check) <= random_n:\n",
-    "            warnings.warn(\n",
-    "                f\"Fewer valid funds ({len(after_run_check)}) than sample size ({random_n}). Returning all.\"\n",
-    "            )\n",
-    "            return after_run_check\n",
-    "        return random.sample(after_run_check, random_n)\n",
-    "\n",
-    "    # Manual fund selection\n",
-    "    \n",
-    "    return after_run_check\n",
-    "\n",
-    "print(\"select_funds (replaced) is ready.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "c3c60582",
-   "metadata": {},
-   "source": [
-    "## 6. Custom Weights\n",
-    "Displays an integer text widget for each fund, requiring the sum of weights to be 100."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 6,
-   "id": "a404c638",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "get_custom_weights function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def get_custom_weights(selected_funds):\n",
-    "    \"\"\"\n",
-    "    Display widgets for each fund to enter weights. Validate sum=100.\n",
-    "    Returns dict {fund: weight_decimal}.\n",
-    "    \"\"\"\n",
-    "    weight_widgets = {}\n",
-    "    for fund in selected_funds:\n",
-    "        w = widgets.BoundedIntText(\n",
-    "            value=0,\n",
-    "            min=0,\n",
-    "            max=100,\n",
-    "            description=f\"{fund}\",\n",
-    "            layout=widgets.Layout(width='250px')\n",
-    "        )\n",
-    "        weight_widgets[fund] = w\n",
-    "    \n",
-    "    confirm_button = widgets.Button(\n",
-    "        description='Confirm Weights',\n",
-    "        button_style='success'\n",
-    "    )\n",
-    "    error_label = widgets.Label(value='', layout=widgets.Layout(color='red'))\n",
-    "    \n",
-    "    box = VBox(list(weight_widgets.values()) + [confirm_button, error_label])\n",
-    "    display(box)\n",
-    "    \n",
-    "    weights_container = {}\n",
-    "    \n",
-    "    def on_confirm_clicked(_):\n",
-    "        total = sum(w.value for w in weight_widgets.values())\n",
-    "        if total != 100:\n",
-    "            error_label.value = f\"Error: Weights sum to {total}, must be 100.\"\n",
-    "            weights_container.clear()\n",
-    "        else:\n",
-    "            for fund, wdg in weight_widgets.items():\n",
-    "                weights_container[fund] = wdg.value / 100.0\n",
-    "            error_label.value = \"Weights confirmed!\"\n",
-    "    \n",
-    "    confirm_button.on_click(on_confirm_clicked)\n",
-    "    return weights_container\n",
-    "\n",
-    "print(\"get_custom_weights function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "b3666a84",
-   "metadata": {},
-   "source": [
-    "## 7. Analysis (In-Sample & Out-of-Sample)\n",
-    "The `run_analysis` function orchestrates the entire process:\n",
-    "- Validates date inputs.\n",
-    "- Converts 'Date' column.\n",
-    "- Identifies risk-free column.\n",
-    "- Fills short gaps.\n",
-    "- Selects funds.\n",
-    "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-    "- Computes individual fund stats and portfolio stats."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 7,
-   "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "run_analysis (with checkpoints) is defined.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def run_analysis(\n",
-    "    df,\n",
-    "    in_start, in_end, out_start, out_end,\n",
-    "    target_vol, monthly_cost,\n",
-    "    selection_mode='all',\n",
-    "    random_n=5,\n",
-    "    custom_weights=None   # ← new argument\n",
-    "):\n",
-    "    \"\"\"\n",
-    "    1) Parse/validate date inputs\n",
-    "    2) Convert Date column if needed\n",
-    "    3) Identify rf_col\n",
-    "    4) Prepare in/out sample DataFrames\n",
-    "    5) CALL select_funds (with debug) and print checkpoints\n",
-    "    6) Compute scale_factors and wrap stats in try/except\n",
-    "    \"\"\"\n",
-    "\n",
-    "    # (1) Parse input dates\n",
-    "    in_sdate  = pd.to_datetime(in_start + \"-01\", errors='coerce')\n",
-    "    in_edate  = pd.to_datetime(in_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "    out_sdate = pd.to_datetime(out_start + \"-01\", errors='coerce')\n",
-    "    out_edate = pd.to_datetime(out_end   + \"-01\", errors='coerce') + pd.offsets.MonthEnd(0)\n",
-    "\n",
-    "    # checkpoint A\n",
-    "    print(\"CHECKPOINT A: Dates parsed:\", in_sdate, in_edate, out_sdate, out_edate)\n",
-    "\n",
-    "    # (2) Ensure Date is datetime64\n",
-    "    if not np.issubdtype(df['Date'].dtype, np.datetime64):\n",
-    "        df['Date'] = pd.to_datetime(df['Date'], errors='coerce')\n",
-    "        df.dropna(subset=['Date'], inplace=True)\n",
-    "        df.sort_values(by='Date', inplace=True)\n",
-    "        df.reset_index(drop=True, inplace=True)\n",
-    "\n",
-    "    # checkpoint B\n",
-    "    print(\"CHECKPOINT B: Date column is datetime64, first dates:\", df['Date'].iloc[0], df['Date'].iloc[-1])\n",
-    "\n",
-    "    # (3) Identify risk-free column\n",
-    "    rf_col = identify_risk_free_fund(df)\n",
-    "    print(f\"INFO: Identified '{rf_col}' as the risk-free column (lowest stdev).\")\n",
-    "\n",
-    "    # (4) Build in-sample & out-sample slices\n",
-    "    in_sample_df  = df[(df['Date'] >= in_sdate)  & (df['Date'] <= in_edate)].copy()\n",
-    "    out_sample_df = df[(df['Date'] >= out_sdate) & (df['Date'] <= out_edate)].copy()\n",
-    "    in_sample_rf  = in_sample_df[rf_col]\n",
-    "    out_sample_rf = out_sample_df[rf_col]\n",
-    "\n",
-    "    print(f\"CHECKPOINT C: in_sample rows = {len(in_sample_df)}, out_sample rows = {len(out_sample_df)}\")\n",
-    "\n",
-    "    \n",
-    "    \n",
-    "    # (5) Assemble fund_cols and call select_funds\n",
-    "    if selection_mode == 'manual' and custom_weights is not None:\n",
-    "        # In manual mode, we trust the user’s chosen tickers outright:\n",
-    "        selected_funds = list(custom_weights.keys())\n",
-    "        print(f\"CHECKPOINT D (manual): using custom_weights keys → {selected_funds}\")\n",
-    "    else:\n",
-    "        # ────────── Old Step 5: run select_funds ──────────\n",
-    "        all_fund_cols = fund_cols.copy()\n",
-    "        print(f\"CHECKPOINT D: about to call select_funds with {len(all_fund_cols)} candidates\")\n",
-    "\n",
-    "        selected_funds = select_funds(\n",
-    "            df,\n",
-    "            rf_col,\n",
-    "            fund_columns=all_fund_cols,\n",
-    "            in_sdate=in_sdate,\n",
-    "            in_edate=in_edate,\n",
-    "            out_sdate=out_sdate,\n",
-    "            out_edate=out_edate,\n",
-    "            selection_mode=selection_mode,\n",
-    "            random_n=random_n\n",
-    "        )\n",
-    "\n",
-    "    if len(selected_funds) == 0:\n",
-    "        logging.warning(\"No valid funds remain after filtering.\")\n",
-    "        print(\"Warning: No valid funds. Try adjusting your selection or data filters.\")\n",
-    "        return None\n",
-    "\n",
-    "    print(f\"CHECKPOINT E: select_funds returned {len(selected_funds)} funds → {selected_funds}\")\n",
-    "\n",
-    "    if not selected_funds:\n",
-    "        print(\"No valid funds after select_funds. Exiting run_analysis.\")\n",
-    "        return None\n",
-    "\n",
-    "    # (6) Compute scale_factors BEFORE entering stats‐try/except\n",
-    "    scale_factors = {}\n",
-    "    for fund in selected_funds:\n",
-    "        fund_in_rets = in_sample_df[fund].dropna()\n",
-    "        current_vol  = annualize_volatility(fund_in_rets)\n",
-    "        if pd.isna(current_vol) or current_vol == 0:\n",
-    "            scale_factors[fund] = 1.0\n",
-    "        else:\n",
-    "            scale_factors[fund] = target_vol / current_vol\n",
-    "\n",
-    "    print(\"CHECKPOINT F: scale_factors computed (showing first 5):\", \n",
-    "          {f: scale_factors[f] for f in selected_funds[:5]})\n",
-    "\n",
-    "    # Pre-allocate DataFrames for scaled returns\n",
-    "    in_sample_scaled  = pd.DataFrame(index=in_sample_df.index, columns=selected_funds)\n",
-    "    out_sample_scaled = pd.DataFrame(index=out_sample_df.index, columns=selected_funds)\n",
-    "\n",
-    "    # ────── TRY/EXCEPT AROUND ONLY THE “STATS” PORTION ──────\n",
-    "    try:\n",
-    "        # Scale returns (with cost)\n",
-    "        for fund in selected_funds:\n",
-    "            sf = scale_factors[fund]\n",
-    "            adj_in  = in_sample_df[fund] * sf - monthly_cost\n",
-    "            adj_in[adj_in < -1.0] = -1.0\n",
-    "            in_sample_scaled[fund] = adj_in\n",
-    "\n",
-    "            if not out_sample_df.empty:\n",
-    "                adj_out = out_sample_df[fund] * sf - monthly_cost\n",
-    "                adj_out[adj_out < -1.0] = -1.0\n",
-    "                out_sample_scaled[fund] = adj_out\n",
-    "\n",
-    "        # Helper for stats\n",
-    "        def compute_stats(series, rf_series):\n",
-    "            r   = annualize_return(series)\n",
-    "            v   = annualize_volatility(series)\n",
-    "            sr  = sharpe_ratio(series, rf_series)\n",
-    "            so  = sortino_ratio(series, rf_series)\n",
-    "            mdd = max_drawdown(series)\n",
-    "            return (r, v, sr, so, mdd)\n",
-    "\n",
-    "        # In-sample per-fund stats\n",
-    "        in_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            in_sample_stats[fund] = compute_stats(in_sample_scaled[fund], in_sample_rf)\n",
-    "\n",
-    "        # Out-sample per-fund (adjusted) stats\n",
-    "        out_sample_stats = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats[fund] = compute_stats(out_sample_scaled[fund], out_sample_rf)\n",
-    "\n",
-    "        # Out-sample per-fund (raw) stats\n",
-    "        out_sample_stats_raw = {}\n",
-    "        for fund in selected_funds:\n",
-    "            out_sample_stats_raw[fund] = compute_stats(out_sample_df[fund], out_sample_rf)\n",
-    "\n",
-    "        # Equal-weight portfolio\n",
-    "        ew_w = np.array([1.0/len(selected_funds)] * len(selected_funds))\n",
-    "        in_ew_port      = calc_portfolio_returns(ew_w, in_sample_scaled[selected_funds])\n",
-    "        out_ew_port     = calc_portfolio_returns(ew_w, out_sample_scaled[selected_funds])\n",
-    "        out_ew_port_raw = calc_portfolio_returns(ew_w, out_sample_df[selected_funds])\n",
-    "\n",
-    "        in_ew_stats      = compute_stats(in_ew_port, in_sample_rf)\n",
-    "        out_ew_stats     = compute_stats(out_ew_port, out_sample_rf)\n",
-    "        out_ew_stats_raw = compute_stats(out_ew_port_raw, out_sample_rf)\n",
-    "\n",
-    "        # User‐weight placeholder\n",
-    "        if custom_weights is None:\n",
-    "            # No manual weights passed → use equal‐weight\n",
-    "            user_weight_dict = {f: 1.0/len(selected_funds) for f in selected_funds}\n",
-    "        else:\n",
-    "            # Manual weights passed → convert each percentage to a decimal\n",
-    "            total_pct = sum(custom_weights.values())  # should be 100\n",
-    "            # (We’ve already validated earlier that total_pct == 100.)\n",
-    "            user_weight_dict = {f: custom_weights[f] / 100.0 for f in selected_funds}\n",
-    "        \n",
-    "        # Build the numpy weight array in the same order as selected_funds\n",
-    "        custom_w = np.array([user_weight_dict[f] for f in selected_funds])\n",
-    "        \n",
-    "        # Compute “user‐weighted” portfolio returns\n",
-    "        in_user_port      = calc_portfolio_returns(custom_w, in_sample_scaled[selected_funds])\n",
-    "        out_user_port     = calc_portfolio_returns(custom_w, out_sample_scaled[selected_funds])\n",
-    "        out_user_port_raw = calc_portfolio_returns(custom_w, out_sample_df[selected_funds])\n",
-    "        \n",
-    "        # Compute the corresponding stats\n",
-    "        in_user_stats      = compute_stats(in_user_port, in_sample_rf)\n",
-    "        out_user_stats     = compute_stats(out_user_port, out_sample_rf)\n",
-    "        out_user_stats_raw = compute_stats(out_user_port_raw, out_sample_rf)\n",
-    "\n",
-    "        results = {\n",
-    "            'selected_funds':       selected_funds,\n",
-    "            'in_sample_scaled':     in_sample_scaled,\n",
-    "            'out_sample_scaled':    out_sample_scaled,\n",
-    "            'in_sample_stats':      in_sample_stats,\n",
-    "            'out_sample_stats':     out_sample_stats,\n",
-    "            'out_sample_stats_raw': out_sample_stats_raw,\n",
-    "            'in_ew_stats':          in_ew_stats,\n",
-    "            'out_ew_stats':         out_ew_stats,\n",
-    "            'out_ew_stats_raw':     out_ew_stats_raw,\n",
-    "            'in_user_stats':        in_user_stats,\n",
-    "            'out_user_stats':       out_user_stats,\n",
-    "            'out_user_stats_raw':   out_user_stats_raw\n",
-    "        }\n",
-    "\n",
-    "    except Exception as e:\n",
-    "        print(\"ERROR inside stats-block:\", e)\n",
-    "        return None\n",
-    "\n",
-    "    # Everything succeeded\n",
-    "    return results\n",
-    "\n",
-    "print(\"run_analysis (with checkpoints) is defined.\")\n"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "183dc5df",
-   "metadata": {},
-   "source": [
-    "## 8. Excel Export\n",
-    "Creates an Excel file with two sheets (In-Sample, Out-of-Sample) and two tables per sheet (Equal-weight and User-weight)."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 8,
-   "id": "8e2cce23",
-   "metadata": {},
-   "outputs": [
-    {
-     "name": "stdout",
-     "output_type": "stream",
-     "text": [
-      "export_to_excel function ready.\n"
-     ]
-    }
-   ],
-   "source": [
-    "def export_to_excel(results_dict, output_filename=\"AnalysisOutput.xlsx\"):\n",
-    "    \"\"\"\n",
-    "    Create an Excel file with two tabs: In-Sample, Out-of-Sample.\n",
-    "    Each has two tables: (1) Equal-Weight, (2) User-Weighted.\n",
-    "    Columns for Return(%), Vol(%), Sharpe, Sortino, MaxDD(%).\n",
-    "    For OOS, also show 'before scaling' vs. 'after scaling' returns/vol.\n",
-    "    \"\"\"\n",
-    "    selected_funds = results_dict['selected_funds']\n",
-    "    in_sample_stats = results_dict['in_sample_stats']\n",
-    "    out_sample_stats_scaled = results_dict['out_sample_stats']\n",
-    "    out_sample_stats_raw = results_dict['out_sample_stats_raw']\n",
-    "\n",
-    "    in_ew_stats = results_dict['in_ew_stats']\n",
-    "    out_ew_stats_scaled = results_dict['out_ew_stats']\n",
-    "    out_ew_stats_raw = results_dict['out_ew_stats_raw']\n",
-    "\n",
-    "    in_user_stats = results_dict['in_user_stats']\n",
-    "    out_user_stats_scaled = results_dict['out_user_stats']\n",
-    "    out_user_stats_raw = results_dict['out_user_stats_raw']\n",
-    "\n",
-    "    # --- In-Sample DataFrames ---\n",
-    "    in_eq_data = []\n",
-    "    in_user_data = []\n",
-    "    for fund in selected_funds:\n",
-    "        r, v, s, so, mdd = in_sample_stats[fund]\n",
-    "        in_eq_data.append([fund, r, v, s, so, mdd])\n",
-    "        in_user_data.append([fund, r, v, s, so, mdd])\n",
-    "\n",
-    "    in_eq_data.append([\n",
-    "        'Equal-Weight Portfolio',\n",
-    "        in_ew_stats[0],\n",
-    "        in_ew_stats[1],\n",
-    "        in_ew_stats[2],\n",
-    "        in_ew_stats[3],\n",
-    "        in_ew_stats[4]\n",
-    "    ])\n",
-    "    in_user_data.append([\n",
-    "        'User-Weighted Portfolio',\n",
-    "        in_user_stats[0],\n",
-    "        in_user_stats[1],\n",
-    "        in_user_stats[2],\n",
-    "        in_user_stats[3],\n",
-    "        in_user_stats[4]\n",
-    "    ])\n",
-    "\n",
-    "    in_eq_df = pd.DataFrame(\n",
-    "        in_eq_data,\n",
-    "        columns=['Fund', 'Return (%)', 'Volatility (%)', 'Sharpe', 'Sortino', 'MaxDD (%)']\n",
-    "    )\n",
-    "    in_user_df = pd.DataFrame(\n",
-    "        in_user_data,\n",
-    "        columns=['Fund', 'Return (%)', 'Volatility (%)', 'Sharpe', 'Sortino', 'MaxDD (%)']\n",
-    "    )\n",
-    "\n",
-    "    # --- Out-of-Sample DataFrames ---\n",
-    "    # columns: [Fund, RetBefore(%), VolBefore(%), RetAfter(%), VolAfter(%), Sharpe(After), Sortino(After), MaxDD(After)(%)]\n",
-    "    out_eq_data = []\n",
-    "    out_user_data = []\n",
-    "\n",
-    "    for fund in selected_funds:\n",
-    "        r_raw, v_raw, _, _, _ = out_sample_stats_raw[fund]\n",
-    "        r_scaled, v_scaled, s_scaled, so_scaled, mdd_scaled = out_sample_stats_scaled[fund]\n",
-    "        out_eq_data.append([\n",
-    "            fund,\n",
-    "            r_raw,\n",
-    "            v_raw,\n",
-    "            r_scaled,\n",
-    "            v_scaled,\n",
-    "            s_scaled,\n",
-    "            so_scaled,\n",
-    "            mdd_scaled\n",
-    "        ])\n",
-    "        out_user_data.append([\n",
-    "            fund,\n",
-    "            r_raw,\n",
-    "            v_raw,\n",
-    "            r_scaled,\n",
-    "            v_scaled,\n",
-    "            s_scaled,\n",
-    "            so_scaled,\n",
-    "            mdd_scaled\n",
-    "        ])\n",
-    "\n",
-    "    r_ew_raw, v_ew_raw, _, _, _ = out_ew_stats_raw\n",
-    "    r_ew_scaled, v_ew_scaled, s_ew_scaled, so_ew_scaled, mdd_ew_scaled = out_ew_stats_scaled\n",
-    "    out_eq_data.append([\n",
-    "        'Equal-Weight Portfolio',\n",
-    "        r_ew_raw,\n",
-    "        v_ew_raw,\n",
-    "        r_ew_scaled,\n",
-    "        v_ew_scaled,\n",
-    "        s_ew_scaled,\n",
-    "        so_ew_scaled,\n",
-    "        mdd_ew_scaled\n",
-    "    ])\n",
-    "\n",
-    "    r_user_raw, v_user_raw, _, _, _ = out_user_stats_raw\n",
-    "    r_user_scaled, v_user_scaled, s_user_scaled, so_user_scaled, mdd_user_scaled = out_user_stats_scaled\n",
-    "    out_user_data.append([\n",
-    "        'User-Weighted Portfolio',\n",
-    "        r_user_raw,\n",
-    "        v_user_raw,\n",
-    "        r_user_scaled,\n",
-    "        v_user_scaled,\n",
-    "        s_user_scaled,\n",
-    "        so_user_scaled,\n",
-    "        mdd_user_scaled\n",
-    "    ])\n",
-    "\n",
-    "    out_eq_df = pd.DataFrame(\n",
-    "        out_eq_data,\n",
-    "        columns=['Fund', 'RetBefore(%)', 'VolBefore(%)', 'RetAfter(%)', 'VolAfter(%)', 'Sharpe(After)', 'Sortino(After)', 'MaxDD(After)(%)']\n",
-    "    )\n",
-    "    out_user_df = pd.DataFrame(\n",
-    "        out_user_data,\n",
-    "        columns=['Fund', 'RetBefore(%)', 'VolBefore(%)', 'RetAfter(%)', 'VolAfter(%)', 'Sharpe(After)', 'Sortino(After)', 'MaxDD(After)(%)']\n",
-    "    )\n",
-    "\n",
-    "    writer = pd.ExcelWriter(output_filename, engine='xlsxwriter')\n",
-    "\n",
-    "    # In-Sample Sheet\n",
-    "    in_eq_df.to_excel(writer, sheet_name='In-Sample', startrow=0, index=False)\n",
-    "    in_user_df.to_excel(writer, sheet_name='In-Sample', startrow=len(in_eq_df)+3, index=False)\n",
-    "\n",
-    "    # Out-of-Sample Sheet\n",
-    "    out_eq_df.to_excel(writer, sheet_name='Out-of-Sample', startrow=0, index=False)\n",
-    "    out_user_df.to_excel(writer, sheet_name='Out-of-Sample', startrow=len(out_eq_df)+3, index=False)\n",
-    "\n",
-    "    workbook = writer.book\n",
-    "    pct_format = workbook.add_format({'num_format': '0.0%'})\n",
-    "    decimal_format = workbook.add_format({'num_format': '0.00'})  # for non-percent columns\n",
-    "    bold_format = workbook.add_format({'bold': True})\n",
-    "\n",
-    "    # Format In-Sample\n",
-    "    in_sample_ws = writer.sheets['In-Sample']\n",
-    "    in_sample_ws.set_column(0, 0, 28)  # Fund column\n",
-    "    in_sample_ws.set_column(1, 2, 8, pct_format)\n",
-    "    in_sample_ws.set_column(3, 4, 8, decimal_format)\n",
-    "    in_sample_ws.set_column(5, 5, 8, pct_format)\n",
-    "    \n",
-    "    # Bold headers\n",
-    "    for colx in range(in_eq_df.shape[1]):\n",
-    "        in_sample_ws.write(0, colx, in_eq_df.columns[colx], bold_format)\n",
-    "    for colx in range(in_user_df.shape[1]):\n",
-    "        in_sample_ws.write(len(in_eq_df)+3, colx, in_user_df.columns[colx], bold_format)\n",
-    "\n",
-    "    # Format Out-of-Sample\n",
-    "    out_sample_ws = writer.sheets['Out-of-Sample']\n",
-    "    out_sample_ws.set_column(0, 0, 28)\n",
-    "    out_sample_ws.set_column(1, 7, 15, pct_format)\n",
-    "    for colx in range(out_eq_df.shape[1]):\n",
-    "        out_sample_ws.write(0, colx, out_eq_df.columns[colx], bold_format)\n",
-    "    for colx in range(out_user_df.shape[1]):\n",
-    "        out_sample_ws.write(len(out_eq_df)+3, colx, out_user_df.columns[colx], bold_format)\n",
-    "\n",
-    "    writer.close()\n",
-    "    logging.info(f\"Exported analysis to {output_filename} successfully.\")\n",
-    "    print(f\"Excel file created: {output_filename}\")\n",
-    "\n",
-    "print(\"export_to_excel function ready.\")"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "ee8c2c6d",
-   "metadata": {},
-   "source": [
-    "## 8. Run Parameters"
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": 9,
-   "id": "d7b7c730-225c-4c69-9dbf-d1ec9971a26f",
-   "metadata": {
-    "scrolled": true
-   },
-   "outputs": [
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "e390c0e0510241e0b0fd824f2da08e54",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "VBox(children=(VBox(children=(Text(value='2005-07', description='In-Sample Start:'), Text(value='2008-06', des…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    },
-    {
-     "data": {
-      "application/vnd.jupyter.widget-view+json": {
-       "model_id": "09de5d61dfaa4ab3bda2192bbd07a991",
-       "version_major": 2,
-       "version_minor": 0
-      },
-      "text/plain": [
-       "Output(layout=Layout(border_bottom='1px solid gray', border_left='1px solid gray', border_right='1px solid gra…"
-      ]
-     },
-     "metadata": {},
-     "output_type": "display_data"
-    }
-   ],
-   "source": [
-    "# Because we set fund_select.layout.display='none' above, it starts out hidden.\n",
-    "display(master_vbox, output_area)"
-   ]
-  },
-  {
-   "cell_type": "markdown",
-   "id": "86794206",
-   "metadata": {},
-   "source": [
-    "### Using This Notebook\n",
-    "1. Run all cells.\n",
-    "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-    "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-    "4. For interactive selection, do:\n",
-    "   ```python\n",
-    "   display(ui_inputs)\n",
-    "   ```\n",
-    "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-    "5. For custom weights, call:\n",
-    "   ```python\n",
-    "   my_weights = get_custom_weights(selected_funds)\n",
-    "   ```\n",
-    "   Then pass `my_weights` into your logic.\n"
-   ]
-  }
- ],
- "metadata": {
-  "kernelspec": {
-   "display_name": "Python (base)",
-   "language": "python",
-   "name": "base"
-  },
-  "language_info": {
-   "codemirror_mode": {
-    "name": "ipython",
-    "version": 3
-   },
-   "file_extension": ".py",
-   "mimetype": "text/x-python",
-   "name": "python",
-   "nbconvert_exporter": "python",
-   "pygments_lexer": "ipython3",
-   "version": "3.12.2"
-  }
- },
- "nbformat": 4,
- "nbformat_minor": 5
-}
diff --git a/.ipynb_checkpoints/trend_portfolio_analysis_order_fixed-checkpoint.ipynb b/.ipynb_checkpoints/trend_portfolio_analysis_order_fixed-checkpoint.ipynb
deleted file mode 100644
index 8a5b75e7df2c5785b0345cc91275b975ba619369..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/trend_portfolio_analysis_order_fixed-checkpoint.ipynb
+++ /dev/null
@@ -1,661 +0,0 @@
-{
-  "cells": [
-    {
-      "cell_type": "code",
-      "execution_count": 1,
-      "id": "4896c7dd",
-      "metadata": {
-        "colab": {
-          "base_uri": "https://localhost:8080/",
-          "height": 194
-        },
-        "id": "4896c7dd",
-        "outputId": "25b623df-3f7c-49c7-9bc2-9f32dc1f90df"
-      },
-      "outputs": [
-        {
-          "output_type": "stream",
-          "name": "stdout",
-          "text": [
-            "Trend Portfolio Analysis v1.0.0\n",
-            "✓ Uploading CSV file…\n"
-          ]
-        },
-        {
-          "output_type": "display_data",
-          "data": {
-            "text/plain": [
-              "<IPython.core.display.HTML object>"
-            ],
-            "text/html": [
-              "\n",
-              "     <input type=\"file\" id=\"files-b0b7c599-feb7-4395-b6dd-1d5703d7a513\" name=\"files[]\" multiple disabled\n",
-              "        style=\"border:none\" />\n",
-              "     <output id=\"result-b0b7c599-feb7-4395-b6dd-1d5703d7a513\">\n",
-              "      Upload widget is only available when the cell has been executed in the\n",
-              "      current browser session. Please rerun this cell to enable.\n",
-              "      </output>\n",
-              "      <script>// Copyright 2017 Google LLC\n",
-              "//\n",
-              "// Licensed under the Apache License, Version 2.0 (the \"License\");\n",
-              "// you may not use this file except in compliance with the License.\n",
-              "// You may obtain a copy of the License at\n",
-              "//\n",
-              "//      http://www.apache.org/licenses/LICENSE-2.0\n",
-              "//\n",
-              "// Unless required by applicable law or agreed to in writing, software\n",
-              "// distributed under the License is distributed on an \"AS IS\" BASIS,\n",
-              "// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n",
-              "// See the License for the specific language governing permissions and\n",
-              "// limitations under the License.\n",
-              "\n",
-              "/**\n",
-              " * @fileoverview Helpers for google.colab Python module.\n",
-              " */\n",
-              "(function(scope) {\n",
-              "function span(text, styleAttributes = {}) {\n",
-              "  const element = document.createElement('span');\n",
-              "  element.textContent = text;\n",
-              "  for (const key of Object.keys(styleAttributes)) {\n",
-              "    element.style[key] = styleAttributes[key];\n",
-              "  }\n",
-              "  return element;\n",
-              "}\n",
-              "\n",
-              "// Max number of bytes which will be uploaded at a time.\n",
-              "const MAX_PAYLOAD_SIZE = 100 * 1024;\n",
-              "\n",
-              "function _uploadFiles(inputId, outputId) {\n",
-              "  const steps = uploadFilesStep(inputId, outputId);\n",
-              "  const outputElement = document.getElementById(outputId);\n",
-              "  // Cache steps on the outputElement to make it available for the next call\n",
-              "  // to uploadFilesContinue from Python.\n",
-              "  outputElement.steps = steps;\n",
-              "\n",
-              "  return _uploadFilesContinue(outputId);\n",
-              "}\n",
-              "\n",
-              "// This is roughly an async generator (not supported in the browser yet),\n",
-              "// where there are multiple asynchronous steps and the Python side is going\n",
-              "// to poll for completion of each step.\n",
-              "// This uses a Promise to block the python side on completion of each step,\n",
-              "// then passes the result of the previous step as the input to the next step.\n",
-              "function _uploadFilesContinue(outputId) {\n",
-              "  const outputElement = document.getElementById(outputId);\n",
-              "  const steps = outputElement.steps;\n",
-              "\n",
-              "  const next = steps.next(outputElement.lastPromiseValue);\n",
-              "  return Promise.resolve(next.value.promise).then((value) => {\n",
-              "    // Cache the last promise value to make it available to the next\n",
-              "    // step of the generator.\n",
-              "    outputElement.lastPromiseValue = value;\n",
-              "    return next.value.response;\n",
-              "  });\n",
-              "}\n",
-              "\n",
-              "/**\n",
-              " * Generator function which is called between each async step of the upload\n",
-              " * process.\n",
-              " * @param {string} inputId Element ID of the input file picker element.\n",
-              " * @param {string} outputId Element ID of the output display.\n",
-              " * @return {!Iterable<!Object>} Iterable of next steps.\n",
-              " */\n",
-              "function* uploadFilesStep(inputId, outputId) {\n",
-              "  const inputElement = document.getElementById(inputId);\n",
-              "  inputElement.disabled = false;\n",
-              "\n",
-              "  const outputElement = document.getElementById(outputId);\n",
-              "  outputElement.innerHTML = '';\n",
-              "\n",
-              "  const pickedPromise = new Promise((resolve) => {\n",
-              "    inputElement.addEventListener('change', (e) => {\n",
-              "      resolve(e.target.files);\n",
-              "    });\n",
-              "  });\n",
-              "\n",
-              "  const cancel = document.createElement('button');\n",
-              "  inputElement.parentElement.appendChild(cancel);\n",
-              "  cancel.textContent = 'Cancel upload';\n",
-              "  const cancelPromise = new Promise((resolve) => {\n",
-              "    cancel.onclick = () => {\n",
-              "      resolve(null);\n",
-              "    };\n",
-              "  });\n",
-              "\n",
-              "  // Wait for the user to pick the files.\n",
-              "  const files = yield {\n",
-              "    promise: Promise.race([pickedPromise, cancelPromise]),\n",
-              "    response: {\n",
-              "      action: 'starting',\n",
-              "    }\n",
-              "  };\n",
-              "\n",
-              "  cancel.remove();\n",
-              "\n",
-              "  // Disable the input element since further picks are not allowed.\n",
-              "  inputElement.disabled = true;\n",
-              "\n",
-              "  if (!files) {\n",
-              "    return {\n",
-              "      response: {\n",
-              "        action: 'complete',\n",
-              "      }\n",
-              "    };\n",
-              "  }\n",
-              "\n",
-              "  for (const file of files) {\n",
-              "    const li = document.createElement('li');\n",
-              "    li.append(span(file.name, {fontWeight: 'bold'}));\n",
-              "    li.append(span(\n",
-              "        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n",
-              "        `last modified: ${\n",
-              "            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n",
-              "                                    'n/a'} - `));\n",
-              "    const percent = span('0% done');\n",
-              "    li.appendChild(percent);\n",
-              "\n",
-              "    outputElement.appendChild(li);\n",
-              "\n",
-              "    const fileDataPromise = new Promise((resolve) => {\n",
-              "      const reader = new FileReader();\n",
-              "      reader.onload = (e) => {\n",
-              "        resolve(e.target.result);\n",
-              "      };\n",
-              "      reader.readAsArrayBuffer(file);\n",
-              "    });\n",
-              "    // Wait for the data to be ready.\n",
-              "    let fileData = yield {\n",
-              "      promise: fileDataPromise,\n",
-              "      response: {\n",
-              "        action: 'continue',\n",
-              "      }\n",
-              "    };\n",
-              "\n",
-              "    // Use a chunked sending to avoid message size limits. See b/62115660.\n",
-              "    let position = 0;\n",
-              "    do {\n",
-              "      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n",
-              "      const chunk = new Uint8Array(fileData, position, length);\n",
-              "      position += length;\n",
-              "\n",
-              "      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n",
-              "      yield {\n",
-              "        response: {\n",
-              "          action: 'append',\n",
-              "          file: file.name,\n",
-              "          data: base64,\n",
-              "        },\n",
-              "      };\n",
-              "\n",
-              "      let percentDone = fileData.byteLength === 0 ?\n",
-              "          100 :\n",
-              "          Math.round((position / fileData.byteLength) * 100);\n",
-              "      percent.textContent = `${percentDone}% done`;\n",
-              "\n",
-              "    } while (position < fileData.byteLength);\n",
-              "  }\n",
-              "\n",
-              "  // All done.\n",
-              "  yield {\n",
-              "    response: {\n",
-              "      action: 'complete',\n",
-              "    }\n",
-              "  };\n",
-              "}\n",
-              "\n",
-              "scope.google = scope.google || {};\n",
-              "scope.google.colab = scope.google.colab || {};\n",
-              "scope.google.colab._files = {\n",
-              "  _uploadFiles,\n",
-              "  _uploadFilesContinue,\n",
-              "};\n",
-              "})(self);\n",
-              "</script> "
-            ]
-          },
-          "metadata": {}
-        },
-        {
-          "output_type": "stream",
-          "name": "stdout",
-          "text": [
-            "Saving hedge_fund_returns_with_indexes.csv to hedge_fund_returns_with_indexes.csv\n",
-            "✓ Loaded CSV: hedge_fund_returns_with_indexes.csv\n",
-            "✓ Auto-detecting fund lifetimes and truncating post-exit data…\n",
-            "✓ Separating risk-free rate and fund returns…\n",
-            "✓ Loading configuration…\n",
-            "Configuration: {}\n"
-          ]
-        }
-      ],
-      "source": [
-        "# === Setup & Configuration ===\n",
-        "__version__ = \"1.0.0\"\n",
-        "print(f\"Trend Portfolio Analysis v{__version__}\")\n",
-        "\n",
-        "import pandas as pd\n",
-        "import numpy as np\n",
-        "import yaml\n",
-        "import os\n",
-        "import warnings\n",
-        "from datetime import datetime\n",
-        "from dateutil.relativedelta import relativedelta\n",
-        "from pandas.tseries.offsets import DateOffset\n",
-        "from google.colab import files\n",
-        "\n",
-        "warnings.filterwarnings(\"ignore\")\n",
-        "\n",
-        "# 1) Upload & read CSV\n",
-        "print(\"✓ Uploading CSV file…\")\n",
-        "uploaded = files.upload()\n",
-        "csv_path = next(iter(uploaded))\n",
-        "print(f\"✓ Loaded CSV: {csv_path}\")\n",
-        "\n",
-        "# Robust file reading: handle CSV or Excel\n",
-        "import pandas as pd\n",
-        "import os\n",
-        "file_ext = os.path.splitext(csv_path)[1].lower()\n",
-        "if file_ext in ('.xls', '.xlsx', '.xlsm'):\n",
-        "    raw_df = pd.read_excel(csv_path, index_col=0)\n",
-        "else:\n",
-        "    try:\n",
-        "        raw_df = pd.read_csv(csv_path, index_col=0, na_values=[''])\n",
-        "    except pd.errors.ParserError:\n",
-        "        # fallback: infer delimiter\n",
-        "        raw_df = pd.read_csv(csv_path, index_col=0, sep=None, engine='python')\n",
-        "raw_df.index = pd.to_datetime(raw_df.index).to_period('M').to_timestamp('M')\n",
-        "raw_df.replace(r'^\\s*$', np.nan, regex=True, inplace=True)\n",
-        "raw_df.sort_index(inplace=True)\n",
-        "\n",
-        "# 2) Auto-truncate post-exit\n",
-        "print(\"✓ Auto-detecting fund lifetimes and truncating post-exit data…\")\n",
-        "fund_cols = [\n",
-        "    c for c in raw_df.columns\n",
-        "    if c not in (\"Risk_Free\", \"S&P 500\", \"Bloomberg Barclays Agg\", \"60/40 Portfolio\")\n",
-        "       and not c.startswith(\"EqualWeight_\")\n",
-        "]\n",
-        "for fund in fund_cols:\n",
-        "    s = raw_df[fund]\n",
-        "    if not s.dropna().empty:\n",
-        "        exit_dt = s.last_valid_index()\n",
-        "        raw_df.loc[raw_df.index > exit_dt, fund] = np.nan\n",
-        "\n",
-        "# 3) Split out series\n",
-        "print(\"✓ Separating risk-free rate and fund returns…\")\n",
-        "rf_series    = raw_df.iloc[:, 0]\n",
-        "fund_returns = raw_df[fund_cols]\n",
-        "\n",
-        "# 4) Load YAML config\n",
-        "print(\"✓ Loading configuration…\")\n",
-        "config = {}\n",
-        "cfg_path = \"trend_portfolio_config.yaml\"\n",
-        "if os.path.exists(cfg_path):\n",
-        "    with open(cfg_path) as f:\n",
-        "        config = yaml.safe_load(f) or {}\n",
-        "print(\"Configuration:\", config)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 2,
-      "id": "e0b938ad",
-      "metadata": {
-        "id": "e0b938ad"
-      },
-      "outputs": [],
-      "source": [
-        "# === Utility Functions ===\n",
-        "import pandas as pd\n",
-        "import numpy as np\n",
-        "from pandas.tseries.offsets import DateOffset\n",
-        "\n",
-        "def parse_ym(ym_str):\n",
-        "    \"\"\"Parse 'YYYY-MM' into a month-end Timestamp.\"\"\"\n",
-        "    return pd.to_datetime(ym_str + '-01').to_period('M').to_timestamp('M')\n",
-        "\n",
-        "def select_funds_with_complete_data(returns, start_date, end_date):\n",
-        "    \"\"\"Return funds with complete in-sample and out-of-sample data.\"\"\"\n",
-        "    from pandas.tseries.offsets import DateOffset\n",
-        "\n",
-        "    out_start = end_date + DateOffset(months=1)\n",
-        "    out_end   = out_start + DateOffset(months=11)\n",
-        "\n",
-        "    # Exclude any risk-free column\n",
-        "    funds = [\n",
-        "        f for f in returns.columns\n",
-        "        if f.lower() not in (\"risk_free\", \"rf\", \"risk free\")\n",
-        "    ]\n",
-        "\n",
-        "    valid = []\n",
-        "    for f in funds:\n",
-        "        s = returns[f]\n",
-        "        if (\n",
-        "            s.loc[start_date:end_date].notna().all()\n",
-        "            and s.loc[out_start:out_end].notna().all()\n",
-        "        ):\n",
-        "            valid.append(f)\n",
-        "\n",
-        "    print(f\"✓ Filtered {len(valid)}/{len(funds)} eligible funds\")\n",
-        "    return valid\n",
-        "\n",
-        "def adjust_returns(raw_returns, target_vol, leverage_cost):\n",
-        "    \"\"\"Scale returns to target volatility, subtract cost.\"\"\"\n",
-        "    ann_vol = raw_returns.std() * np.sqrt(12)\n",
-        "    factor = target_vol / ann_vol\n",
-        "    factor = factor.replace([np.inf, -np.inf], 0).fillna(0)\n",
-        "    return raw_returns.multiply(factor, axis=1).sub(leverage_cost)\n",
-        "\n",
-        "def compute_summary_stats(df, rf):\n",
-        "    \"\"\"Compute annualized return, volatility, and Sharpe ratio per fund.\"\"\"\n",
-        "    # Annualized return per fund\n",
-        "    ann_return      = ((1 + df).prod() ** (12 / len(df))) - 1\n",
-        "    # Annualized volatility per fund\n",
-        "    ann_volatility  = df.std() * np.sqrt(12)\n",
-        "    # Excess return per fund\n",
-        "    excess_return   = ann_return - (rf.mean() * 12)\n",
-        "    # Sharpe ratio per fund\n",
-        "    sharpe          = excess_return / ann_volatility\n",
-        "    # Build DataFrame: one row per fund\n",
-        "    return pd.DataFrame({\n",
-        "        \"Ann Return\":      ann_return * 100,\n",
-        "        \"Ann Volatility\":  ann_volatility * 100,\n",
-        "        \"Sharpe Ratio\":    sharpe\n",
-        "    })\n",
-        "def compute_portfolio_stats(df, rf, weights):\n",
-        "    \"\"\"Compute portfolio stats given weights.\"\"\"\n",
-        "    # Robustness check: make sure Risk_Free isn't in df.columns\n",
-        "    if any(col.lower() in (\"risk_free\",\"rf\",\"risk free\") for col in df.columns):\n",
-        "        raise ValueError(\"Risk-free rate must not be included among portfolio funds\")\n",
-        "    port = df.dot(weights)"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 6,
-      "id": "ce3a7896",
-      "metadata": {
-        "id": "ce3a7896"
-      },
-      "outputs": [],
-      "source": [
-        "def export_to_excel_bt_os(stats_bt, stats_os,\n",
-        "                          port_bt, port_os,\n",
-        "                          path,\n",
-        "                          start_date, end_date,\n",
-        "                          out_start, out_end,\n",
-        "                          selected_funds):\n",
-        "    \"\"\"\n",
-        "    Export in-sample (BT) and out-of-sample (OS) stats and portfolio stats\n",
-        "    to a styled Excel file, then validate row counts.\n",
-        "    \"\"\"\n",
-        "\n",
-        "    # --- Prepare DataFrames with Fund column ---\n",
-        "    df_bt = stats_bt.copy().reset_index().rename(columns={'index': 'Fund'})\n",
-        "    df_os = stats_os.copy().reset_index().rename(columns={'index': 'Fund'})\n",
-        "\n",
-        "    # Portfolio rows\n",
-        "    port_bt_df = pd.DataFrame([port_bt]).reset_index().rename(columns={'index': 'Fund'})\n",
-        "    port_os_df = pd.DataFrame([port_os]).reset_index().rename(columns={'index': 'Fund'})\n",
-        "    port_bt_df['Fund'] = 'Equal Weight Portfolio'\n",
-        "    port_os_df['Fund'] = 'Equal Weight Portfolio'\n",
-        "\n",
-        "    # Concat funds + portfolio\n",
-        "    df_bt = pd.concat([df_bt, port_bt_df], ignore_index=True)\n",
-        "    df_os = pd.concat([df_os, port_os_df], ignore_index=True)\n",
-        "\n",
-        "    # Convert percentage columns back to decimals for Excel formatting\n",
-        "    df_bt['Ann Return']     = (df_bt['Ann Return'] / 100).round(3)\n",
-        "    df_bt['Ann Volatility'] = (df_bt['Ann Volatility'] / 100).round(3)\n",
-        "    df_bt['Sharpe Ratio']   = df_bt['Sharpe Ratio'].round(2)\n",
-        "\n",
-        "    df_os['Ann Return']     = (df_os['Ann Return'] / 100).round(3)\n",
-        "    df_os['Ann Volatility'] = (df_os['Ann Volatility'] / 100).round(3)\n",
-        "    df_os['Sharpe Ratio']   = df_os['Sharpe Ratio'].round(2)\n",
-        "\n",
-        "    # --- Write to Excel with styling ---\n",
-        "    with pd.ExcelWriter(path, engine='xlsxwriter') as writer:\n",
-        "        workbook = writer.book\n",
-        "\n",
-        "        # Formats\n",
-        "        title_fmt  = workbook.add_format({'bold': True, 'font_size': 14, 'align': 'center'})\n",
-        "        header_fmt = workbook.add_format({'bold': True, 'bg_color': '#D7E4BC',\n",
-        "                                          'border': 1, 'align': 'center'})\n",
-        "        pct_fmt    = workbook.add_format({'num_format': '0.0%', 'border': 1})\n",
-        "        dec2_fmt   = workbook.add_format({'num_format': '0.00', 'border': 1})\n",
-        "\n",
-        "        def write_sheet(df, sheet_name, title_text):\n",
-        "            ws = workbook.add_worksheet(sheet_name)\n",
-        "            writer.sheets[sheet_name] = ws\n",
-        "\n",
-        "            # Merged title row A1:D1\n",
-        "            ws.merge_range('A1:D1', title_text, title_fmt)\n",
-        "\n",
-        "            # Write the DataFrame starting at row 3 (zero-indexed row 2)\n",
-        "            df.to_excel(writer, sheet_name=sheet_name, startrow=2, index=False)\n",
-        "\n",
-        "            # Header row formatting\n",
-        "            for col_idx, col in enumerate(df.columns):\n",
-        "                ws.write(2, col_idx, col, header_fmt)\n",
-        "\n",
-        "            # Column widths & formats\n",
-        "            ws.set_column('A:A', 30)       # Fund\n",
-        "            ws.set_column('B:B', 15, pct_fmt)  # Ann Return\n",
-        "            ws.set_column('C:C', 18, pct_fmt)  # Ann Volatility\n",
-        "            ws.set_column('D:D', 15, dec2_fmt) # Sharpe Ratio\n",
-        "\n",
-        "            # Freeze panes below header\n",
-        "            ws.freeze_panes(3, 0)\n",
-        "\n",
-        "            # Autofilter on header row\n",
-        "            ws.autofilter(2, 0, 2 + len(df), len(df.columns) - 1)\n",
-        "\n",
-        "        # In-Sample sheet\n",
-        "        bt_name = f\"{start_date.strftime('%y-%m')}-{end_date.strftime('%y-%m')} BT\"\n",
-        "        bt_title = f\"In-Sample Results ({start_date.strftime('%Y-%m')} to {end_date.strftime('%Y-%m')})\"\n",
-        "        write_sheet(df_bt, bt_name, bt_title)\n",
-        "\n",
-        "        # Out-of-Sample sheet\n",
-        "        os_name = f\"{out_start.strftime('%y-%m')}-{out_end.strftime('%y-%m')} OS\"\n",
-        "        os_title = f\"Out-of-Sample Results ({out_start.strftime('%Y-%m')} to {out_end.strftime('%Y-%m')})\"\n",
-        "        write_sheet(df_os, os_name, os_title)\n",
-        "\n",
-        "    print(f\"✅ Exported styled Excel results to {path}\")\n",
-        "\n",
-        ""
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 7,
-      "id": "f66bd626",
-      "metadata": {
-        "colab": {
-          "base_uri": "https://localhost:8080/"
-        },
-        "id": "f66bd626",
-        "outputId": "b9ea766e-5f13-457c-c782-25dc9855964f"
-      },
-      "outputs": [
-        {
-          "output_type": "stream",
-          "name": "stdout",
-          "text": [
-            "Enter start date (YYYY-MM): 2005-07\n",
-            "Enter end date (YYYY-MM): 2008-06\n",
-            "Target volatility (e.g. 0.10): .25\n",
-            "Leverage cost (e.g. 0.0025): .003\n",
-            "Selection mode [all/random/manual]: random\n",
-            "✓ Selection mode: random\n",
-            "Sample size (if random): 15\n",
-            "✓ Parameter validation complete\n"
-          ]
-        }
-      ],
-      "source": [
-        "# === Validate & Input Parameters ===\n",
-        "from pandas.tseries.offsets import DateOffset\n",
-        "\n",
-        "# Helper to pull from config or prompt\n",
-        "def get_param(key, prompt):\n",
-        "    val = config.get(key, \"\")\n",
-        "    while not val:\n",
-        "        val = input(f\"{prompt}\").strip()\n",
-        "    return val\n",
-        "\n",
-        "# Dates\n",
-        "start_date = parse_ym(get_param(\"start_date\", \"Enter start date (YYYY-MM): \"))\n",
-        "end_date   = parse_ym(get_param(\"end_date\",   \"Enter end date (YYYY-MM): \"))\n",
-        "if start_date >= end_date:\n",
-        "    raise ValueError(\"start_date must be before end_date\")\n",
-        "\n",
-        "# Target volatility\n",
-        "target_vol = float(get_param(\"target_volatility\", \"Target volatility (e.g. 0.10): \"))\n",
-        "if target_vol <= 0:\n",
-        "    raise ValueError(\"target_volatility must be > 0\")\n",
-        "\n",
-        "# Leverage cost\n",
-        "leverage_cost = float(get_param(\"leverage_cost\", \"Leverage cost (e.g. 0.0025): \"))\n",
-        "if leverage_cost < 0:\n",
-        "    raise ValueError(\"leverage_cost must be >= 0\")\n",
-        "\n",
-        "# Selection mode\n",
-        "selection_mode = get_param(\"selection_mode\", \"Selection mode [all/random/manual]: \").lower()\n",
-        "if selection_mode not in (\"all\", \"random\", \"manual\"):\n",
-        "    raise ValueError(\"selection_mode must be one of all, random, manual\")\n",
-        "print(f\"✓ Selection mode: {selection_mode}\")\n",
-        "\n",
-        "# Sample size\n",
-        "sample_size = int(get_param(\"sample_size\", \"Sample size (if random): \"))\n",
-        "if sample_size <= 0:\n",
-        "    raise ValueError(\"sample_size must be > 0\")\n",
-        "\n",
-        "# Out-of-sample window check\n",
-        "out_start = end_date + DateOffset(months=1)\n",
-        "out_end   = out_start   + DateOffset(months=11)\n",
-        "last_date = fund_returns.index.max()\n",
-        "if out_end > last_date:\n",
-        "    raise ValueError(f\"OOS end {out_end.date()} exceeds data max {last_date.date()}\")\n",
-        "print(\"✓ Parameter validation complete\")\n"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 8,
-      "id": "59771a04",
-      "metadata": {
-        "colab": {
-          "base_uri": "https://localhost:8080/"
-        },
-        "id": "59771a04",
-        "outputId": "88161e41-41ae-4b9b-ba5a-955a7b7fd9db"
-      },
-      "outputs": [
-        {
-          "output_type": "stream",
-          "name": "stdout",
-          "text": [
-            "✓ Filtered 28/101 eligible funds\n",
-            "✓ Randomly selected 15 funds\n",
-            "✓ Returns adjusted\n",
-            "✓ Summary statistics computed\n",
-            "✓ Portfolio statistics computed\n"
-          ]
-        }
-      ],
-      "source": [
-        "# === Main Execution ===\n",
-        "# Select funds\n",
-        "if selection_mode == \"all\":\n",
-        "    selected_funds = select_funds_with_complete_data(fund_returns, start_date, end_date)\n",
-        "elif selection_mode == \"random\":\n",
-        "    eligible = select_funds_with_complete_data(fund_returns, start_date, end_date)\n",
-        "    selected_funds = list(np.random.choice(eligible, size=min(sample_size,len(eligible)), replace=False))\n",
-        "    print(f\"✓ Randomly selected {len(selected_funds)} funds\")\n",
-        "else:  # manual\n",
-        "    import ipywidgets as widgets\n",
-        "    from IPython.display import display, clear_output\n",
-        "    checkboxes = [widgets.Checkbox(f, False) for f in fund_returns.columns]\n",
-        "    button = widgets.Button(description=\"Confirm Selection\")\n",
-        "    out = widgets.Output()\n",
-        "    def confirm(b):\n",
-        "        with out:\n",
-        "            clear_output()\n",
-        "            global selected_funds\n",
-        "            selected_funds = [cb.description for cb in checkboxes if cb.value]\n",
-        "            if not selected_funds:\n",
-        "                print(\"Error: At least one fund must be selected\")\n",
-        "            else:\n",
-        "                print(f\"✓ Manual selection: {len(selected_funds)} funds\")\n",
-        "    button.on_click(confirm)\n",
-        "    display(widgets.VBox(checkboxes + [button, out]))\n",
-        "\n",
-        "# Wait for manual selection if needed\n",
-        "    time.sleep(1)\n",
-        "\n",
-        "# Compute returns slices\n",
-        "returns_bt = fund_returns[selected_funds].loc[start_date:end_date]\n",
-        "returns_os = fund_returns[selected_funds].loc[out_start:out_end]\n",
-        "\n",
-        "# Adjust returns\n",
-        "adj_bt = adjust_returns(returns_bt, target_vol, leverage_cost)\n",
-        "adj_os = adjust_returns(returns_os, target_vol, leverage_cost)\n",
-        "print(\"✓ Returns adjusted\")\n",
-        "\n",
-        "# Compute stats\n",
-        "stats_bt = compute_summary_stats(adj_bt, rf_series.loc[start_date:end_date])\n",
-        "stats_os = compute_summary_stats(adj_os, rf_series.loc[out_start:out_end])\n",
-        "print(\"✓ Summary statistics computed\")\n",
-        "\n",
-        "# Portfolio stats\n",
-        "weights = np.repeat(1/len(selected_funds), len(selected_funds))\n",
-        "port_bt = compute_portfolio_stats(adj_bt, rf_series.loc[start_date:end_date], weights)\n",
-        "port_os = compute_portfolio_stats(adj_os, rf_series.loc[out_start:out_end], weights)\n",
-        "print(\"✓ Portfolio statistics computed\")"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 13,
-      "id": "7f7237ce",
-      "metadata": {
-        "colab": {
-          "base_uri": "https://localhost:8080/"
-        },
-        "id": "7f7237ce",
-        "outputId": "2a21304c-9170-4fd9-f119-4a47e97a4213"
-      },
-      "outputs": [
-        {
-          "output_type": "stream",
-          "name": "stdout",
-          "text": [
-            "Requirement already satisfied: xlsxwriter in /usr/local/lib/python3.11/dist-packages (3.2.3)\n",
-            "✅ Exported styled Excel results to Trend_Portfolio_Results_v1.0.0_20250530_0043.xlsx\n"
-          ]
-        }
-      ],
-      "source": [
-        "!pip install xlsxwriter\n",
-        "# === Export Results ===\n",
-        "timestamp = datetime.now().strftime(\"%Y%m%d_%H%M\")\n",
-        "output_file = f\"Trend_Portfolio_Results_v{__version__}_{timestamp}.xlsx\"\n",
-        "export_to_excel_bt_os(stats_bt, stats_os, port_bt, port_os, output_file, start_date, end_date, out_start, out_end, selected_funds)\n",
-        "\n"
-      ]
-    }
-  ],
-  "metadata": {
-    "colab": {
-      "provenance": []
-    },
-    "kernelspec": {
-      "display_name": "Python 3",
-      "name": "python3"
-    },
-    "language_info": {
-      "name": "python"
-    }
-  },
-  "nbformat": 4,
-  "nbformat_minor": 5
-}
\ No newline at end of file
diff --git a/.ipynb_checkpoints/your_notebook-checkpoint.ipynb b/.ipynb_checkpoints/your_notebook-checkpoint.ipynb
deleted file mode 100644
index fb1a38319eacfa6ad111729ece05641377ae134f..0000000000000000000000000000000000000000
--- a/.ipynb_checkpoints/your_notebook-checkpoint.ipynb
+++ /dev/null
@@ -1,4329 +0,0 @@
-{
-  "cells": [
-    {
-      "cell_type": "markdown",
-      "id": "22994893-0193-45bc-b9e3-a97b328ecaea",
-      "metadata": {
-        "id": "22994893-0193-45bc-b9e3-a97b328ecaea"
-      },
-      "source": [
-        "# Volatility Scaling & Portfolio Analysis\n",
-        "\n",
-        "This notebook demonstrates how to:\n",
-        "1. Imports, Data Loader and Rf Detector\n",
-        "2. Select fund (month period logic)\n",
-        "3. Weight prep\n",
-        "4. Core Stats + Run Analysis\n",
-        "5. Export\n",
-        "6. Widget /UI\n",
-        "7. Output in-sample and out-of-sample results to Excel with formatting."
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 1,
-      "id": "30ea203f",
-      "metadata": {
-        "id": "30ea203f",
-        "tags": []
-      },
-      "outputs": [],
-      "source": [
-        "# ===============================================================\n",
-        "#      VOL-ADJ TREND ANALYSIS  –  SINGLE-FILE VERSION\n",
-        "# ===============================================================\n",
-        "\n",
-        "# ───────────────────────────────────────────────────────────────\n",
-        "#  0 · IMPORTS  (all in one place)\n",
-        "# ───────────────────────────────────────────────────────────────\n",
-        "import pandas as pd\n",
-        "import numpy as np\n",
-        "from dataclasses import dataclass, field\n",
-        "from collections import namedtuple\n",
-        "import xlsxwriter\n",
-        "import logging\n",
-        "from io import BytesIO\n",
-        "import ipywidgets as widgets\n",
-        "from IPython.display import display, clear_output\n",
-        "from ipyfilechooser import FileChooser\n",
-        "from typing import List, Dict, Optional, Callable\n",
-        "\n",
-        "logging.getLogger().setLevel(logging.ERROR)\n",
-        "\n",
-        "# ───────────────────────────────────────────────────────────────\n",
-        "#  1 · Class Configurations\n",
-        "# ───────────────────────────────────────────────────────────────\n",
-        "@dataclass\n",
-        "class FundSelectionConfig:\n",
-        "    max_missing_months:         int = 3   # used to replace the “<=3 missing” rule\n",
-        "    max_consecutive_month_gap:  int = 6   # used to replace the “<=6 gap” ruleimplausible_value_limit: float = 1.0\n",
-        "    implausible_value_limit: float  = 1\n",
-        "    outlier_threshold: float = 0.5\n",
-        "    zero_return_threshold: float = 0.2\n",
-        "    enforce_monotonic_index: bool = True\n",
-        "    allow_duplicate_dates: bool = False\n",
-        "    max_missing_ratio: float      = 0.05\n",
-        "    max_drawdown: float           = 0.3\n",
-        "    min_volatility: float         = 0.05\n",
-        "    max_volatility: float         = 1.0\n",
-        "    min_avg_return: float         = 0.0\n",
-        "    max_skewness: float           = 3.0\n",
-        "    max_kurtosis: float           = 10.0\n",
-        "    expected_freq: str            = \"B\"\n",
-        "    max_gap_days: int             = 3\n",
-        "    min_aum_usd: float            = 1e7\n",
-        "\n",
-        "# Configuration dataclass\n",
-        "@dataclass\n",
-        "class RiskStatsConfig:\n",
-        "    metrics_to_run: List[str] = field(default_factory=lambda: [\n",
-        "        \"AnnualReturn\", \"Volatility\", \"Sharpe\", \"Sortino\", \"MaxDrawdown\"\n",
-        "    ])\n",
-        "    risk_free: float = 0.0\n",
-        "    periods_per_year: int = 12\n",
-        "\n",
-        "# 2. Registry and decorator\n",
-        "METRIC_REGISTRY: Dict[str, Callable[[pd.Series, float, int], float]] = {}\n",
-        "\n",
-        "def register_metric(name: str):\n",
-        "    \"\"\"\n",
-        "    Decorator to register a metric function under a given name.\n",
-        "    \"\"\"\n",
-        "    def decorator(fn: Callable[pd.Series, float]):\n",
-        "        METRIC_REGISTRY[name] = fn\n",
-        "        return fn\n",
-        "    return decorator\n",
-        "\n",
-        "FORMATTERS_EXCEL: dict[str, Callable] = {}\n",
-        "def register_formatter_excel(category: str):\n",
-        "    def decorator(fn: Callable):\n",
-        "        FORMATTERS_EXCEL[category] = fn\n",
-        "        return fn\n",
-        "    return decorator\n",
-        "\n",
-        "# Example formatters (extend as needed)\n",
-        "\n",
-        "def make_summary_formatter(\n",
-        "    res: dict,\n",
-        "    in_start: str,\n",
-        "    in_end: str,\n",
-        "    out_start: str,\n",
-        "    out_end: str\n",
-        "):\n",
-        "    \"\"\"\n",
-        "    Registers a single 'summary' sheet formatter that writes:\n",
-        "      1. Portfolio rows (Equal & User weight),\n",
-        "      2. Blank spacer,\n",
-        "      3. Fund rows,\n",
-        "      4. Blank spacer,\n",
-        "      5. Index rows\n",
-        "    using the data in `res`.\n",
-        "    \"\"\"\n",
-        "    @register_formatter_excel(\"summary\")\n",
-        "    def fmt_summary(ws, wb):\n",
-        "        # Predefine formats\n",
-        "        bold = wb.add_format({\"bold\": True})\n",
-        "        int0 = wb.add_format({\"num_format\": \"0\"})\n",
-        "        num2 = wb.add_format({\"num_format\": \"0.00\"})\n",
-        "        red  = wb.add_format({\"num_format\": \"0.00\", \"font_color\": \"red\"})\n",
-        "        safe = lambda v: \"\" if (pd.isna(v) or not np.isfinite(v)) else v\n",
-        "        pct  = lambda t: [t[0]*100, t[1]*100, t[2], t[3], t[4]*100]\n",
-        "\n",
-        "        # Write static headers\n",
-        "        ws.write_row(0, 0, [\"Vol-Adj Trend Analysis\"], bold)\n",
-        "        ws.write_row(1, 0, [f\"In:  {in_start} → {in_end}\"], bold)\n",
-        "        ws.write_row(2, 0, [f\"Out: {out_start} → {out_end}\"], bold)\n",
-        "\n",
-        "        row = 5\n",
-        "        # 1. Portfolio rows\n",
-        "        for label, in_s, out_s in [\n",
-        "            (\"Equal Weight\", res[\"in_ew_stats\"], res[\"out_ew_stats\"]),\n",
-        "            (\"User Weight\",  res[\"in_user_stats\"], res[\"out_user_stats\"])\n",
-        "        ]:\n",
-        "            ws.write(row, 0, label, bold)\n",
-        "            ws.write(row, 1, safe(\"\") if True else int0)\n",
-        "            vals = pct(tuple(in_s)) + pct(tuple(out_s))\n",
-        "            fmts = ([num2]*4 + [red]) * 2\n",
-        "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-        "                ws.write(row, col, safe(v), fmt)\n",
-        "            row += 1\n",
-        "\n",
-        "        # spacer\n",
-        "        row += 1\n",
-        "\n",
-        "        # 2. Fund rows\n",
-        "        for fund, stat_in in res[\"in_sample_stats\"].items():\n",
-        "            stat_out = res[\"out_sample_stats\"][fund]\n",
-        "            ws.write(row, 0, fund, bold)\n",
-        "            wt = res[\"fund_weights\"][fund]\n",
-        "            ws.write(row, 1, safe(wt*100), int0)\n",
-        "            vals = pct(tuple(stat_in)) + pct(tuple(stat_out))\n",
-        "            fmts = ([num2]*4 + [red]) * 2\n",
-        "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-        "                ws.write(row, col, safe(v), fmt)\n",
-        "            row += 1\n",
-        "\n",
-        "        # spacer\n",
-        "        row += 1\n",
-        "\n",
-        "        # 3. Index rows\n",
-        "        for idx, pair in res.get(\"index_stats\", {}).items():\n",
-        "            in_idx = pair[\"in_sample\"]\n",
-        "            out_idx= pair[\"out_sample\"]\n",
-        "            ws.write(row, 0, idx, bold)\n",
-        "            ws.write(row, 1, safe(\"\") if True else int0)\n",
-        "            vals = pct(tuple(in_idx)) + pct(tuple(out_idx))\n",
-        "            fmts = ([num2]*4 + [red]) * 2\n",
-        "            for col, (v, fmt) in enumerate(zip(vals, fmts), start=2):\n",
-        "                ws.write(row, col, safe(v), fmt)\n",
-        "            row += 1\n",
-        "\n",
-        "    return fmt_summary\n",
-        "\n",
-        "# ───────────────────────────────────────────────────────────────\n",
-        "#  2 · CSV LOADER + RF DETECTOR\n",
-        "# ───────────────────────────────────────────────────────────────\n",
-        "logger = logging.getLogger(__name__)\n",
-        "\n",
-        "def load_csv(path: str) -> pd.DataFrame | None:\n",
-        "    try:\n",
-        "        df = pd.read_csv(path)\n",
-        "    except FileNotFoundError as e:\n",
-        "        logger.error(f\"File not found: {path}\")\n",
-        "        return None\n",
-        "    except pd.errors.EmptyDataError:\n",
-        "        logger.error(f\"No data in file: {path}\")\n",
-        "        return None\n",
-        "    except pd.errors.ParserError as e:\n",
-        "        logger.error(f\"Parsing error in {path}: {e}\")\n",
-        "        return None\n",
-        "\n",
-        "    if \"Date\" not in df.columns:\n",
-        "        logger.error(f\"Validation failed ({path}): missing 'Date' column\")\n",
-        "        return None\n",
-        "\n",
-        "    # Optionally check for NaNs in 'Date' column\n",
-        "    if df[\"Date\"].isnull().any():\n",
-        "        logger.warning(f\"Null values found in 'Date' column of {path}\")\n",
-        "\n",
-        "    return df\n",
-        "\n",
-        "def identify_risk_free_fund(df: pd.DataFrame) -> str:\n",
-        "    returns = df.drop(columns=\"Date\", errors=\"ignore\")\n",
-        "    stdevs  = returns.std(skipna=True, ddof=0)\n",
-        "    return stdevs.idxmin()"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c",
-      "metadata": {
-        "id": "9e7a576b-aa3f-42e0-bfdc-f4a950b7d97c"
-      },
-      "source": [
-        "## 2. Select Funds"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 2,
-      "id": "ff528d69-5a52-4b75-8af4-17974826f4ab",
-      "metadata": {
-        "id": "ff528d69-5a52-4b75-8af4-17974826f4ab"
-      },
-      "outputs": [],
-      "source": [
-        "# ===============================================================\n",
-        "# 2 · SELECT_FUNDS  (restored ≤ 3-missing-months rule)\n",
-        "# ===============================================================\n",
-        "\n",
-        "cfg = FundSelectionConfig(\n",
-        "    max_missing_months           = 3,\n",
-        "    max_consecutive_month_gap    = 6,\n",
-        "    outlier_threshold            = 0.5,\n",
-        "    zero_return_threshold        = 0.2,\n",
-        "    enforce_monotonic_index      = True,\n",
-        "    allow_duplicate_dates        = False,\n",
-        "    max_missing_ratio            = 0.05,\n",
-        "    max_drawdown                 = 0.3,\n",
-        "    min_volatility               = 0.05,\n",
-        "    max_volatility               = 1.0,\n",
-        "    min_avg_return               = 0.0,\n",
-        "    max_skewness                 = 3.0,\n",
-        "    max_kurtosis                 = 10.0,\n",
-        "    expected_freq                = \"B\",\n",
-        "    max_gap_days                 = 3,\n",
-        "    min_aum_usd                  = 1e7,\n",
-        ")\n",
-        "\n",
-        "def select_funds(\n",
-        "    df: pd.DataFrame,\n",
-        "    rf_col: str,\n",
-        "    fund_columns: list[str],\n",
-        "    in_sdate: str,\n",
-        "    in_edate: str,\n",
-        "    out_sdate: str,\n",
-        "    out_edate: str,\n",
-        "    cfg: FundSelectionConfig,\n",
-        "    selection_mode: str = \"all\",\n",
-        "    random_n: int | None = None\n",
-        ") -> list[str]:\n",
-        "    \"\"\"\n",
-        "    Select eligible funds with additional data-validity and coverage checks driven by FundSelectionConfig.\n",
-        "    \"\"\"\n",
-        "    # Ensure Date is datetime and sorted\n",
-        "    if not pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-        "        df = df.copy()\n",
-        "        df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-        "        df.dropna(subset=[\"Date\"], inplace=True)\n",
-        "    df = df.sort_values(\"Date\")  # guarantee monotonic index\n",
-        "\n",
-        "    # Prepare monthly periods within analysis window\n",
-        "    df[\"Month\"] = df[\"Date\"].dt.to_period(\"M\")\n",
-        "    span = pd.period_range(\n",
-        "        pd.Period(in_sdate, \"M\"), pd.Period(out_edate, \"M\"), freq=\"M\"\n",
-        "    )\n",
-        "\n",
-        "    eligible_funds: list[str] = []\n",
-        "    for f in fund_columns:\n",
-        "        try:\n",
-        "            ser = df.set_index(\"Date\")[f]\n",
-        "            clean = ser.dropna()\n",
-        "\n",
-        "            # 1. Implausible value limits\n",
-        "            if not clean.between(-cfg.implausible_value_limit, cfg.implausible_value_limit).all():\n",
-        "                raise ValueError(f\"Values outside ±{cfg.implausible_value_limit}\")\n",
-        "\n",
-        "            # 2. Extreme outlier threshold\n",
-        "            if (clean.abs() > cfg.outlier_threshold).any():\n",
-        "                raise ValueError(f\"Outliers beyond ±{cfg.outlier_threshold}\")\n",
-        "\n",
-        "            # 3. Excessive zero-return rate\n",
-        "            if (clean == 0).mean() > cfg.zero_return_threshold:\n",
-        "                raise ValueError(f\"Zero-return proportion > {cfg.zero_return_threshold}\")\n",
-        "\n",
-        "            # 4. Monotonic date index\n",
-        "            if cfg.enforce_monotonic_index and not clean.index.is_monotonic_increasing:\n",
-        "                raise ValueError(\"Date index not monotonically increasing\")\n",
-        "\n",
-        "            # 5. Duplicate dates\n",
-        "            if not cfg.allow_duplicate_dates and clean.index.duplicated().any():\n",
-        "                raise ValueError(\"Duplicate dates detected in index\")\n",
-        "\n",
-        "            # 6. Coverage checks using config thresholds\n",
-        "            m_ok = df.groupby(\"Month\")[f].apply(lambda col: col.notna().any())\n",
-        "            mask = m_ok.reindex(span, fill_value=False).to_numpy()\n",
-        "\n",
-        "            # tolerance for missing months per-cfg\n",
-        "            missing_count = (~mask).sum()\n",
-        "            if missing_count > cfg.max_missing_months:\n",
-        "                raise ValueError(f\"Missing-month count {missing_count} exceeds {cfg.max_missing_months}\")\n",
-        "\n",
-        "            # maximum run of consecutive missing months per-cfg with guard\n",
-        "            temp = np.flatnonzero(np.r_[True, mask, True])\n",
-        "            if temp.size <= 1:\n",
-        "                gap = 0\n",
-        "            else:\n",
-        "                gap = np.diff(temp).max() - 1\n",
-        "            if gap > cfg.max_consecutive_month_gap:\n",
-        "                raise ValueError(f\"Consecutive-missing gap {gap} exceeds {cfg.max_consecutive_month_gap}\")\n",
-        "\n",
-        "            eligible_funds.append(f)\n",
-        "\n",
-        "        except ValueError as e:\n",
-        "            logging.warning(\"Excluded %s: %s\", f, e)\n",
-        "        except KeyError as e:\n",
-        "            logging.warning(\"Missing data for %s: %s\", f, e)\n",
-        "        except Exception as e:\n",
-        "            logging.warning(\"Unexpected error on %s: %s\", f, e)\n",
-        "\n",
-        "    # Final selection-mode logic\n",
-        "    if selection_mode == \"all\" or random_n is None:\n",
-        "        return eligible_funds\n",
-        "    if selection_mode == \"random\":\n",
-        "        if random_n > len(eligible_funds):\n",
-        "            raise ValueError(\n",
-        "                f\"random_n exceeds eligible pool: {random_n} > {len(eligible_funds)}\"\n",
-        "            )\n",
-        "        return list(np.random.choice(eligible_funds, random_n, replace=False))\n",
-        "\n",
-        "    raise ValueError(f\"Unsupported selection_mode '{selection_mode}'\")\n",
-        "\n"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "id": "ac53bc18",
-      "metadata": {
-        "id": "ac53bc18"
-      },
-      "source": [
-        "## 3. Weight Prep"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 3,
-      "id": "59a9bf13",
-      "metadata": {
-        "id": "59a9bf13"
-      },
-      "outputs": [],
-      "source": [
-        "# ───────────────────────────────────────────────────────────────\n",
-        "#  3 · WEIGHT PREP\n",
-        "# ───────────────────────────────────────────────────────────────\n",
-        "def prepare_weights(selected: list[str],\n",
-        "                    custom: Dict[str, int] | None) -> tuple[Dict[str, float], np.ndarray]:\n",
-        "    if not custom:\n",
-        "        w = {f: 1/len(selected) for f in selected}\n",
-        "    else:\n",
-        "        missing = [f for f in selected if f not in custom]\n",
-        "        if missing:\n",
-        "            raise ValueError(f\"Missing weights for {missing}\")\n",
-        "        w = {f: pct/100 for f, pct in custom.items()}\n",
-        "        if abs(sum(w.values()) - 1) > 1e-6:\n",
-        "            raise ValueError(\"Custom weights must sum to 100.\")\n",
-        "    vec = np.array([w[f] for f in selected])\n",
-        "    return w, vec"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "id": "b3666a84",
-      "metadata": {
-        "id": "b3666a84"
-      },
-      "source": [
-        "## 4. Analysis (In-Sample & Out-of-Sample)\n",
-        "The `run_analysis` function orchestrates the entire process:\n",
-        "- Function definitions\n",
-        "- Validates date inputs.\n",
-        "- Converts 'Date' column.\n",
-        "- Identifies risk-free column.\n",
-        "- Fills short gaps.\n",
-        "- Selects funds.\n",
-        "- Computes in-sample scaling factors and applies them in- and out-of-sample.\n",
-        "- Computes individual fund stats and portfolio stats."
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 4,
-      "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44",
-      "metadata": {
-        "id": "72976bb9-5ceb-4a2f-953d-193aca9aab44"
-      },
-      "outputs": [],
-      "source": [
-        "# ===============================================================\n",
-        "# 4 · CORE STATS  +  RUN_ANALYSIS  (helpers included, weight fix)\n",
-        "# ===============================================================\n",
-        "\n",
-        "M_PER_YEAR = 12           # constant used across helpers\n",
-        "\n",
-        "# ---------- helpers --------------------------------------------\n",
-        "def _ensure_dt(df: pd.DataFrame) -> pd.DataFrame:\n",
-        "    \"\"\"Return a copy whose Date column is datetime64[ns].\"\"\"\n",
-        "    if pd.api.types.is_datetime64_any_dtype(df[\"Date\"]):\n",
-        "        return df\n",
-        "    df = df.copy()\n",
-        "    df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")\n",
-        "    df.dropna(subset=[\"Date\"], inplace=True)\n",
-        "    return df\n",
-        "\n",
-        "# 3. Metric function definitions\n",
-        "# === Metric Function Definitions with flexible annualization ===\n",
-        "@register_metric(\"AnnualReturn\")\n",
-        "def compute_annual_return(\n",
-        "    returns: pd.Series,\n",
-        "    periods_per_year: int = 252,\n",
-        "    **kwargs\n",
-        ") -> float:\n",
-        "    \"\"\"\n",
-        "    Geometric annualized return based on periods_per_year.\n",
-        "    \"\"\"\n",
-        "    r = returns.dropna()\n",
-        "    if r.empty:\n",
-        "        return np.nan\n",
-        "    total_growth = (1 + r).prod()\n",
-        "    n_periods = len(r)\n",
-        "    return total_growth ** (periods_per_year / n_periods) - 1\n",
-        "\n",
-        "@register_metric(\"Volatility\")\n",
-        "def compute_volatility(\n",
-        "    returns: pd.Series,\n",
-        "    periods_per_year: int = 252,\n",
-        "    **kwargs\n",
-        ") -> float:\n",
-        "    \"\"\"\n",
-        "    Annualized standard deviation of returns with flexible scaling.\n",
-        "    \"\"\"\n",
-        "    r = returns.dropna()\n",
-        "    if r.empty:\n",
-        "        return 0.0\n",
-        "    return r.std(ddof=0) * np.sqrt(periods_per_year)\n",
-        "\n",
-        "@register_metric(\"Sharpe\")\n",
-        "def compute_sharpe(\n",
-        "    returns: pd.Series,\n",
-        "    risk_free: float = 0.0,\n",
-        "    periods_per_year: int = 252,\n",
-        "    **kwargs\n",
-        ") -> float:\n",
-        "    \"\"\"\n",
-        "    Sharpe ratio using flexible annualized return and volatility.\n",
-        "    \"\"\"\n",
-        "    vol = compute_volatility(returns, periods_per_year=periods_per_year)\n",
-        "    if vol == 0:\n",
-        "        return np.nan\n",
-        "    ann_ret = compute_annual_return(returns, periods_per_year=periods_per_year)\n",
-        "    return (ann_ret - risk_free) / vol\n",
-        "\n",
-        "@register_metric(\"Sortino\")\n",
-        "def compute_sortino(\n",
-        "    returns: pd.Series,\n",
-        "    risk_free: float = 0.0,\n",
-        "    periods_per_year: int = 252,\n",
-        "    **kwargs\n",
-        ") -> float:\n",
-        "    \"\"\"\n",
-        "    Sortino ratio using flexible annualized return and downside deviation.\n",
-        "    \"\"\"\n",
-        "    r = returns.dropna()\n",
-        "    if r.empty:\n",
-        "        return np.nan\n",
-        "    ann_ret = compute_annual_return(returns, periods_per_year=periods_per_year)\n",
-        "    # Define per-period risk-free rate\n",
-        "    period_rf = risk_free / periods_per_year\n",
-        "    excess = r - period_rf\n",
-        "    downside = excess[excess < 0]\n",
-        "    if downside.empty:\n",
-        "        return np.nan\n",
-        "    down_dev = np.sqrt((downside ** 2).mean()) * np.sqrt(periods_per_year)\n",
-        "    if down_dev == 0:\n",
-        "        return np.nan\n",
-        "    return (ann_ret - risk_free) / down_dev\n",
-        "\n",
-        "@register_metric(\"MaxDrawdown\")\n",
-        "def compute_max_drawdown(\n",
-        "    returns: pd.Series,\n",
-        "    **kwargs\n",
-        ") -> float:\n",
-        "    \"\"\"\n",
-        "    Maximum drawdown (peak-to-trough) of cumulative returns.\n",
-        "    \"\"\"\n",
-        "    r = returns.dropna()\n",
-        "    if r.empty:\n",
-        "        return 0.0\n",
-        "    cum = (1 + r).cumprod()\n",
-        "    peak = cum.cummax()\n",
-        "    drawdown = (cum / peak) - 1\n",
-        "    return float(drawdown.min())\n",
-        "\n",
-        "# Alias for backward compatibility\n",
-        "_ann_vol = compute_volatility\n",
-        "\n",
-        "# === Aggregator with Centralized Error Handling ===\n",
-        "\n",
-        "def _stats(\n",
-        "    returns: pd.Series,\n",
-        "    cfg: RiskStatsConfig,\n",
-        "    **metric_kwargs\n",
-        ") -> namedtuple:\n",
-        "    \"\"\"\n",
-        "    Run each metric in cfg.metrics_to_run, returning a namedtuple of values.\n",
-        "    Uses cfg.periods_per_year for annualization.\n",
-        "    Centralized try/except ensures one failing metric doesn’t break the batch.\n",
-        "    \"\"\"\n",
-        "    Stat = namedtuple(\"Stat\", cfg.metrics_to_run)\n",
-        "    values: list[float] = []\n",
-        "    for name in cfg.metrics_to_run:\n",
-        "        fn = METRIC_REGISTRY.get(name)\n",
-        "        if fn is None:\n",
-        "            logging.error(\"Metric '%s' not registered\", name)\n",
-        "            values.append(np.nan)\n",
-        "            continue\n",
-        "        try:\n",
-        "            params = {\n",
-        "                \"risk_free\": cfg.risk_free,\n",
-        "                \"periods_per_year\": cfg.periods_per_year,\n",
-        "                **metric_kwargs\n",
-        "            }\n",
-        "            val = fn(returns, **params)\n",
-        "        except ZeroDivisionError:\n",
-        "            logging.warning(\"%s: division by zero, setting NaN\", name)\n",
-        "            val = np.nan\n",
-        "        except (ValueError, TypeError) as e:\n",
-        "            logging.warning(\"%s: invalid input (%s), setting NaN\", name, e)\n",
-        "            val = np.nan\n",
-        "        except Exception as e:\n",
-        "            logging.error(\"%s: unexpected error (%s), setting NaN\", name, e)\n",
-        "            val = np.nan\n",
-        "        values.append(val)\n",
-        "    return Stat(*values)\n",
-        "\n",
-        "# ---------- main ------------------------------------------------\n",
-        "def run_analysis(\n",
-        "    df,\n",
-        "    selected,\n",
-        "    w_vec,\n",
-        "    w_dict,\n",
-        "    rf_col,\n",
-        "    in_start,\n",
-        "    in_end,\n",
-        "    out_start,\n",
-        "    out_end,\n",
-        "    target_vol,\n",
-        "    monthly_cost,\n",
-        "    indices_list\n",
-        "):\n",
-        "    \"\"\"\n",
-        "    Vectorised run_analysis with correct weight re-normalisation\n",
-        "    after funds are dropped.\n",
-        "    Returns the same keys used by the UI and export functions.\n",
-        "    \"\"\"\n",
-        "    df = _ensure_dt(df)\n",
-        "\n",
-        "    # ---- date masks --------------------------------------------------\n",
-        "    in_s = pd.to_datetime(in_start)  + pd.offsets.MonthEnd(0)\n",
-        "    in_e = pd.to_datetime(in_end)    + pd.offsets.MonthEnd(0)\n",
-        "    out_s= pd.to_datetime(out_start) + pd.offsets.MonthEnd(0)\n",
-        "    out_e= pd.to_datetime(out_end)   + pd.offsets.MonthEnd(0)\n",
-        "\n",
-        "    m_in  = df[\"Date\"].between(in_s,  in_e)\n",
-        "    m_out = df[\"Date\"].between(out_s, out_e)\n",
-        "\n",
-        "    in_df,  out_df  = df.loc[m_in,  selected], df.loc[m_out, selected]\n",
-        "    in_rf,  out_rf  = df.loc[m_in,  rf_col],   df.loc[m_out, rf_col]\n",
-        "\n",
-        "    # ---- drop funds with any NaNs in either window ------------------\n",
-        "    good = [f for f in selected\n",
-        "            if in_df[f].notna().all() and out_df[f].notna().all()]\n",
-        "    dropped = list(set(selected) - set(good))\n",
-        "    if dropped:\n",
-        "        logging.warning(\"Dropped funds: %s\", dropped)\n",
-        "\n",
-        "    selected = good\n",
-        "    # >>>> new guard: kick out any accidental index columns\n",
-        "    selected = [f for f in selected if f not in (indices_list or [])]\n",
-        "    # <<<<\n",
-        "\n",
-        "    in_df, out_df = in_df[selected], out_df[selected]\n",
-        "\n",
-        "    # rebuild weights\n",
-        "    if w_dict is None:                      # equal-weight path\n",
-        "        w_dict = {f: 1/len(selected) for f in selected}\n",
-        "    else:                                   # manual path → rescale\n",
-        "        pct   = {f: w_dict[f]*100 for f in selected}\n",
-        "        total = sum(pct.values())\n",
-        "        w_dict = {f: p/total for f, p in pct.items()}\n",
-        "    w_vec = np.array([w_dict[f] for f in selected])\n",
-        "\n",
-        "    # ---- scaling ----------------------------------------------------\n",
-        "    vols = in_df.apply(compute_volatility)\n",
-        "    scale = np.where(vols > 0, target_vol / vols, 1.0)\n",
-        "    in_sc  = (in_df * scale) - monthly_cost\n",
-        "    out_sc = (out_df * scale) - monthly_cost\n",
-        "    in_sc.clip(lower=-1, inplace=True)\n",
-        "    out_sc.clip(lower=-1, inplace=True)\n",
-        "\n",
-        "    # ---- stats ------------------------------------------------------\n",
-        "    rf_value = in_rf.mean() if hasattr(in_rf, \"mean\") else float(in_rf)\n",
-        "\n",
-        "    # Create a RiskStatsConfig for in-sample stats\n",
-        "    stats_cfg = RiskStatsConfig(risk_free=rf_value)\n",
-        "\n",
-        "    # Now compute stats for each scenario, always passing stats_cfg first\n",
-        "    in_stat = {\n",
-        "        f: _stats(in_sc[f], stats_cfg)\n",
-        "        for f in selected\n",
-        "    }\n",
-        "    out_rf_value = out_rf.mean() if hasattr(out_rf, \"mean\") else float(out_rf)\n",
-        "\n",
-        "    # Re‐use the same config, updating only the risk_free field\n",
-        "    stats_cfg.risk_free = out_rf_value\n",
-        "\n",
-        "    out_stat = {\n",
-        "        f: _stats(out_sc[f], stats_cfg)\n",
-        "        for f in selected\n",
-        "    }\n",
-        "\n",
-        "    ew_vec = np.full(len(selected), 1/len(selected))\n",
-        "    w_vec = np.full(len(selected), 1/len(selected))\n",
-        "\n",
-        "    in_ew_stats  = _stats(in_sc.dot(ew_vec),  stats_cfg)\n",
-        "    out_ew_stats = _stats(out_sc.dot(ew_vec), stats_cfg)\n",
-        "    in_user_stats  = _stats(in_sc.dot(w_vec),  stats_cfg)\n",
-        "    out_user_stats = _stats(out_sc.dot(w_vec), stats_cfg)\n",
-        "\n",
-        "    results = {\n",
-        "        \"selected_funds\": selected,\n",
-        "        \"indices_list\":   indices_list or [],\n",
-        "        \"fund_weights\":   w_dict,\n",
-        "        \"ew_weights\":     {f: 1/len(selected) for f in selected},\n",
-        "        \"in_sample_stats\":  in_stat,\n",
-        "        \"out_sample_stats\": out_stat,\n",
-        "        \"in_ew_stats\":     in_ew_stats,\n",
-        "        \"out_ew_stats\":    out_ew_stats,\n",
-        "        \"in_user_stats\":   in_user_stats,\n",
-        "        \"out_user_stats\":  out_user_stats,\n",
-        "        \"dropped\":         dropped,\n",
-        "    }\n",
-        "\n",
-        "    # ---- optional index stats ---------------------------------------\n",
-        "    if indices_list:\n",
-        "        idx_stats = {}\n",
-        "        for col in indices_list:\n",
-        "            idx_stats[col] = {\n",
-        "                \"in_sample\":  _stats(df.loc[m_in,  col], stats_cfg),\n",
-        "                \"out_sample\": _stats(df.loc[m_out, col], stats_cfg),\n",
-        "            }\n",
-        "        results[\"index_stats\"] = idx_stats\n",
-        "\n",
-        "    return results\n"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "id": "183dc5df",
-      "metadata": {
-        "id": "183dc5df"
-      },
-      "source": [
-        "## 5. Excel Export\n",
-        "Creates an Excel file with In-Sample, Out-of-Sample and Equal-weight and User-weight."
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 5,
-      "id": "8e2cce23",
-      "metadata": {
-        "id": "8e2cce23"
-      },
-      "outputs": [],
-      "source": [
-        "# ───────────────────────────────────────────────────────────────\n",
-        "#  5 · EXPORT  (NaN-safe, weight-format fix)\n",
-        "# ───────────────────────────────────────────────────────────────\n",
-        "# ───────── 5 · EXPORT  (final, bug-free) ───────────────────────\n",
-        "# ───────── 5 · EXPORT  (self-healing index section) ───────────\n",
-        "# ───────── 5 · EXPORT  (final safe version) ───────────────────\n",
-        "\n",
-        "def export_to_excel(\n",
-        "    data: dict[str, pd.DataFrame],\n",
-        "    output_path: str,\n",
-        "    default_format: Optional[Callable] = None\n",
-        ") -> None:\n",
-        "    \"\"\"\n",
-        "    Exports each DataFrame in `data` to its own sheet in `output_path`.\n",
-        "    Applies a registered formatter for each category (sheet name).\n",
-        "    If no formatter is found, applies `default_format` if provided.\n",
-        "\n",
-        "    For the Summary sheet, data is written starting at row 5 to make room for custom headers.\n",
-        "    \"\"\"\n",
-        "    startrows = {\"summary\": 5}\n",
-        "    with pd.ExcelWriter(output_path, engine=\"xlsxwriter\") as writer:\n",
-        "        for category, df in data.items():\n",
-        "            startrow = startrows.get(category, 0)\n",
-        "            df.to_excel(writer, sheet_name=category, index=False, startrow=startrow)\n",
-        "            fn = FORMATTERS_EXCEL.get(category, default_format)\n",
-        "            if fn: fn(writer.sheets[category], writer.book)\n",
-        "    # Workbook is auto-saved and closed by the context manager\n"
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "id": "ee8c2c6d",
-      "metadata": {
-        "id": "ee8c2c6d"
-      },
-      "source": [
-        "## 6. Run Parameters, Widgets & User Inputs\n",
-        "Here we define some IPython widgets for in-sample/out-of-sample dates, target volatility, monthly cost, etc. Also lets us use custom weights."
-      ]
-    },
-    {
-      "cell_type": "markdown",
-      "id": "86794206",
-      "metadata": {
-        "id": "86794206"
-      },
-      "source": [
-        "### Using This Notebook\n",
-        "1. Run all cells.\n",
-        "2. Call `demo_run()` in a new cell to see a quick example with dummy data.\n",
-        "3. To use your own data, load it into a DataFrame (make sure it has a 'Date' column and decimal returns in other columns), then call `run_analysis()` and `export_to_excel()`.\n",
-        "4. For interactive selection, do:\n",
-        "   ```python\n",
-        "   display(ui_inputs)\n",
-        "   ```\n",
-        "   Then wire the `apply_button` to a callback function that reads the widget values and runs `run_analysis()`.\n",
-        "5. For custom weights, call:\n",
-        "   ```python\n",
-        "   my_weights = get_custom_weights(selected_funds)\n",
-        "   ```\n",
-        "   Then pass `my_weights` into your logic.\n"
-      ]
-    },
-    {
-      "cell_type": "code",
-      "execution_count": 6,
-      "id": "e48de568-962e-4690-a6fc-be7a4ec0a3c6",
-      "metadata": {
-        "colab": {
-          "base_uri": "https://localhost:8080/",
-          "height": 896,
-          "referenced_widgets": [
-            "8face5cf545b40ceaf10b1506e754d71",
-            "db185d3992024056acfa2ffe419931d8",
-            "c459f2c677ff4bea8db916696b7b600e",
-            "170d05f5ba184c13bb39914b17257476",
-            "64045569d769471e92ac17aebf71022f",
-            "f83a99900b324015862cad100f5bfc0c",
-            "ee231bb4cb97454591e7a6774bb2f7bd",
-            "eceecb3f8a864d1eb15aab7d531e3cd1",
-            "75ad9c9f175f4960999958cd9f6d056a",
-            "e0d83789c4034d9ab9b3c2fa85870beb",
-            "ae753571f5814a65865abbdb10540373",
-            "125e415320644832a8be95b92713e257",
-            "8c053f4df9ff486f84b123eda524cbe7",
-            "d3bae0e7a2474ea4bdce0b0b9e413059",
-            "516389ac0f0042a0bbeab3bd64493997",
-            "e7dc4acbb2eb4a0e8c5112e4b2a85393",
-            "332172fad96e4be2857e530ba9df86c6",
-            "354bbc188daa4493967e2b143ceea510",
-            "6dc67c18884044ac811b3a256f69171e",
-            "d80f632f65c44c338a41d0b4e3dc5ea7",
-            "9a302560059a43338397161ea2ad37c7",
-            "a8d2ae4652394bb4b2a740097a4d7ea7",
-            "dbe1076d681040169eca1b570e2485e2",
-            "593aad971d274b90b56cecc15e09dc39",
-            "6418ed5196fd485cae29568a24bf60ae",
-            "d12e413cbeac41a39fd9b94479c1eca8",
-            "10e898df8a0e460b9f3e3a40b48f51f4",
-            "97212667726d480eb944e25ec32cfc25",
-            "6e75d93c40ea4c40b9162ab51e807d98",
-            "646d2e69e110438fa2feb8b60af24bb7",
-            "47ae7b5e18314a2596b33cc6c774942b",
-            "05a596b6c3864ddc931b3112153f12ab",
-            "8f3ec331c368446b8552a06238a12608",
-            "3814c0e0fa1c438e87df5b60a82dd3e4",
-            "6c7f140622534a6cab6133758aa7a936",
-            "5759bee9a2034ed3b9b4196e158b58eb",
-            "6e5e4fc36c674146a86dc3f8b6edbd7d",
-            "fa9ee776b338497e9385f3d1a8d02fff",
-            "32bac6722d6d47a6b5a88372e9e5d44e",
-            "dfbe93388b474442833b5e7b7efc1e5f",
-            "d13209a7e5c94f6585d47c2430fa7885",
-            "704f7526c3934eed85b653fb00714114",
-            "08882c12ccaa4d058bc554020c044559",
-            "1c01c7f8d62041198190f4bfbe21aff5",
-            "9ac98c85e0f147f8a191f6d32651d0cc",
-            "e00ed42085424c6f91fb07fb2d22ee62",
-            "818aa783706f4087a3754d39d861ced6",
-            "258e8504f9cc4be783ea207c43e56214",
-            "bedc16eeb19740bb9ee6e810bc9b7a71",
-            "2e2775bb4c6e4b98ba4706d90b24e042",
-            "b411a590b161465185dfd853a6dd95d6",
-            "a503b43ca679455f978c6903bdb598cf",
-            "70dfa008682a460aa02625a933b33606",
-            "514e5aafad0044cb9df9232ef0a4e264",
-            "367366f650c644d59791946a3c8d86d0",
-            "15de8a73c52642c598ad8baeb3609499",
-            "2e6724a498d54c73a8f594b19c6a3d20",
-            "09e8f8999ea1463a9d603da4f4f70b12",
-            "1da4518f46b84fc7b84d387c7e34f050",
-            "021e4dc72d814e5d8c42592b541b6723",
-            "97f4dce2a3874dafaeb0ba92775ae2a0",
-            "f5539db7aca6440e9c3dee43697c4fae",
-            "2e96cf393a754d279bcf02c66548f6dd",
-            "0b231b28c644443db3e659a17096f55c",
-            "62c2030d08cf4f1e91c9c9038f31b864",
-            "e5c317ba51ed45818d7d60cc4aaec11d",
-            "7e5dd5f9379a4104ad7965a34e569a7a",
-            "383dee58194446698cb8eb9df41b7778",
-            "72bdf8a1ccfa4d0985547020c90908a0",
-            "8a9b22cd239d43d191387ebc9e660ff8",
-            "86a9efbe68f5450685a4e8aa1c96e84e",
-            "38d3e511fdc14bcaa7b04d8583be18dc",
-            "8d9670b7900c40b8849f7e4629d50424",
-            "eed45853cf99427398e7b16f2cab9f8b",
-            "5363ac1b24b24811ae9c63b86dfbf359",
-            "74577bb60c55412d9c38960d7d865fd6",
-            "d37456fcb76f4acda7978257483bf2ad",
-            "d6710d2b4b0b4b02b5358d2d152fbad9",
-            "ca05ab87b3e040cbbf4016ae0671fc40",
-            "958a21d97fa546a2b314e2c988b43589",
-            "202010c9f8324e1493baa92d83ff9335",
-            "4a022a6055c34004b7a3aa671a168ee3",
-            "c9b1027aad95413c94835aef5ce74a5b",
-            "ae45af3a4d3d4fb8b1c2827585ed7f7f",
-            "574d70e37e6a449dbdd4365c2d86fda8",
-            "d9f6106f986b4ea49d957594d8d5c324",
-            "e8b9fd55c6094126b24ab2e7cffa4dc5",
-            "f5e355edbbc946b3b6e1ba36f839d45b",
-            "78906e475e9d4bda8b7e0c4ca4de577c",
-            "65dbf5a3b3a2406aa9f807b74dc5543b",
-            "269ab898c24e4cf697ad3dc2854a7215",
-            "ff9bd5c776a741248e4a64d445950c90",
-            "4b551eab21b34f488d743ea730a541d8",
-            "05b7cb98ce374c10828efb3d205fe4ff",
-            "6c1e290b8fdf4e31872f11e0c5438b5d",
-            "be7153ab36374e62a7d6a234dc1c973e",
-            "d22068b3d502469fa1631d698a3d3779",
-            "e02a002607844c6ba0249122b505b8f5",
-            "d807a3a60ca14ddda5fbec481049b6d4"
-          ]
-        },
-        "id": "e48de568-962e-4690-a6fc-be7a4ec0a3c6",
-        "outputId": "795bb6da-96a0-42e2-c760-7d516fd82610"
-      },
-      "outputs": [
-        {
-          "data": {
-            "application/vnd.jupyter.widget-view+json": {
-              "model_id": "707a5f34098a499db0dbaf22783f7e2a",
-              "version_major": 2,
-              "version_minor": 0
-            },
-            "text/plain": [
-              "VBox(children=(HTML(value='<h4>1. Load data</h4>'), ToggleButtons(description='Source:', options=(('Local', 'l…"
-            ]
-          },
-          "metadata": {},
-          "output_type": "display_data"
-        }
-      ],
-      "source": [
-        "# ===============================================================\n",
-        "#            STREAMLINED ANALYSIS UI  (phase-2 clean)\n",
-        "# ===============================================================\n",
-        "\n",
-        "# ---------- session store ----------\n",
-        "session = {\"df\": None, \"rf\": None, \"sel\": None, \"cweights\": None}\n",
-        "\n",
-        "# ---------- 1 · DATA LOAD ----------\n",
-        "src = widgets.ToggleButtons(\n",
-        "    options=[(\"Local\", \"local\"), (\"URL\", \"url\")],\n",
-        "    description=\"Source:\"\n",
-        ")\n",
-        "\n",
-        "chooser = FileChooser()\n",
-        "url_box = widgets.Text(placeholder=\"https://…/file.csv\", layout={\"width\":\"70%\"})\n",
-        "load_btn = widgets.Button(description=\"Load CSV\", button_style=\"success\")\n",
-        "load_out = widgets.Output()\n",
-        "\n",
-        "def _toggle_src(c):\n",
-        "    chooser.layout.display = \"block\" if c[\"new\"]==\"local\" else \"none\"\n",
-        "    url_box.layout.display  = \"block\" if c[\"new\"]==\"url\"   else \"none\"\n",
-        "src.observe(_toggle_src, names=\"value\"); _toggle_src({\"new\":src.value})\n",
-        "\n",
-        "def _load(_):\n",
-        "    with load_out:\n",
-        "        clear_output()\n",
-        "        try:\n",
-        "            path = chooser.selected if src.value==\"local\" else url_box.value.strip()\n",
-        "            if not path: raise ValueError(\"choose file / URL\")\n",
-        "            if src.value==\"url\" and not path.lower().endswith(\".csv\"):\n",
-        "                raise ValueError(\"URL must end with .csv\")\n",
-        "            df = load_csv(path)\n",
-        "            df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")  # single coercion\n",
-        "            rf = identify_risk_free_fund(df)\n",
-        "            session.update(df=df, rf=rf, sel=None, cweights=None)\n",
-        "            print(f\"✅ Loaded {len(df):,} rows × {df.shape[1]} cols | RF → {rf}\")\n",
-        "        except Exception as e:\n",
-        "            print(\"❌\", e); session[\"df\"]=None\n",
-        "load_btn.on_click(_load)\n",
-        "\n",
-        "# ---------- 2 · PARAMS ------------\n",
-        "index_cnt = widgets.BoundedIntText(0, min=0, max=10, description=\"# Indices:\")\n",
-        "in_start,in_end  = widgets.Text(\"2005-07\"), widgets.Text(\"2008-06\")\n",
-        "out_start,out_end= widgets.Text(\"2008-07\"), widgets.Text(\"2009-06\")\n",
-        "for w,lbl in [(in_start,\"In Start:\"),(in_end,\"In End:\"),\n",
-        "              (out_start,\"Out Start:\"),(out_end,\"Out End:\")]:\n",
-        "    w.description = lbl\n",
-        "target_vol   = widgets.FloatText(0.25,  description=\"Target Vol:\")\n",
-        "monthly_cost = widgets.FloatText(0.0033, description=\"Monthly Cost:\")\n",
-        "\n",
-        "# ---------- 3 · SELECTION ----------\n",
-        "mode_dd = widgets.Dropdown(\n",
-        "    options=[(\"All\", \"all\"), (\"Random\", \"random\"), (\"Manual\", \"manual\")],\n",
-        "    value=\"all\",\n",
-        "    description=\"Mode:\"\n",
-        ")\n",
-        "rand_n   = widgets.BoundedIntText(5, min=2, max=100, description=\"Sample N:\")\n",
-        "fund_table, total_lbl = widgets.VBox([]), widgets.Label(\"Total = 0 %\")\n",
-        "\n",
-        "def _toggle_sel(_=None):\n",
-        "    rand_n.layout.display  = \"block\" if mode_dd.value==\"random\" else \"none\"\n",
-        "    vis = \"block\" if mode_dd.value==\"manual\" else \"none\"\n",
-        "    fund_table.layout.display = total_lbl.layout.display = vis\n",
-        "mode_dd.observe(_toggle_sel, names=\"value\"); _toggle_sel()\n",
-        "\n",
-        "# ---------- helpers ---------------\n",
-        "def _eligible_pool():\n",
-        "    df, rf = session[\"df\"], session[\"rf\"]\n",
-        "    if df is None:\n",
-        "        print(\"⚠️ data not loaded\"); return []\n",
-        "\n",
-        "    # ---- date parse guard -----------------------------------\n",
-        "    try:\n",
-        "        in_s  = pd.to_datetime(in_start.value)+pd.offsets.MonthEnd(0)\n",
-        "        in_e  = pd.to_datetime(in_end.value)  +pd.offsets.MonthEnd(0)\n",
-        "        out_s = pd.to_datetime(out_start.value)+pd.offsets.MonthEnd(0)\n",
-        "        out_e = pd.to_datetime(out_end.value)  +pd.offsets.MonthEnd(0)\n",
-        "    except Exception:\n",
-        "        print(\"❌ invalid dates\"); return []\n",
-        "\n",
-        "    # ---- build indices (RIGHT-most idx_n non-RF columns) ----\n",
-        "    idx_n     = index_cnt.value\n",
-        "    data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-        "    non_rf    = [c for c in data_cols if c != rf]\n",
-        "    indices   = non_rf[-idx_n:] if idx_n else []          # <- fixed\n",
-        "    cand      = [c for c in data_cols if c not in indices]\n",
-        "\n",
-        "    # ---- run select_funds ----------------------------------\n",
-        "    elig = select_funds(\n",
-        "        df=df,\n",
-        "        rf_col=rf,\n",
-        "        fund_columns=cand,\n",
-        "        in_sdate=in_s,\n",
-        "        in_edate=in_e,\n",
-        "        out_sdate=out_s,\n",
-        "        out_edate=out_e,\n",
-        "        cfg=cfg,                     # ← Explicitly supply your config here\n",
-        "        selection_mode=\"all\",\n",
-        "    )\n",
-        "    # … diagnostics print unchanged …\n",
-        "    return elig\n",
-        "\n",
-        "def _build_manual(*_):\n",
-        "    if mode_dd.value!=\"manual\" or session[\"df\"] is None: return\n",
-        "    valid = _eligible_pool()\n",
-        "    print(\"DEBUG  eligible funds =\", len(valid))              # ← line 1\n",
-        "    print(\"DEBUG  list sample   →\", valid[:25], \"…\")           # ← line 2\n",
-        "    if not valid:\n",
-        "        print(\"❌ No eligible funds\"); return\n",
-        "    fund_table.children = []                # reset\n",
-        "\n",
-        "    def _update_total(*_):\n",
-        "        tot = sum(r.children[1].value for r in fund_table.children\n",
-        "                  if r.children[0].value)\n",
-        "        total_lbl.value = f\"Total = {tot} %\"\n",
-        "\n",
-        "    for f in valid:\n",
-        "        cb = widgets.Checkbox(description=f, layout={\"width\":\"200px\"})\n",
-        "        wt = widgets.BoundedIntText(0, min=0, max=100,\n",
-        "                                    layout={\"width\":\"60px\"}, disabled=True)\n",
-        "        def _toggle(ch, box=wt):           # single observer\n",
-        "            box.disabled = not ch[\"new\"]\n",
-        "            if box.disabled: box.value = 0\n",
-        "            _update_total()\n",
-        "        cb.observe(_toggle, names=\"value\")\n",
-        "        wt.observe(_update_total, names=\"value\")\n",
-        "        fund_table.children += (widgets.HBox([cb, wt]),)\n",
-        "    _update_total()\n",
-        "\n",
-        "mode_dd.observe(lambda ch: _build_manual() if ch[\"new\"]==\"manual\" else None,\n",
-        "                names=\"value\")\n",
-        "for w in (in_start,in_end,out_start,out_end): w.observe(_build_manual,names=\"value\")\n",
-        "\n",
-        "# ---------- 4 · RUN ---------------\n",
-        "run_btn = widgets.Button(description=\"Run Analysis\", button_style=\"success\")\n",
-        "run_out = widgets.Output(layout={\"border\":\"1px solid #999\",\n",
-        "                                 \"height\":\"340px\",\"overflow_y\":\"auto\"})\n",
-        "\n",
-        "def _run(_):\n",
-        "    with run_out:\n",
-        "        clear_output()\n",
-        "        df, rf = session[\"df\"], session[\"rf\"]\n",
-        "        if df is None: print(\"⚠️ Load data first\"); return\n",
-        "\n",
-        "        # indices (robust)\n",
-        "        idx_n     = index_cnt.value\n",
-        "        data_cols = [c for c in df.columns if c not in [\"Date\", rf, \"Month\"]]\n",
-        "        non_rf    = [c for c in data_cols if c != rf]\n",
-        "        indices   = non_rf[-idx_n:] if idx_n else []\n",
-        "\n",
-        "        # pool + selection\n",
-        "        pool = _eligible_pool()\n",
-        "        if not pool: print(\"❌ No eligible funds\"); return\n",
-        "        if mode_dd.value==\"all\":\n",
-        "            sel, custom = pool, None\n",
-        "        elif mode_dd.value==\"random\":\n",
-        "            if rand_n.value>len(pool): print(\"⚠️ Sample N too big\"); return\n",
-        "            sel, custom = list(np.random.choice(pool, rand_n.value, replace=False)), None\n",
-        "        else:\n",
-        "            sel, custom = [], {}\n",
-        "            if not fund_table.children: _build_manual()\n",
-        "            for row in fund_table.children:\n",
-        "                cb, wt = row.children\n",
-        "                if cb.value: sel.append(cb.description); custom[cb.description]=wt.value\n",
-        "            if sum(custom.values())!=100: print(\"⚠️ Weights ≠ 100\"); return\n",
-        "\n",
-        "        w_dict,w_vec = prepare_weights(sel, custom)\n",
-        "\n",
-        "        res = run_analysis(df, sel, w_vec, w_dict, rf,\n",
-        "                           in_start.value, in_end.value,\n",
-        "                           out_start.value, out_end.value,\n",
-        "                           target_vol.value, monthly_cost.value,\n",
-        "                           indices)\n",
-        "\n",
-        "        print(\"✅ analysis complete |\", len(sel), \"funds\")\n",
-        "        if res[\"dropped\"]:\n",
-        "            print(\"⚠️ Dropped:\", res[\"dropped\"])\n",
-        "        if indices: print(\"📊 Indices:\", indices)\n",
-        "\n",
-        "        fname=f\"IS_{in_start.value}_{out_start.value}.xlsx\"\n",
-        "        # register only the combined summary formatter\n",
-        "        make_summary_formatter(\n",
-        "            res,\n",
-        "            in_start.value,\n",
-        "            in_end.value,\n",
-        "            out_start.value,\n",
-        "            out_end.value\n",
-        "        )\n",
-        "\n",
-        "        # Build a minimal data dict with just the 'summary' sheet.\n",
-        "        # The formatter will populate all rows (portfolio, funds, spacer, indices).\n",
-        "        data = {\n",
-        "            \"summary\": pd.DataFrame()\n",
-        "        }\n",
-        "\n",
-        "        print(\"Sheets to write:\", list(data.keys()))\n",
-        "        print(\"Formatters:\", list(FORMATTERS_EXCEL.keys()))\n",
-        "\n",
-        "        # Export — this will call fmt_summary(ws, wb) on the 'summary' sheet.\n",
-        "        export_to_excel(data, fname)\n",
-        "        print(\"Workbook saved as\", fname)\n",
-        "\n",
-        "run_btn.on_click(_run)\n",
-        "\n",
-        "# ---------- DISPLAY --------------\n",
-        "display(widgets.VBox([\n",
-        "    widgets.HTML(\"<h4>1. Load data</h4>\"),\n",
-        "    src, chooser, url_box, load_btn, load_out,\n",
-        "    widgets.HTML(\"<hr><h4>2. Parameters</h4>\"),\n",
-        "    widgets.HBox([index_cnt]),\n",
-        "    widgets.HBox([in_start,in_end,out_start,out_end]),\n",
-        "    widgets.HBox([target_vol,monthly_cost]),\n",
-        "    widgets.HTML(\"<hr><h4>3. Fund selection</h4>\"),\n",
-        "    widgets.HBox([mode_dd,rand_n]),\n",
-        "    fund_table, total_lbl,\n",
-        "    widgets.HTML(\"<hr>\"),\n",
-        "    run_btn,\n",
-        "    run_out\n",
-        "]))\n"
-      ]
-    }
-  ],
-  "metadata": {
-    "colab": {
-      "provenance": []
-    },
-    "kernelspec": {
-      "display_name": "Python (base)",
-      "language": "python",
-      "name": "base"
-    },
-    "language_info": {
-      "codemirror_mode": {
-        "name": "ipython",
-        "version": 3
-      },
-      "file_extension": ".py",
-      "mimetype": "text/x-python",
-      "name": "python",
-      "nbconvert_exporter": "python",
-      "pygments_lexer": "ipython3",
-      "version": "3.12.2"
-    },
-    "widgets": {
-      "application/vnd.jupyter.widget-state+json": {
-        "021e4dc72d814e5d8c42592b541b6723": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "SelectModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "SelectModel",
-            "_options_labels": [
-              "📁 ..",
-              "📁 sample_data",
-              "Vol_Adj_Trend_Analysis_1_3_TrEx.ipynb"
-            ],
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "SelectView",
-            "description": "",
-            "description_tooltip": null,
-            "disabled": false,
-            "index": null,
-            "layout": "IPY_MODEL_f5e355edbbc946b3b6e1ba36f839d45b",
-            "rows": 8,
-            "style": "IPY_MODEL_78906e475e9d4bda8b7e0c4ca4de577c"
-          }
-        },
-        "05a596b6c3864ddc931b3112153f12ab": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "05b7cb98ce374c10828efb3d205fe4ff": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HTMLModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HTMLModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HTMLView",
-            "description": "",
-            "description_tooltip": null,
-            "layout": "IPY_MODEL_be7153ab36374e62a7d6a234dc1c973e",
-            "placeholder": "",
-            "style": "IPY_MODEL_d22068b3d502469fa1631d698a3d3779",
-            "value": "<span style=\"color:black;\">No selection</span>"
-          }
-        },
-        "08882c12ccaa4d058bc554020c044559": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "09e8f8999ea1463a9d603da4f4f70b12": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DropdownModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DropdownModel",
-            "_options_labels": [
-              "/content",
-              "/"
-            ],
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "DropdownView",
-            "description": "",
-            "description_tooltip": null,
-            "disabled": false,
-            "index": 0,
-            "layout": "IPY_MODEL_ae45af3a4d3d4fb8b1c2827585ed7f7f",
-            "style": "IPY_MODEL_574d70e37e6a449dbdd4365c2d86fda8"
-          }
-        },
-        "0b231b28c644443db3e659a17096f55c": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "BoxModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "BoxModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "BoxView",
-            "box_style": "",
-            "children": [
-              "IPY_MODEL_05b7cb98ce374c10828efb3d205fe4ff"
-            ],
-            "layout": "IPY_MODEL_6c1e290b8fdf4e31872f11e0c5438b5d"
-          }
-        },
-        "10e898df8a0e460b9f3e3a40b48f51f4": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": "none",
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": "500px"
-          }
-        },
-        "125e415320644832a8be95b92713e257": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HTMLModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HTMLModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HTMLView",
-            "description": "",
-            "description_tooltip": null,
-            "layout": "IPY_MODEL_1c01c7f8d62041198190f4bfbe21aff5",
-            "placeholder": "​",
-            "style": "IPY_MODEL_9ac98c85e0f147f8a191f6d32651d0cc",
-            "value": "<hr><h4>3. Fund selection</h4>"
-          }
-        },
-        "15de8a73c52642c598ad8baeb3609499": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": "none",
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "170d05f5ba184c13bb39914b17257476": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "VBoxModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "VBoxModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "VBoxView",
-            "box_style": "",
-            "children": [
-              "IPY_MODEL_593aad971d274b90b56cecc15e09dc39",
-              "IPY_MODEL_6418ed5196fd485cae29568a24bf60ae",
-              "IPY_MODEL_d12e413cbeac41a39fd9b94479c1eca8"
-            ],
-            "layout": "IPY_MODEL_10e898df8a0e460b9f3e3a40b48f51f4"
-          }
-        },
-        "1c01c7f8d62041198190f4bfbe21aff5": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "1da4518f46b84fc7b84d387c7e34f050": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "TextModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "TextModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "TextView",
-            "continuous_update": true,
-            "description": "",
-            "description_tooltip": null,
-            "disabled": false,
-            "layout": "IPY_MODEL_d9f6106f986b4ea49d957594d8d5c324",
-            "placeholder": "output filename",
-            "style": "IPY_MODEL_e8b9fd55c6094126b24ab2e7cffa4dc5",
-            "value": ""
-          }
-        },
-        "202010c9f8324e1493baa92d83ff9335": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "258e8504f9cc4be783ea207c43e56214": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "269ab898c24e4cf697ad3dc2854a7215": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "ButtonStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "ButtonStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "button_color": null,
-            "font_weight": ""
-          }
-        },
-        "2e2775bb4c6e4b98ba4706d90b24e042": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": "none",
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "2e6724a498d54c73a8f594b19c6a3d20": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "2e96cf393a754d279bcf02c66548f6dd": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "ButtonModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "ButtonModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "ButtonView",
-            "button_style": "",
-            "description": "Cancel",
-            "disabled": false,
-            "icon": "",
-            "layout": "IPY_MODEL_ff9bd5c776a741248e4a64d445950c90",
-            "style": "IPY_MODEL_4b551eab21b34f488d743ea730a541d8",
-            "tooltip": ""
-          }
-        },
-        "32bac6722d6d47a6b5a88372e9e5d44e": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "TextModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "TextModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "TextView",
-            "continuous_update": true,
-            "description": "Out End:",
-            "description_tooltip": null,
-            "disabled": false,
-            "layout": "IPY_MODEL_eed45853cf99427398e7b16f2cab9f8b",
-            "placeholder": "​",
-            "style": "IPY_MODEL_5363ac1b24b24811ae9c63b86dfbf359",
-            "value": "2009-06"
-          }
-        },
-        "332172fad96e4be2857e530ba9df86c6": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "ButtonModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "ButtonModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "ButtonView",
-            "button_style": "success",
-            "description": "Run Analysis",
-            "disabled": false,
-            "icon": "",
-            "layout": "IPY_MODEL_514e5aafad0044cb9df9232ef0a4e264",
-            "style": "IPY_MODEL_367366f650c644d59791946a3c8d86d0",
-            "tooltip": ""
-          }
-        },
-        "354bbc188daa4493967e2b143ceea510": {
-          "model_module": "@jupyter-widgets/output",
-          "model_module_version": "1.0.0",
-          "model_name": "OutputModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/output",
-            "_model_module_version": "1.0.0",
-            "_model_name": "OutputModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/output",
-            "_view_module_version": "1.0.0",
-            "_view_name": "OutputView",
-            "layout": "IPY_MODEL_d807a3a60ca14ddda5fbec481049b6d4",
-            "msg_id": "",
-            "outputs": [
-              {
-                "name": "stdout",
-                "output_type": "stream",
-                "text": [
-                  "✅ analysis complete | 15 funds\n",
-                  "⚠️ Dropped: ['Crescent Management']\n",
-                  "📊 Indices: ['EqualWeight_60', 'EqualWeight_40']\n"
-                ]
-              },
-              {
-                "ename": "TypeError",
-                "evalue": "make_portfolio_formatter() takes 2 positional arguments but 5 were given",
-                "output_type": "error",
-                "traceback": [
-                  "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
-                  "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
-                  "\u001b[0;32m<ipython-input-56-445aa7dfbbcf>\u001b[0m in \u001b[0;36m_run\u001b[0;34m(_)\u001b[0m\n\u001b[1;32m    257\u001b[0m         \u001b[0;31m# … build your summary_df, in_stat, out_stat, weights …\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    258\u001b[0m         \u001b[0mmake_summary_formatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msummary_df\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0min_start\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0min_end\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_start\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_end\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0min_stat\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mout_stat\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mw_dict\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 259\u001b[0;31m         \u001b[0mmake_portfolio_formatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mportfolio_df\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"in_ew_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"out_ew_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"in_user_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"out_user_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    260\u001b[0m         \u001b[0mmake_indices_formatter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mindices_df\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mres\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\"index_stats\"\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    261\u001b[0m         \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"Sheets to write:\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mlist\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mkeys\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
-                  "\u001b[0;31mTypeError\u001b[0m: make_portfolio_formatter() takes 2 positional arguments but 5 were given"
-                ]
-              }
-            ]
-          }
-        },
-        "367366f650c644d59791946a3c8d86d0": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "ButtonStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "ButtonStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "button_color": null,
-            "font_weight": ""
-          }
-        },
-        "3814c0e0fa1c438e87df5b60a82dd3e4": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "BoundedIntTextModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "BoundedIntTextModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "IntTextView",
-            "continuous_update": false,
-            "description": "# Indices:",
-            "description_tooltip": null,
-            "disabled": false,
-            "layout": "IPY_MODEL_e5c317ba51ed45818d7d60cc4aaec11d",
-            "max": 10,
-            "min": 0,
-            "step": 1,
-            "style": "IPY_MODEL_7e5dd5f9379a4104ad7965a34e569a7a",
-            "value": 2
-          }
-        },
-        "383dee58194446698cb8eb9df41b7778": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "38d3e511fdc14bcaa7b04d8583be18dc": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "47ae7b5e18314a2596b33cc6c774942b": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "ButtonStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "ButtonStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "button_color": null,
-            "font_weight": ""
-          }
-        },
-        "4a022a6055c34004b7a3aa671a168ee3": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": "block",
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "4b551eab21b34f488d743ea730a541d8": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "ButtonStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "ButtonStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "button_color": null,
-            "font_weight": ""
-          }
-        },
-        "514e5aafad0044cb9df9232ef0a4e264": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "516389ac0f0042a0bbeab3bd64493997": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "LabelModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "LabelModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "LabelView",
-            "description": "",
-            "description_tooltip": null,
-            "layout": "IPY_MODEL_2e2775bb4c6e4b98ba4706d90b24e042",
-            "placeholder": "​",
-            "style": "IPY_MODEL_b411a590b161465185dfd853a6dd95d6",
-            "value": "Total = 0 %"
-          }
-        },
-        "5363ac1b24b24811ae9c63b86dfbf359": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "574d70e37e6a449dbdd4365c2d86fda8": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "5759bee9a2034ed3b9b4196e158b58eb": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "TextModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "TextModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "TextView",
-            "continuous_update": true,
-            "description": "In Start:",
-            "description_tooltip": null,
-            "disabled": false,
-            "layout": "IPY_MODEL_383dee58194446698cb8eb9df41b7778",
-            "placeholder": "​",
-            "style": "IPY_MODEL_72bdf8a1ccfa4d0985547020c90908a0",
-            "value": "2005-07"
-          }
-        },
-        "593aad971d274b90b56cecc15e09dc39": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HTMLModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HTMLModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HTMLView",
-            "description": "",
-            "description_tooltip": null,
-            "layout": "IPY_MODEL_15de8a73c52642c598ad8baeb3609499",
-            "placeholder": "​",
-            "style": "IPY_MODEL_2e6724a498d54c73a8f594b19c6a3d20",
-            "value": ""
-          }
-        },
-        "62c2030d08cf4f1e91c9c9038f31b864": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": "auto"
-          }
-        },
-        "64045569d769471e92ac17aebf71022f": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "TextModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "TextModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "TextView",
-            "continuous_update": true,
-            "description": "",
-            "description_tooltip": null,
-            "disabled": false,
-            "layout": "IPY_MODEL_97212667726d480eb944e25ec32cfc25",
-            "placeholder": "https://…/file.csv",
-            "style": "IPY_MODEL_6e75d93c40ea4c40b9162ab51e807d98",
-            "value": "https://raw.githubusercontent.com/stranske/Trend_Model_Project/refs/heads/main/hedge_fund_returns_with_indexes.csv"
-          }
-        },
-        "6418ed5196fd485cae29568a24bf60ae": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "GridBoxModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "GridBoxModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "GridBoxView",
-            "box_style": "",
-            "children": [
-              "IPY_MODEL_09e8f8999ea1463a9d603da4f4f70b12",
-              "IPY_MODEL_1da4518f46b84fc7b84d387c7e34f050",
-              "IPY_MODEL_021e4dc72d814e5d8c42592b541b6723"
-            ],
-            "layout": "IPY_MODEL_97f4dce2a3874dafaeb0ba92775ae2a0"
-          }
-        },
-        "646d2e69e110438fa2feb8b60af24bb7": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "65dbf5a3b3a2406aa9f807b74dc5543b": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": "6em",
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": "6em"
-          }
-        },
-        "6c1e290b8fdf4e31872f11e0c5438b5d": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": "auto",
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "6c7f140622534a6cab6133758aa7a936": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "6dc67c18884044ac811b3a256f69171e": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "6e5e4fc36c674146a86dc3f8b6edbd7d": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "TextModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "TextModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "TextView",
-            "continuous_update": true,
-            "description": "In End:",
-            "description_tooltip": null,
-            "disabled": false,
-            "layout": "IPY_MODEL_8a9b22cd239d43d191387ebc9e660ff8",
-            "placeholder": "​",
-            "style": "IPY_MODEL_86a9efbe68f5450685a4e8aa1c96e84e",
-            "value": "2008-06"
-          }
-        },
-        "6e75d93c40ea4c40b9162ab51e807d98": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "704f7526c3934eed85b653fb00714114": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "FloatTextModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "FloatTextModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "FloatTextView",
-            "continuous_update": false,
-            "description": "Monthly Cost:",
-            "description_tooltip": null,
-            "disabled": false,
-            "layout": "IPY_MODEL_d6710d2b4b0b4b02b5358d2d152fbad9",
-            "step": null,
-            "style": "IPY_MODEL_ca05ab87b3e040cbbf4016ae0671fc40",
-            "value": 0.0033
-          }
-        },
-        "70dfa008682a460aa02625a933b33606": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "72bdf8a1ccfa4d0985547020c90908a0": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "74577bb60c55412d9c38960d7d865fd6": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "75ad9c9f175f4960999958cd9f6d056a": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HBoxModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HBoxModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HBoxView",
-            "box_style": "",
-            "children": [
-              "IPY_MODEL_3814c0e0fa1c438e87df5b60a82dd3e4"
-            ],
-            "layout": "IPY_MODEL_6c7f140622534a6cab6133758aa7a936"
-          }
-        },
-        "78906e475e9d4bda8b7e0c4ca4de577c": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "7e5dd5f9379a4104ad7965a34e569a7a": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "818aa783706f4087a3754d39d861ced6": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "BoundedIntTextModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "BoundedIntTextModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "IntTextView",
-            "continuous_update": false,
-            "description": "Sample N:",
-            "description_tooltip": null,
-            "disabled": false,
-            "layout": "IPY_MODEL_4a022a6055c34004b7a3aa671a168ee3",
-            "max": 100,
-            "min": 2,
-            "step": 1,
-            "style": "IPY_MODEL_c9b1027aad95413c94835aef5ce74a5b",
-            "value": 15
-          }
-        },
-        "86a9efbe68f5450685a4e8aa1c96e84e": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "8a9b22cd239d43d191387ebc9e660ff8": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "8c053f4df9ff486f84b123eda524cbe7": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HBoxModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HBoxModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HBoxView",
-            "box_style": "",
-            "children": [
-              "IPY_MODEL_e00ed42085424c6f91fb07fb2d22ee62",
-              "IPY_MODEL_818aa783706f4087a3754d39d861ced6"
-            ],
-            "layout": "IPY_MODEL_258e8504f9cc4be783ea207c43e56214"
-          }
-        },
-        "8d9670b7900c40b8849f7e4629d50424": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "8f3ec331c368446b8552a06238a12608": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "8face5cf545b40ceaf10b1506e754d71": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "VBoxModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "VBoxModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "VBoxView",
-            "box_style": "",
-            "children": [
-              "IPY_MODEL_db185d3992024056acfa2ffe419931d8",
-              "IPY_MODEL_c459f2c677ff4bea8db916696b7b600e",
-              "IPY_MODEL_170d05f5ba184c13bb39914b17257476",
-              "IPY_MODEL_64045569d769471e92ac17aebf71022f",
-              "IPY_MODEL_f83a99900b324015862cad100f5bfc0c",
-              "IPY_MODEL_ee231bb4cb97454591e7a6774bb2f7bd",
-              "IPY_MODEL_eceecb3f8a864d1eb15aab7d531e3cd1",
-              "IPY_MODEL_75ad9c9f175f4960999958cd9f6d056a",
-              "IPY_MODEL_e0d83789c4034d9ab9b3c2fa85870beb",
-              "IPY_MODEL_ae753571f5814a65865abbdb10540373",
-              "IPY_MODEL_125e415320644832a8be95b92713e257",
-              "IPY_MODEL_8c053f4df9ff486f84b123eda524cbe7",
-              "IPY_MODEL_d3bae0e7a2474ea4bdce0b0b9e413059",
-              "IPY_MODEL_516389ac0f0042a0bbeab3bd64493997",
-              "IPY_MODEL_e7dc4acbb2eb4a0e8c5112e4b2a85393",
-              "IPY_MODEL_332172fad96e4be2857e530ba9df86c6",
-              "IPY_MODEL_354bbc188daa4493967e2b143ceea510"
-            ],
-            "layout": "IPY_MODEL_6dc67c18884044ac811b3a256f69171e"
-          }
-        },
-        "958a21d97fa546a2b314e2c988b43589": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "97212667726d480eb944e25ec32cfc25": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": "block",
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": "70%"
-          }
-        },
-        "97f4dce2a3874dafaeb0ba92775ae2a0": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": "none",
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": "0px 0px",
-            "grid_row": null,
-            "grid_template_areas": "\n                    'pathlist filename'\n                    'dircontent dircontent'\n                    ",
-            "grid_template_columns": "60% 40%",
-            "grid_template_rows": "auto auto",
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": "auto"
-          }
-        },
-        "9a302560059a43338397161ea2ad37c7": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "9ac98c85e0f147f8a191f6d32651d0cc": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "a503b43ca679455f978c6903bdb598cf": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "a8d2ae4652394bb4b2a740097a4d7ea7": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "ae45af3a4d3d4fb8b1c2827585ed7f7f": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": "pathlist",
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": "auto"
-          }
-        },
-        "ae753571f5814a65865abbdb10540373": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HBoxModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HBoxModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HBoxView",
-            "box_style": "",
-            "children": [
-              "IPY_MODEL_d13209a7e5c94f6585d47c2430fa7885",
-              "IPY_MODEL_704f7526c3934eed85b653fb00714114"
-            ],
-            "layout": "IPY_MODEL_08882c12ccaa4d058bc554020c044559"
-          }
-        },
-        "b411a590b161465185dfd853a6dd95d6": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "be7153ab36374e62a7d6a234dc1c973e": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": "0 0 0 1em",
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "bedc16eeb19740bb9ee6e810bc9b7a71": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": "none",
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "c459f2c677ff4bea8db916696b7b600e": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "ToggleButtonsModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "ToggleButtonsModel",
-            "_options_labels": [
-              "Local",
-              "URL"
-            ],
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "ToggleButtonsView",
-            "button_style": "",
-            "description": "Source:",
-            "description_tooltip": null,
-            "disabled": false,
-            "icons": [],
-            "index": 1,
-            "layout": "IPY_MODEL_a8d2ae4652394bb4b2a740097a4d7ea7",
-            "style": "IPY_MODEL_dbe1076d681040169eca1b570e2485e2",
-            "tooltips": []
-          }
-        },
-        "c9b1027aad95413c94835aef5ce74a5b": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "ca05ab87b3e040cbbf4016ae0671fc40": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "d12e413cbeac41a39fd9b94479c1eca8": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HBoxModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HBoxModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HBoxView",
-            "box_style": "",
-            "children": [
-              "IPY_MODEL_f5539db7aca6440e9c3dee43697c4fae",
-              "IPY_MODEL_2e96cf393a754d279bcf02c66548f6dd",
-              "IPY_MODEL_0b231b28c644443db3e659a17096f55c"
-            ],
-            "layout": "IPY_MODEL_62c2030d08cf4f1e91c9c9038f31b864"
-          }
-        },
-        "d13209a7e5c94f6585d47c2430fa7885": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "FloatTextModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "FloatTextModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "FloatTextView",
-            "continuous_update": false,
-            "description": "Target Vol:",
-            "description_tooltip": null,
-            "disabled": false,
-            "layout": "IPY_MODEL_74577bb60c55412d9c38960d7d865fd6",
-            "step": null,
-            "style": "IPY_MODEL_d37456fcb76f4acda7978257483bf2ad",
-            "value": 0.25
-          }
-        },
-        "d22068b3d502469fa1631d698a3d3779": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "d37456fcb76f4acda7978257483bf2ad": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "d3bae0e7a2474ea4bdce0b0b9e413059": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "VBoxModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "VBoxModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "VBoxView",
-            "box_style": "",
-            "children": [],
-            "layout": "IPY_MODEL_bedc16eeb19740bb9ee6e810bc9b7a71"
-          }
-        },
-        "d6710d2b4b0b4b02b5358d2d152fbad9": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "d807a3a60ca14ddda5fbec481049b6d4": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": "1px solid #999",
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": "340px",
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": "auto",
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "d80f632f65c44c338a41d0b4e3dc5ea7": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "d9f6106f986b4ea49d957594d8d5c324": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": "filename",
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": "auto"
-          }
-        },
-        "db185d3992024056acfa2ffe419931d8": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HTMLModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HTMLModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HTMLView",
-            "description": "",
-            "description_tooltip": null,
-            "layout": "IPY_MODEL_d80f632f65c44c338a41d0b4e3dc5ea7",
-            "placeholder": "​",
-            "style": "IPY_MODEL_9a302560059a43338397161ea2ad37c7",
-            "value": "<h4>1. Load data</h4>"
-          }
-        },
-        "dbe1076d681040169eca1b570e2485e2": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "ToggleButtonsStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "ToggleButtonsStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "button_width": "",
-            "description_width": "",
-            "font_weight": ""
-          }
-        },
-        "dfbe93388b474442833b5e7b7efc1e5f": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "e00ed42085424c6f91fb07fb2d22ee62": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DropdownModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DropdownModel",
-            "_options_labels": [
-              "All",
-              "Random",
-              "Manual"
-            ],
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "DropdownView",
-            "description": "Mode:",
-            "description_tooltip": null,
-            "disabled": false,
-            "index": 1,
-            "layout": "IPY_MODEL_958a21d97fa546a2b314e2c988b43589",
-            "style": "IPY_MODEL_202010c9f8324e1493baa92d83ff9335"
-          }
-        },
-        "e02a002607844c6ba0249122b505b8f5": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "e0d83789c4034d9ab9b3c2fa85870beb": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HBoxModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HBoxModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HBoxView",
-            "box_style": "",
-            "children": [
-              "IPY_MODEL_5759bee9a2034ed3b9b4196e158b58eb",
-              "IPY_MODEL_6e5e4fc36c674146a86dc3f8b6edbd7d",
-              "IPY_MODEL_fa9ee776b338497e9385f3d1a8d02fff",
-              "IPY_MODEL_32bac6722d6d47a6b5a88372e9e5d44e"
-            ],
-            "layout": "IPY_MODEL_dfbe93388b474442833b5e7b7efc1e5f"
-          }
-        },
-        "e5c317ba51ed45818d7d60cc4aaec11d": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "e7dc4acbb2eb4a0e8c5112e4b2a85393": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HTMLModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HTMLModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HTMLView",
-            "description": "",
-            "description_tooltip": null,
-            "layout": "IPY_MODEL_a503b43ca679455f978c6903bdb598cf",
-            "placeholder": "​",
-            "style": "IPY_MODEL_70dfa008682a460aa02625a933b33606",
-            "value": "<hr>"
-          }
-        },
-        "e8b9fd55c6094126b24ab2e7cffa4dc5": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "DescriptionStyleModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "DescriptionStyleModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "StyleView",
-            "description_width": ""
-          }
-        },
-        "eceecb3f8a864d1eb15aab7d531e3cd1": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "HTMLModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "HTMLModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "HTMLView",
-            "description": "",
-            "description_tooltip": null,
-            "layout": "IPY_MODEL_05a596b6c3864ddc931b3112153f12ab",
-            "placeholder": "​",
-            "style": "IPY_MODEL_8f3ec331c368446b8552a06238a12608",
-            "value": "<hr><h4>2. Parameters</h4>"
-          }
-        },
-        "ee231bb4cb97454591e7a6774bb2f7bd": {
-          "model_module": "@jupyter-widgets/output",
-          "model_module_version": "1.0.0",
-          "model_name": "OutputModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/output",
-            "_model_module_version": "1.0.0",
-            "_model_name": "OutputModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/output",
-            "_view_module_version": "1.0.0",
-            "_view_name": "OutputView",
-            "layout": "IPY_MODEL_e02a002607844c6ba0249122b505b8f5",
-            "msg_id": "",
-            "outputs": [
-              {
-                "name": "stdout",
-                "output_type": "stream",
-                "text": [
-                  "✅ Loaded 312 rows × 104 cols | RF → Risk-Free Rate\n"
-                ]
-              },
-              {
-                "name": "stderr",
-                "output_type": "stream",
-                "text": [
-                  "<ipython-input-56-445aa7dfbbcf>:33: UserWarning: Could not infer format, so each element will be parsed individually, falling back to `dateutil`. To ensure parsing is consistent and as-expected, please specify a format.\n",
-                  "  df[\"Date\"] = pd.to_datetime(df[\"Date\"], errors=\"coerce\")  # single coercion\n"
-                ]
-              }
-            ]
-          }
-        },
-        "eed45853cf99427398e7b16f2cab9f8b": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": null
-          }
-        },
-        "f5539db7aca6440e9c3dee43697c4fae": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "ButtonModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "ButtonModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "ButtonView",
-            "button_style": "",
-            "description": "Select",
-            "disabled": false,
-            "icon": "",
-            "layout": "IPY_MODEL_65dbf5a3b3a2406aa9f807b74dc5543b",
-            "style": "IPY_MODEL_269ab898c24e4cf697ad3dc2854a7215",
-            "tooltip": ""
-          }
-        },
-        "f5e355edbbc946b3b6e1ba36f839d45b": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": null,
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": "dircontent",
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": null,
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": "auto"
-          }
-        },
-        "f83a99900b324015862cad100f5bfc0c": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "ButtonModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "ButtonModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "ButtonView",
-            "button_style": "success",
-            "description": "Load CSV",
-            "disabled": false,
-            "icon": "",
-            "layout": "IPY_MODEL_646d2e69e110438fa2feb8b60af24bb7",
-            "style": "IPY_MODEL_47ae7b5e18314a2596b33cc6c774942b",
-            "tooltip": ""
-          }
-        },
-        "fa9ee776b338497e9385f3d1a8d02fff": {
-          "model_module": "@jupyter-widgets/controls",
-          "model_module_version": "1.5.0",
-          "model_name": "TextModel",
-          "state": {
-            "_dom_classes": [],
-            "_model_module": "@jupyter-widgets/controls",
-            "_model_module_version": "1.5.0",
-            "_model_name": "TextModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/controls",
-            "_view_module_version": "1.5.0",
-            "_view_name": "TextView",
-            "continuous_update": true,
-            "description": "Out Start:",
-            "description_tooltip": null,
-            "disabled": false,
-            "layout": "IPY_MODEL_38d3e511fdc14bcaa7b04d8583be18dc",
-            "placeholder": "​",
-            "style": "IPY_MODEL_8d9670b7900c40b8849f7e4629d50424",
-            "value": "2008-07"
-          }
-        },
-        "ff9bd5c776a741248e4a64d445950c90": {
-          "model_module": "@jupyter-widgets/base",
-          "model_module_version": "1.2.0",
-          "model_name": "LayoutModel",
-          "state": {
-            "_model_module": "@jupyter-widgets/base",
-            "_model_module_version": "1.2.0",
-            "_model_name": "LayoutModel",
-            "_view_count": null,
-            "_view_module": "@jupyter-widgets/base",
-            "_view_module_version": "1.2.0",
-            "_view_name": "LayoutView",
-            "align_content": null,
-            "align_items": null,
-            "align_self": null,
-            "border": null,
-            "bottom": null,
-            "display": "none",
-            "flex": null,
-            "flex_flow": null,
-            "grid_area": null,
-            "grid_auto_columns": null,
-            "grid_auto_flow": null,
-            "grid_auto_rows": null,
-            "grid_column": null,
-            "grid_gap": null,
-            "grid_row": null,
-            "grid_template_areas": null,
-            "grid_template_columns": null,
-            "grid_template_rows": null,
-            "height": null,
-            "justify_content": null,
-            "justify_items": null,
-            "left": null,
-            "margin": null,
-            "max_height": null,
-            "max_width": null,
-            "min_height": null,
-            "min_width": "6em",
-            "object_fit": null,
-            "object_position": null,
-            "order": null,
-            "overflow": null,
-            "overflow_x": null,
-            "overflow_y": null,
-            "padding": null,
-            "right": null,
-            "top": null,
-            "visibility": null,
-            "width": "6em"
-          }
-        },
-        "state": {}
-      }
-    }
-  },
-  "nbformat": 4,
-  "nbformat_minor": 5
-}
diff --git a/.jupyter/desktop-workspaces/default-37a8.jupyterlab-workspace b/.jupyter/desktop-workspaces/default-37a8.jupyterlab-workspace
deleted file mode 100644
index 0b9089958c88b7a043581a72bdbeb9f69940117c..0000000000000000000000000000000000000000
--- a/.jupyter/desktop-workspaces/default-37a8.jupyterlab-workspace
+++ /dev/null
@@ -1 +0,0 @@
-{"data":{"layout-restorer:data":{"main":{"dock":{"type":"tab-area","currentIndex":0,"widgets":["notebook:Vol_Adj_Trend_Analysis1.2.TrEx.ipynb"]},"current":"notebook:Vol_Adj_Trend_Analysis_1.1.TrEx.ipynb"},"down":{"size":0,"widgets":[]},"left":{"collapsed":true,"visible":false,"widgets":["filebrowser","running-sessions","@jupyterlab/toc:plugin","debugger-sidebar","extensionmanager.main-view"],"widgetStates":{"jp-running-sessions":{"sizes":[0.16666666666666666,0.16666666666666666,0.16666666666666666,0.16666666666666666,0.16666666666666666,0.16666666666666666],"expansionStates":[false,false,false,false,false,false]},"jp-debugger-sidebar":{"sizes":[0.2,0.2,0.2,0.2,0.2],"expansionStates":[false,false,false,false,false]},"extensionmanager.main-view":{"sizes":[0.3333333333333333,0.3333333333333333,0.3333333333333333],"expansionStates":[false,false,false]}}},"right":{"collapsed":true,"visible":false,"widgets":["jp-property-inspector"],"widgetStates":{}},"relativeSizes":[0,1,0],"top":{"simpleVisibility":true}},"docmanager:recents":{"opened":[{"path":"","contentType":"directory","root":"~/Library/CloudStorage/Dropbox/Learning/Code/Trend Modeling Project"},{"path":"Vol_Adj_Trend_Analysis_1.1.TrEx.ipynb","contentType":"notebook","factory":"Notebook","root":"~/Library/CloudStorage/Dropbox/Learning/Code/Trend Modeling Project"},{"path":"Vol_Adj_Trend_Analysis1.2.TrEx.ipynb","contentType":"notebook","factory":"Notebook","root":"~/Library/CloudStorage/Dropbox/Learning/Code/Trend Modeling Project"}],"closed":[]},"notebook:Vol_Adj_Trend_Analysis1.2.TrEx.ipynb":{"data":{"path":"Vol_Adj_Trend_Analysis1.2.TrEx.ipynb","factory":"Notebook"}},"notebook:Vol_Adj_Trend_Analysis_1.1.TrEx.ipynb":{"data":{"path":"Vol_Adj_Trend_Analysis_1.1.TrEx.ipynb","factory":"Notebook"}}},"metadata":{"id":"default"}}
\ No newline at end of file
 
EOF
)