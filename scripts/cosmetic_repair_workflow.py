"""Workflow helpers for the cosmetic repair GitHub Actions job.

This module provides small CLI entry points that the workflow can invoke to
interact with the JSON summary generated by ``scripts/ci_cosmetic_repair.py``.
Separating the helpers into a standalone script keeps the workflow YAML free
from complex ``python -c`` invocations and makes the logic easier to test.
"""

from __future__ import annotations

import argparse
import json
import os
from pathlib import Path
from typing import Iterable, Sequence

DEFAULT_SUMMARY = Path(".cosmetic-repair-summary.json")
SUMMARY_KEYS: Sequence[str] = ("status", "branch", "pr_url")


def _load_summary(path: Path) -> dict[str, object]:
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
    except FileNotFoundError:
        raise SystemExit(0) from None
    return data


def capture_outputs(summary_file: Path, output_path: Path | None) -> None:
    if output_path is None or not summary_file.exists():
        raise SystemExit(0)

    data = _load_summary(summary_file)
    with output_path.open("a", encoding="utf-8") as handle:
        for key in SUMMARY_KEYS:
            value = data.get(key)
            if value:
                handle.write(f"{key}={value}\n")


def evaluate_outcome(
    summary_file: Path,
    output_path: Path | None,
    pytest_exit_code: int,
) -> None:
    if output_path is None:
        raise SystemExit("GITHUB_OUTPUT is not defined")

    should_fail = False
    reason = ""

    if pytest_exit_code != 0:
        if summary_file.exists():
            data = _load_summary(summary_file)
            applied = int(data.get("applied", 0))
            if applied == 0:
                should_fail = True
                reason = "Pytest failures detected but no cosmetic fixes were applied."
        else:
            should_fail = True
            reason = "Pytest failures detected but repair summary was not generated."

    with output_path.open("a", encoding="utf-8") as handle:
        result = "true" if should_fail else "false"
        handle.write(f"should_fail={result}\n")
        if reason:
            handle.write(f"reason={reason}\n")


def render_summary(summary_file: Path) -> None:
    data = _load_summary(summary_file)
    status = data.get("status", "unknown")
    print(f"- Status: **{status}**")

    changed = data.get("changed_files") or []
    if changed:
        if not isinstance(changed, Iterable) or isinstance(changed, (str, bytes)):
            changed_list: Iterable[object] = [changed]
        else:
            changed_list = changed
        changed_items = list(changed_list)
        print(f"- Changed files ({len(changed_items)}):")
        for path in changed_items:
            print(f"  - `{path}`")
    else:
        print("- No file changes detected.")

    pr_url = data.get("pr_url")
    if pr_url:
        print(f"- PR: {pr_url}")

    instructions = data.get("instructions") or []
    if instructions:
        print("- Instructions processed:")
        if not isinstance(instructions, Iterable):
            instructions_iter: Iterable[object] = [instructions]
        else:
            instructions_iter = instructions
        for entry in instructions_iter:
            if not isinstance(entry, dict):
                continue
            kind = entry.get("kind", "unknown")
            path = entry.get("path", "?")
            guard = entry.get("guard", "")
            extra = f" ({guard})" if guard else ""
            print(f"  - `{kind}` â†’ `{path}`{extra}")


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Helpers for the cosmetic repair workflow",
    )
    subparsers = parser.add_subparsers(dest="command", required=True)

    capture = subparsers.add_parser(
        "capture", help="write summary fields to GITHUB_OUTPUT"
    )
    capture.add_argument("--summary-file", type=Path, default=DEFAULT_SUMMARY)
    capture.add_argument("--output", type=Path, default=None)

    evaluate = subparsers.add_parser("evaluate", help="emit should_fail metadata")
    evaluate.add_argument("--summary-file", type=Path, default=DEFAULT_SUMMARY)
    evaluate.add_argument("--output", type=Path, default=None)
    evaluate.add_argument("--pytest-exit-code", type=int, required=True)

    render = subparsers.add_parser(
        "render", help="print markdown summary for the step summary"
    )
    render.add_argument("--summary-file", type=Path, default=DEFAULT_SUMMARY)

    return parser


def main(argv: Sequence[str] | None = None) -> None:
    parser = build_parser()
    args = parser.parse_args(argv)

    if args.command == "capture":
        output = args.output
        if output is None:
            output_env = os.environ.get("GITHUB_OUTPUT") or ""
            output = Path(output_env) if output_env else None
        capture_outputs(args.summary_file, output)
        return

    if args.command == "evaluate":
        output = args.output
        if output is None:
            output_env = os.environ.get("GITHUB_OUTPUT") or ""
            output = Path(output_env) if output_env else None
        evaluate_outcome(args.summary_file, output, args.pytest_exit_code)
        return

    if args.command == "render":
        render_summary(args.summary_file)
        return

    parser.error(f"Unknown command: {args.command}")


if __name__ == "__main__":
    from trend_analysis.script_logging import setup_script_logging

    setup_script_logging(module_file=__file__)
    main()
