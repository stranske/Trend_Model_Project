{"type":"thread.started","thread_id":"019b822f-6c59-78a0-9aaa-827a4d40d930"}
{"type":"turn.started"}
{"type":"item.completed","item":{"id":"item_0","type":"reasoning","text":"**Searching for relevant files with rg**"}}
{"type":"item.started","item":{"id":"item_1","type":"command_execution","command":"/bin/bash -lc 'rg -n \"compute_constrained_weights|max_weight|vol_adjust\" src tests'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_1","type":"command_execution","command":"/bin/bash -lc 'rg -n \"compute_constrained_weights|max_weight|vol_adjust\" src tests'","aggregated_output":"src/trend_analysis/gui/app.py:372:    cfg.setdefault(\"vol_adjust\", as_dict(cfg.get(\"vol_adjust\")))\nsrc/trend_analysis/gui/app.py:804:        value=store.cfg.get(\"use_vol_adjust\", False),\nsrc/trend_analysis/gui/app.py:845:        store.cfg[\"use_vol_adjust\"] = bool(change[\"new\"])\nsrc/trend_analysis/signal_presets.py:26:            \"vol_adjust\": self.spec.vol_adjust,\nsrc/trend_analysis/signal_presets.py:43:            \"vol_adjust\": self.spec.vol_adjust,\nsrc/trend_analysis/signal_presets.py:60:            vol_adjust=True,\nsrc/trend_analysis/signal_presets.py:72:            vol_adjust=True,\nsrc/trend_analysis/signal_presets.py:84:            vol_adjust=True,\ntests/test_multi_period_engine_incremental_extra.py:18:    vol_adjust: Dict[str, Any]\ntests/test_multi_period_engine_incremental_extra.py:28:            \"vol_adjust\": self.vol_adjust,\ntests/test_multi_period_engine_incremental_extra.py:64:        vol_adjust={\"target_vol\": 1.0},\ntests/test_multi_period_engine_incremental_extra.py:134:        vol_adjust={\"target_vol\": 1.0},\ntests/test_multi_period_engine_incremental_extra.py:191:        vol_adjust={\"target_vol\": 1.0},\ntests/test_multi_period_engine_incremental_extra.py:244:        vol_adjust={\"target_vol\": 1.0},\nsrc/trend_analysis/multi_period/engine.py:743:    trend_spec = _build_trend_spec(cfg, getattr(cfg, \"vol_adjust\", {}) or {})\nsrc/trend_analysis/multi_period/engine.py:1003:                _resolve_target_vol(getattr(cfg, \"vol_adjust\", {})),\nsrc/trend_analysis/multi_period/engine.py:1005:                floor_vol=cfg.vol_adjust.get(\"floor_vol\"),\nsrc/trend_analysis/multi_period/engine.py:1006:                warmup_periods=int(cfg.vol_adjust.get(\"warmup_periods\", 0) or 0),\nsrc/trend_analysis/multi_period/engine.py:1017:                risk_window=cfg.vol_adjust.get(\"window\"),\nsrc/trend_analysis/multi_period/engine.py:1517:    max_w_bound = float(constraints.get(\"max_weight\", 0.18))  # decimal\nsrc/trend_analysis/multi_period/engine.py:3447:            # - total < 1.0: max_weight caps too tight\nsrc/trend_analysis/multi_period/engine.py:3472:            _resolve_target_vol(getattr(cfg, \"vol_adjust\", {})),\nsrc/trend_analysis/multi_period/engine.py:3474:            floor_vol=cfg.vol_adjust.get(\"floor_vol\"),\nsrc/trend_analysis/multi_period/engine.py:3475:            warmup_periods=int(cfg.vol_adjust.get(\"warmup_periods\", 0) or 0),\nsrc/trend_analysis/multi_period/engine.py:3484:            risk_window=cfg.vol_adjust.get(\"window\"),\ntests/test_signals_causality.py:16:def test_compute_trend_signals_is_causal_without_vol_adjust() -> None:\ntests/test_signals_causality.py:28:def test_compute_trend_signals_is_causal_with_vol_adjust() -> None:\ntests/test_signals_causality.py:30:    spec = TrendSpec(window=4, min_periods=4, vol_adjust=True, vol_target=0.5)\ntests/test_config_load.py:31:        \"vol_adjust\": {\"target_vol\": 0.15},\ntests/test_multi_period_regime_wiring.py:37:            \"vol_adjust\": {\nsrc/trend_analysis/config/models.py:42:            \"vol_adjust\": data.get(\"vol_adjust\", {}),\nsrc/trend_analysis/config/models.py:60:    vol_adjust: dict[str, Any]\nsrc/trend_analysis/config/models.py:280:        vol_adjust: dict[str, Any] = Field(default_factory=dict)\nsrc/trend_analysis/config/models.py:304:            \"vol_adjust\",\nsrc/trend_analysis/config/models.py:409:            \"vol_adjust\",\nsrc/trend_analysis/config/models.py:421:            \"vol_adjust\",\nsrc/trend_analysis/config/models.py:444:        vol_adjust: Dict[str, Any]\nsrc/trend_analysis/config/models.py:464:                \"vol_adjust\": {},\nsrc/trend_analysis/config/models.py:494:                \"vol_adjust\",\nsrc/trend_analysis/config/models.py:579:        \"vol_adjust\",\nsrc/trend_analysis/config/models.py:593:    vol_adjust: Dict[str, Any]\nsrc/trend_analysis/config/models.py:744:        \"vol_adjust\",\nsrc/trend_analysis/config/models.py:835:        \"vol_adjust\",\ntests/test_trend_signals.py:35:def test_vol_adjustment_changes_scale():\ntests/test_trend_signals.py:39:        returns, TrendSpec(window=4, vol_adjust=True, vol_target=1.0)\ntests/test_trend_signals.py:81:    spec = TrendSpec(window=4, vol_adjust=True)\ntests/test_trend_signals.py:110:    spec = TrendSpec(window=3, vol_adjust=True, vol_target=1.0, zscore=True)\nsrc/trend_analysis/config/legacy.py:43:    vol_adjust: dict[str, Any]\ntests/test_engine_incremental_cov.py:25:        vol_adjust={},\nsrc/trend_analysis/config/model.py:503:            raise ValueError(\"vol_adjust.target_vol must be numeric.\") from exc\nsrc/trend_analysis/config/model.py:505:            raise ValueError(\"vol_adjust.target_vol must be greater than zero.\")\nsrc/trend_analysis/config/model.py:514:            raise ValueError(\"vol_adjust.floor_vol must be numeric.\") from exc\nsrc/trend_analysis/config/model.py:516:            raise ValueError(\"vol_adjust.floor_vol cannot be negative.\")\nsrc/trend_analysis/config/model.py:525:            raise ValueError(\"vol_adjust.warmup_periods must be an integer.\") from exc\nsrc/trend_analysis/config/model.py:527:            raise ValueError(\"vol_adjust.warmup_periods cannot be negative.\")\nsrc/trend_analysis/config/model.py:536:    vol_adjust: RiskSettings\nsrc/trend_analysis/risk.py:42:    \"\"\"Diagnostics emitted by :func:`compute_constrained_weights`.\"\"\"\nsrc/trend_analysis/risk.py:239:def compute_constrained_weights(\nsrc/trend_analysis/risk.py:248:    max_weight: float | None,\nsrc/trend_analysis/risk.py:267:    effective_max_weight = max_weight\nsrc/trend_analysis/risk.py:268:    if max_weight is not None:\nsrc/trend_analysis/risk.py:270:            max_weight_val = float(max_weight)\nsrc/trend_analysis/risk.py:272:            max_weight_val = None\nsrc/trend_analysis/risk.py:273:        if max_weight_val is not None and max_weight_val > 0 and len(base) > 0:\nsrc/trend_analysis/risk.py:275:            if max_weight_val * len(base) < 1.0 - NUMERICAL_TOLERANCE_HIGH:\nsrc/trend_analysis/risk.py:276:                max_weight_val = min_cap\nsrc/trend_analysis/risk.py:277:        effective_max_weight = max_weight_val\nsrc/trend_analysis/risk.py:281:        \"max_weight\": effective_max_weight,\nsrc/trend_analysis/risk.py:346:    \"compute_constrained_weights\",\nsrc/trend_analysis/config/bridge.py:56:        \"vol_adjust\": {\"target_vol\": target_vol},\ntests/test_rebalance_frequency_wiring.py:37:                \"max_weight\": 0.8,\ntests/test_rebalance_frequency_wiring.py:44:    vol_adjust: dict[str, object] = field(\ntests/test_rebalance_frequency_wiring.py:56:            \"vol_adjust\": dict(self.vol_adjust),\nsrc/trend_analysis/signals.py:117:    vol_adjust: bool = False\nsrc/trend_analysis/signals.py:177:    if spec.vol_adjust:\nsrc/trend_analysis/api.py:43:    vol_adjust_cfg: Mapping[str, Any] | None = None,\nsrc/trend_analysis/api.py:49:        trend_spec = _build_trend_spec({\"signals\": signals_cfg}, vol_adjust_cfg or {})\nsrc/trend_analysis/api.py:399:    vol_adjust_cfg = getattr(config, \"vol_adjust\", {}) or {}\nsrc/trend_analysis/api.py:445:        _resolve_target_vol(vol_adjust_cfg),\nsrc/trend_analysis/api.py:447:        floor_vol=vol_adjust_cfg.get(\"floor_vol\"),\nsrc/trend_analysis/api.py:448:        warmup_periods=int(vol_adjust_cfg.get(\"warmup_periods\", 0) or 0),\nsrc/trend_analysis/api.py:462:        risk_window=vol_adjust_cfg.get(\"window\"),\nsrc/trend_analysis/api.py:467:        vol_adjust_cfg=vol_adjust_cfg,\ntests/test_trend_analysis_config_model.py:506:        \"vol_adjust\": {\ntests/test_trend_analysis_config_model.py:521:    assert cfg.vol_adjust.target_vol == pytest.approx(0.2)\ntests/test_optimizer_constraints.py:16:def test_max_weight_cap_redistributes():\ntests/test_optimizer_constraints.py:18:    out = apply_constraints(w, {\"long_only\": True, \"max_weight\": 0.55})\ntests/test_optimizer_constraints.py:23:def test_too_small_max_weight_infeasible():\ntests/test_optimizer_constraints.py:26:        apply_constraints(w, {\"max_weight\": 0.3})\ntests/test_optimizer_constraints.py:53:        apply_constraints(w, {\"long_only\": True, \"max_weight\": 0.4})\ntests/test_optimizer_constraints.py:78:    with pytest.raises(ConstraintViolation, match=\"max_weight must be positive\"):\ntests/test_optimizer_constraints.py:146:        \"max_weight\": 0.4,\ntests/test_optimizer_constraints.py:190:def test_cash_weight_infeasible_with_max_weight():\ntests/test_optimizer_constraints.py:195:        match=\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\",\ntests/test_optimizer_constraints.py:197:        apply_constraints(w, {\"cash_weight\": 0.3, \"max_weight\": 0.3})\ntests/test_optimizer_constraints.py:200:def test_cash_weight_exceeds_max_weight_for_cash():\ntests/test_optimizer_constraints.py:201:    # cash_weight larger than max_weight should raise\ntests/test_optimizer_constraints.py:203:    with pytest.raises(ConstraintViolation, match=\"exceeds max_weight\"):\ntests/test_optimizer_constraints.py:204:        apply_constraints(w, {\"cash_weight\": 0.6, \"max_weight\": 0.5})\ntests/test_optimizer_constraints.py:207:def test_cash_weight_respects_max_weight_after_residual_scaling():\ntests/test_optimizer_constraints.py:210:    out = apply_constraints(w, {\"cash_weight\": 0.3, \"max_weight\": 0.4})\nsrc/trend_analysis/pipeline.py:43:    compute_constrained_weights,\nsrc/trend_analysis/pipeline.py:948:    raw_max_weight = constraints_cfg.get(\"max_weight\")\nsrc/trend_analysis/pipeline.py:950:        max_weight_val = float(raw_max_weight) if raw_max_weight is not None else None\nsrc/trend_analysis/pipeline.py:952:        max_weight_val = None\nsrc/trend_analysis/pipeline.py:1033:        vol_adjust=False,\nsrc/trend_analysis/pipeline.py:1044:        weights_series, risk_diagnostics = compute_constrained_weights(\nsrc/trend_analysis/pipeline.py:1052:            max_weight=max_weight_val,\nsrc/trend_analysis/pipeline.py:1446:def _resolve_target_vol(vol_adjust_cfg: Mapping[str, Any] | Any) -> float | None:\nsrc/trend_analysis/pipeline.py:1447:    enabled = _section_get(vol_adjust_cfg, \"enabled\")\nsrc/trend_analysis/pipeline.py:1450:    target_raw = _section_get(vol_adjust_cfg, \"target_vol\", 1.0)\nsrc/trend_analysis/pipeline.py:1647:    vol_adjust_cfg: Mapping[str, Any] | Any,\nsrc/trend_analysis/pipeline.py:1690:    vol_adjust_default = bool(_section_get(vol_adjust_cfg, \"enabled\", False))\nsrc/trend_analysis/pipeline.py:1691:    vol_adjust_flag = bool(\nsrc/trend_analysis/pipeline.py:1692:        _signal_setting(\"vol_adjust\", \"trend_vol_adjust\", vol_adjust_default)\nsrc/trend_analysis/pipeline.py:1695:    if vol_target_raw is None and vol_adjust_flag:\nsrc/trend_analysis/pipeline.py:1696:        vol_target_raw = _section_get(vol_adjust_cfg, \"target_vol\")\nsrc/trend_analysis/pipeline.py:1722:        vol_adjust=vol_adjust_flag,\nsrc/trend_analysis/pipeline.py:2661:    vol_adjust = _cfg_section(cfg, \"vol_adjust\")\nsrc/trend_analysis/pipeline.py:2671:    trend_spec = _build_trend_spec(cfg, vol_adjust)\nsrc/trend_analysis/pipeline.py:2682:        _resolve_target_vol(vol_adjust),\nsrc/trend_analysis/pipeline.py:2684:        floor_vol=_section_get(vol_adjust, \"floor_vol\"),\nsrc/trend_analysis/pipeline.py:2685:        warmup_periods=int(_section_get(vol_adjust, \"warmup_periods\", 0) or 0),\nsrc/trend_analysis/pipeline.py:2699:        risk_window=_section_get(vol_adjust, \"window\"),\nsrc/trend_analysis/pipeline.py:2788:    vol_adjust = _cfg_section(cfg, \"vol_adjust\")\nsrc/trend_analysis/pipeline.py:2799:    trend_spec = _build_trend_spec(cfg, vol_adjust)\nsrc/trend_analysis/pipeline.py:2810:        _resolve_target_vol(vol_adjust),\nsrc/trend_analysis/pipeline.py:2812:        floor_vol=_section_get(vol_adjust, \"floor_vol\"),\nsrc/trend_analysis/pipeline.py:2813:        warmup_periods=int(_section_get(vol_adjust, \"warmup_periods\", 0) or 0),\nsrc/trend_analysis/pipeline.py:2827:        risk_window=_section_get(vol_adjust, \"window\"),\nsrc/trend_analysis/engine/optimizer.py:20:    max_weight: float | None = None\nsrc/trend_analysis/engine/optimizer.py:51:        raise ConstraintViolation(\"max_weight must be positive\")\nsrc/trend_analysis/engine/optimizer.py:58:        raise ConstraintViolation(\"max_weight too small for number of assets\")\nsrc/trend_analysis/engine/optimizer.py:154:        if constraints.max_weight is not None and len(working) > 0:\nsrc/trend_analysis/engine/optimizer.py:156:            if eq_after - NUMERICAL_TOLERANCE_HIGH > constraints.max_weight:\nsrc/trend_analysis/engine/optimizer.py:158:                    \"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\"\nsrc/trend_analysis/engine/optimizer.py:163:    if constraints.max_weight is not None:\nsrc/trend_analysis/engine/optimizer.py:164:        working = _apply_cap(working, constraints.max_weight, total=total_allocation)\nsrc/trend_analysis/engine/optimizer.py:181:        if constraints.max_weight is not None:\nsrc/trend_analysis/engine/optimizer.py:183:                working, constraints.max_weight, total=total_allocation\nsrc/trend_analysis/engine/optimizer.py:192:            constraints.max_weight is not None\nsrc/trend_analysis/engine/optimizer.py:193:            and w.loc[\"CASH\"] > constraints.max_weight + NUMERICAL_TOLERANCE_HIGH\nsrc/trend_analysis/engine/optimizer.py:195:            raise ConstraintViolation(\"cash_weight exceeds max_weight constraint\")\nsrc/trend_analysis/engine/optimizer.py:213:        # Feasibility with max_weight: if max_weight is set ensure each non-cash asset\nsrc/trend_analysis/engine/optimizer.py:215:        if constraints.max_weight is not None:\nsrc/trend_analysis/engine/optimizer.py:216:            cap = constraints.max_weight\nsrc/trend_analysis/engine/optimizer.py:221:                    \"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\"\nsrc/trend_analysis/engine/optimizer.py:229:        # If max_weight applies to CASH as well enforce; else skip. We enforce for consistency.\nsrc/trend_analysis/engine/optimizer.py:231:            constraints.max_weight is not None\nsrc/trend_analysis/engine/optimizer.py:232:            and w.loc[\"CASH\"] > constraints.max_weight + NUMERICAL_TOLERANCE_HIGH\nsrc/trend_analysis/engine/optimizer.py:234:            raise ConstraintViolation(\"cash_weight exceeds max_weight constraint\")\nsrc/trend_analysis/engine/optimizer.py:255:        # Feasibility with max_weight: if max_weight is set ensure each non-cash asset\nsrc/trend_analysis/engine/optimizer.py:257:        if constraints.max_weight is not None:\nsrc/trend_analysis/engine/optimizer.py:258:            cap = constraints.max_weight\nsrc/trend_analysis/engine/optimizer.py:263:                    \"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\"\nsrc/trend_analysis/engine/optimizer.py:271:        # If max_weight applies to CASH as well enforce; else skip. We enforce for consistency.\nsrc/trend_analysis/engine/optimizer.py:273:            constraints.max_weight is not None\nsrc/trend_analysis/engine/optimizer.py:274:            and w.loc[\"CASH\"] > constraints.max_weight + NUMERICAL_TOLERANCE_HIGH\nsrc/trend_analysis/engine/optimizer.py:276:            raise ConstraintViolation(\"cash_weight exceeds max_weight constraint\")\ntests/test_cli_trend_presets.py:30:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_cli_trend_presets.py:50:    assert signals[\"vol_adjust\"] is preset.spec.vol_adjust\ntests/test_pipeline_branch_coverage.py:194:    def fake_compute_constrained_weights(\ntests/test_pipeline_branch_coverage.py:203:        pipeline, \"compute_constrained_weights\", fake_compute_constrained_weights\ntests/test_pipeline_branch_coverage.py:267:    def fake_compute_constrained_weights(\ntests/test_pipeline_branch_coverage.py:298:        pipeline, \"compute_constrained_weights\", fake_compute_constrained_weights\nsrc/trend_analysis/weights/robust_weighting.py:147:        max_weight: float = 1.0,\nsrc/trend_analysis/weights/robust_weighting.py:160:            max_weight: Maximum weight constraint\nsrc/trend_analysis/weights/robust_weighting.py:167:        self.max_weight = float(max_weight)\nsrc/trend_analysis/weights/robust_weighting.py:242:            weights = np.clip(weights, self.min_weight, self.max_weight)\nsrc/trend_analysis/presets.py:32:_DEFAULT_SPEC_VOL_ADJUST = _DEFAULT_TREND_SPEC.vol_adjust\nsrc/trend_analysis/presets.py:123:    vol_adjust = bool(signals.get(\"vol_adjust\", False))\nsrc/trend_analysis/presets.py:131:        vol_adjust=vol_adjust,\nsrc/trend_analysis/presets.py:190:            \"vol_adjust\": spec.vol_adjust,\nsrc/trend_analysis/presets.py:199:    def vol_adjust_defaults(self) -> dict[str, Any]:\nsrc/trend_analysis/presets.py:202:        preset = self._config.get(\"vol_adjust\")\nsrc/trend_analysis/presets.py:219:        vol_adjust_section = (\nsrc/trend_analysis/presets.py:220:            self._config.get(\"vol_adjust\")\nsrc/trend_analysis/presets.py:221:            if isinstance(self._config.get(\"vol_adjust\"), Mapping)\nsrc/trend_analysis/presets.py:227:            if vol_adjust_section is not None:\nsrc/trend_analysis/presets.py:228:                enabled = self.trend_spec.vol_adjust\nsrc/trend_analysis/presets.py:229:            elif signals_cfg is not None and \"vol_adjust\" in signals_cfg:\nsrc/trend_analysis/presets.py:230:                enabled = bool(signals_cfg.get(\"vol_adjust\"))\nsrc/trend_analysis/presets.py:231:            elif self.trend_spec.vol_adjust != _DEFAULT_SPEC_VOL_ADJUST:\nsrc/trend_analysis/presets.py:232:                enabled = self.trend_spec.vol_adjust\nsrc/trend_analysis/presets.py:410:    vol_adjust_cfg = getattr(config, \"vol_adjust\", {})\nsrc/trend_analysis/presets.py:411:    if isinstance(vol_adjust_cfg, MutableMapping):\nsrc/trend_analysis/presets.py:412:        vol_adjust = vol_adjust_cfg\nsrc/trend_analysis/presets.py:413:    elif isinstance(vol_adjust_cfg, Mapping):\nsrc/trend_analysis/presets.py:414:        vol_adjust = dict(vol_adjust_cfg)\nsrc/trend_analysis/presets.py:416:        vol_adjust = {}\nsrc/trend_analysis/presets.py:418:    defaults = preset.vol_adjust_defaults()\nsrc/trend_analysis/presets.py:419:    vol_adjust.update({k: v for k, v in defaults.items() if v is not None})\nsrc/trend_analysis/presets.py:420:    setattr(config, \"vol_adjust\", vol_adjust)\nsrc/trend/reporting/unified.py:369:    scaling = \"Vol-adjusted\" if spec.vol_adjust else \"Raw\"\nsrc/trend/reporting/unified.py:372:    if spec.vol_adjust and isinstance(target, (int, float)):\nsrc/trend/reporting/unified.py:456:    vol_adj = _get(config, \"vol_adjust\", {})\ntests/test_weighting_engines_extended.py:79:        max_weight=0.8,\ntests/test_gui_app_simple.py:107:            store.cfg[\"use_vol_adjust\"] = True\ntests/test_gui_app_simple.py:111:            assert store.cfg[\"use_vol_adjust\"] is True\ntests/test_config_legacy_output_conversion.py:17:        \"vol_adjust\": {},\ntests/test_config_legacy_output_conversion.py:45:        \"vol_adjust\": {},\ntests/test_config_legacy_output_conversion.py:71:        \"vol_adjust\": {},\ntests/test_config_legacy_output_conversion.py:95:        \"vol_adjust\": {},\ntests/test_pipeline_run_cache_fallbacks.py:80:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_pipeline_run_cache_fallbacks.py:131:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_pipeline_run_cache_fallbacks.py:324:def test_build_trend_spec_uses_vol_adjust_default() -> None:\ntests/test_pipeline_run_cache_fallbacks.py:325:    cfg = {\"signals\": {\"vol_adjust\": True}}\ntests/test_pipeline_run_cache_fallbacks.py:328:    assert spec.vol_adjust is True\ntests/test_pipeline_run_cache_fallbacks.py:458:    def fake_compute_constrained_weights(*_args, **_kwargs):  # noqa: ANN001\ntests/test_pipeline_run_cache_fallbacks.py:472:        pipeline, \"compute_constrained_weights\", fake_compute_constrained_weights\ntests/test_pipeline_run_cache_fallbacks.py:533:    def fake_compute_constrained_weights(*_args, **_kwargs):\ntests/test_pipeline_run_cache_fallbacks.py:545:        pipeline, \"compute_constrained_weights\", fake_compute_constrained_weights\ntests/test_pipeline_run_cache_fallbacks.py:562:        constraints={\"max_weight\": \"oops\"},\ntests/test_signal_presets_module.py:71:            vol_adjust=False,\ntests/test_signal_presets_module.py:82:        \"vol_adjust\": False,\ntests/test_signal_presets_module.py:91:        \"vol_adjust\": False,\ntests/test_spec_loader.py:100:        signals={\"window\": 10, \"lag\": 1, \"vol_adjust\": True, \"vol_target\": 0.2},\ntests/test_spec_loader.py:159:            \"vol_adjust\": False,\ntests/test_spec_loader.py:163:        \"vol_adjust\": {\"target_vol\": 0.15, \"floor_vol\": 0.05, \"warmup_periods\": 0},\ntests/test_spec_loader.py:196:    assert spec.trend.vol_target is None  # Disabled by vol_adjust False\ntests/test_cli_cache_stats.py:31:        vol_adjust={},\ntests/test_multi_period_inception_filter.py:20:        self.vol_adjust: dict[str, Any] = {\"target_vol\": 1.0}\ntests/test_multi_period_inception_filter.py:41:                \"max_weight\": 1.0,\ntests/test_api_run_simulation_extra.py:22:        self.vol_adjust = {\"target_vol\": 1.0}\ntests/test_config_validation.py:41:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_config_validation.py:82:        \"vol_adjust\",\ntests/test_default_export.py:15:                \"vol_adjust: {target_vol: 1.0}\",\ntests/test_cli_cache_stats_disabled.py:32:        vol_adjust={},\nsrc/trend_model/spec.py:153:    vol_adjust = bool(_section_get(signals, \"vol_adjust\", False))\nsrc/trend_model/spec.py:155:    if not vol_adjust:\nsrc/trend_model/spec.py:166:        vol_adjust=vol_adjust,\nsrc/trend_model/spec.py:175:    vol_adjust = _cfg_section(cfg, \"vol_adjust\")\nsrc/trend_model/spec.py:244:        target_vol=_coerce_float(_section_get(vol_adjust, \"target_vol\")),\nsrc/trend_model/spec.py:245:        floor_vol=_coerce_float(_section_get(vol_adjust, \"floor_vol\")),\nsrc/trend_model/spec.py:247:            _section_get(vol_adjust, \"warmup_periods\", 0), default=0\ntests/test_signals_validation.py:37:def test_compute_trend_signals_vol_adjust_without_target() -> None:\ntests/test_signals_validation.py:45:    spec = TrendSpec(window=3, vol_adjust=True, vol_target=None)\ntests/test_signals_validation.py:51:    assert result.attrs[\"spec\"][\"vol_adjust\"] is True\ntests/test_app_coverage.py:974:        \"vol_adjust\",\ntests/test_app_coverage.py:1420:    assert store.cfg[\"use_vol_adjust\"] is True\ntests/test_constants.py:69:                \"vol_adjust: {target_vol: 1.0}\",\ntests/test_trend_config_model_negative_paths.py:209:        \"vol_adjust\": {\"target_vol\": 1.0},\ntests/test_trend_config_model_negative_paths.py:248:    assert \"vol_adjust.target_vol must be greater than zero\" in str(exc.value)\ntests/test_trend_config_model_negative_paths.py:267:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model_negative_paths.py:338:    assert \"vol_adjust.floor_vol cannot be negative\" in str(exc.value)\ntests/test_multi_period_engine_branch_coverage.py:44:                \"max_weight\": 0.6,\ntests/test_multi_period_engine_branch_coverage.py:51:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_branch_coverage.py:60:            \"vol_adjust\": self.vol_adjust,\ntests/test_multi_period_engine_branch_coverage.py:129:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_branch_coverage.py:141:            \"vol_adjust\": self.vol_adjust,\ntests/test_streamlit_smoke_ci.py:82:        vol_adjust={\"target_vol\": 1.0},\ntests/test_multi_period_engine_branch_completion.py:60:            \"vol_adjust\": self.vol_adjust,\ntests/test_multi_period_engine_branch_completion.py:84:                \"max_weight\": 0.6,\ntests/test_multi_period_engine_branch_completion.py:90:                \"max_weight\": 0.6,\ntests/test_multi_period_engine_branch_completion.py:96:        vol_adjust={\"target_vol\": 1.0, \"window\": 12},\ntests/test_cli.py:55:        \"vol_adjust\": {\"target_vol\": 0.15},\ntests/test_cli.py:81:        captured[\"vol_adjust\"] = getattr(cfg_obj, \"vol_adjust\", {})\ntests/test_cli.py:121:    assert signals[\"vol_adjust\"] is True\ntests/test_cli.py:124:    vol_adjust = captured[\"vol_adjust\"]\ntests/test_cli.py:125:    assert isinstance(vol_adjust, dict)\ntests/test_cli.py:126:    assert vol_adjust[\"window\"][\"length\"] == 126\ntests/test_cli.py:219:        vol_adjust={},\ntests/test_cli.py:248:        vol_adjust={},\ntests/test_cli.py:360:        vol_adjust={},\ntests/test_cli.py:473:        vol_adjust={},\ntests/test_cli.py:573:        vol_adjust={},\ntests/test_multi_period_rebalancer.py:186:            \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_multi_period_sticky_periods.py:45:                \"max_weight\": 1.0,\ntests/test_multi_period_sticky_periods.py:51:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_sticky_periods.py:60:            \"vol_adjust\": self.vol_adjust,\ntests/test_trend_presets.py:39:    cfg = SimpleNamespace(vol_adjust={}, run={}, signals={})\ntests/test_trend_presets.py:44:    assert cfg.signals[\"vol_adjust\"] is True\ntests/test_trend_presets.py:46:    assert cfg.vol_adjust[\"window\"][\"length\"] == preset.trend_spec.window\ntests/test_trend_presets.py:69:          vol_adjust: false\ntests/test_pipeline_integration_direct.py:31:        \"vol_adjust\": {\"enabled\": True, \"target_vol\": 1.0},\ntests/test_pipeline_integration_direct.py:54:                \"max_weight\": 0.6,\ntests/test_threshold_hold_alignment.py:32:        {\"max_funds\": 4, \"min_weight\": 0.05, \"max_weight\": 0.6, \"min_weight_strikes\": 1}\ntests/test_config_models_additional.py:25:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_config_models_additional.py:270:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_api_run_simulation.py:44:        vol_adjust={\"target_vol\": 1.0},\ntests/test_api_run_simulation.py:82:        vol_adjust={\"target_vol\": 1.0},\ntests/test_volatility_settings_wiring.py:44:                \"max_weight\": 0.8,\ntests/test_volatility_settings_wiring.py:50:    vol_adjust: dict[str, object] = field(\ntests/test_volatility_settings_wiring.py:66:            \"vol_adjust\": dict(self.vol_adjust),\ntests/test_volatility_settings_wiring.py:110:def test_vol_adjust_enabled_changes_scaling() -> None:\ntests/test_volatility_settings_wiring.py:113:    cfg.vol_adjust[\"enabled\"] = False\ntests/test_volatility_settings_wiring.py:121:    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"simple\", \"lambda\": 0.94}\ntests/test_volatility_settings_wiring.py:123:    cfg.vol_adjust[\"window\"] = {\"length\": 3, \"decay\": \"simple\", \"lambda\": 0.94}\ntests/test_volatility_settings_wiring.py:130:    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"ewma\", \"lambda\": 0.9}\ntests/test_volatility_settings_wiring.py:132:    cfg.vol_adjust[\"window\"] = {\"length\": 3, \"decay\": \"ewma\", \"lambda\": 0.9}\ntests/test_volatility_settings_wiring.py:139:    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"ewma\", \"lambda\": 0.9}\ntests/test_volatility_settings_wiring.py:141:    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"simple\", \"lambda\": 0.9}\ntests/test_volatility_settings_wiring.py:148:    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"ewma\", \"lambda\": 0.9}\ntests/test_volatility_settings_wiring.py:150:    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"ewma\", \"lambda\": 0.6}\ntests/test_config_model_branch_coverage.py:37:        \"vol_adjust\": _risk_settings(),\ntests/test_multi_period_engine_incremental_fallback.py:35:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_incremental_fallback.py:47:            \"vol_adjust\": self.vol_adjust,\ntests/test_pipeline_entrypoints.py:61:        \"vol_adjust\": {},\ntests/test_presets_extended.py:40:                \"vol_adjust\": \"yes\",\ntests/test_presets_extended.py:51:    assert spec.vol_adjust is True\ntests/test_presets_extended.py:58:        window=20, min_periods=10, vol_adjust=True, vol_target=0.2, zscore=True\ntests/test_presets_extended.py:68:        \"signals\": {\"vol_adjust\": False},\ntests/test_presets_extended.py:69:        \"vol_adjust\": {\"enabled\": None, \"target_vol\": None},\ntests/test_presets_extended.py:112:    spec = TrendSpec(window=15, vol_adjust=False)\ntests/test_presets_extended.py:120:    cfg = SimpleNamespace(signals={\"window\": 5}, vol_adjust=(\"ignored\",), run={})\ntests/test_presets_extended.py:123:    assert cfg.vol_adjust[\"enabled\"] is True\ntests/test_presets_extended.py:127:def test_vol_adjust_defaults_handles_signal_overrides() -> None:\ntests/test_presets_extended.py:128:    spec = TrendSpec(window=40, vol_adjust=False)\ntests/test_presets_extended.py:130:        \"signals\": {\"vol_adjust\": True},\ntests/test_presets_extended.py:139:    defaults = preset.vol_adjust_defaults()\ntests/test_presets_extended.py:147:def test_vol_adjust_defaults_copies_window_mapping() -> None:\ntests/test_presets_extended.py:148:    spec = TrendSpec(window=20, vol_adjust=True, vol_target=0.5)\ntests/test_presets_extended.py:152:        \"vol_adjust\": MappingProxyType(\ntests/test_presets_extended.py:166:    defaults = preset.vol_adjust_defaults()\ntests/test_presets_extended.py:174:def test_vol_adjust_defaults_uses_spec_when_no_signals() -> None:\ntests/test_presets_extended.py:175:    spec = TrendSpec(window=15, vol_adjust=True)\ntests/test_presets_extended.py:183:    defaults = preset.vol_adjust_defaults()\ntests/test_presets_extended.py:317:    spec = TrendSpec(window=30, vol_adjust=True, vol_target=0.3)\ntests/test_presets_extended.py:323:        _config=presets._freeze_mapping({\"vol_adjust\": {\"enabled\": True}}),\ntests/test_presets_extended.py:329:        vol_adjust=MappingProxyType({\"enabled\": False}),\ntests/test_presets_extended.py:334:    assert cfg.vol_adjust[\"enabled\"] is True\ntests/test_presets_extended.py:347:    cfg = SimpleNamespace(signals=None, vol_adjust=\"skip\", run=None)\ntests/test_presets_extended.py:350:    assert cfg.vol_adjust[\"enabled\"] is True\ntests/test_config_human_errors.py:85:    def test_vol_adjust_as_number(self):\ntests/test_config_human_errors.py:86:        \"\"\"Test vol_adjust section as number instead of dict.\"\"\"\ntests/test_config_human_errors.py:87:        cfg = {\"version\": \"1.0\", \"data\": {}, \"vol_adjust\": 42}\ntests/test_config_human_errors.py:90:            match=\"vol_adjust must be a dictionary\",\ntests/test_config_human_errors.py:108:            \"vol_adjust\",\ntests/test_config_human_errors.py:156:        vol_adjust: {}\ntests/test_run_analysis_cli_default.py:15:                \"vol_adjust: {target_vol: 1.0}\",\ntests/test_cli_no_structured_log.py:32:        \"vol_adjust\": {\"target_vol\": 1.0},\ntests/test_multi_period_engine_extended.py:55:        self.vol_adjust: Dict[str, Any] = {\"target_vol\": 1.0}\ntests/test_multi_period_engine_turnover_extended.py:153:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_turnover_extended.py:169:            \"vol_adjust\": self.vol_adjust,\ntests/test_config_models_fallback_loader.py:84:        \"vol_adjust\": {\"target_vol\": 1.0},\ntests/test_config_models_fallback_loader.py:90:    assert set(validated.keys()) >= {\"data\", \"portfolio\", \"vol_adjust\"}\ntests/test_config_models_fallback_loader.py:136:        \"vol_adjust\": {},\ntests/test_config_models_fallback_loader.py:191:        \"vol_adjust\": {},\ntests/test_risk_free_default_alignment.py:41:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_risk_free_default_alignment.py:50:            \"vol_adjust\": self.vol_adjust,\ntests/test_risk_free_default_alignment.py:67:        vol_adjust={\"target_vol\": 1.0},\ntests/test_risk_free_default_alignment.py:238:            \"vol_adjust\": {\"target_vol\": 1.0},\ntests/test_config_models.py:11:# Required keys are version, data, preprocessing, vol_adjust, sample_split,\ntests/test_config_models.py:24:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_config_models.py:47:        \"vol_adjust\",\ntests/test_multi_period_exits_cooldown.py:20:        self.vol_adjust: dict[str, Any] = {\"target_vol\": 1.0}\ntests/test_multi_period_exits_cooldown.py:42:                \"max_weight\": 1.0,\ntests/test_multi_period_engine_incremental_cov.py:29:        self.vol_adjust: dict[str, float] = {\"target_vol\": 1.0}\ntests/test_optimizer_constraints_additional.py:77:    constraints = ConstraintSet(cash_weight=0.25, max_weight=0.6)\ntests/test_optimizer_constraints_additional.py:85:    # The residual capital should respect the max_weight constraint and maintain order.\ntests/test_optimizer_constraints_additional.py:107:    # group cap.  ``max_weight`` must be reapplied to keep the non-capped assets\ntests/test_optimizer_constraints_additional.py:111:        max_weight=0.35,\ntests/test_optimizer_constraints_additional.py:134:def test_apply_constraints_group_caps_and_cash_respect_max_weight() -> None:\ntests/test_optimizer_constraints_additional.py:136:    ``max_weight``.\"\"\"\ntests/test_optimizer_constraints_additional.py:141:        \"max_weight\": 0.35,\ntests/test_optimizer_constraints_additional.py:154:    \"\"\"If the remaining allocation breaches ``max_weight`` feasibility, raise\ntests/test_optimizer_constraints_additional.py:161:        match=\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\",\ntests/test_optimizer_constraints_additional.py:163:        apply_constraints(weights, ConstraintSet(cash_weight=0.5, max_weight=0.2))\ntests/test_optimizer_constraints_additional.py:166:def test_apply_constraints_cash_slice_respects_max_weight_cap() -> None:\ntests/test_optimizer_constraints_additional.py:167:    \"\"\"The dedicated CASH slice must honour ``max_weight`` once\ntests/test_optimizer_constraints_additional.py:174:        match=\"cash_weight exceeds max_weight constraint\",\ntests/test_optimizer_constraints_additional.py:176:        apply_constraints(weights, ConstraintSet(cash_weight=0.6, max_weight=0.5))\ntests/test_optimizer_constraints_additional.py:188:        max_weight=0.4,\ntests/test_optimizer_constraints_additional.py:226:        self.max_weight = kwargs.get(\"max_weight\")\ntests/test_optimizer_constraints_additional.py:257:    constraints = _DynamicConstraintSet([0.5, 0.1], max_weight=0.3)\ntests/test_optimizer_constraints_additional.py:261:        match=\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\",\ntests/test_optimizer_constraints_additional.py:272:    constraints = _DynamicConstraintSet([0.2, 0.6], max_weight=0.5)\ntests/test_optimizer_constraints_additional.py:274:    with pytest.raises(ConstraintViolation, match=\"cash_weight exceeds max_weight\"):\ntests/test_optimizer_constraints_additional.py:308:            'if eq_after - NUMERICAL_TOLERANCE_HIGH > cap:\\n    raise ConstraintViolation(\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\")',\ntests/test_optimizer_constraints_additional.py:319:            'raise ConstraintViolation(\"cash_weight exceeds max_weight constraint\")',\ntests/test_optimizer_constraints_additional.py:349:            'if eq_after - NUMERICAL_TOLERANCE_HIGH > cap:\\n    raise ConstraintViolation(\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\")',\ntests/test_optimizer_constraints_additional.py:360:            'raise ConstraintViolation(\"cash_weight exceeds max_weight constraint\")',\ntests/test_config_models_coverage_extensions.py:53:        \"vol_adjust\": {},\ntests/test_trend_cli.py:65:        vol_adjust={\"target_vol\": 0.15},\ntests/test_trend_cli.py:190:        vol_adjust={},\ntests/test_trend_cli.py:224:        vol_adjust={},\ntests/test_trend_cli.py:264:        vol_adjust={},\ntests/test_multi_period_engine_additional.py:101:        self.vol_adjust = {\"target_vol\": 1.0}\ntests/test_multi_period_engine_additional.py:438:                        \"max_weight\": 0.6,\ntests/test_multi_period_engine_additional.py:616:                        \"max_weight\": 0.6,\ntests/test_multi_period_engine_additional.py:742:                        \"max_weight\": 0.99,\ntests/test_multi_period_engine_additional.py:879:                        \"max_weight\": 0.6,\ntests/test_multi_period_engine_additional.py:1151:            \"constraints\": {\"min_weight\": 0.2, \"max_weight\": 0.6, \"max_funds\": 3},\ntests/trend_analysis/test_signal_presets_module.py:61:        \"vol_adjust\": True,\ntests/trend_analysis/test_signal_presets_module.py:73:        vol_adjust=False,\ntests/trend_analysis/test_signal_presets_module.py:83:        \"vol_adjust\": False,\ntests/trend_analysis/test_signal_presets_module.py:93:        vol_adjust=True,\ntests/trend_analysis/test_signal_presets_module.py:103:        \"vol_adjust\": True,\ntests/test_optimizer_constraints_guardrails.py:36:def test_apply_constraints_reapplies_max_weight_after_group_caps() -> None:\ntests/test_optimizer_constraints_guardrails.py:39:        max_weight=0.5,\ntests/test_optimizer_constraints_guardrails.py:61:def test_apply_constraints_detects_cash_weight_infeasible_against_max_weight() -> None:\ntests/test_optimizer_constraints_guardrails.py:66:        match=\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\",\ntests/test_optimizer_constraints_guardrails.py:68:        apply_constraints(weights, ConstraintSet(max_weight=0.3, cash_weight=0.25))\ntests/test_optimizer_constraints_guardrails.py:75:        ConstraintViolation, match=\"cash_weight exceeds max_weight constraint\"\ntests/test_optimizer_constraints_guardrails.py:77:        apply_constraints(weights, ConstraintSet(max_weight=0.45, cash_weight=0.5))\ntests/test_optimizer_constraints_guardrails.py:82:    constraints = ConstraintSet(max_weight=0.4, cash_weight=0.25)\ntests/test_optimizer_constraints_guardrails.py:122:    adjusted = apply_constraints(weights, {\"cash_weight\": 0.25, \"max_weight\": 0.45})\ntests/test_optimizer_constraints_guardrails.py:137:        weights, ConstraintSet(max_weight=0.6, cash_weight=0.2)\ntests/test_pipeline_optional_features.py:262:        \"max_weight\": 1.0,\ntests/test_pipeline_optional_features.py:609:        constraints={\"max_weight\": 0.5},\ntests/test_pipeline_optional_features.py:646:        constraints={\"max_weight\": 0.8},\ntests/test_pipeline_optional_features.py:681:        constraints={\"max_weight\": 0.4},\ntests/trend_analysis/test_presets.py:33:        \"vol_adjust\": {\"window\": {\"length\": 21}},\ntests/trend_analysis/test_presets.py:98:    assert spec.vol_adjust is False\ntests/trend_analysis/test_presets.py:150:def test_trend_preset_signals_and_vol_adjust_defaults(\ntests/trend_analysis/test_presets.py:156:    defaults = sample_preset.vol_adjust_defaults()\ntests/trend_analysis/test_presets.py:167:def test_vol_adjust_defaults_preserves_existing_target(sample_config: dict[str, Any]):\ntests/trend_analysis/test_presets.py:169:    custom[\"vol_adjust\"] = {\"target_vol\": 0.2}\ntests/trend_analysis/test_presets.py:177:    defaults = preset.vol_adjust_defaults()\ntests/trend_analysis/test_presets.py:181:def test_vol_adjust_defaults_respects_existing_enabled_flag(\ntests/trend_analysis/test_presets.py:187:    custom[\"vol_adjust\"] = {\"enabled\": True, \"window\": MappingProxyType({\"length\": 5})}\ntests/trend_analysis/test_presets.py:195:    defaults = preset.vol_adjust_defaults()\ntests/trend_analysis/test_presets.py:201:def test_vol_adjust_defaults_handles_non_mapping_source(sample_config: dict[str, Any]):\ntests/trend_analysis/test_presets.py:203:    custom[\"vol_adjust\"] = \"disabled\"\ntests/trend_analysis/test_presets.py:211:    defaults = preset.vol_adjust_defaults()\ntests/trend_analysis/test_presets.py:264:  vol_adjust: true\ntests/trend_analysis/test_presets.py:319:            self.vol_adjust = {\"enabled\": True, \"extra\": \"keep\"}\ntests/trend_analysis/test_presets.py:327:    assert config.vol_adjust[\"enabled\"] is False\ntests/trend_analysis/test_presets.py:328:    assert config.vol_adjust[\"target_vol\"] == pytest.approx(0.7)\ntests/trend_analysis/test_presets.py:329:    assert config.vol_adjust[\"extra\"] == \"keep\"\ntests/trend_analysis/test_presets.py:339:            self.vol_adjust = \"disabled\"\ntests/trend_analysis/test_presets.py:347:    assert config.vol_adjust[\"enabled\"] is False\ntests/trend_analysis/test_presets.py:359:            self.vol_adjust = MappingProxyType({\"enabled\": True})\ntests/trend_analysis/test_presets.py:366:    assert config.vol_adjust[\"enabled\"] is sample_preset.trend_spec.vol_adjust\ntests/test_multi_period_engine_branch_new.py:20:        self.vol_adjust: dict[str, float] = {\"target_vol\": 1.0}\ntests/test_multi_period_engine_branch_new.py:36:            \"vol_adjust\": dict(self.vol_adjust),\ntests/test_multi_period_engine_missing_policy.py:33:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_missing_policy.py:42:            \"vol_adjust\": self.vol_adjust,\ntests/test_api_signal_settings.py:35:        vol_adjust={\"target_vol\": 1.0},\ntests/test_api_signal_settings.py:64:            \"trend_vol_adjust\": False,\ntests/test_api_signal_settings.py:73:            \"trend_vol_adjust\": False,\ntests/test_api_signal_settings.py:100:            \"trend_vol_adjust\": False,\ntests/test_api_signal_settings.py:109:            \"trend_vol_adjust\": False,\ntests/test_risk_additional.py:47:def test_compute_constrained_weights_applies_controls(monkeypatch):\ntests/test_risk_additional.py:67:    result, diagnostics = risk.compute_constrained_weights(\ntests/test_risk_additional.py:75:        max_weight=0.7,\ntests/test_risk_additional.py:88:    assert payload_capture[\"payload\"][\"max_weight\"] == 0.7\ntests/test_risk_additional.py:95:def test_compute_constrained_weights_handles_non_datetime_index(monkeypatch):\ntests/test_risk_additional.py:108:    result, diagnostics = risk.compute_constrained_weights(\ntests/test_risk_additional.py:116:        max_weight=None,\ntests/test_risk_additional.py:127:def test_compute_constrained_weights_skips_scaling_when_disabled(monkeypatch):\ntests/test_risk_additional.py:144:    disabled, diag_disabled = risk.compute_constrained_weights(\ntests/test_risk_additional.py:152:        max_weight=None,\ntests/test_risk_additional.py:154:    enabled, _ = risk.compute_constrained_weights(\ntests/test_risk_additional.py:162:        max_weight=None,\ntests/test_risk_additional.py:172:def test_compute_constrained_weights_window_length_changes_scaling(monkeypatch):\ntests/test_risk_additional.py:190:    _, diag_short = risk.compute_constrained_weights(\ntests/test_risk_additional.py:198:        max_weight=None,\ntests/test_risk_additional.py:200:    _, diag_long = risk.compute_constrained_weights(\ntests/test_risk_additional.py:208:        max_weight=None,\ntests/test_risk_additional.py:214:def test_compute_constrained_weights_decay_changes_scaling(monkeypatch):\ntests/test_risk_additional.py:232:    _, diag_simple = risk.compute_constrained_weights(\ntests/test_risk_additional.py:240:        max_weight=None,\ntests/test_risk_additional.py:242:    _, diag_ewma = risk.compute_constrained_weights(\ntests/test_risk_additional.py:250:        max_weight=None,\ntests/test_risk_additional.py:256:def test_compute_constrained_weights_ewma_lambda_changes_scaling(monkeypatch):\ntests/test_risk_additional.py:274:    _, diag_fast = risk.compute_constrained_weights(\ntests/test_risk_additional.py:282:        max_weight=None,\ntests/test_risk_additional.py:284:    _, diag_slow = risk.compute_constrained_weights(\ntests/test_risk_additional.py:292:        max_weight=None,\ntests/test_risk_additional.py:298:def test_compute_constrained_weights_validates_inputs(monkeypatch):\ntests/test_risk_additional.py:302:        risk.compute_constrained_weights(\ntests/test_risk_additional.py:310:            max_weight=None,\ntests/test_risk_additional.py:314:        risk.compute_constrained_weights(\ntests/test_risk_additional.py:322:            max_weight=None,\ntests/test_run_multi_analysis_cli.py:15:                \"vol_adjust: {target_vol: 1.0}\",\ntests/test_pipeline.py:31:        \"vol_adjust\": {\"target_vol\": 1.0},\ntests/test_pipeline.py:257:        vol_adjust={},\ntests/test_pipeline.py:444:        \"max_weight\": 0.55,\ntests/test_pipeline.py:490:        constraints={\"max_weight\": 0.6},\ntests/test_trend_config_model_additional.py:302:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_invariants.py:18:from trend_analysis.risk import RiskWindow, compute_constrained_weights\ntests/test_invariants.py:52:def test_compute_constrained_weights_produces_finite_normalised_weights() -> None:\ntests/test_invariants.py:58:    weights, diagnostics = compute_constrained_weights(\ntests/test_invariants.py:66:        max_weight=0.7,\ntests/test_signal_presets_regressions.py:40:            vol_adjust=True,\ntests/test_run_analysis_cli_export.py:15:                \"vol_adjust: {target_vol: 1.0}\",\ntests/test_multi_period_engine_keepalive.py:46:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_keepalive.py:56:            \"vol_adjust\": self.vol_adjust,\ntests/test_multi_period_engine_keepalive.py:262:        \"constraints\": {\"max_funds\": 2, \"min_weight\": 0.05, \"max_weight\": 0.9},\ntests/soft_coverage/test_signal_presets_soft.py:50:        \"vol_adjust\": True,\ntests/soft_coverage/test_signal_presets_soft.py:59:        window=21, min_periods=None, lag=2, vol_adjust=False, vol_target=None\ntests/soft_coverage/test_signal_presets_soft.py:71:        \"vol_adjust\": False,\ntests/soft_coverage/test_signal_presets_soft.py:80:        \"vol_adjust\": False,\ntests/test_config_models_fallback_unit.py:61:        \"vol_adjust\": {},\ntests/test_config_models_fallback_unit.py:140:            vol_adjust={},\ntests/test_gui.py:70:        \"vol_adjust\": {},\ntests/test_constraint_optimizer.py:9:def test_long_only_and_max_weight():\ntests/test_constraint_optimizer.py:11:    out = apply_constraints(w, {\"long_only\": True, \"max_weight\": 0.55})\ntests/test_constraint_optimizer.py:21:        \"max_weight\": 0.6,\ntests/test_constraint_optimizer.py:30:def test_infeasible_max_weight():\ntests/test_constraint_optimizer.py:33:        apply_constraints(w, {\"max_weight\": 0.4})\ntests/test_constraint_optimizer.py:73:def test_cash_weight_violates_max_weight_cap() -> None:\ntests/test_constraint_optimizer.py:75:    constraints = {\"cash_weight\": 0.4, \"max_weight\": 0.3}\ntests/test_constraint_optimizer.py:76:    with pytest.raises(ConstraintViolation, match=\"exceeds max_weight\"):\ntests/test_constraint_optimizer.py:80:def test_cash_weight_exceeds_max_weight_limit() -> None:\ntests/test_constraint_optimizer.py:82:    constraints = {\"cash_weight\": 0.6, \"max_weight\": 0.5}\ntests/test_constraint_optimizer.py:83:    with pytest.raises(ConstraintViolation, match=\"cash_weight exceeds max_weight\"):\ntests/test_trend_reporting_unified_helpers.py:111:        vol_adjust={\"target_vol\": 0.15, \"floor_vol\": 0.05, \"warmup_periods\": 3},\ntests/test_trend_reporting_unified_helpers.py:127:        vol_adjust=True,\ntests/test_trend_reporting_unified_helpers.py:369:        vol_adjust={\"floor_vol\": 0.02, \"warmup_periods\": 5},\ntests/test_trend_reporting_unified_helpers.py:373:        trend_spec=SimpleNamespace(window=63, lag=1, vol_adjust=False, zscore=False),\ntests/test_trend_reporting_unified_helpers.py:388:        sample_split=None, vol_adjust=None, portfolio=None, run=None, benchmarks=None\ntests/test_cli_api_golden_master.py:43:        vol_adjust={\"target_vol\": 1.0},\ntests/test_config_fallback_minimal.py:28:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_multi_period_engine_price_frames.py:40:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_price_frames.py:49:            \"vol_adjust\": self.vol_adjust,\ntests/test_trend_analysis_cli_main.py:29:        vol_adjust={},\ntests/test_run_full.py:21:        vol_adjust={\"target_vol\": 1.0},\ntests/test_run_full.py:56:        vol_adjust={},\ntests/test_run_full.py:72:        vol_adjust={},\ntests/test_pipeline_constraints_integration.py:43:def test_pipeline_applies_cash_and_max_weight_constraints():\ntests/test_pipeline_constraints_integration.py:57:            \"max_weight\": 0.4,\ntests/test_pipeline_constraints_integration.py:72:def test_pipeline_max_weight_with_vol_adjust_enabled():\ntests/test_pipeline_constraints_integration.py:88:            \"max_weight\": 0.35,\ntests/test_weight_engines_pathological.py:235:            max_weight=1.0,\ntests/test_multi_period_engine_threshold_bounds.py:47:                \"max_weight\": 0.55,\ntests/test_multi_period_engine_threshold_bounds.py:54:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_threshold_bounds.py:63:            \"vol_adjust\": self.vol_adjust,\ntests/test_multi_period_engine_price_frames_extra.py:26:        self.vol_adjust: dict[str, float] = {\"target_vol\": 1.0}\ntests/test_config_model.py:533:            \"vol_adjust\": {\ntests/test_config_model.py:544:        assert cfg.vol_adjust.target_vol == 0.2\ntests/test_config_model.py:557:            \"vol_adjust\": {\ntests/test_config_model.py:581:            \"vol_adjust\": {\ntests/test_config_model.py:607:            \"vol_adjust\": {\ntests/test_config_model.py:614:        with pytest.raises(ValueError, match=\"vol_adjust.target_vol\"):\ntests/test_config_model.py:631:            vol_adjust:\ntests/test_config_alignment.py:105:        \"vol_adjust\": {\"target_vol\": 0.1, \"floor_vol\": 0.0, \"warmup_periods\": 0},\ntests/test_multi_period_engine_threshold_events_extended.py:45:                \"max_weight\": 0.6,\ntests/test_multi_period_engine_threshold_events_extended.py:52:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_threshold_events_extended.py:62:            \"vol_adjust\": dict(self.vol_adjust),\ntests/test_multi_period_engine_threshold_events_extended.py:95:                \"max_weight\": 0.35,\ntests/test_multi_period_engine_threshold_events_extended.py:101:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_threshold_events_extended.py:111:            \"vol_adjust\": dict(self.vol_adjust),\ntests/test_optimizer_branch_coverage.py:81:            optimizer.ConstraintSet(cash_weight=0.5, max_weight=0.2),\ntests/test_optimizer_branch_coverage.py:108:            optimizer.ConstraintSet(cash_weight=0.2, max_weight=0.5),\ntests/test_optimizer_branch_coverage.py:117:            optimizer.ConstraintSet(cash_weight=0.6, max_weight=0.5),\ntests/test_unified_api_integration.py:43:            vol_adjust={\"target_vol\": 1.0},\ntests/test_config_model_validation.py:180:        \"vol_adjust\": {\ntests/test_cli_no_cache_flag.py:27:        vol_adjust={},\ntests/test_risk.py:12:    compute_constrained_weights,\ntests/test_risk.py:36:def test_compute_constrained_weights_scales_and_constrains() -> None:\ntests/test_risk.py:47:    weights, diagnostics = compute_constrained_weights(\ntests/test_risk.py:55:        max_weight=0.6,\ntests/test_risk.py:67:def test_compute_constrained_weights_respects_turnover_cap() -> None:\ntests/test_risk.py:78:    weights, diagnostics = compute_constrained_weights(\ntests/test_risk.py:86:        max_weight=0.8,\ntests/test_risk.py:95:def test_compute_constrained_weights_lambda_penalty_reduces_turnover() -> None:\ntests/test_risk.py:106:    _, diag_zero = compute_constrained_weights(\ntests/test_risk.py:114:        max_weight=0.9,\ntests/test_risk.py:119:    _, diag_high = compute_constrained_weights(\ntests/test_risk.py:127:        max_weight=0.9,\ntests/test_risk.py:136:def test_compute_constrained_weights_respects_max_weight_with_vol_adjust() -> None:\ntests/test_risk.py:147:    weights, diagnostics = compute_constrained_weights(\ntests/test_risk.py:155:        max_weight=0.35,\ntests/test_risk.py:165:def test_compute_constrained_weights_caps_after_large_vol_scaling() -> None:\ntests/test_risk.py:176:    weights, diagnostics = compute_constrained_weights(\ntests/test_risk.py:184:        max_weight=0.35,\ntests/test_risk.py:194:def test_compute_constrained_weights_enforces_max_weight_with_vol_adjust() -> None:\ntests/test_risk.py:205:    weights, diagnostics = compute_constrained_weights(\ntests/test_risk.py:213:        max_weight=0.35,\ntests/test_risk.py:255:def test_compute_constrained_weights_validates_inputs() -> None:\ntests/test_risk.py:257:        risk.compute_constrained_weights(\ntests/test_risk.py:265:            max_weight=None,\ntests/test_risk.py:268:        risk.compute_constrained_weights(\ntests/test_risk.py:276:            max_weight=None,\ntests/test_risk.py:282:        risk.compute_constrained_weights(\ntests/test_risk.py:290:            max_weight=None,\ntests/test_risk.py:294:def test_compute_constrained_weights_uses_dummy_turnover_index() -> None:\ntests/test_risk.py:297:    weights, diagnostics = risk.compute_constrained_weights(\ntests/test_risk.py:305:        max_weight=None,\ntests/test_optimizer.py:15:        weights, optimizer.ConstraintSet(max_weight=0.6)\ntests/test_optimizer.py:57:    constraints = optimizer.ConstraintSet(max_weight=0.45, cash_weight=0.4)\ntests/test_optimizer.py:66:def test_apply_constraints_cash_weight_infeasible_with_max_weight() -> None:\ntests/test_optimizer.py:68:    constraints = optimizer.ConstraintSet(max_weight=0.2, cash_weight=0.2)\ntests/test_trend_analysis_presets.py:26:          vol_adjust: false\ntests/test_trend_analysis_presets.py:32:        vol_adjust:\ntests/test_trend_analysis_presets.py:98:                \"vol_adjust\": True,\ntests/test_trend_analysis_presets.py:107:    assert spec.vol_adjust is True\ntests/test_trend_analysis_presets.py:116:    assert spec.vol_adjust is False\ntests/test_trend_analysis_presets.py:126:                \"vol_adjust\": True,\ntests/test_trend_analysis_presets.py:146:                \"vol_adjust\": {\"enabled\": False, \"window\": {\"slow\": 63}},\ntests/test_trend_analysis_presets.py:168:        \"vol_adjust\": True,\ntests/test_trend_analysis_presets.py:174:    vol_adjust_defaults = preset.vol_adjust_defaults()\ntests/test_trend_analysis_presets.py:175:    assert vol_adjust_defaults[\"enabled\"] is False\ntests/test_trend_analysis_presets.py:176:    assert vol_adjust_defaults[\"target_vol\"] == pytest.approx(0.15)\ntests/test_trend_analysis_presets.py:177:    assert vol_adjust_defaults[\"window\"][\"slow\"] == 63\ntests/test_trend_analysis_presets.py:178:    assert vol_adjust_defaults[\"window\"][\"length\"] == 50\ntests/test_trend_analysis_presets.py:179:    assert vol_adjust_defaults is not preset._config.get(\"vol_adjust\")\ntests/test_trend_analysis_presets.py:195:    defaults = preset.vol_adjust_defaults()\ntests/test_trend_analysis_presets.py:201:def test_vol_adjust_defaults_handles_read_only_window_mapping(\ntests/test_trend_analysis_presets.py:205:        {\"signals\": {\"window\": 12, \"vol_adjust\": True, \"vol_target\": 0.2}}\ntests/test_trend_analysis_presets.py:215:                \"vol_adjust\": {\ntests/test_trend_analysis_presets.py:226:    defaults = preset.vol_adjust_defaults()\ntests/test_trend_analysis_presets.py:231:def test_vol_adjust_defaults_respects_explicit_enabled_flag() -> None:\ntests/test_trend_analysis_presets.py:236:        vol_adjust=True,\ntests/test_trend_analysis_presets.py:247:                \"vol_adjust\": {\ntests/test_trend_analysis_presets.py:256:    defaults = preset.vol_adjust_defaults()\ntests/test_trend_analysis_presets.py:270:        vol_adjust={\"enabled\": False},\ntests/test_trend_analysis_presets.py:278:    vol_defaults = preset.vol_adjust_defaults()\ntests/test_trend_analysis_presets.py:285:    assert config.vol_adjust[\"enabled\"] is False\ntests/test_trend_analysis_presets.py:342:  vol_adjust: true\ntests/test_trend_analysis_presets.py:356:vol_adjust:\ntests/test_trend_analysis_presets.py:394:    config = SimpleNamespace(signals={\"lag\": 9}, vol_adjust={}, run={})\ntests/test_trend_analysis_presets.py:397:    assert config.signals[\"vol_adjust\"] is True\ntests/test_trend_analysis_presets.py:398:    assert config.vol_adjust[\"enabled\"] is False\ntests/test_trend_analysis_presets.py:399:    assert config.vol_adjust[\"target_vol\"] == pytest.approx(0.1)\ntests/test_trend_analysis_presets.py:456:  vol_adjust: false\ntests/test_trend_analysis_presets.py:468:        vol_adjust = ()\ntests/test_trend_analysis_presets.py:474:    assert isinstance(config.vol_adjust, dict)\ntests/test_pipeline_helpers_additional.py:137:def test_build_trend_spec_uses_vol_adjust_defaults() -> None:\ntests/test_pipeline_helpers_additional.py:153:    # ``vol_adjust`` should fall back to the vol config default when unset.\ntests/test_pipeline_helpers_additional.py:154:    assert spec.vol_adjust is True\ntests/test_pipeline_helpers_additional.py:321:            \"vol_adjust\": True,\ntests/test_pipeline_helpers_additional.py:337:            \"vol_adjust\": True,\ntests/test_pipeline_helpers_additional.py:344:    cfg_missing_target = {\"signals\": {\"vol_adjust\": True}}\ntests/test_pipeline_helpers_additional.py:613:        mp.setattr(pipeline, \"compute_constrained_weights\", boom_weights)\ntests/test_pipeline_helpers_additional.py:637:            constraints={\"max_weight\": \"bad\"},\ntests/test_pipeline_helpers_additional.py:647:                vol_adjust=False,\ntests/test_pipeline_helpers_additional.py:707:        mp.setattr(pipeline, \"compute_constrained_weights\", fake_weights)\ntests/test_pipeline_helpers_additional.py:727:                vol_adjust=False,\ntests/test_pipeline_helpers_additional.py:781:        vol_adjust={\"target_vol\": 1.0},\ntests/test_pipeline_helpers_additional.py:841:        vol_adjust={\"target_vol\": 1.0},\ntests/test_pipeline_helpers_additional.py:1064:        mp.setattr(pipeline, \"compute_constrained_weights\", fake_weights)\ntests/test_pipeline_helpers_additional.py:1099:                vol_adjust=False,\ntests/test_pipeline_helpers_additional.py:1280:        mp.setattr(pipeline, \"compute_constrained_weights\", fake_weights)\ntests/test_pipeline_helpers_additional.py:1392:        mp.setattr(pipeline, \"compute_constrained_weights\", fake_weights)\ntests/test_pipeline_helpers_additional.py:1482:        mp.setattr(pipeline, \"compute_constrained_weights\", fake_weights)\ntests/test_pipeline_helpers_additional.py:1568:        mp.setattr(pipeline, \"compute_constrained_weights\", fake_weights)\ntests/test_pipeline_helpers_additional.py:1653:        mp.setattr(pipeline, \"compute_constrained_weights\", fake_weights)\ntests/test_pipeline_helpers_additional.py:1716:        vol_adjust={\"target_vol\": 1.0},\ntests/test_pipeline_helpers_additional.py:1769:        vol_adjust={\"target_vol\": 1.0},\ntests/test_pipeline_helpers_additional.py:1824:        vol_adjust={\"target_vol\": 1.0},\ntests/test_pipeline_helpers_additional.py:1873:        vol_adjust={\"target_vol\": 1.0},\ntests/test_trend_config_model.py:29:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:95:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:127:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:147:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:172:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:198:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:221:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:244:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:286:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:311:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:334:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_trend_config_model.py:366:                \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_config_fallback_additional.py:78:        \"vol_adjust\",\ntests/test_config_fallback_additional.py:129:            vol_adjust={},\ntests/test_config_fallback_additional.py:180:            \"vol_adjust\": {},\ntests/test_config_fallback_additional.py:217:            \"vol_adjust\": {},\ntests/test_config_legacy.py:18:        \"vol_adjust\": {\"target_vol\": 0.1},\ntests/test_multi_period_missing_policy_observability.py:40:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_missing_policy_observability.py:50:            \"vol_adjust\": self.vol_adjust,\ntests/test_logging_integration.py:33:        vol_adjust={\"target_vol\": 1.0},\ntests/test_multi_period_engine.py:149:        self.vol_adjust: dict[str, float] = {\"target_vol\": 1.0}\ntests/test_robust_weighting_integration.py:58:        vol_adjust={\"enabled\": False},\ntests/test_robust_weighting_integration.py:92:        vol_adjust={\"enabled\": False},\ntests/test_signal_presets.py:25:    assert preset.spec.vol_adjust is True\ntests/test_signal_presets.py:34:    assert config[\"vol_adjust\"] is True\ntests/test_signal_presets.py:51:            vol_adjust=False,\ntests/test_signal_presets.py:63:        \"vol_adjust\": False,\ntests/test_signal_presets.py:76:            vol_adjust=True,\ntests/test_signal_presets.py:88:        \"vol_adjust\": True,\ntests/test_multi_period_engine_threshold_edgecases.py:46:                \"max_weight\": 0.8,\ntests/test_multi_period_engine_threshold_edgecases.py:53:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\ntests/test_multi_period_engine_threshold_edgecases.py:62:            \"vol_adjust\": self.vol_adjust,\ntests/test_multi_period_engine_threshold_edgecases.py:199:        {\"max_funds\": 3, \"min_weight\": 0.05, \"max_weight\": 0.8, \"min_weight_strikes\": 2}\ntests/test_multi_period_engine_threshold_edgecases.py:338:        {\"max_funds\": 2, \"min_weight\": 0.0, \"max_weight\": 1.0, \"min_weight_strikes\": 2}\ntests/test_multi_period_engine_threshold_edgecases.py:429:        {\"max_funds\": 2, \"min_weight\": 0.0, \"max_weight\": 1.0, \"min_weight_strikes\": 2}\ntests/test_multi_period_engine_threshold_edgecases.py:720:            \"max_weight\": 0.6,\ntests/test_multi_period_engine_threshold_edgecases.py:936:            \"max_weight\": 0.6,\ntests/test_multi_period_engine_threshold_edgecases.py:1040:            \"max_weight\": 0.3,\ntests/test_api_run_simulation_branches.py:30:        \"vol_adjust\": {},\ntests/test_api_run_simulation_branches.py:65:        vol_adjust={\"target_vol\": 1.5},\ntests/app/test_guardrails_component.py:102:        return None, \"vol_adjust -> target_vol\\n must be greater than zero\"\ntests/app/test_guardrails_component.py:116:    assert \"vol_adjust\" in errors[0]\ntests/test_trend_analysis_presets_additional.py:48:      vol_adjust: true\ntests/test_trend_analysis_presets_additional.py:51:    vol_adjust:\ntests/test_trend_analysis_presets_additional.py:71:    vol_adjust:\ntests/test_trend_analysis_presets_additional.py:135:        \"vol_adjust\": False,\ntests/test_trend_analysis_presets_additional.py:139:    vol_defaults = preset.vol_adjust_defaults()\ntests/test_trend_analysis_presets_additional.py:160:            self.vol_adjust = {\"enabled\": True, \"window\": {\"legacy\": 20}}\ntests/test_trend_analysis_presets_additional.py:167:    assert config.signals[\"vol_adjust\"] is False\ntests/test_trend_analysis_presets_additional.py:168:    assert config.vol_adjust[\"enabled\"] is False\ntests/test_trend_analysis_presets_additional.py:169:    assert config.vol_adjust[\"target_vol\"] == 0.25\ntests/test_trend_analysis_presets_additional.py:170:    assert config.vol_adjust[\"window\"] == {\"short\": 12, \"long\": 63, \"length\": 75}\ntests/test_trend_analysis_presets_additional.py:209:def test_vol_adjust_defaults_uses_trend_spec_when_section_missing() -> None:\ntests/test_trend_analysis_presets_additional.py:214:        trend_spec=presets.TrendSpec(window=45, vol_adjust=True, vol_target=0.4),\ntests/test_trend_analysis_presets_additional.py:218:    defaults = preset.vol_adjust_defaults()\ntests/test_trend_analysis_presets_additional.py:225:def test_vol_adjust_defaults_prefers_config_section_over_signals() -> None:\ntests/test_trend_analysis_presets_additional.py:230:        trend_spec=presets.TrendSpec(window=80, vol_adjust=False, vol_target=0.3),\ntests/test_trend_analysis_presets_additional.py:232:            \"signals\": {\"vol_adjust\": True},\ntests/test_trend_analysis_presets_additional.py:233:            \"vol_adjust\": {\ntests/test_trend_analysis_presets_additional.py:240:    defaults = preset.vol_adjust_defaults()\ntests/test_trend_analysis_presets_additional.py:247:def test_vol_adjust_defaults_copies_general_mapping() -> None:\ntests/test_trend_analysis_presets_additional.py:267:        _config={\"vol_adjust\": {\"window\": window}},\ntests/test_trend_analysis_presets_additional.py:270:    defaults = preset.vol_adjust_defaults()\ntests/test_trend_analysis_presets_additional.py:282:        trend_spec=presets.TrendSpec(window=70, vol_adjust=True, vol_target=0.2),\ntests/test_trend_analysis_presets_additional.py:283:        _config={\"vol_adjust\": {\"window\": {\"length\": 70}}},\ntests/test_trend_analysis_presets_additional.py:289:            self.vol_adjust = MappingProxyType({\"existing\": 1})\ntests/test_trend_analysis_presets_additional.py:295:    assert config.vol_adjust[\"existing\"] == 1\ntests/test_trend_analysis_presets_additional.py:296:    assert config.vol_adjust[\"enabled\"] is True\ntests/test_trend_analysis_presets_additional.py:297:    assert config.vol_adjust[\"window\"][\"length\"] == 70\ntests/test_trend_analysis_presets_additional.py:330:def test_vol_adjust_defaults_reads_signal_toggle_when_section_invalid() -> None:\ntests/test_trend_analysis_presets_additional.py:335:        trend_spec=presets.TrendSpec(window=70, vol_adjust=False, vol_target=None),\ntests/test_trend_analysis_presets_additional.py:338:                \"signals\": {\"vol_adjust\": True, \"vol_target\": 0.6},\ntests/test_trend_analysis_presets_additional.py:339:                \"vol_adjust\": \"ignored\",\ntests/test_trend_analysis_presets_additional.py:344:    defaults = preset.vol_adjust_defaults()\ntests/test_trend_signals_validation.py:32:def test_vol_adjust_without_target_inverts_rolling_std() -> None:\ntests/test_trend_signals_validation.py:42:    spec_no_target = TrendSpec(window=3, min_periods=3, vol_adjust=True)\ntests/test_trend_signals_validation.py:57:    assert adjusted.attrs[\"spec\"][\"vol_adjust\"] is True\ntests/app/test_demo_runner_component.py:134:        \"portfolio\": {\"cooldown_months\": 2, \"max_weight\": 0.2},\ntests/app/test_demo_runner_component.py:170:    assert dumped[\"vol_adjust\"] == {\ntests/app/test_demo_runner_component.py:307:        vol_adjust={\"target_vol\": 0.1},\ntests/app/test_demo_runner_component.py:495:        vol_adjust={\"target_vol\": 0.1},\ntests/app/test_analysis_runner_config.py:120:        \"vol_adjust_enabled\": True,\ntests/app/test_analysis_runner_config.py:127:    assert cfg.vol_adjust[\"window\"][\"decay\"] == \"simple\"\ntests/test_multi_period_engine_cov_cache.py:27:        self.vol_adjust = {\"target_vol\": 1.0}\ntests/test_buy_and_hold_selection.py:108:        vol_adjust={\ntests/test_buy_and_hold_selection.py:286:            vol_adjust={\"target_vol\": 0.1},\ntests/test_signal_presets_additional.py:65:        \"vol_adjust\": False,\ntests/test_signal_presets_additional.py:93:        \"vol_adjust\": False,\ntests/test_signals_engine.py:27:def test_vol_adjustment_scales_output(sample_returns: pd.DataFrame) -> None:\ntests/test_signals_engine.py:30:        sample_returns, TrendSpec(window=3, lag=1, vol_adjust=True, vol_target=1.0)\ntests/test_signals_engine.py:66:    spec = TrendSpec(window=3, lag=1, vol_adjust=True, vol_target=1.0)\ntests/test_signals_additional.py:8:def test_compute_trend_signals_vol_adjust_and_attrs():\ntests/test_signals_additional.py:16:    spec = TrendSpec(window=3, lag=1, vol_adjust=True, vol_target=0.5)\ntests/test_robust_weighting.py:254:            \"robust_mv\", min_weight=0.1, max_weight=0.6, shrinkage_method=\"none\"\ntests/test_robust_weighting.py:269:            \"robust_mv\", shrinkage_method=\"none\", min_weight=-1.0, max_weight=1.0\ntests/test_unified_report.py:64:        vol_adjust={\"target_vol\": 0.15},\ntests/test_unified_report.py:103:        window=45, lag=2, vol_adjust=True, vol_target=0.2, zscore=True\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_2","type":"reasoning","text":"**Opening test file**"}}
{"type":"item.started","item":{"id":"item_3","type":"command_execution","command":"/bin/bash -lc \"sed -n '1,260p' tests/test_risk.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_3","type":"command_execution","command":"/bin/bash -lc \"sed -n '1,260p' tests/test_risk.py\"","aggregated_output":"from __future__ import annotations\n\nimport numpy as np\nimport pandas as pd\nimport pandas.testing as pdt\nimport pytest\n\nimport trend_analysis.risk as risk\nfrom trend_analysis.engine.optimizer import ConstraintViolation\nfrom trend_analysis.risk import (\n    RiskWindow,\n    compute_constrained_weights,\n    realised_volatility,\n)\n\n\ndef test_realised_volatility_returns_annualised_series() -> None:\n    returns = pd.DataFrame(\n        {\n            \"A\": [0.01, -0.02, 0.015, 0.005],\n            \"B\": [0.005, 0.007, -0.01, 0.012],\n        },\n        index=pd.date_range(\"2020-01-31\", periods=4, freq=\"ME\"),\n    )\n    window = RiskWindow(length=3, decay=\"simple\")\n\n    vol = realised_volatility(returns, window, periods_per_year=12)\n\n    assert list(vol.columns) == [\"A\", \"B\"]\n    assert len(vol) == 4\n    # Last value should reflect the most recent window and be positive\n    assert vol.iloc[-1][\"A\"] > 0\n    assert vol.iloc[-1][\"B\"] > 0\n\n\ndef test_compute_constrained_weights_scales_and_constrains() -> None:\n    returns = pd.DataFrame(\n        {\n            \"A\": [0.01, 0.02, -0.005, 0.004, 0.011],\n            \"B\": [-0.004, 0.006, 0.007, -0.003, 0.005],\n            \"C\": [0.002, -0.001, 0.003, 0.004, 0.002],\n        },\n        index=pd.date_range(\"2021-01-31\", periods=5, freq=\"ME\"),\n    )\n    base = {\"A\": 0.5, \"B\": 0.3, \"C\": 0.2}\n\n    weights, diagnostics = compute_constrained_weights(\n        base,\n        returns,\n        window=RiskWindow(length=3, decay=\"simple\"),\n        target_vol=0.15,\n        periods_per_year=12,\n        floor_vol=0.02,\n        long_only=True,\n        max_weight=0.6,\n        previous_weights=None,\n        max_turnover=None,\n    )\n\n    assert abs(weights.sum() - 1.0) < 1e-9\n    assert (weights >= 0).all()\n    assert diagnostics.turnover_value >= 0\n    assert not diagnostics.asset_volatility.empty\n    assert diagnostics.scale_factors.loc[\"A\"] >= 0\n\n\ndef test_compute_constrained_weights_respects_turnover_cap() -> None:\n    returns = pd.DataFrame(\n        {\n            \"A\": [0.01, -0.02, 0.015, 0.005],\n            \"B\": [0.005, 0.007, -0.01, 0.012],\n        },\n        index=pd.date_range(\"2020-01-31\", periods=4, freq=\"ME\"),\n    )\n    base = {\"A\": 0.7, \"B\": 0.3}\n    prev = {\"A\": 0.2, \"B\": 0.8}\n\n    weights, diagnostics = compute_constrained_weights(\n        base,\n        returns,\n        window=RiskWindow(length=2, decay=\"simple\"),\n        target_vol=0.1,\n        periods_per_year=12,\n        floor_vol=0.01,\n        long_only=True,\n        max_weight=0.8,\n        previous_weights=prev,\n        max_turnover=0.2,\n    )\n\n    assert diagnostics.turnover_value <= 0.2000001\n    assert abs(weights.sum() - 1.0) < 1e-9\n\n\ndef test_compute_constrained_weights_lambda_penalty_reduces_turnover() -> None:\n    returns = pd.DataFrame(\n        {\n            \"A\": [0.02, 0.015, -0.01, 0.025],\n            \"B\": [-0.01, 0.01, 0.02, -0.005],\n        },\n        index=pd.date_range(\"2021-06-30\", periods=4, freq=\"ME\"),\n    )\n    base = {\"A\": 0.8, \"B\": 0.2}\n    prev = {\"A\": 0.1, \"B\": 0.9}\n\n    _, diag_zero = compute_constrained_weights(\n        base,\n        returns,\n        window=RiskWindow(length=2, decay=\"simple\"),\n        target_vol=0.12,\n        periods_per_year=12,\n        floor_vol=0.01,\n        long_only=True,\n        max_weight=0.9,\n        previous_weights=prev,\n        lambda_tc=0.0,\n        max_turnover=None,\n    )\n    _, diag_high = compute_constrained_weights(\n        base,\n        returns,\n        window=RiskWindow(length=2, decay=\"simple\"),\n        target_vol=0.12,\n        periods_per_year=12,\n        floor_vol=0.01,\n        long_only=True,\n        max_weight=0.9,\n        previous_weights=prev,\n        lambda_tc=0.8,\n        max_turnover=None,\n    )\n\n    assert diag_high.turnover_value < diag_zero.turnover_value\n\n\ndef test_compute_constrained_weights_respects_max_weight_with_vol_adjust() -> None:\n    returns = pd.DataFrame(\n        {\n            \"A\": [0.001, 0.002, 0.0015, 0.001, 0.0018],\n            \"B\": [0.05, -0.04, 0.06, -0.05, 0.04],\n            \"C\": [0.03, -0.02, 0.025, -0.03, 0.02],\n        },\n        index=pd.date_range(\"2023-01-31\", periods=5, freq=\"ME\"),\n    )\n    base = {\"A\": 1 / 3, \"B\": 1 / 3, \"C\": 1 / 3}\n\n    weights, diagnostics = compute_constrained_weights(\n        base,\n        returns,\n        window=RiskWindow(length=3, decay=\"simple\"),\n        target_vol=0.2,\n        periods_per_year=12,\n        floor_vol=0.01,\n        long_only=True,\n        max_weight=0.35,\n        previous_weights=None,\n        max_turnover=None,\n    )\n\n    assert abs(weights.sum() - 1.0) < 1e-9\n    assert weights.max() <= 0.35 + 1e-9\n    assert diagnostics.scale_factors.loc[\"A\"] > 1.0\n\n\ndef test_compute_constrained_weights_caps_after_large_vol_scaling() -> None:\n    returns = pd.DataFrame(\n        {\n            \"A\": [0.0005, 0.0007, 0.0006, 0.0008, 0.0007],\n            \"B\": [0.06, -0.05, 0.07, -0.06, 0.05],\n            \"C\": [0.04, -0.03, 0.035, -0.04, 0.03],\n        },\n        index=pd.date_range(\"2023-06-30\", periods=5, freq=\"ME\"),\n    )\n    base = {\"A\": 0.4, \"B\": 0.3, \"C\": 0.3}\n\n    weights, diagnostics = compute_constrained_weights(\n        base,\n        returns,\n        window=RiskWindow(length=3, decay=\"simple\"),\n        target_vol=0.6,\n        periods_per_year=12,\n        floor_vol=0.01,\n        long_only=True,\n        max_weight=0.35,\n        previous_weights=None,\n        max_turnover=None,\n    )\n\n    assert abs(weights.sum() - 1.0) < 1e-9\n    assert weights.max() <= 0.35 + 1e-9\n    assert diagnostics.scale_factors.loc[\"A\"] > 1.0\n\n\ndef test_compute_constrained_weights_enforces_max_weight_with_vol_adjust() -> None:\n    returns = pd.DataFrame(\n        {\n            \"A\": [0.0002, 0.0001, 0.0003, 0.0002, 0.0001],\n            \"B\": [0.08, -0.07, 0.06, -0.05, 0.07],\n            \"C\": [0.06, -0.05, 0.07, -0.06, 0.05],\n        },\n        index=pd.date_range(\"2024-01-31\", periods=5, freq=\"ME\"),\n    )\n    base = {\"A\": 1 / 3, \"B\": 1 / 3, \"C\": 1 / 3}\n\n    weights, diagnostics = compute_constrained_weights(\n        base,\n        returns,\n        window=RiskWindow(length=3, decay=\"simple\"),\n        target_vol=0.8,\n        periods_per_year=12,\n        floor_vol=0.001,\n        long_only=True,\n        max_weight=0.35,\n        previous_weights=None,\n        max_turnover=None,\n    )\n\n    assert abs(weights.sum() - 1.0) < 1e-9\n    assert weights.max() <= 0.35 + 1e-9\n    assert diagnostics.scale_factors.loc[\"A\"] > 5.0\n\n\ndef test_periods_per_year_from_code_defaults() -> None:\n    assert risk.periods_per_year_from_code(None) == 12.0\n    assert risk.periods_per_year_from_code(\"W\") == 52.0\n    assert risk.periods_per_year_from_code(\"unknown\") == 12.0\n\n\ndef test_realised_volatility_validates_inputs() -> None:\n    with pytest.raises(ValueError):\n        risk.realised_volatility(pd.DataFrame(), risk.RiskWindow(length=3))\n    with pytest.raises(ValueError):\n        risk.realised_volatility(pd.DataFrame({\"A\": [0.1]}), risk.RiskWindow(length=0))\n    with pytest.raises(ValueError):\n        risk.realised_volatility(\n            pd.DataFrame({\"A\": [0.1, -0.2]}),\n            risk.RiskWindow(length=2, decay=\"ewma\", ewma_lambda=1.5),\n        )\n\n\ndef test_normalise_handles_zero_sum() -> None:\n    series = pd.Series({\"A\": 0.0, \"B\": 0.0})\n    normalised = risk._normalise(series)\n    assert normalised.equals(series)\n\n\ndef test_enforce_turnover_cap_with_previous() -> None:\n    target = pd.Series({\"A\": 0.7, \"B\": 0.3})\n    prev = pd.Series({\"A\": 0.1, \"B\": 0.9})\n    adjusted, turnover = risk._enforce_turnover_cap(target, prev, max_turnover=0.4)\n    assert abs(adjusted.sum() - 1.0) < 1e-12\n    assert turnover <= 0.4 + 1e-6\n\n\ndef test_compute_constrained_weights_validates_inputs() -> None:\n    with pytest.raises(ValueError):\n        risk.compute_constrained_weights(\n            {},\n            pd.DataFrame(),\n            window=risk.RiskWindow(2),\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_4","type":"reasoning","text":"**Inspecting max_weight tests with vol_adjust**"}}
{"type":"item.started","item":{"id":"item_5","type":"command_execution","command":"/bin/bash -lc \"sed -n '220,360p' src/trend_analysis/risk.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_5","type":"command_execution","command":"/bin/bash -lc \"sed -n '220,360p' src/trend_analysis/risk.py\"","aggregated_output":"    )\n    trimmed = working.copy()\n    trimmed.loc[~trimmed.index.isin(keep)] = 0.0\n\n    if has_cash:\n        cash_weight = float(weights.loc[cash_label])\n        remaining = 1.0 - cash_weight\n        if remaining < 0:\n            remaining = 0.0\n        trimmed_sum = float(trimmed.sum())\n        if trimmed_sum != 0 and remaining > 0:\n            trimmed = trimmed * (remaining / trimmed_sum)\n        result = trimmed.copy()\n        result.loc[cash_label] = cash_weight\n        return result.reindex(weights.index)\n\n    return trimmed.reindex(weights.index)\n\n\ndef compute_constrained_weights(\n    base_weights: Mapping[str, float] | pd.Series,\n    returns: pd.DataFrame,\n    *,\n    window: RiskWindow,\n    target_vol: float | None,\n    periods_per_year: float,\n    floor_vol: float | None,\n    long_only: bool,\n    max_weight: float | None,\n    max_active_positions: int | None = None,\n    previous_weights: Mapping[str, float] | pd.Series | None = None,\n    lambda_tc: float | None = None,\n    max_turnover: float | None = None,\n    group_caps: Mapping[str, float] | None = None,\n    groups: Mapping[str, str] | None = None,\n) -> tuple[pd.Series, RiskDiagnostics]:\n    \"\"\"Apply risk controls and return final weights plus diagnostics.\"\"\"\n\n    if returns.empty:\n        raise ValueError(\"returns cannot be empty\")\n\n    base = _ensure_series(base_weights)\n    if base.empty:\n        raise ValueError(\"base_weights cannot be empty\")\n\n    base = _normalise(base)\n\n    effective_max_weight = max_weight\n    if max_weight is not None:\n        try:\n            max_weight_val = float(max_weight)\n        except (TypeError, ValueError):\n            max_weight_val = None\n        if max_weight_val is not None and max_weight_val > 0 and len(base) > 0:\n            min_cap = 1.0 / len(base)\n            if max_weight_val * len(base) < 1.0 - NUMERICAL_TOLERANCE_HIGH:\n                max_weight_val = min_cap\n        effective_max_weight = max_weight_val\n\n    constraint_payload = {\n        \"long_only\": bool(long_only),\n        \"max_weight\": effective_max_weight,\n        \"group_caps\": group_caps,\n        \"groups\": groups,\n    }\n    constrained_base = optimizer_mod.apply_constraints(base, constraint_payload)\n    constrained_base = constrained_base.reindex(base.index, fill_value=0.0)\n    constrained_base = _normalise(constrained_base)\n\n    realised = realised_volatility(returns, window, periods_per_year=periods_per_year)\n    latest = realised.iloc[-1].reindex(base.index).ffill().bfill()\n    latest = latest.reindex(base.index).fillna(realised.mean(axis=0))\n    positive = latest[latest > 0]\n    fallback = float(positive.min()) if not positive.empty else 1.0\n    latest = latest.fillna(fallback)\n\n    scale_factors = _scale_factors(latest, target_vol, floor_vol=floor_vol)\n    scaled = _normalise(constrained_base.mul(scale_factors))\n    constrained = optimizer_mod.apply_constraints(scaled, constraint_payload)\n    constrained = _normalise(constrained)\n\n    prev_series = (\n        _ensure_series(previous_weights) if previous_weights is not None else None\n    )\n    constrained = _apply_turnover_penalty(constrained, prev_series, lambda_tc)\n    constrained, turnover_value = _enforce_turnover_cap(\n        constrained, prev_series, max_turnover\n    )\n    constrained = constrained.reindex(base.index, fill_value=0.0)\n    constrained = _enforce_max_active(constrained, max_active_positions)\n    constrained = _normalise(constrained)\n\n    aligned_returns = returns.reindex(columns=constrained.index, fill_value=0.0)\n    portfolio_returns = aligned_returns.mul(constrained, axis=1).sum(axis=1)\n    portfolio_vol = realised_volatility(\n        portfolio_returns.to_frame(\"portfolio\"),\n        window,\n        periods_per_year=periods_per_year,\n    )[\"portfolio\"]\n\n    turnover_index: Iterable[pd.Timestamp]\n    if isinstance(returns.index, pd.DatetimeIndex) and len(returns.index) > 0:\n        turnover_index = [returns.index[-1]]\n    else:\n        turnover_index = [pd.Timestamp(\"1970-01-01\")]  # dummy timestamp\n\n    turnover_series = pd.Series(\n        [turnover_value],\n        index=pd.Index(turnover_index, name=\"rebalance\"),\n        name=\"turnover\",\n    )\n\n    diagnostics = RiskDiagnostics(\n        asset_volatility=realised,\n        portfolio_volatility=portfolio_vol,\n        turnover=turnover_series,\n        turnover_value=float(turnover_value),\n        scale_factors=scale_factors.reindex(constrained.index).fillna(0.0),\n    )\n\n    return constrained, diagnostics\n\n\n__all__ = [\n    \"RiskDiagnostics\",\n    \"RiskWindow\",\n    \"compute_constrained_weights\",\n    \"periods_per_year_from_code\",\n    \"realised_volatility\",\n]\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_6","type":"reasoning","text":"**Reviewing test coverage for max_weight with vol_adjust**"}}
{"type":"item.started","item":{"id":"item_7","type":"command_execution","command":"/bin/bash -lc \"sed -n '1,200p' tests/test_pipeline_constraints_integration.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_7","type":"command_execution","command":"/bin/bash -lc \"sed -n '1,200p' tests/test_pipeline_constraints_integration.py\"","aggregated_output":"import numpy as np\nimport pandas as pd\n\nfrom trend_analysis.core.rank_selection import RiskStatsConfig\nfrom trend_analysis.pipeline import _run_analysis\nfrom trend_analysis.plugins import WeightEngine, weight_engine_registry\n\nRUN_KWARGS = {\"risk_free_column\": \"RF\", \"allow_risk_free_fallback\": False}\n\n\n@weight_engine_registry.register(\"negative_test_engine\")\nclass NegativeTestEngine(WeightEngine):\n    \"\"\"Test-only engine that emits a deliberate short weight.\"\"\"\n\n    def weight(self, cov: pd.DataFrame) -> pd.Series:\n        if cov.empty:\n            return pd.Series(dtype=float)\n        weights = pd.Series(0.0, index=cov.index, dtype=float)\n        if len(weights) == 1:\n            weights.iloc[0] = 1.0\n        else:\n            weights.iloc[0] = 0.6\n            weights.iloc[1] = -0.2\n            if len(weights) > 2:\n                weights.iloc[2] = 0.6\n        return weights\n\n\ndef make_dummy_returns(n_months: int = 24) -> pd.DataFrame:\n    dates = pd.date_range(\"2022-01-31\", periods=n_months, freq=\"ME\")\n    rng = np.random.default_rng(42)\n    data = {\n        \"Date\": dates,\n        \"FundA\": rng.normal(0.01, 0.02, size=n_months),\n        \"FundB\": rng.normal(0.008, 0.02, size=n_months),\n        \"FundC\": rng.normal(0.011, 0.02, size=n_months),\n        \"FundD\": rng.normal(0.009, 0.02, size=n_months),\n        \"RF\": np.zeros(n_months),\n    }\n    return pd.DataFrame(data)\n\n\ndef test_pipeline_applies_cash_and_max_weight_constraints():\n    df = make_dummy_returns()\n    res = _run_analysis(\n        df,\n        in_start=\"2022-01\",\n        in_end=\"2022-12\",\n        out_start=\"2023-01\",\n        out_end=\"2023-12\",\n        target_vol=0.10,\n        monthly_cost=0.0,\n        selection_mode=\"all\",\n        stats_cfg=RiskStatsConfig(),\n        constraints={\n            \"long_only\": True,\n            \"max_weight\": 0.4,\n            \"cash_weight\": 0.1,\n        },\n        **RUN_KWARGS,\n    )\n    assert res is not None\n    weights = res[\"fund_weights\"]  # mapping fund->weight (excludes CASH synthetic line)\n    assert isinstance(weights, dict)\n    total = sum(weights.values())\n    assert 0.99 <= total <= 1.01\n    assert all(w <= 0.4 + 1e-9 for w in weights.values())\n    # Ensure no CASH synthetic line leaked into fund weights\n    assert \"CASH\" not in weights\n\n\ndef test_pipeline_max_weight_with_vol_adjust_enabled():\n    df = make_dummy_returns()\n    custom_weights = {\"FundA\": 80.0, \"FundB\": 10.0, \"FundC\": 10.0, \"FundD\": 0.0}\n    res = _run_analysis(\n        df,\n        in_start=\"2022-01\",\n        in_end=\"2022-12\",\n        out_start=\"2023-01\",\n        out_end=\"2023-12\",\n        target_vol=0.10,\n        monthly_cost=0.0,\n        selection_mode=\"all\",\n        custom_weights=custom_weights,\n        stats_cfg=RiskStatsConfig(),\n        constraints={\n            \"long_only\": True,\n            \"max_weight\": 0.35,\n        },\n        **RUN_KWARGS,\n    )\n    assert res is not None\n    weights = res[\"fund_weights\"]\n    assert isinstance(weights, dict)\n    assert all(weight <= 0.35 + 1e-9 for weight in weights.values())\n\n\ndef test_pipeline_long_only_blocks_negative_custom_weights():\n    df = make_dummy_returns()\n    custom_weights = {\"FundA\": 70.0, \"FundB\": -20.0, \"FundC\": 50.0, \"FundD\": 0.0}\n\n    res_long_only = _run_analysis(\n        df,\n        in_start=\"2022-01\",\n        in_end=\"2022-12\",\n        out_start=\"2023-01\",\n        out_end=\"2023-12\",\n        target_vol=None,\n        monthly_cost=0.0,\n        selection_mode=\"all\",\n        custom_weights=custom_weights,\n        stats_cfg=RiskStatsConfig(),\n        constraints={\"long_only\": True},\n        **RUN_KWARGS,\n    )\n    assert res_long_only is not None\n    weights_long = res_long_only[\"fund_weights\"]\n    assert all(weight >= 0 for weight in weights_long.values())\n\n    res_short_ok = _run_analysis(\n        df,\n        in_start=\"2022-01\",\n        in_end=\"2022-12\",\n        out_start=\"2023-01\",\n        out_end=\"2023-12\",\n        target_vol=None,\n        monthly_cost=0.0,\n        selection_mode=\"all\",\n        custom_weights=custom_weights,\n        stats_cfg=RiskStatsConfig(),\n        constraints={\"long_only\": False},\n        **RUN_KWARGS,\n    )\n    assert res_short_ok is not None\n    weights_short = res_short_ok[\"fund_weights\"]\n    assert any(weight < 0 for weight in weights_short.values())\n\n\ndef test_pipeline_long_only_clips_negative_weight_engine_weights():\n    df = make_dummy_returns()\n    res_long_only = _run_analysis(\n        df,\n        in_start=\"2022-01\",\n        in_end=\"2022-12\",\n        out_start=\"2023-01\",\n        out_end=\"2023-12\",\n        target_vol=None,\n        monthly_cost=0.0,\n        selection_mode=\"all\",\n        weighting_scheme=\"negative_test_engine\",\n        stats_cfg=RiskStatsConfig(),\n        constraints={\"long_only\": True},\n        **RUN_KWARGS,\n    )\n    assert res_long_only is not None\n    weights_long = res_long_only[\"fund_weights\"]\n    assert all(weight >= 0 for weight in weights_long.values())\n\n    res_short_ok = _run_analysis(\n        df,\n        in_start=\"2022-01\",\n        in_end=\"2022-12\",\n        out_start=\"2023-01\",\n        out_end=\"2023-12\",\n        target_vol=None,\n        monthly_cost=0.0,\n        selection_mode=\"all\",\n        weighting_scheme=\"negative_test_engine\",\n        stats_cfg=RiskStatsConfig(),\n        constraints={\"long_only\": False},\n        **RUN_KWARGS,\n    )\n    assert res_short_ok is not None\n    weights_short = res_short_ok[\"fund_weights\"]\n    assert any(weight < 0 for weight in weights_short.values())\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_8","type":"reasoning","text":"**Investigating vol_adjust usage**"}}
{"type":"item.started","item":{"id":"item_9","type":"command_execution","command":"/bin/bash -lc 'rg -n \"def _run_analysis\" -n src/trend_analysis/pipeline.py'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_9","type":"command_execution","command":"/bin/bash -lc 'rg -n \"def _run_analysis\" -n src/trend_analysis/pipeline.py'","aggregated_output":"2283:def _run_analysis_with_diagnostics(\n2417:def _run_analysis(\n","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_10","type":"command_execution","command":"/bin/bash -lc \"sed -n '2417,2525p' src/trend_analysis/pipeline.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_10","type":"command_execution","command":"/bin/bash -lc \"sed -n '2417,2525p' src/trend_analysis/pipeline.py\"","aggregated_output":"def _run_analysis(\n    df: pd.DataFrame,\n    in_start: str,\n    in_end: str,\n    out_start: str,\n    out_end: str,\n    target_vol: float | None,\n    monthly_cost: float,\n    *,\n    floor_vol: float | None = None,\n    warmup_periods: int = 0,\n    selection_mode: str = \"all\",\n    random_n: int = 8,\n    custom_weights: dict[str, float] | None = None,\n    rank_kwargs: Mapping[str, Any] | None = None,\n    manual_funds: list[str] | None = None,\n    indices_list: list[str] | None = None,\n    benchmarks: dict[str, str] | None = None,\n    seed: int = 42,\n    stats_cfg: RiskStatsConfig | None = None,\n    weighting_scheme: str | None = None,\n    constraints: dict[str, Any] | None = None,\n    missing_policy: str | Mapping[str, str] | None = None,\n    missing_limit: int | Mapping[str, int | None] | None = None,\n    risk_window: Mapping[str, Any] | None = None,\n    periods_per_year_override: float | None = None,\n    previous_weights: Mapping[str, float] | None = None,\n    lambda_tc: float | None = None,\n    max_turnover: float | None = None,\n    signal_spec: TrendSpec | None = None,\n    regime_cfg: Mapping[str, Any] | None = None,\n    weight_policy: Mapping[str, Any] | None = None,\n    risk_free_column: str | None = None,\n    allow_risk_free_fallback: bool | None = None,\n    weight_engine_params: Mapping[str, Any] | None = None,\n) -> AnalysisResult | None:\n    \"\"\"Backward-compatible wrapper returning raw payloads for tests.\"\"\"\n\n    result = _run_analysis_with_diagnostics(\n        df,\n        in_start,\n        in_end,\n        out_start,\n        out_end,\n        target_vol,\n        monthly_cost,\n        floor_vol=floor_vol,\n        warmup_periods=warmup_periods,\n        selection_mode=selection_mode,\n        random_n=random_n,\n        custom_weights=custom_weights,\n        rank_kwargs=rank_kwargs,\n        manual_funds=manual_funds,\n        indices_list=indices_list,\n        benchmarks=benchmarks,\n        seed=seed,\n        stats_cfg=stats_cfg,\n        weighting_scheme=weighting_scheme,\n        constraints=constraints,\n        missing_policy=missing_policy,\n        missing_limit=missing_limit,\n        risk_window=risk_window,\n        periods_per_year_override=periods_per_year_override,\n        previous_weights=previous_weights,\n        lambda_tc=lambda_tc,\n        max_turnover=max_turnover,\n        signal_spec=signal_spec,\n        regime_cfg=regime_cfg,\n        weight_policy=weight_policy,\n        risk_free_column=risk_free_column,\n        allow_risk_free_fallback=allow_risk_free_fallback,\n        weight_engine_params=weight_engine_params,\n    )\n    return result.unwrap()\n\n\n_DEFAULT_RUN_ANALYSIS = _run_analysis\n\n\ndef _invoke_analysis_with_diag(*args: Any, **kwargs: Any) -> PipelineResult:\n    \"\"\"Call the patched analysis hook and normalise into a PipelineResult.\"\"\"\n\n    if _run_analysis is _DEFAULT_RUN_ANALYSIS:\n        return _run_analysis_with_diagnostics(*args, **kwargs)\n    patched_result = _run_analysis(*args, **kwargs)\n    if isinstance(patched_result, PipelineResult):\n        return patched_result\n    if isinstance(patched_result, DiagnosticResult):\n        return PipelineResult(\n            value=patched_result.value,\n            diagnostic=patched_result.diagnostic,\n        )\n    return PipelineResult(value=patched_result, diagnostic=None)\n\n\ndef run_analysis(\n    df: pd.DataFrame,\n    in_start: str,\n    in_end: str,\n    out_start: str,\n    out_end: str,\n    target_vol: float | None,\n    monthly_cost: float,\n    *,\n    floor_vol: float | None = None,\n    warmup_periods: int = 0,\n    selection_mode: str = \"all\",\n    random_n: int = 8,\n    custom_weights: dict[str, float] | None = None,\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_11","type":"reasoning","text":"**Investigating vol_adjust in TrendSpec**"}}
{"type":"item.started","item":{"id":"item_12","type":"command_execution","command":"/bin/bash -lc 'rg -n \"class TrendSpec\" -n src/trend_analysis'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_12","type":"command_execution","command":"/bin/bash -lc 'rg -n \"class TrendSpec\" -n src/trend_analysis'","aggregated_output":"src/trend_analysis/signal_presets.py:12:class TrendSpecPreset:\nsrc/trend_analysis/signals.py:110:class TrendSpec:\n","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_13","type":"command_execution","command":"/bin/bash -lc \"sed -n '100,160p' src/trend_analysis/signals.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_13","type":"command_execution","command":"/bin/bash -lc \"sed -n '100,160p' src/trend_analysis/signals.py\"","aggregated_output":"        return\n    start = time.perf_counter()\n    try:\n        yield\n    finally:\n        duration_ms = (time.perf_counter() - start) * 1000.0\n        LOGGER.debug(\"compute_trend_signals[%s] %.2f ms\", stage, duration_ms)\n\n\n@dataclass(frozen=True, slots=True)\nclass TrendSpec:\n    \"\"\"Configuration for generating time-series momentum style signals.\"\"\"\n\n    kind: Literal[\"tsmom\"] = \"tsmom\"\n    window: int = 63\n    min_periods: int | None = None\n    lag: int = 1\n    vol_adjust: bool = False\n    vol_target: float | None = None\n    zscore: bool | float = False\n\n    def __post_init__(self) -> None:\n        if self.window <= 0:\n            raise ValueError(\"window must be a positive integer\")\n        if self.min_periods is not None and self.min_periods <= 0:\n            raise ValueError(\"min_periods must be positive when provided\")\n        if self.lag < 1:\n            raise ValueError(\"lag must be at least 1\")\n        if self.vol_target is not None and self.vol_target < 0:\n            raise ValueError(\"vol_target must be non-negative when provided\")\n\n\ndef _as_float_frame(df: pd.DataFrame) -> pd.DataFrame:\n    def _build() -> pd.DataFrame:\n        numeric = df.copy()\n        for column in numeric.columns:\n            numeric[column] = pd.to_numeric(numeric[column], errors=\"coerce\")\n        return numeric.astype(float)\n\n    return _memoised_frame(df, \"float_frame\", _build)\n\n\ndef _zscore_rows(frame: pd.DataFrame) -> pd.DataFrame:\n    demeaned = frame.sub(frame.mean(axis=1, skipna=True), axis=0)\n    std = frame.std(axis=1, skipna=True, ddof=0).replace(0.0, np.nan)\n    normalised = demeaned.div(std, axis=0)\n    return normalised.fillna(0.0)\n\n\ndef _resolve_zscore_scale(setting: bool | float) -> float | None:\n    if isinstance(setting, bool):\n        return 1.0 if setting else None\n    try:\n        scale = float(setting)\n    except (TypeError, ValueError):\n        return None\n    if not np.isfinite(scale) or scale <= 0:\n        return None\n    return scale\n\n\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_14","type":"reasoning","text":"**Investigating vol_adjust activation**"}}
{"type":"item.started","item":{"id":"item_15","type":"command_execution","command":"/bin/bash -lc 'rg -n \"vol_adjust\" -n src/trend_analysis/pipeline.py | head'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_15","type":"command_execution","command":"/bin/bash -lc 'rg -n \"vol_adjust\" -n src/trend_analysis/pipeline.py | head'","aggregated_output":"1033:        vol_adjust=False,\n1446:def _resolve_target_vol(vol_adjust_cfg: Mapping[str, Any] | Any) -> float | None:\n1447:    enabled = _section_get(vol_adjust_cfg, \"enabled\")\n1450:    target_raw = _section_get(vol_adjust_cfg, \"target_vol\", 1.0)\n1647:    vol_adjust_cfg: Mapping[str, Any] | Any,\n1690:    vol_adjust_default = bool(_section_get(vol_adjust_cfg, \"enabled\", False))\n1691:    vol_adjust_flag = bool(\n1692:        _signal_setting(\"vol_adjust\", \"trend_vol_adjust\", vol_adjust_default)\n1695:    if vol_target_raw is None and vol_adjust_flag:\n1696:        vol_target_raw = _section_get(vol_adjust_cfg, \"target_vol\")\n","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_16","type":"command_execution","command":"/bin/bash -lc \"sed -n '1640,1735p' src/trend_analysis/pipeline.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_16","type":"command_execution","command":"/bin/bash -lc \"sed -n '1640,1735p' src/trend_analysis/pipeline.py\"","aggregated_output":"        \"risk_diagnostics\": {},\n        \"fund_weights\": {},\n    }\n\n\ndef _build_trend_spec(\n    cfg: Mapping[str, Any] | Any,\n    vol_adjust_cfg: Mapping[str, Any] | Any,\n) -> TrendSpec | None:\n    \"\"\"Build a TrendSpec from config, or None if no signals config is present.\n\n    Returns None when no ``signals`` section is configured, so that callers\n    fall back to the existing default behaviour (signal window derived from\n    the in-sample risk window).\n    \"\"\"\n    signals_cfg = _cfg_section(cfg, \"signals\")\n\n    # Return None when no signals config is present - this preserves the old\n    # default behaviour where signal_spec=None causes the pipeline to derive\n    # the window from the risk window length rather than hardcoding 63.\n    if not signals_cfg:\n        return None\n\n    def _signal_setting(key: str, alias: str | None, default: Any = None) -> Any:\n        value = _section_get(signals_cfg, key, None)\n        if value is None and alias:\n            value = _section_get(signals_cfg, alias, None)\n        return default if value is None else value\n\n    kind = str(_section_get(signals_cfg, \"kind\", \"tsmom\") or \"tsmom\").lower()\n    if kind != \"tsmom\":  # pragma: no cover - future extension guard\n        raise ValueError(f\"Unsupported trend signal kind: {kind}\")\n\n    try:\n        window_raw = _signal_setting(\"window\", \"trend_window\", 63)\n        window = int(window_raw)\n    except (TypeError, ValueError):\n        window = 63\n    min_periods_raw = _signal_setting(\"min_periods\", \"trend_min_periods\")\n    try:\n        min_periods = int(min_periods_raw) if min_periods_raw is not None else None\n    except (TypeError, ValueError):\n        min_periods = None\n\n    try:\n        lag_raw = _signal_setting(\"lag\", \"trend_lag\", 1)\n        lag = max(1, int(lag_raw))\n    except (TypeError, ValueError):\n        lag = 1\n\n    vol_adjust_default = bool(_section_get(vol_adjust_cfg, \"enabled\", False))\n    vol_adjust_flag = bool(\n        _signal_setting(\"vol_adjust\", \"trend_vol_adjust\", vol_adjust_default)\n    )\n    vol_target_raw = _signal_setting(\"vol_target\", \"trend_vol_target\")\n    if vol_target_raw is None and vol_adjust_flag:\n        vol_target_raw = _section_get(vol_adjust_cfg, \"target_vol\")\n    try:\n        vol_target = float(vol_target_raw) if vol_target_raw is not None else None\n        if vol_target is not None and vol_target <= 0:\n            vol_target = None\n    except (TypeError, ValueError):\n        vol_target = None\n\n    zscore_setting = _signal_setting(\"zscore\", \"trend_zscore\", False)\n    if isinstance(zscore_setting, bool):\n        zscore_flag: bool | float = zscore_setting\n    else:\n        try:\n            zscore_value = float(zscore_setting)\n        except (TypeError, ValueError):\n            zscore_flag = False\n        else:\n            zscore_flag = zscore_value if np.isfinite(zscore_value) else False\n            if isinstance(zscore_flag, float) and zscore_flag <= 0:\n                zscore_flag = False\n\n    return TrendSpec(\n        kind=\"tsmom\",\n        window=max(1, window),\n        min_periods=min_periods,\n        lag=lag,\n        vol_adjust=vol_adjust_flag,\n        vol_target=vol_target,\n        zscore=zscore_flag,\n    )\n\n\ndef _policy_from_config(\n    cfg: Mapping[str, Any] | None,\n) -> tuple[str | Mapping[str, str] | None, int | Mapping[str, int | None] | None]:\n    if not cfg:\n        return None, None\n    policy_base = cfg.get(\"policy\")\n    per_asset = cfg.get(\"per_asset\")\n    policy_spec: str | Mapping[str, str] | None\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_17","type":"reasoning","text":"**Investigating signal_spec usage**"}}
{"type":"item.started","item":{"id":"item_18","type":"command_execution","command":"/bin/bash -lc 'rg -n \"signal_spec\" -n src/trend_analysis/pipeline.py'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_18","type":"command_execution","command":"/bin/bash -lc 'rg -n \"signal_spec\" -n src/trend_analysis/pipeline.py'","aggregated_output":"195:    effective_signal_spec: TrendSpec\n753:    signal_spec: TrendSpec | None,\n1029:    effective_signal_spec = signal_spec or TrendSpec(\n1039:        signal_frame = compute_trend_signals(signal_inputs, effective_signal_spec)\n1247:        effective_signal_spec=effective_signal_spec,\n1399:            \"signal_spec\": computation.effective_signal_spec,\n1658:    # default behaviour where signal_spec=None causes the pipeline to derive\n2312:    signal_spec: TrendSpec | None = None,\n2396:        signal_spec=signal_spec,\n2446:    signal_spec: TrendSpec | None = None,\n2483:        signal_spec=signal_spec,\n2541:    signal_spec: TrendSpec | None = None,\n2593:        signal_spec=signal_spec,\n2703:        signal_spec=trend_spec,\n2831:        signal_spec=trend_spec,\n","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_19","type":"command_execution","command":"/bin/bash -lc \"sed -n '980,1065p' src/trend_analysis/pipeline.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_19","type":"command_execution","command":"/bin/bash -lc \"sed -n '980,1065p' src/trend_analysis/pipeline.py\"","aggregated_output":"        base_series = pd.Series(\n            np.repeat(1.0 / len(fund_cols), len(fund_cols)),\n            index=fund_cols,\n            dtype=float,\n        )\n\n    negative_assets = base_series[base_series < 0].index.tolist()\n    if negative_assets:\n        if weight_engine_used:\n            source = f\"weight engine '{weighting_scheme}'\"\n        elif custom_weights_input:\n            source = \"custom weights\"\n        else:\n            source = \"base weights\"\n        action = \"clip negatives to zero\" if long_only else \"allow short allocations\"\n        logger.info(\n            \"%s produced %d negative weights; long_only=%s so pipeline will %s.\",\n            source,\n            len(negative_assets),\n            long_only,\n            action,\n        )\n\n    window_cfg = dict(risk_window or {})\n    try:\n        window_length = int(window_cfg.get(\"length\", len(window.in_df)))\n    except (TypeError, ValueError):\n        window_length = len(window.in_df)\n    if window_length <= 0:\n        window_length = max(len(window.in_df), 1)\n    decay_mode = str(window_cfg.get(\"decay\", \"simple\"))\n    lambda_value = window_cfg.get(\"lambda\", window_cfg.get(\"ewma_lambda\", 0.94))\n    try:\n        ewma_lambda = float(lambda_value)\n    except (TypeError, ValueError):\n        ewma_lambda = 0.94\n    window_spec = RiskWindow(\n        length=window_length, decay=decay_mode, ewma_lambda=ewma_lambda\n    )\n\n    turnover_cap = None\n    if max_turnover is not None:\n        try:\n            mt = float(max_turnover)\n        except (TypeError, ValueError):\n            mt = None\n        if mt is not None and mt > 0:\n            turnover_cap = mt\n\n    effective_signal_spec = signal_spec or TrendSpec(\n        window=window_spec.length,\n        min_periods=None,\n        lag=1,\n        vol_adjust=False,\n        vol_target=None,\n        zscore=False,\n    )\n    signal_inputs = _scoped_signal_inputs()\n    if not signal_inputs.empty:\n        signal_frame = compute_trend_signals(signal_inputs, effective_signal_spec)\n    else:\n        signal_frame = pd.DataFrame(dtype=float)\n\n    try:\n        weights_series, risk_diagnostics = compute_constrained_weights(\n            base_series,\n            window.in_df[fund_cols],\n            window=window_spec,\n            target_vol=target_vol,\n            periods_per_year=window.periods_per_year,\n            floor_vol=min_floor if min_floor > 0 else None,\n            long_only=long_only,\n            max_weight=max_weight_val,\n            max_active_positions=max_active_val,\n            previous_weights=previous_weights,\n            lambda_tc=lambda_tc,\n            max_turnover=turnover_cap,\n            group_caps=group_caps_map,\n            groups=groups_map,\n        )\n    except Exception as exc:  # pragma: no cover - defensive fallback\n        logger.warning(\n            \"Risk controls failed; falling back to base weights: %s\", exc, exc_info=True\n        )\n        weights_series = base_series.copy()\n        asset_vol = realised_volatility(\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_20","type":"reasoning","text":"**Investigating vol_adjust_enabled usage**"}}
{"type":"item.started","item":{"id":"item_21","type":"command_execution","command":"/bin/bash -lc 'rg -n \"vol_adjust_enabled\" -n'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_21","type":"command_execution","command":"/bin/bash -lc 'rg -n \"vol_adjust_enabled\" -n'","aggregated_output":"codex-session-4136.jsonl:5:{\"type\":\"item.completed\",\"item\":{\"id\":\"item_1\",\"type\":\"command_execution\",\"command\":\"/bin/bash -lc 'rg -n \\\"compute_constrained_weights|max_weight|vol_adjust\\\" src tests'\",\"aggregated_output\":\"src/trend_analysis/gui/app.py:372:    cfg.setdefault(\\\"vol_adjust\\\", as_dict(cfg.get(\\\"vol_adjust\\\")))\\nsrc/trend_analysis/gui/app.py:804:        value=store.cfg.get(\\\"use_vol_adjust\\\", False),\\nsrc/trend_analysis/gui/app.py:845:        store.cfg[\\\"use_vol_adjust\\\"] = bool(change[\\\"new\\\"])\\nsrc/trend_analysis/signal_presets.py:26:            \\\"vol_adjust\\\": self.spec.vol_adjust,\\nsrc/trend_analysis/signal_presets.py:43:            \\\"vol_adjust\\\": self.spec.vol_adjust,\\nsrc/trend_analysis/signal_presets.py:60:            vol_adjust=True,\\nsrc/trend_analysis/signal_presets.py:72:            vol_adjust=True,\\nsrc/trend_analysis/signal_presets.py:84:            vol_adjust=True,\\ntests/test_multi_period_engine_incremental_extra.py:18:    vol_adjust: Dict[str, Any]\\ntests/test_multi_period_engine_incremental_extra.py:28:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_multi_period_engine_incremental_extra.py:64:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_multi_period_engine_incremental_extra.py:134:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_multi_period_engine_incremental_extra.py:191:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_multi_period_engine_incremental_extra.py:244:        vol_adjust={\\\"target_vol\\\": 1.0},\\nsrc/trend_analysis/multi_period/engine.py:743:    trend_spec = _build_trend_spec(cfg, getattr(cfg, \\\"vol_adjust\\\", {}) or {})\\nsrc/trend_analysis/multi_period/engine.py:1003:                _resolve_target_vol(getattr(cfg, \\\"vol_adjust\\\", {})),\\nsrc/trend_analysis/multi_period/engine.py:1005:                floor_vol=cfg.vol_adjust.get(\\\"floor_vol\\\"),\\nsrc/trend_analysis/multi_period/engine.py:1006:                warmup_periods=int(cfg.vol_adjust.get(\\\"warmup_periods\\\", 0) or 0),\\nsrc/trend_analysis/multi_period/engine.py:1017:                risk_window=cfg.vol_adjust.get(\\\"window\\\"),\\nsrc/trend_analysis/multi_period/engine.py:1517:    max_w_bound = float(constraints.get(\\\"max_weight\\\", 0.18))  # decimal\\nsrc/trend_analysis/multi_period/engine.py:3447:            # - total < 1.0: max_weight caps too tight\\nsrc/trend_analysis/multi_period/engine.py:3472:            _resolve_target_vol(getattr(cfg, \\\"vol_adjust\\\", {})),\\nsrc/trend_analysis/multi_period/engine.py:3474:            floor_vol=cfg.vol_adjust.get(\\\"floor_vol\\\"),\\nsrc/trend_analysis/multi_period/engine.py:3475:            warmup_periods=int(cfg.vol_adjust.get(\\\"warmup_periods\\\", 0) or 0),\\nsrc/trend_analysis/multi_period/engine.py:3484:            risk_window=cfg.vol_adjust.get(\\\"window\\\"),\\ntests/test_signals_causality.py:16:def test_compute_trend_signals_is_causal_without_vol_adjust() -> None:\\ntests/test_signals_causality.py:28:def test_compute_trend_signals_is_causal_with_vol_adjust() -> None:\\ntests/test_signals_causality.py:30:    spec = TrendSpec(window=4, min_periods=4, vol_adjust=True, vol_target=0.5)\\ntests/test_config_load.py:31:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.15},\\ntests/test_multi_period_regime_wiring.py:37:            \\\"vol_adjust\\\": {\\nsrc/trend_analysis/config/models.py:42:            \\\"vol_adjust\\\": data.get(\\\"vol_adjust\\\", {}),\\nsrc/trend_analysis/config/models.py:60:    vol_adjust: dict[str, Any]\\nsrc/trend_analysis/config/models.py:280:        vol_adjust: dict[str, Any] = Field(default_factory=dict)\\nsrc/trend_analysis/config/models.py:304:            \\\"vol_adjust\\\",\\nsrc/trend_analysis/config/models.py:409:            \\\"vol_adjust\\\",\\nsrc/trend_analysis/config/models.py:421:            \\\"vol_adjust\\\",\\nsrc/trend_analysis/config/models.py:444:        vol_adjust: Dict[str, Any]\\nsrc/trend_analysis/config/models.py:464:                \\\"vol_adjust\\\": {},\\nsrc/trend_analysis/config/models.py:494:                \\\"vol_adjust\\\",\\nsrc/trend_analysis/config/models.py:579:        \\\"vol_adjust\\\",\\nsrc/trend_analysis/config/models.py:593:    vol_adjust: Dict[str, Any]\\nsrc/trend_analysis/config/models.py:744:        \\\"vol_adjust\\\",\\nsrc/trend_analysis/config/models.py:835:        \\\"vol_adjust\\\",\\ntests/test_trend_signals.py:35:def test_vol_adjustment_changes_scale():\\ntests/test_trend_signals.py:39:        returns, TrendSpec(window=4, vol_adjust=True, vol_target=1.0)\\ntests/test_trend_signals.py:81:    spec = TrendSpec(window=4, vol_adjust=True)\\ntests/test_trend_signals.py:110:    spec = TrendSpec(window=3, vol_adjust=True, vol_target=1.0, zscore=True)\\nsrc/trend_analysis/config/legacy.py:43:    vol_adjust: dict[str, Any]\\ntests/test_engine_incremental_cov.py:25:        vol_adjust={},\\nsrc/trend_analysis/config/model.py:503:            raise ValueError(\\\"vol_adjust.target_vol must be numeric.\\\") from exc\\nsrc/trend_analysis/config/model.py:505:            raise ValueError(\\\"vol_adjust.target_vol must be greater than zero.\\\")\\nsrc/trend_analysis/config/model.py:514:            raise ValueError(\\\"vol_adjust.floor_vol must be numeric.\\\") from exc\\nsrc/trend_analysis/config/model.py:516:            raise ValueError(\\\"vol_adjust.floor_vol cannot be negative.\\\")\\nsrc/trend_analysis/config/model.py:525:            raise ValueError(\\\"vol_adjust.warmup_periods must be an integer.\\\") from exc\\nsrc/trend_analysis/config/model.py:527:            raise ValueError(\\\"vol_adjust.warmup_periods cannot be negative.\\\")\\nsrc/trend_analysis/config/model.py:536:    vol_adjust: RiskSettings\\nsrc/trend_analysis/risk.py:42:    \\\"\\\"\\\"Diagnostics emitted by :func:`compute_constrained_weights`.\\\"\\\"\\\"\\nsrc/trend_analysis/risk.py:239:def compute_constrained_weights(\\nsrc/trend_analysis/risk.py:248:    max_weight: float | None,\\nsrc/trend_analysis/risk.py:267:    effective_max_weight = max_weight\\nsrc/trend_analysis/risk.py:268:    if max_weight is not None:\\nsrc/trend_analysis/risk.py:270:            max_weight_val = float(max_weight)\\nsrc/trend_analysis/risk.py:272:            max_weight_val = None\\nsrc/trend_analysis/risk.py:273:        if max_weight_val is not None and max_weight_val > 0 and len(base) > 0:\\nsrc/trend_analysis/risk.py:275:            if max_weight_val * len(base) < 1.0 - NUMERICAL_TOLERANCE_HIGH:\\nsrc/trend_analysis/risk.py:276:                max_weight_val = min_cap\\nsrc/trend_analysis/risk.py:277:        effective_max_weight = max_weight_val\\nsrc/trend_analysis/risk.py:281:        \\\"max_weight\\\": effective_max_weight,\\nsrc/trend_analysis/risk.py:346:    \\\"compute_constrained_weights\\\",\\nsrc/trend_analysis/config/bridge.py:56:        \\\"vol_adjust\\\": {\\\"target_vol\\\": target_vol},\\ntests/test_rebalance_frequency_wiring.py:37:                \\\"max_weight\\\": 0.8,\\ntests/test_rebalance_frequency_wiring.py:44:    vol_adjust: dict[str, object] = field(\\ntests/test_rebalance_frequency_wiring.py:56:            \\\"vol_adjust\\\": dict(self.vol_adjust),\\nsrc/trend_analysis/signals.py:117:    vol_adjust: bool = False\\nsrc/trend_analysis/signals.py:177:    if spec.vol_adjust:\\nsrc/trend_analysis/api.py:43:    vol_adjust_cfg: Mapping[str, Any] | None = None,\\nsrc/trend_analysis/api.py:49:        trend_spec = _build_trend_spec({\\\"signals\\\": signals_cfg}, vol_adjust_cfg or {})\\nsrc/trend_analysis/api.py:399:    vol_adjust_cfg = getattr(config, \\\"vol_adjust\\\", {}) or {}\\nsrc/trend_analysis/api.py:445:        _resolve_target_vol(vol_adjust_cfg),\\nsrc/trend_analysis/api.py:447:        floor_vol=vol_adjust_cfg.get(\\\"floor_vol\\\"),\\nsrc/trend_analysis/api.py:448:        warmup_periods=int(vol_adjust_cfg.get(\\\"warmup_periods\\\", 0) or 0),\\nsrc/trend_analysis/api.py:462:        risk_window=vol_adjust_cfg.get(\\\"window\\\"),\\nsrc/trend_analysis/api.py:467:        vol_adjust_cfg=vol_adjust_cfg,\\ntests/test_trend_analysis_config_model.py:506:        \\\"vol_adjust\\\": {\\ntests/test_trend_analysis_config_model.py:521:    assert cfg.vol_adjust.target_vol == pytest.approx(0.2)\\ntests/test_optimizer_constraints.py:16:def test_max_weight_cap_redistributes():\\ntests/test_optimizer_constraints.py:18:    out = apply_constraints(w, {\\\"long_only\\\": True, \\\"max_weight\\\": 0.55})\\ntests/test_optimizer_constraints.py:23:def test_too_small_max_weight_infeasible():\\ntests/test_optimizer_constraints.py:26:        apply_constraints(w, {\\\"max_weight\\\": 0.3})\\ntests/test_optimizer_constraints.py:53:        apply_constraints(w, {\\\"long_only\\\": True, \\\"max_weight\\\": 0.4})\\ntests/test_optimizer_constraints.py:78:    with pytest.raises(ConstraintViolation, match=\\\"max_weight must be positive\\\"):\\ntests/test_optimizer_constraints.py:146:        \\\"max_weight\\\": 0.4,\\ntests/test_optimizer_constraints.py:190:def test_cash_weight_infeasible_with_max_weight():\\ntests/test_optimizer_constraints.py:195:        match=\\\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\\\",\\ntests/test_optimizer_constraints.py:197:        apply_constraints(w, {\\\"cash_weight\\\": 0.3, \\\"max_weight\\\": 0.3})\\ntests/test_optimizer_constraints.py:200:def test_cash_weight_exceeds_max_weight_for_cash():\\ntests/test_optimizer_constraints.py:201:    # cash_weight larger than max_weight should raise\\ntests/test_optimizer_constraints.py:203:    with pytest.raises(ConstraintViolation, match=\\\"exceeds max_weight\\\"):\\ntests/test_optimizer_constraints.py:204:        apply_constraints(w, {\\\"cash_weight\\\": 0.6, \\\"max_weight\\\": 0.5})\\ntests/test_optimizer_constraints.py:207:def test_cash_weight_respects_max_weight_after_residual_scaling():\\ntests/test_optimizer_constraints.py:210:    out = apply_constraints(w, {\\\"cash_weight\\\": 0.3, \\\"max_weight\\\": 0.4})\\nsrc/trend_analysis/pipeline.py:43:    compute_constrained_weights,\\nsrc/trend_analysis/pipeline.py:948:    raw_max_weight = constraints_cfg.get(\\\"max_weight\\\")\\nsrc/trend_analysis/pipeline.py:950:        max_weight_val = float(raw_max_weight) if raw_max_weight is not None else None\\nsrc/trend_analysis/pipeline.py:952:        max_weight_val = None\\nsrc/trend_analysis/pipeline.py:1033:        vol_adjust=False,\\nsrc/trend_analysis/pipeline.py:1044:        weights_series, risk_diagnostics = compute_constrained_weights(\\nsrc/trend_analysis/pipeline.py:1052:            max_weight=max_weight_val,\\nsrc/trend_analysis/pipeline.py:1446:def _resolve_target_vol(vol_adjust_cfg: Mapping[str, Any] | Any) -> float | None:\\nsrc/trend_analysis/pipeline.py:1447:    enabled = _section_get(vol_adjust_cfg, \\\"enabled\\\")\\nsrc/trend_analysis/pipeline.py:1450:    target_raw = _section_get(vol_adjust_cfg, \\\"target_vol\\\", 1.0)\\nsrc/trend_analysis/pipeline.py:1647:    vol_adjust_cfg: Mapping[str, Any] | Any,\\nsrc/trend_analysis/pipeline.py:1690:    vol_adjust_default = bool(_section_get(vol_adjust_cfg, \\\"enabled\\\", False))\\nsrc/trend_analysis/pipeline.py:1691:    vol_adjust_flag = bool(\\nsrc/trend_analysis/pipeline.py:1692:        _signal_setting(\\\"vol_adjust\\\", \\\"trend_vol_adjust\\\", vol_adjust_default)\\nsrc/trend_analysis/pipeline.py:1695:    if vol_target_raw is None and vol_adjust_flag:\\nsrc/trend_analysis/pipeline.py:1696:        vol_target_raw = _section_get(vol_adjust_cfg, \\\"target_vol\\\")\\nsrc/trend_analysis/pipeline.py:1722:        vol_adjust=vol_adjust_flag,\\nsrc/trend_analysis/pipeline.py:2661:    vol_adjust = _cfg_section(cfg, \\\"vol_adjust\\\")\\nsrc/trend_analysis/pipeline.py:2671:    trend_spec = _build_trend_spec(cfg, vol_adjust)\\nsrc/trend_analysis/pipeline.py:2682:        _resolve_target_vol(vol_adjust),\\nsrc/trend_analysis/pipeline.py:2684:        floor_vol=_section_get(vol_adjust, \\\"floor_vol\\\"),\\nsrc/trend_analysis/pipeline.py:2685:        warmup_periods=int(_section_get(vol_adjust, \\\"warmup_periods\\\", 0) or 0),\\nsrc/trend_analysis/pipeline.py:2699:        risk_window=_section_get(vol_adjust, \\\"window\\\"),\\nsrc/trend_analysis/pipeline.py:2788:    vol_adjust = _cfg_section(cfg, \\\"vol_adjust\\\")\\nsrc/trend_analysis/pipeline.py:2799:    trend_spec = _build_trend_spec(cfg, vol_adjust)\\nsrc/trend_analysis/pipeline.py:2810:        _resolve_target_vol(vol_adjust),\\nsrc/trend_analysis/pipeline.py:2812:        floor_vol=_section_get(vol_adjust, \\\"floor_vol\\\"),\\nsrc/trend_analysis/pipeline.py:2813:        warmup_periods=int(_section_get(vol_adjust, \\\"warmup_periods\\\", 0) or 0),\\nsrc/trend_analysis/pipeline.py:2827:        risk_window=_section_get(vol_adjust, \\\"window\\\"),\\nsrc/trend_analysis/engine/optimizer.py:20:    max_weight: float | None = None\\nsrc/trend_analysis/engine/optimizer.py:51:        raise ConstraintViolation(\\\"max_weight must be positive\\\")\\nsrc/trend_analysis/engine/optimizer.py:58:        raise ConstraintViolation(\\\"max_weight too small for number of assets\\\")\\nsrc/trend_analysis/engine/optimizer.py:154:        if constraints.max_weight is not None and len(working) > 0:\\nsrc/trend_analysis/engine/optimizer.py:156:            if eq_after - NUMERICAL_TOLERANCE_HIGH > constraints.max_weight:\\nsrc/trend_analysis/engine/optimizer.py:158:                    \\\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\\\"\\nsrc/trend_analysis/engine/optimizer.py:163:    if constraints.max_weight is not None:\\nsrc/trend_analysis/engine/optimizer.py:164:        working = _apply_cap(working, constraints.max_weight, total=total_allocation)\\nsrc/trend_analysis/engine/optimizer.py:181:        if constraints.max_weight is not None:\\nsrc/trend_analysis/engine/optimizer.py:183:                working, constraints.max_weight, total=total_allocation\\nsrc/trend_analysis/engine/optimizer.py:192:            constraints.max_weight is not None\\nsrc/trend_analysis/engine/optimizer.py:193:            and w.loc[\\\"CASH\\\"] > constraints.max_weight + NUMERICAL_TOLERANCE_HIGH\\nsrc/trend_analysis/engine/optimizer.py:195:            raise ConstraintViolation(\\\"cash_weight exceeds max_weight constraint\\\")\\nsrc/trend_analysis/engine/optimizer.py:213:        # Feasibility with max_weight: if max_weight is set ensure each non-cash asset\\nsrc/trend_analysis/engine/optimizer.py:215:        if constraints.max_weight is not None:\\nsrc/trend_analysis/engine/optimizer.py:216:            cap = constraints.max_weight\\nsrc/trend_analysis/engine/optimizer.py:221:                    \\\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\\\"\\nsrc/trend_analysis/engine/optimizer.py:229:        # If max_weight applies to CASH as well enforce; else skip. We enforce for consistency.\\nsrc/trend_analysis/engine/optimizer.py:231:            constraints.max_weight is not None\\nsrc/trend_analysis/engine/optimizer.py:232:            and w.loc[\\\"CASH\\\"] > constraints.max_weight + NUMERICAL_TOLERANCE_HIGH\\nsrc/trend_analysis/engine/optimizer.py:234:            raise ConstraintViolation(\\\"cash_weight exceeds max_weight constraint\\\")\\nsrc/trend_analysis/engine/optimizer.py:255:        # Feasibility with max_weight: if max_weight is set ensure each non-cash asset\\nsrc/trend_analysis/engine/optimizer.py:257:        if constraints.max_weight is not None:\\nsrc/trend_analysis/engine/optimizer.py:258:            cap = constraints.max_weight\\nsrc/trend_analysis/engine/optimizer.py:263:                    \\\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\\\"\\nsrc/trend_analysis/engine/optimizer.py:271:        # If max_weight applies to CASH as well enforce; else skip. We enforce for consistency.\\nsrc/trend_analysis/engine/optimizer.py:273:            constraints.max_weight is not None\\nsrc/trend_analysis/engine/optimizer.py:274:            and w.loc[\\\"CASH\\\"] > constraints.max_weight + NUMERICAL_TOLERANCE_HIGH\\nsrc/trend_analysis/engine/optimizer.py:276:            raise ConstraintViolation(\\\"cash_weight exceeds max_weight constraint\\\")\\ntests/test_cli_trend_presets.py:30:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_cli_trend_presets.py:50:    assert signals[\\\"vol_adjust\\\"] is preset.spec.vol_adjust\\ntests/test_pipeline_branch_coverage.py:194:    def fake_compute_constrained_weights(\\ntests/test_pipeline_branch_coverage.py:203:        pipeline, \\\"compute_constrained_weights\\\", fake_compute_constrained_weights\\ntests/test_pipeline_branch_coverage.py:267:    def fake_compute_constrained_weights(\\ntests/test_pipeline_branch_coverage.py:298:        pipeline, \\\"compute_constrained_weights\\\", fake_compute_constrained_weights\\nsrc/trend_analysis/weights/robust_weighting.py:147:        max_weight: float = 1.0,\\nsrc/trend_analysis/weights/robust_weighting.py:160:            max_weight: Maximum weight constraint\\nsrc/trend_analysis/weights/robust_weighting.py:167:        self.max_weight = float(max_weight)\\nsrc/trend_analysis/weights/robust_weighting.py:242:            weights = np.clip(weights, self.min_weight, self.max_weight)\\nsrc/trend_analysis/presets.py:32:_DEFAULT_SPEC_VOL_ADJUST = _DEFAULT_TREND_SPEC.vol_adjust\\nsrc/trend_analysis/presets.py:123:    vol_adjust = bool(signals.get(\\\"vol_adjust\\\", False))\\nsrc/trend_analysis/presets.py:131:        vol_adjust=vol_adjust,\\nsrc/trend_analysis/presets.py:190:            \\\"vol_adjust\\\": spec.vol_adjust,\\nsrc/trend_analysis/presets.py:199:    def vol_adjust_defaults(self) -> dict[str, Any]:\\nsrc/trend_analysis/presets.py:202:        preset = self._config.get(\\\"vol_adjust\\\")\\nsrc/trend_analysis/presets.py:219:        vol_adjust_section = (\\nsrc/trend_analysis/presets.py:220:            self._config.get(\\\"vol_adjust\\\")\\nsrc/trend_analysis/presets.py:221:            if isinstance(self._config.get(\\\"vol_adjust\\\"), Mapping)\\nsrc/trend_analysis/presets.py:227:            if vol_adjust_section is not None:\\nsrc/trend_analysis/presets.py:228:                enabled = self.trend_spec.vol_adjust\\nsrc/trend_analysis/presets.py:229:            elif signals_cfg is not None and \\\"vol_adjust\\\" in signals_cfg:\\nsrc/trend_analysis/presets.py:230:                enabled = bool(signals_cfg.get(\\\"vol_adjust\\\"))\\nsrc/trend_analysis/presets.py:231:            elif self.trend_spec.vol_adjust != _DEFAULT_SPEC_VOL_ADJUST:\\nsrc/trend_analysis/presets.py:232:                enabled = self.trend_spec.vol_adjust\\nsrc/trend_analysis/presets.py:410:    vol_adjust_cfg = getattr(config, \\\"vol_adjust\\\", {})\\nsrc/trend_analysis/presets.py:411:    if isinstance(vol_adjust_cfg, MutableMapping):\\nsrc/trend_analysis/presets.py:412:        vol_adjust = vol_adjust_cfg\\nsrc/trend_analysis/presets.py:413:    elif isinstance(vol_adjust_cfg, Mapping):\\nsrc/trend_analysis/presets.py:414:        vol_adjust = dict(vol_adjust_cfg)\\nsrc/trend_analysis/presets.py:416:        vol_adjust = {}\\nsrc/trend_analysis/presets.py:418:    defaults = preset.vol_adjust_defaults()\\nsrc/trend_analysis/presets.py:419:    vol_adjust.update({k: v for k, v in defaults.items() if v is not None})\\nsrc/trend_analysis/presets.py:420:    setattr(config, \\\"vol_adjust\\\", vol_adjust)\\nsrc/trend/reporting/unified.py:369:    scaling = \\\"Vol-adjusted\\\" if spec.vol_adjust else \\\"Raw\\\"\\nsrc/trend/reporting/unified.py:372:    if spec.vol_adjust and isinstance(target, (int, float)):\\nsrc/trend/reporting/unified.py:456:    vol_adj = _get(config, \\\"vol_adjust\\\", {})\\ntests/test_weighting_engines_extended.py:79:        max_weight=0.8,\\ntests/test_gui_app_simple.py:107:            store.cfg[\\\"use_vol_adjust\\\"] = True\\ntests/test_gui_app_simple.py:111:            assert store.cfg[\\\"use_vol_adjust\\\"] is True\\ntests/test_config_legacy_output_conversion.py:17:        \\\"vol_adjust\\\": {},\\ntests/test_config_legacy_output_conversion.py:45:        \\\"vol_adjust\\\": {},\\ntests/test_config_legacy_output_conversion.py:71:        \\\"vol_adjust\\\": {},\\ntests/test_config_legacy_output_conversion.py:95:        \\\"vol_adjust\\\": {},\\ntests/test_pipeline_run_cache_fallbacks.py:80:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_pipeline_run_cache_fallbacks.py:131:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_pipeline_run_cache_fallbacks.py:324:def test_build_trend_spec_uses_vol_adjust_default() -> None:\\ntests/test_pipeline_run_cache_fallbacks.py:325:    cfg = {\\\"signals\\\": {\\\"vol_adjust\\\": True}}\\ntests/test_pipeline_run_cache_fallbacks.py:328:    assert spec.vol_adjust is True\\ntests/test_pipeline_run_cache_fallbacks.py:458:    def fake_compute_constrained_weights(*_args, **_kwargs):  # noqa: ANN001\\ntests/test_pipeline_run_cache_fallbacks.py:472:        pipeline, \\\"compute_constrained_weights\\\", fake_compute_constrained_weights\\ntests/test_pipeline_run_cache_fallbacks.py:533:    def fake_compute_constrained_weights(*_args, **_kwargs):\\ntests/test_pipeline_run_cache_fallbacks.py:545:        pipeline, \\\"compute_constrained_weights\\\", fake_compute_constrained_weights\\ntests/test_pipeline_run_cache_fallbacks.py:562:        constraints={\\\"max_weight\\\": \\\"oops\\\"},\\ntests/test_signal_presets_module.py:71:            vol_adjust=False,\\ntests/test_signal_presets_module.py:82:        \\\"vol_adjust\\\": False,\\ntests/test_signal_presets_module.py:91:        \\\"vol_adjust\\\": False,\\ntests/test_spec_loader.py:100:        signals={\\\"window\\\": 10, \\\"lag\\\": 1, \\\"vol_adjust\\\": True, \\\"vol_target\\\": 0.2},\\ntests/test_spec_loader.py:159:            \\\"vol_adjust\\\": False,\\ntests/test_spec_loader.py:163:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.15, \\\"floor_vol\\\": 0.05, \\\"warmup_periods\\\": 0},\\ntests/test_spec_loader.py:196:    assert spec.trend.vol_target is None  # Disabled by vol_adjust False\\ntests/test_cli_cache_stats.py:31:        vol_adjust={},\\ntests/test_multi_period_inception_filter.py:20:        self.vol_adjust: dict[str, Any] = {\\\"target_vol\\\": 1.0}\\ntests/test_multi_period_inception_filter.py:41:                \\\"max_weight\\\": 1.0,\\ntests/test_api_run_simulation_extra.py:22:        self.vol_adjust = {\\\"target_vol\\\": 1.0}\\ntests/test_config_validation.py:41:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_config_validation.py:82:        \\\"vol_adjust\\\",\\ntests/test_default_export.py:15:                \\\"vol_adjust: {target_vol: 1.0}\\\",\\ntests/test_cli_cache_stats_disabled.py:32:        vol_adjust={},\\nsrc/trend_model/spec.py:153:    vol_adjust = bool(_section_get(signals, \\\"vol_adjust\\\", False))\\nsrc/trend_model/spec.py:155:    if not vol_adjust:\\nsrc/trend_model/spec.py:166:        vol_adjust=vol_adjust,\\nsrc/trend_model/spec.py:175:    vol_adjust = _cfg_section(cfg, \\\"vol_adjust\\\")\\nsrc/trend_model/spec.py:244:        target_vol=_coerce_float(_section_get(vol_adjust, \\\"target_vol\\\")),\\nsrc/trend_model/spec.py:245:        floor_vol=_coerce_float(_section_get(vol_adjust, \\\"floor_vol\\\")),\\nsrc/trend_model/spec.py:247:            _section_get(vol_adjust, \\\"warmup_periods\\\", 0), default=0\\ntests/test_signals_validation.py:37:def test_compute_trend_signals_vol_adjust_without_target() -> None:\\ntests/test_signals_validation.py:45:    spec = TrendSpec(window=3, vol_adjust=True, vol_target=None)\\ntests/test_signals_validation.py:51:    assert result.attrs[\\\"spec\\\"][\\\"vol_adjust\\\"] is True\\ntests/test_app_coverage.py:974:        \\\"vol_adjust\\\",\\ntests/test_app_coverage.py:1420:    assert store.cfg[\\\"use_vol_adjust\\\"] is True\\ntests/test_constants.py:69:                \\\"vol_adjust: {target_vol: 1.0}\\\",\\ntests/test_trend_config_model_negative_paths.py:209:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 1.0},\\ntests/test_trend_config_model_negative_paths.py:248:    assert \\\"vol_adjust.target_vol must be greater than zero\\\" in str(exc.value)\\ntests/test_trend_config_model_negative_paths.py:267:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model_negative_paths.py:338:    assert \\\"vol_adjust.floor_vol cannot be negative\\\" in str(exc.value)\\ntests/test_multi_period_engine_branch_coverage.py:44:                \\\"max_weight\\\": 0.6,\\ntests/test_multi_period_engine_branch_coverage.py:51:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_branch_coverage.py:60:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_multi_period_engine_branch_coverage.py:129:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_branch_coverage.py:141:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_streamlit_smoke_ci.py:82:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_multi_period_engine_branch_completion.py:60:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_multi_period_engine_branch_completion.py:84:                \\\"max_weight\\\": 0.6,\\ntests/test_multi_period_engine_branch_completion.py:90:                \\\"max_weight\\\": 0.6,\\ntests/test_multi_period_engine_branch_completion.py:96:        vol_adjust={\\\"target_vol\\\": 1.0, \\\"window\\\": 12},\\ntests/test_cli.py:55:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.15},\\ntests/test_cli.py:81:        captured[\\\"vol_adjust\\\"] = getattr(cfg_obj, \\\"vol_adjust\\\", {})\\ntests/test_cli.py:121:    assert signals[\\\"vol_adjust\\\"] is True\\ntests/test_cli.py:124:    vol_adjust = captured[\\\"vol_adjust\\\"]\\ntests/test_cli.py:125:    assert isinstance(vol_adjust, dict)\\ntests/test_cli.py:126:    assert vol_adjust[\\\"window\\\"][\\\"length\\\"] == 126\\ntests/test_cli.py:219:        vol_adjust={},\\ntests/test_cli.py:248:        vol_adjust={},\\ntests/test_cli.py:360:        vol_adjust={},\\ntests/test_cli.py:473:        vol_adjust={},\\ntests/test_cli.py:573:        vol_adjust={},\\ntests/test_multi_period_rebalancer.py:186:            \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_multi_period_sticky_periods.py:45:                \\\"max_weight\\\": 1.0,\\ntests/test_multi_period_sticky_periods.py:51:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_sticky_periods.py:60:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_trend_presets.py:39:    cfg = SimpleNamespace(vol_adjust={}, run={}, signals={})\\ntests/test_trend_presets.py:44:    assert cfg.signals[\\\"vol_adjust\\\"] is True\\ntests/test_trend_presets.py:46:    assert cfg.vol_adjust[\\\"window\\\"][\\\"length\\\"] == preset.trend_spec.window\\ntests/test_trend_presets.py:69:          vol_adjust: false\\ntests/test_pipeline_integration_direct.py:31:        \\\"vol_adjust\\\": {\\\"enabled\\\": True, \\\"target_vol\\\": 1.0},\\ntests/test_pipeline_integration_direct.py:54:                \\\"max_weight\\\": 0.6,\\ntests/test_threshold_hold_alignment.py:32:        {\\\"max_funds\\\": 4, \\\"min_weight\\\": 0.05, \\\"max_weight\\\": 0.6, \\\"min_weight_strikes\\\": 1}\\ntests/test_config_models_additional.py:25:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_config_models_additional.py:270:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_api_run_simulation.py:44:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_api_run_simulation.py:82:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_volatility_settings_wiring.py:44:                \\\"max_weight\\\": 0.8,\\ntests/test_volatility_settings_wiring.py:50:    vol_adjust: dict[str, object] = field(\\ntests/test_volatility_settings_wiring.py:66:            \\\"vol_adjust\\\": dict(self.vol_adjust),\\ntests/test_volatility_settings_wiring.py:110:def test_vol_adjust_enabled_changes_scaling() -> None:\\ntests/test_volatility_settings_wiring.py:113:    cfg.vol_adjust[\\\"enabled\\\"] = False\\ntests/test_volatility_settings_wiring.py:121:    cfg.vol_adjust[\\\"window\\\"] = {\\\"length\\\": 6, \\\"decay\\\": \\\"simple\\\", \\\"lambda\\\": 0.94}\\ntests/test_volatility_settings_wiring.py:123:    cfg.vol_adjust[\\\"window\\\"] = {\\\"length\\\": 3, \\\"decay\\\": \\\"simple\\\", \\\"lambda\\\": 0.94}\\ntests/test_volatility_settings_wiring.py:130:    cfg.vol_adjust[\\\"window\\\"] = {\\\"length\\\": 6, \\\"decay\\\": \\\"ewma\\\", \\\"lambda\\\": 0.9}\\ntests/test_volatility_settings_wiring.py:132:    cfg.vol_adjust[\\\"window\\\"] = {\\\"length\\\": 3, \\\"decay\\\": \\\"ewma\\\", \\\"lambda\\\": 0.9}\\ntests/test_volatility_settings_wiring.py:139:    cfg.vol_adjust[\\\"window\\\"] = {\\\"length\\\": 6, \\\"decay\\\": \\\"ewma\\\", \\\"lambda\\\": 0.9}\\ntests/test_volatility_settings_wiring.py:141:    cfg.vol_adjust[\\\"window\\\"] = {\\\"length\\\": 6, \\\"decay\\\": \\\"simple\\\", \\\"lambda\\\": 0.9}\\ntests/test_volatility_settings_wiring.py:148:    cfg.vol_adjust[\\\"window\\\"] = {\\\"length\\\": 6, \\\"decay\\\": \\\"ewma\\\", \\\"lambda\\\": 0.9}\\ntests/test_volatility_settings_wiring.py:150:    cfg.vol_adjust[\\\"window\\\"] = {\\\"length\\\": 6, \\\"decay\\\": \\\"ewma\\\", \\\"lambda\\\": 0.6}\\ntests/test_config_model_branch_coverage.py:37:        \\\"vol_adjust\\\": _risk_settings(),\\ntests/test_multi_period_engine_incremental_fallback.py:35:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_incremental_fallback.py:47:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_pipeline_entrypoints.py:61:        \\\"vol_adjust\\\": {},\\ntests/test_presets_extended.py:40:                \\\"vol_adjust\\\": \\\"yes\\\",\\ntests/test_presets_extended.py:51:    assert spec.vol_adjust is True\\ntests/test_presets_extended.py:58:        window=20, min_periods=10, vol_adjust=True, vol_target=0.2, zscore=True\\ntests/test_presets_extended.py:68:        \\\"signals\\\": {\\\"vol_adjust\\\": False},\\ntests/test_presets_extended.py:69:        \\\"vol_adjust\\\": {\\\"enabled\\\": None, \\\"target_vol\\\": None},\\ntests/test_presets_extended.py:112:    spec = TrendSpec(window=15, vol_adjust=False)\\ntests/test_presets_extended.py:120:    cfg = SimpleNamespace(signals={\\\"window\\\": 5}, vol_adjust=(\\\"ignored\\\",), run={})\\ntests/test_presets_extended.py:123:    assert cfg.vol_adjust[\\\"enabled\\\"] is True\\ntests/test_presets_extended.py:127:def test_vol_adjust_defaults_handles_signal_overrides() -> None:\\ntests/test_presets_extended.py:128:    spec = TrendSpec(window=40, vol_adjust=False)\\ntests/test_presets_extended.py:130:        \\\"signals\\\": {\\\"vol_adjust\\\": True},\\ntests/test_presets_extended.py:139:    defaults = preset.vol_adjust_defaults()\\ntests/test_presets_extended.py:147:def test_vol_adjust_defaults_copies_window_mapping() -> None:\\ntests/test_presets_extended.py:148:    spec = TrendSpec(window=20, vol_adjust=True, vol_target=0.5)\\ntests/test_presets_extended.py:152:        \\\"vol_adjust\\\": MappingProxyType(\\ntests/test_presets_extended.py:166:    defaults = preset.vol_adjust_defaults()\\ntests/test_presets_extended.py:174:def test_vol_adjust_defaults_uses_spec_when_no_signals() -> None:\\ntests/test_presets_extended.py:175:    spec = TrendSpec(window=15, vol_adjust=True)\\ntests/test_presets_extended.py:183:    defaults = preset.vol_adjust_defaults()\\ntests/test_presets_extended.py:317:    spec = TrendSpec(window=30, vol_adjust=True, vol_target=0.3)\\ntests/test_presets_extended.py:323:        _config=presets._freeze_mapping({\\\"vol_adjust\\\": {\\\"enabled\\\": True}}),\\ntests/test_presets_extended.py:329:        vol_adjust=MappingProxyType({\\\"enabled\\\": False}),\\ntests/test_presets_extended.py:334:    assert cfg.vol_adjust[\\\"enabled\\\"] is True\\ntests/test_presets_extended.py:347:    cfg = SimpleNamespace(signals=None, vol_adjust=\\\"skip\\\", run=None)\\ntests/test_presets_extended.py:350:    assert cfg.vol_adjust[\\\"enabled\\\"] is True\\ntests/test_config_human_errors.py:85:    def test_vol_adjust_as_number(self):\\ntests/test_config_human_errors.py:86:        \\\"\\\"\\\"Test vol_adjust section as number instead of dict.\\\"\\\"\\\"\\ntests/test_config_human_errors.py:87:        cfg = {\\\"version\\\": \\\"1.0\\\", \\\"data\\\": {}, \\\"vol_adjust\\\": 42}\\ntests/test_config_human_errors.py:90:            match=\\\"vol_adjust must be a dictionary\\\",\\ntests/test_config_human_errors.py:108:            \\\"vol_adjust\\\",\\ntests/test_config_human_errors.py:156:        vol_adjust: {}\\ntests/test_run_analysis_cli_default.py:15:                \\\"vol_adjust: {target_vol: 1.0}\\\",\\ntests/test_cli_no_structured_log.py:32:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 1.0},\\ntests/test_multi_period_engine_extended.py:55:        self.vol_adjust: Dict[str, Any] = {\\\"target_vol\\\": 1.0}\\ntests/test_multi_period_engine_turnover_extended.py:153:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_turnover_extended.py:169:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_config_models_fallback_loader.py:84:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 1.0},\\ntests/test_config_models_fallback_loader.py:90:    assert set(validated.keys()) >= {\\\"data\\\", \\\"portfolio\\\", \\\"vol_adjust\\\"}\\ntests/test_config_models_fallback_loader.py:136:        \\\"vol_adjust\\\": {},\\ntests/test_config_models_fallback_loader.py:191:        \\\"vol_adjust\\\": {},\\ntests/test_risk_free_default_alignment.py:41:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_risk_free_default_alignment.py:50:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_risk_free_default_alignment.py:67:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_risk_free_default_alignment.py:238:            \\\"vol_adjust\\\": {\\\"target_vol\\\": 1.0},\\ntests/test_config_models.py:11:# Required keys are version, data, preprocessing, vol_adjust, sample_split,\\ntests/test_config_models.py:24:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_config_models.py:47:        \\\"vol_adjust\\\",\\ntests/test_multi_period_exits_cooldown.py:20:        self.vol_adjust: dict[str, Any] = {\\\"target_vol\\\": 1.0}\\ntests/test_multi_period_exits_cooldown.py:42:                \\\"max_weight\\\": 1.0,\\ntests/test_multi_period_engine_incremental_cov.py:29:        self.vol_adjust: dict[str, float] = {\\\"target_vol\\\": 1.0}\\ntests/test_optimizer_constraints_additional.py:77:    constraints = ConstraintSet(cash_weight=0.25, max_weight=0.6)\\ntests/test_optimizer_constraints_additional.py:85:    # The residual capital should respect the max_weight constraint and maintain order.\\ntests/test_optimizer_constraints_additional.py:107:    # group cap.  ``max_weight`` must be reapplied to keep the non-capped assets\\ntests/test_optimizer_constraints_additional.py:111:        max_weight=0.35,\\ntests/test_optimizer_constraints_additional.py:134:def test_apply_constraints_group_caps_and_cash_respect_max_weight() -> None:\\ntests/test_optimizer_constraints_additional.py:136:    ``max_weight``.\\\"\\\"\\\"\\ntests/test_optimizer_constraints_additional.py:141:        \\\"max_weight\\\": 0.35,\\ntests/test_optimizer_constraints_additional.py:154:    \\\"\\\"\\\"If the remaining allocation breaches ``max_weight`` feasibility, raise\\ntests/test_optimizer_constraints_additional.py:161:        match=\\\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\\\",\\ntests/test_optimizer_constraints_additional.py:163:        apply_constraints(weights, ConstraintSet(cash_weight=0.5, max_weight=0.2))\\ntests/test_optimizer_constraints_additional.py:166:def test_apply_constraints_cash_slice_respects_max_weight_cap() -> None:\\ntests/test_optimizer_constraints_additional.py:167:    \\\"\\\"\\\"The dedicated CASH slice must honour ``max_weight`` once\\ntests/test_optimizer_constraints_additional.py:174:        match=\\\"cash_weight exceeds max_weight constraint\\\",\\ntests/test_optimizer_constraints_additional.py:176:        apply_constraints(weights, ConstraintSet(cash_weight=0.6, max_weight=0.5))\\ntests/test_optimizer_constraints_additional.py:188:        max_weight=0.4,\\ntests/test_optimizer_constraints_additional.py:226:        self.max_weight = kwargs.get(\\\"max_weight\\\")\\ntests/test_optimizer_constraints_additional.py:257:    constraints = _DynamicConstraintSet([0.5, 0.1], max_weight=0.3)\\ntests/test_optimizer_constraints_additional.py:261:        match=\\\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\\\",\\ntests/test_optimizer_constraints_additional.py:272:    constraints = _DynamicConstraintSet([0.2, 0.6], max_weight=0.5)\\ntests/test_optimizer_constraints_additional.py:274:    with pytest.raises(ConstraintViolation, match=\\\"cash_weight exceeds max_weight\\\"):\\ntests/test_optimizer_constraints_additional.py:308:            'if eq_after - NUMERICAL_TOLERANCE_HIGH > cap:\\\\n    raise ConstraintViolation(\\\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\\\")',\\ntests/test_optimizer_constraints_additional.py:319:            'raise ConstraintViolation(\\\"cash_weight exceeds max_weight constraint\\\")',\\ntests/test_optimizer_constraints_additional.py:349:            'if eq_after - NUMERICAL_TOLERANCE_HIGH > cap:\\\\n    raise ConstraintViolation(\\\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\\\")',\\ntests/test_optimizer_constraints_additional.py:360:            'raise ConstraintViolation(\\\"cash_weight exceeds max_weight constraint\\\")',\\ntests/test_config_models_coverage_extensions.py:53:        \\\"vol_adjust\\\": {},\\ntests/test_trend_cli.py:65:        vol_adjust={\\\"target_vol\\\": 0.15},\\ntests/test_trend_cli.py:190:        vol_adjust={},\\ntests/test_trend_cli.py:224:        vol_adjust={},\\ntests/test_trend_cli.py:264:        vol_adjust={},\\ntests/test_multi_period_engine_additional.py:101:        self.vol_adjust = {\\\"target_vol\\\": 1.0}\\ntests/test_multi_period_engine_additional.py:438:                        \\\"max_weight\\\": 0.6,\\ntests/test_multi_period_engine_additional.py:616:                        \\\"max_weight\\\": 0.6,\\ntests/test_multi_period_engine_additional.py:742:                        \\\"max_weight\\\": 0.99,\\ntests/test_multi_period_engine_additional.py:879:                        \\\"max_weight\\\": 0.6,\\ntests/test_multi_period_engine_additional.py:1151:            \\\"constraints\\\": {\\\"min_weight\\\": 0.2, \\\"max_weight\\\": 0.6, \\\"max_funds\\\": 3},\\ntests/trend_analysis/test_signal_presets_module.py:61:        \\\"vol_adjust\\\": True,\\ntests/trend_analysis/test_signal_presets_module.py:73:        vol_adjust=False,\\ntests/trend_analysis/test_signal_presets_module.py:83:        \\\"vol_adjust\\\": False,\\ntests/trend_analysis/test_signal_presets_module.py:93:        vol_adjust=True,\\ntests/trend_analysis/test_signal_presets_module.py:103:        \\\"vol_adjust\\\": True,\\ntests/test_optimizer_constraints_guardrails.py:36:def test_apply_constraints_reapplies_max_weight_after_group_caps() -> None:\\ntests/test_optimizer_constraints_guardrails.py:39:        max_weight=0.5,\\ntests/test_optimizer_constraints_guardrails.py:61:def test_apply_constraints_detects_cash_weight_infeasible_against_max_weight() -> None:\\ntests/test_optimizer_constraints_guardrails.py:66:        match=\\\"cash_weight infeasible: remaining allocation forces per-asset weight above max_weight\\\",\\ntests/test_optimizer_constraints_guardrails.py:68:        apply_constraints(weights, ConstraintSet(max_weight=0.3, cash_weight=0.25))\\ntests/test_optimizer_constraints_guardrails.py:75:        ConstraintViolation, match=\\\"cash_weight exceeds max_weight constraint\\\"\\ntests/test_optimizer_constraints_guardrails.py:77:        apply_constraints(weights, ConstraintSet(max_weight=0.45, cash_weight=0.5))\\ntests/test_optimizer_constraints_guardrails.py:82:    constraints = ConstraintSet(max_weight=0.4, cash_weight=0.25)\\ntests/test_optimizer_constraints_guardrails.py:122:    adjusted = apply_constraints(weights, {\\\"cash_weight\\\": 0.25, \\\"max_weight\\\": 0.45})\\ntests/test_optimizer_constraints_guardrails.py:137:        weights, ConstraintSet(max_weight=0.6, cash_weight=0.2)\\ntests/test_pipeline_optional_features.py:262:        \\\"max_weight\\\": 1.0,\\ntests/test_pipeline_optional_features.py:609:        constraints={\\\"max_weight\\\": 0.5},\\ntests/test_pipeline_optional_features.py:646:        constraints={\\\"max_weight\\\": 0.8},\\ntests/test_pipeline_optional_features.py:681:        constraints={\\\"max_weight\\\": 0.4},\\ntests/trend_analysis/test_presets.py:33:        \\\"vol_adjust\\\": {\\\"window\\\": {\\\"length\\\": 21}},\\ntests/trend_analysis/test_presets.py:98:    assert spec.vol_adjust is False\\ntests/trend_analysis/test_presets.py:150:def test_trend_preset_signals_and_vol_adjust_defaults(\\ntests/trend_analysis/test_presets.py:156:    defaults = sample_preset.vol_adjust_defaults()\\ntests/trend_analysis/test_presets.py:167:def test_vol_adjust_defaults_preserves_existing_target(sample_config: dict[str, Any]):\\ntests/trend_analysis/test_presets.py:169:    custom[\\\"vol_adjust\\\"] = {\\\"target_vol\\\": 0.2}\\ntests/trend_analysis/test_presets.py:177:    defaults = preset.vol_adjust_defaults()\\ntests/trend_analysis/test_presets.py:181:def test_vol_adjust_defaults_respects_existing_enabled_flag(\\ntests/trend_analysis/test_presets.py:187:    custom[\\\"vol_adjust\\\"] = {\\\"enabled\\\": True, \\\"window\\\": MappingProxyType({\\\"length\\\": 5})}\\ntests/trend_analysis/test_presets.py:195:    defaults = preset.vol_adjust_defaults()\\ntests/trend_analysis/test_presets.py:201:def test_vol_adjust_defaults_handles_non_mapping_source(sample_config: dict[str, Any]):\\ntests/trend_analysis/test_presets.py:203:    custom[\\\"vol_adjust\\\"] = \\\"disabled\\\"\\ntests/trend_analysis/test_presets.py:211:    defaults = preset.vol_adjust_defaults()\\ntests/trend_analysis/test_presets.py:264:  vol_adjust: true\\ntests/trend_analysis/test_presets.py:319:            self.vol_adjust = {\\\"enabled\\\": True, \\\"extra\\\": \\\"keep\\\"}\\ntests/trend_analysis/test_presets.py:327:    assert config.vol_adjust[\\\"enabled\\\"] is False\\ntests/trend_analysis/test_presets.py:328:    assert config.vol_adjust[\\\"target_vol\\\"] == pytest.approx(0.7)\\ntests/trend_analysis/test_presets.py:329:    assert config.vol_adjust[\\\"extra\\\"] == \\\"keep\\\"\\ntests/trend_analysis/test_presets.py:339:            self.vol_adjust = \\\"disabled\\\"\\ntests/trend_analysis/test_presets.py:347:    assert config.vol_adjust[\\\"enabled\\\"] is False\\ntests/trend_analysis/test_presets.py:359:            self.vol_adjust = MappingProxyType({\\\"enabled\\\": True})\\ntests/trend_analysis/test_presets.py:366:    assert config.vol_adjust[\\\"enabled\\\"] is sample_preset.trend_spec.vol_adjust\\ntests/test_multi_period_engine_branch_new.py:20:        self.vol_adjust: dict[str, float] = {\\\"target_vol\\\": 1.0}\\ntests/test_multi_period_engine_branch_new.py:36:            \\\"vol_adjust\\\": dict(self.vol_adjust),\\ntests/test_multi_period_engine_missing_policy.py:33:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_missing_policy.py:42:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_api_signal_settings.py:35:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_api_signal_settings.py:64:            \\\"trend_vol_adjust\\\": False,\\ntests/test_api_signal_settings.py:73:            \\\"trend_vol_adjust\\\": False,\\ntests/test_api_signal_settings.py:100:            \\\"trend_vol_adjust\\\": False,\\ntests/test_api_signal_settings.py:109:            \\\"trend_vol_adjust\\\": False,\\ntests/test_risk_additional.py:47:def test_compute_constrained_weights_applies_controls(monkeypatch):\\ntests/test_risk_additional.py:67:    result, diagnostics = risk.compute_constrained_weights(\\ntests/test_risk_additional.py:75:        max_weight=0.7,\\ntests/test_risk_additional.py:88:    assert payload_capture[\\\"payload\\\"][\\\"max_weight\\\"] == 0.7\\ntests/test_risk_additional.py:95:def test_compute_constrained_weights_handles_non_datetime_index(monkeypatch):\\ntests/test_risk_additional.py:108:    result, diagnostics = risk.compute_constrained_weights(\\ntests/test_risk_additional.py:116:        max_weight=None,\\ntests/test_risk_additional.py:127:def test_compute_constrained_weights_skips_scaling_when_disabled(monkeypatch):\\ntests/test_risk_additional.py:144:    disabled, diag_disabled = risk.compute_constrained_weights(\\ntests/test_risk_additional.py:152:        max_weight=None,\\ntests/test_risk_additional.py:154:    enabled, _ = risk.compute_constrained_weights(\\ntests/test_risk_additional.py:162:        max_weight=None,\\ntests/test_risk_additional.py:172:def test_compute_constrained_weights_window_length_changes_scaling(monkeypatch):\\ntests/test_risk_additional.py:190:    _, diag_short = risk.compute_constrained_weights(\\ntests/test_risk_additional.py:198:        max_weight=None,\\ntests/test_risk_additional.py:200:    _, diag_long = risk.compute_constrained_weights(\\ntests/test_risk_additional.py:208:        max_weight=None,\\ntests/test_risk_additional.py:214:def test_compute_constrained_weights_decay_changes_scaling(monkeypatch):\\ntests/test_risk_additional.py:232:    _, diag_simple = risk.compute_constrained_weights(\\ntests/test_risk_additional.py:240:        max_weight=None,\\ntests/test_risk_additional.py:242:    _, diag_ewma = risk.compute_constrained_weights(\\ntests/test_risk_additional.py:250:        max_weight=None,\\ntests/test_risk_additional.py:256:def test_compute_constrained_weights_ewma_lambda_changes_scaling(monkeypatch):\\ntests/test_risk_additional.py:274:    _, diag_fast = risk.compute_constrained_weights(\\ntests/test_risk_additional.py:282:        max_weight=None,\\ntests/test_risk_additional.py:284:    _, diag_slow = risk.compute_constrained_weights(\\ntests/test_risk_additional.py:292:        max_weight=None,\\ntests/test_risk_additional.py:298:def test_compute_constrained_weights_validates_inputs(monkeypatch):\\ntests/test_risk_additional.py:302:        risk.compute_constrained_weights(\\ntests/test_risk_additional.py:310:            max_weight=None,\\ntests/test_risk_additional.py:314:        risk.compute_constrained_weights(\\ntests/test_risk_additional.py:322:            max_weight=None,\\ntests/test_run_multi_analysis_cli.py:15:                \\\"vol_adjust: {target_vol: 1.0}\\\",\\ntests/test_pipeline.py:31:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 1.0},\\ntests/test_pipeline.py:257:        vol_adjust={},\\ntests/test_pipeline.py:444:        \\\"max_weight\\\": 0.55,\\ntests/test_pipeline.py:490:        constraints={\\\"max_weight\\\": 0.6},\\ntests/test_trend_config_model_additional.py:302:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_invariants.py:18:from trend_analysis.risk import RiskWindow, compute_constrained_weights\\ntests/test_invariants.py:52:def test_compute_constrained_weights_produces_finite_normalised_weights() -> None:\\ntests/test_invariants.py:58:    weights, diagnostics = compute_constrained_weights(\\ntests/test_invariants.py:66:        max_weight=0.7,\\ntests/test_signal_presets_regressions.py:40:            vol_adjust=True,\\ntests/test_run_analysis_cli_export.py:15:                \\\"vol_adjust: {target_vol: 1.0}\\\",\\ntests/test_multi_period_engine_keepalive.py:46:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_keepalive.py:56:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_multi_period_engine_keepalive.py:262:        \\\"constraints\\\": {\\\"max_funds\\\": 2, \\\"min_weight\\\": 0.05, \\\"max_weight\\\": 0.9},\\ntests/soft_coverage/test_signal_presets_soft.py:50:        \\\"vol_adjust\\\": True,\\ntests/soft_coverage/test_signal_presets_soft.py:59:        window=21, min_periods=None, lag=2, vol_adjust=False, vol_target=None\\ntests/soft_coverage/test_signal_presets_soft.py:71:        \\\"vol_adjust\\\": False,\\ntests/soft_coverage/test_signal_presets_soft.py:80:        \\\"vol_adjust\\\": False,\\ntests/test_config_models_fallback_unit.py:61:        \\\"vol_adjust\\\": {},\\ntests/test_config_models_fallback_unit.py:140:            vol_adjust={},\\ntests/test_gui.py:70:        \\\"vol_adjust\\\": {},\\ntests/test_constraint_optimizer.py:9:def test_long_only_and_max_weight():\\ntests/test_constraint_optimizer.py:11:    out = apply_constraints(w, {\\\"long_only\\\": True, \\\"max_weight\\\": 0.55})\\ntests/test_constraint_optimizer.py:21:        \\\"max_weight\\\": 0.6,\\ntests/test_constraint_optimizer.py:30:def test_infeasible_max_weight():\\ntests/test_constraint_optimizer.py:33:        apply_constraints(w, {\\\"max_weight\\\": 0.4})\\ntests/test_constraint_optimizer.py:73:def test_cash_weight_violates_max_weight_cap() -> None:\\ntests/test_constraint_optimizer.py:75:    constraints = {\\\"cash_weight\\\": 0.4, \\\"max_weight\\\": 0.3}\\ntests/test_constraint_optimizer.py:76:    with pytest.raises(ConstraintViolation, match=\\\"exceeds max_weight\\\"):\\ntests/test_constraint_optimizer.py:80:def test_cash_weight_exceeds_max_weight_limit() -> None:\\ntests/test_constraint_optimizer.py:82:    constraints = {\\\"cash_weight\\\": 0.6, \\\"max_weight\\\": 0.5}\\ntests/test_constraint_optimizer.py:83:    with pytest.raises(ConstraintViolation, match=\\\"cash_weight exceeds max_weight\\\"):\\ntests/test_trend_reporting_unified_helpers.py:111:        vol_adjust={\\\"target_vol\\\": 0.15, \\\"floor_vol\\\": 0.05, \\\"warmup_periods\\\": 3},\\ntests/test_trend_reporting_unified_helpers.py:127:        vol_adjust=True,\\ntests/test_trend_reporting_unified_helpers.py:369:        vol_adjust={\\\"floor_vol\\\": 0.02, \\\"warmup_periods\\\": 5},\\ntests/test_trend_reporting_unified_helpers.py:373:        trend_spec=SimpleNamespace(window=63, lag=1, vol_adjust=False, zscore=False),\\ntests/test_trend_reporting_unified_helpers.py:388:        sample_split=None, vol_adjust=None, portfolio=None, run=None, benchmarks=None\\ntests/test_cli_api_golden_master.py:43:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_config_fallback_minimal.py:28:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_multi_period_engine_price_frames.py:40:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_price_frames.py:49:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_trend_analysis_cli_main.py:29:        vol_adjust={},\\ntests/test_run_full.py:21:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_run_full.py:56:        vol_adjust={},\\ntests/test_run_full.py:72:        vol_adjust={},\\ntests/test_pipeline_constraints_integration.py:43:def test_pipeline_applies_cash_and_max_weight_constraints():\\ntests/test_pipeline_constraints_integration.py:57:            \\\"max_weight\\\": 0.4,\\ntests/test_pipeline_constraints_integration.py:72:def test_pipeline_max_weight_with_vol_adjust_enabled():\\ntests/test_pipeline_constraints_integration.py:88:            \\\"max_weight\\\": 0.35,\\ntests/test_weight_engines_pathological.py:235:            max_weight=1.0,\\ntests/test_multi_period_engine_threshold_bounds.py:47:                \\\"max_weight\\\": 0.55,\\ntests/test_multi_period_engine_threshold_bounds.py:54:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_threshold_bounds.py:63:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_multi_period_engine_price_frames_extra.py:26:        self.vol_adjust: dict[str, float] = {\\\"target_vol\\\": 1.0}\\ntests/test_config_model.py:533:            \\\"vol_adjust\\\": {\\ntests/test_config_model.py:544:        assert cfg.vol_adjust.target_vol == 0.2\\ntests/test_config_model.py:557:            \\\"vol_adjust\\\": {\\ntests/test_config_model.py:581:            \\\"vol_adjust\\\": {\\ntests/test_config_model.py:607:            \\\"vol_adjust\\\": {\\ntests/test_config_model.py:614:        with pytest.raises(ValueError, match=\\\"vol_adjust.target_vol\\\"):\\ntests/test_config_model.py:631:            vol_adjust:\\ntests/test_config_alignment.py:105:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1, \\\"floor_vol\\\": 0.0, \\\"warmup_periods\\\": 0},\\ntests/test_multi_period_engine_threshold_events_extended.py:45:                \\\"max_weight\\\": 0.6,\\ntests/test_multi_period_engine_threshold_events_extended.py:52:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_threshold_events_extended.py:62:            \\\"vol_adjust\\\": dict(self.vol_adjust),\\ntests/test_multi_period_engine_threshold_events_extended.py:95:                \\\"max_weight\\\": 0.35,\\ntests/test_multi_period_engine_threshold_events_extended.py:101:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_threshold_events_extended.py:111:            \\\"vol_adjust\\\": dict(self.vol_adjust),\\ntests/test_optimizer_branch_coverage.py:81:            optimizer.ConstraintSet(cash_weight=0.5, max_weight=0.2),\\ntests/test_optimizer_branch_coverage.py:108:            optimizer.ConstraintSet(cash_weight=0.2, max_weight=0.5),\\ntests/test_optimizer_branch_coverage.py:117:            optimizer.ConstraintSet(cash_weight=0.6, max_weight=0.5),\\ntests/test_unified_api_integration.py:43:            vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_config_model_validation.py:180:        \\\"vol_adjust\\\": {\\ntests/test_cli_no_cache_flag.py:27:        vol_adjust={},\\ntests/test_risk.py:12:    compute_constrained_weights,\\ntests/test_risk.py:36:def test_compute_constrained_weights_scales_and_constrains() -> None:\\ntests/test_risk.py:47:    weights, diagnostics = compute_constrained_weights(\\ntests/test_risk.py:55:        max_weight=0.6,\\ntests/test_risk.py:67:def test_compute_constrained_weights_respects_turnover_cap() -> None:\\ntests/test_risk.py:78:    weights, diagnostics = compute_constrained_weights(\\ntests/test_risk.py:86:        max_weight=0.8,\\ntests/test_risk.py:95:def test_compute_constrained_weights_lambda_penalty_reduces_turnover() -> None:\\ntests/test_risk.py:106:    _, diag_zero = compute_constrained_weights(\\ntests/test_risk.py:114:        max_weight=0.9,\\ntests/test_risk.py:119:    _, diag_high = compute_constrained_weights(\\ntests/test_risk.py:127:        max_weight=0.9,\\ntests/test_risk.py:136:def test_compute_constrained_weights_respects_max_weight_with_vol_adjust() -> None:\\ntests/test_risk.py:147:    weights, diagnostics = compute_constrained_weights(\\ntests/test_risk.py:155:        max_weight=0.35,\\ntests/test_risk.py:165:def test_compute_constrained_weights_caps_after_large_vol_scaling() -> None:\\ntests/test_risk.py:176:    weights, diagnostics = compute_constrained_weights(\\ntests/test_risk.py:184:        max_weight=0.35,\\ntests/test_risk.py:194:def test_compute_constrained_weights_enforces_max_weight_with_vol_adjust() -> None:\\ntests/test_risk.py:205:    weights, diagnostics = compute_constrained_weights(\\ntests/test_risk.py:213:        max_weight=0.35,\\ntests/test_risk.py:255:def test_compute_constrained_weights_validates_inputs() -> None:\\ntests/test_risk.py:257:        risk.compute_constrained_weights(\\ntests/test_risk.py:265:            max_weight=None,\\ntests/test_risk.py:268:        risk.compute_constrained_weights(\\ntests/test_risk.py:276:            max_weight=None,\\ntests/test_risk.py:282:        risk.compute_constrained_weights(\\ntests/test_risk.py:290:            max_weight=None,\\ntests/test_risk.py:294:def test_compute_constrained_weights_uses_dummy_turnover_index() -> None:\\ntests/test_risk.py:297:    weights, diagnostics = risk.compute_constrained_weights(\\ntests/test_risk.py:305:        max_weight=None,\\ntests/test_optimizer.py:15:        weights, optimizer.ConstraintSet(max_weight=0.6)\\ntests/test_optimizer.py:57:    constraints = optimizer.ConstraintSet(max_weight=0.45, cash_weight=0.4)\\ntests/test_optimizer.py:66:def test_apply_constraints_cash_weight_infeasible_with_max_weight() -> None:\\ntests/test_optimizer.py:68:    constraints = optimizer.ConstraintSet(max_weight=0.2, cash_weight=0.2)\\ntests/test_trend_analysis_presets.py:26:          vol_adjust: false\\ntests/test_trend_analysis_presets.py:32:        vol_adjust:\\ntests/test_trend_analysis_presets.py:98:                \\\"vol_adjust\\\": True,\\ntests/test_trend_analysis_presets.py:107:    assert spec.vol_adjust is True\\ntests/test_trend_analysis_presets.py:116:    assert spec.vol_adjust is False\\ntests/test_trend_analysis_presets.py:126:                \\\"vol_adjust\\\": True,\\ntests/test_trend_analysis_presets.py:146:                \\\"vol_adjust\\\": {\\\"enabled\\\": False, \\\"window\\\": {\\\"slow\\\": 63}},\\ntests/test_trend_analysis_presets.py:168:        \\\"vol_adjust\\\": True,\\ntests/test_trend_analysis_presets.py:174:    vol_adjust_defaults = preset.vol_adjust_defaults()\\ntests/test_trend_analysis_presets.py:175:    assert vol_adjust_defaults[\\\"enabled\\\"] is False\\ntests/test_trend_analysis_presets.py:176:    assert vol_adjust_defaults[\\\"target_vol\\\"] == pytest.approx(0.15)\\ntests/test_trend_analysis_presets.py:177:    assert vol_adjust_defaults[\\\"window\\\"][\\\"slow\\\"] == 63\\ntests/test_trend_analysis_presets.py:178:    assert vol_adjust_defaults[\\\"window\\\"][\\\"length\\\"] == 50\\ntests/test_trend_analysis_presets.py:179:    assert vol_adjust_defaults is not preset._config.get(\\\"vol_adjust\\\")\\ntests/test_trend_analysis_presets.py:195:    defaults = preset.vol_adjust_defaults()\\ntests/test_trend_analysis_presets.py:201:def test_vol_adjust_defaults_handles_read_only_window_mapping(\\ntests/test_trend_analysis_presets.py:205:        {\\\"signals\\\": {\\\"window\\\": 12, \\\"vol_adjust\\\": True, \\\"vol_target\\\": 0.2}}\\ntests/test_trend_analysis_presets.py:215:                \\\"vol_adjust\\\": {\\ntests/test_trend_analysis_presets.py:226:    defaults = preset.vol_adjust_defaults()\\ntests/test_trend_analysis_presets.py:231:def test_vol_adjust_defaults_respects_explicit_enabled_flag() -> None:\\ntests/test_trend_analysis_presets.py:236:        vol_adjust=True,\\ntests/test_trend_analysis_presets.py:247:                \\\"vol_adjust\\\": {\\ntests/test_trend_analysis_presets.py:256:    defaults = preset.vol_adjust_defaults()\\ntests/test_trend_analysis_presets.py:270:        vol_adjust={\\\"enabled\\\": False},\\ntests/test_trend_analysis_presets.py:278:    vol_defaults = preset.vol_adjust_defaults()\\ntests/test_trend_analysis_presets.py:285:    assert config.vol_adjust[\\\"enabled\\\"] is False\\ntests/test_trend_analysis_presets.py:342:  vol_adjust: true\\ntests/test_trend_analysis_presets.py:356:vol_adjust:\\ntests/test_trend_analysis_presets.py:394:    config = SimpleNamespace(signals={\\\"lag\\\": 9}, vol_adjust={}, run={})\\ntests/test_trend_analysis_presets.py:397:    assert config.signals[\\\"vol_adjust\\\"] is True\\ntests/test_trend_analysis_presets.py:398:    assert config.vol_adjust[\\\"enabled\\\"] is False\\ntests/test_trend_analysis_presets.py:399:    assert config.vol_adjust[\\\"target_vol\\\"] == pytest.approx(0.1)\\ntests/test_trend_analysis_presets.py:456:  vol_adjust: false\\ntests/test_trend_analysis_presets.py:468:        vol_adjust = ()\\ntests/test_trend_analysis_presets.py:474:    assert isinstance(config.vol_adjust, dict)\\ntests/test_pipeline_helpers_additional.py:137:def test_build_trend_spec_uses_vol_adjust_defaults() -> None:\\ntests/test_pipeline_helpers_additional.py:153:    # ``vol_adjust`` should fall back to the vol config default when unset.\\ntests/test_pipeline_helpers_additional.py:154:    assert spec.vol_adjust is True\\ntests/test_pipeline_helpers_additional.py:321:            \\\"vol_adjust\\\": True,\\ntests/test_pipeline_helpers_additional.py:337:            \\\"vol_adjust\\\": True,\\ntests/test_pipeline_helpers_additional.py:344:    cfg_missing_target = {\\\"signals\\\": {\\\"vol_adjust\\\": True}}\\ntests/test_pipeline_helpers_additional.py:613:        mp.setattr(pipeline, \\\"compute_constrained_weights\\\", boom_weights)\\ntests/test_pipeline_helpers_additional.py:637:            constraints={\\\"max_weight\\\": \\\"bad\\\"},\\ntests/test_pipeline_helpers_additional.py:647:                vol_adjust=False,\\ntests/test_pipeline_helpers_additional.py:707:        mp.setattr(pipeline, \\\"compute_constrained_weights\\\", fake_weights)\\ntests/test_pipeline_helpers_additional.py:727:                vol_adjust=False,\\ntests/test_pipeline_helpers_additional.py:781:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_pipeline_helpers_additional.py:841:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_pipeline_helpers_additional.py:1064:        mp.setattr(pipeline, \\\"compute_constrained_weights\\\", fake_weights)\\ntests/test_pipeline_helpers_additional.py:1099:                vol_adjust=False,\\ntests/test_pipeline_helpers_additional.py:1280:        mp.setattr(pipeline, \\\"compute_constrained_weights\\\", fake_weights)\\ntests/test_pipeline_helpers_additional.py:1392:        mp.setattr(pipeline, \\\"compute_constrained_weights\\\", fake_weights)\\ntests/test_pipeline_helpers_additional.py:1482:        mp.setattr(pipeline, \\\"compute_constrained_weights\\\", fake_weights)\\ntests/test_pipeline_helpers_additional.py:1568:        mp.setattr(pipeline, \\\"compute_constrained_weights\\\", fake_weights)\\ntests/test_pipeline_helpers_additional.py:1653:        mp.setattr(pipeline, \\\"compute_constrained_weights\\\", fake_weights)\\ntests/test_pipeline_helpers_additional.py:1716:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_pipeline_helpers_additional.py:1769:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_pipeline_helpers_additional.py:1824:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_pipeline_helpers_additional.py:1873:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_trend_config_model.py:29:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:95:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:127:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:147:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:172:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:198:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:221:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:244:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:286:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:311:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:334:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_trend_config_model.py:366:                \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_config_fallback_additional.py:78:        \\\"vol_adjust\\\",\\ntests/test_config_fallback_additional.py:129:            vol_adjust={},\\ntests/test_config_fallback_additional.py:180:            \\\"vol_adjust\\\": {},\\ntests/test_config_fallback_additional.py:217:            \\\"vol_adjust\\\": {},\\ntests/test_config_legacy.py:18:        \\\"vol_adjust\\\": {\\\"target_vol\\\": 0.1},\\ntests/test_multi_period_missing_policy_observability.py:40:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_missing_policy_observability.py:50:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_logging_integration.py:33:        vol_adjust={\\\"target_vol\\\": 1.0},\\ntests/test_multi_period_engine.py:149:        self.vol_adjust: dict[str, float] = {\\\"target_vol\\\": 1.0}\\ntests/test_robust_weighting_integration.py:58:        vol_adjust={\\\"enabled\\\": False},\\ntests/test_robust_weighting_integration.py:92:        vol_adjust={\\\"enabled\\\": False},\\ntests/test_signal_presets.py:25:    assert preset.spec.vol_adjust is True\\ntests/test_signal_presets.py:34:    assert config[\\\"vol_adjust\\\"] is True\\ntests/test_signal_presets.py:51:            vol_adjust=False,\\ntests/test_signal_presets.py:63:        \\\"vol_adjust\\\": False,\\ntests/test_signal_presets.py:76:            vol_adjust=True,\\ntests/test_signal_presets.py:88:        \\\"vol_adjust\\\": True,\\ntests/test_multi_period_engine_threshold_edgecases.py:46:                \\\"max_weight\\\": 0.8,\\ntests/test_multi_period_engine_threshold_edgecases.py:53:    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\\\"target_vol\\\": 1.0})\\ntests/test_multi_period_engine_threshold_edgecases.py:62:            \\\"vol_adjust\\\": self.vol_adjust,\\ntests/test_multi_period_engine_threshold_edgecases.py:199:        {\\\"max_funds\\\": 3, \\\"min_weight\\\": 0.05, \\\"max_weight\\\": 0.8, \\\"min_weight_strikes\\\": 2}\\ntests/test_multi_period_engine_threshold_edgecases.py:338:        {\\\"max_funds\\\": 2, \\\"min_weight\\\": 0.0, \\\"max_weight\\\": 1.0, \\\"min_weight_strikes\\\": 2}\\ntests/test_multi_period_engine_threshold_edgecases.py:429:        {\\\"max_funds\\\": 2, \\\"min_weight\\\": 0.0, \\\"max_weight\\\": 1.0, \\\"min_weight_strikes\\\": 2}\\ntests/test_multi_period_engine_threshold_edgecases.py:720:            \\\"max_weight\\\": 0.6,\\ntests/test_multi_period_engine_threshold_edgecases.py:936:            \\\"max_weight\\\": 0.6,\\ntests/test_multi_period_engine_threshold_edgecases.py:1040:            \\\"max_weight\\\": 0.3,\\ntests/test_api_run_simulation_branches.py:30:        \\\"vol_adjust\\\": {},\\ntests/test_api_run_simulation_branches.py:65:        vol_adjust={\\\"target_vol\\\": 1.5},\\ntests/app/test_guardrails_component.py:102:        return None, \\\"vol_adjust -> target_vol\\\\n must be greater than zero\\\"\\ntests/app/test_guardrails_component.py:116:    assert \\\"vol_adjust\\\" in errors[0]\\ntests/test_trend_analysis_presets_additional.py:48:      vol_adjust: true\\ntests/test_trend_analysis_presets_additional.py:51:    vol_adjust:\\ntests/test_trend_analysis_presets_additional.py:71:    vol_adjust:\\ntests/test_trend_analysis_presets_additional.py:135:        \\\"vol_adjust\\\": False,\\ntests/test_trend_analysis_presets_additional.py:139:    vol_defaults = preset.vol_adjust_defaults()\\ntests/test_trend_analysis_presets_additional.py:160:            self.vol_adjust = {\\\"enabled\\\": True, \\\"window\\\": {\\\"legacy\\\": 20}}\\ntests/test_trend_analysis_presets_additional.py:167:    assert config.signals[\\\"vol_adjust\\\"] is False\\ntests/test_trend_analysis_presets_additional.py:168:    assert config.vol_adjust[\\\"enabled\\\"] is False\\ntests/test_trend_analysis_presets_additional.py:169:    assert config.vol_adjust[\\\"target_vol\\\"] == 0.25\\ntests/test_trend_analysis_presets_additional.py:170:    assert config.vol_adjust[\\\"window\\\"] == {\\\"short\\\": 12, \\\"long\\\": 63, \\\"length\\\": 75}\\ntests/test_trend_analysis_presets_additional.py:209:def test_vol_adjust_defaults_uses_trend_spec_when_section_missing() -> None:\\ntests/test_trend_analysis_presets_additional.py:214:        trend_spec=presets.TrendSpec(window=45, vol_adjust=True, vol_target=0.4),\\ntests/test_trend_analysis_presets_additional.py:218:    defaults = preset.vol_adjust_defaults()\\ntests/test_trend_analysis_presets_additional.py:225:def test_vol_adjust_defaults_prefers_config_section_over_signals() -> None:\\ntests/test_trend_analysis_presets_additional.py:230:        trend_spec=presets.TrendSpec(window=80, vol_adjust=False, vol_target=0.3),\\ntests/test_trend_analysis_presets_additional.py:232:            \\\"signals\\\": {\\\"vol_adjust\\\": True},\\ntests/test_trend_analysis_presets_additional.py:233:            \\\"vol_adjust\\\": {\\ntests/test_trend_analysis_presets_additional.py:240:    defaults = preset.vol_adjust_defaults()\\ntests/test_trend_analysis_presets_additional.py:247:def test_vol_adjust_defaults_copies_general_mapping() -> None:\\ntests/test_trend_analysis_presets_additional.py:267:        _config={\\\"vol_adjust\\\": {\\\"window\\\": window}},\\ntests/test_trend_analysis_presets_additional.py:270:    defaults = preset.vol_adjust_defaults()\\ntests/test_trend_analysis_presets_additional.py:282:        trend_spec=presets.TrendSpec(window=70, vol_adjust=True, vol_target=0.2),\\ntests/test_trend_analysis_presets_additional.py:283:        _config={\\\"vol_adjust\\\": {\\\"window\\\": {\\\"length\\\": 70}}},\\ntests/test_trend_analysis_presets_additional.py:289:            self.vol_adjust = MappingProxyType({\\\"existing\\\": 1})\\ntests/test_trend_analysis_presets_additional.py:295:    assert config.vol_adjust[\\\"existing\\\"] == 1\\ntests/test_trend_analysis_presets_additional.py:296:    assert config.vol_adjust[\\\"enabled\\\"] is True\\ntests/test_trend_analysis_presets_additional.py:297:    assert config.vol_adjust[\\\"window\\\"][\\\"length\\\"] == 70\\ntests/test_trend_analysis_presets_additional.py:330:def test_vol_adjust_defaults_reads_signal_toggle_when_section_invalid() -> None:\\ntests/test_trend_analysis_presets_additional.py:335:        trend_spec=presets.TrendSpec(window=70, vol_adjust=False, vol_target=None),\\ntests/test_trend_analysis_presets_additional.py:338:                \\\"signals\\\": {\\\"vol_adjust\\\": True, \\\"vol_target\\\": 0.6},\\ntests/test_trend_analysis_presets_additional.py:339:                \\\"vol_adjust\\\": \\\"ignored\\\",\\ntests/test_trend_analysis_presets_additional.py:344:    defaults = preset.vol_adjust_defaults()\\ntests/test_trend_signals_validation.py:32:def test_vol_adjust_without_target_inverts_rolling_std() -> None:\\ntests/test_trend_signals_validation.py:42:    spec_no_target = TrendSpec(window=3, min_periods=3, vol_adjust=True)\\ntests/test_trend_signals_validation.py:57:    assert adjusted.attrs[\\\"spec\\\"][\\\"vol_adjust\\\"] is True\\ntests/app/test_demo_runner_component.py:134:        \\\"portfolio\\\": {\\\"cooldown_months\\\": 2, \\\"max_weight\\\": 0.2},\\ntests/app/test_demo_runner_component.py:170:    assert dumped[\\\"vol_adjust\\\"] == {\\ntests/app/test_demo_runner_component.py:307:        vol_adjust={\\\"target_vol\\\": 0.1},\\ntests/app/test_demo_runner_component.py:495:        vol_adjust={\\\"target_vol\\\": 0.1},\\ntests/app/test_analysis_runner_config.py:120:        \\\"vol_adjust_enabled\\\": True,\\ntests/app/test_analysis_runner_config.py:127:    assert cfg.vol_adjust[\\\"window\\\"][\\\"decay\\\"] == \\\"simple\\\"\\ntests/test_multi_period_engine_cov_cache.py:27:        self.vol_adjust = {\\\"target_vol\\\": 1.0}\\ntests/test_buy_and_hold_selection.py:108:        vol_adjust={\\ntests/test_buy_and_hold_selection.py:286:            vol_adjust={\\\"target_vol\\\": 0.1},\\ntests/test_signal_presets_additional.py:65:        \\\"vol_adjust\\\": False,\\ntests/test_signal_presets_additional.py:93:        \\\"vol_adjust\\\": False,\\ntests/test_signals_engine.py:27:def test_vol_adjustment_scales_output(sample_returns: pd.DataFrame) -> None:\\ntests/test_signals_engine.py:30:        sample_returns, TrendSpec(window=3, lag=1, vol_adjust=True, vol_target=1.0)\\ntests/test_signals_engine.py:66:    spec = TrendSpec(window=3, lag=1, vol_adjust=True, vol_target=1.0)\\ntests/test_signals_additional.py:8:def test_compute_trend_signals_vol_adjust_and_attrs():\\ntests/test_signals_additional.py:16:    spec = TrendSpec(window=3, lag=1, vol_adjust=True, vol_target=0.5)\\ntests/test_robust_weighting.py:254:            \\\"robust_mv\\\", min_weight=0.1, max_weight=0.6, shrinkage_method=\\\"none\\\"\\ntests/test_robust_weighting.py:269:            \\\"robust_mv\\\", shrinkage_method=\\\"none\\\", min_weight=-1.0, max_weight=1.0\\ntests/test_unified_report.py:64:        vol_adjust={\\\"target_vol\\\": 0.15},\\ntests/test_unified_report.py:103:        window=45, lag=2, vol_adjust=True, vol_target=0.2, zscore=True\\n\",\"exit_code\":0,\"status\":\"completed\"}}\ncodex-session-4136.jsonl:14:{\"type\":\"item.completed\",\"item\":{\"id\":\"item_7\",\"type\":\"command_execution\",\"command\":\"/bin/bash -lc \\\"sed -n '1,200p' tests/test_pipeline_constraints_integration.py\\\"\",\"aggregated_output\":\"import numpy as np\\nimport pandas as pd\\n\\nfrom trend_analysis.core.rank_selection import RiskStatsConfig\\nfrom trend_analysis.pipeline import _run_analysis\\nfrom trend_analysis.plugins import WeightEngine, weight_engine_registry\\n\\nRUN_KWARGS = {\\\"risk_free_column\\\": \\\"RF\\\", \\\"allow_risk_free_fallback\\\": False}\\n\\n\\n@weight_engine_registry.register(\\\"negative_test_engine\\\")\\nclass NegativeTestEngine(WeightEngine):\\n    \\\"\\\"\\\"Test-only engine that emits a deliberate short weight.\\\"\\\"\\\"\\n\\n    def weight(self, cov: pd.DataFrame) -> pd.Series:\\n        if cov.empty:\\n            return pd.Series(dtype=float)\\n        weights = pd.Series(0.0, index=cov.index, dtype=float)\\n        if len(weights) == 1:\\n            weights.iloc[0] = 1.0\\n        else:\\n            weights.iloc[0] = 0.6\\n            weights.iloc[1] = -0.2\\n            if len(weights) > 2:\\n                weights.iloc[2] = 0.6\\n        return weights\\n\\n\\ndef make_dummy_returns(n_months: int = 24) -> pd.DataFrame:\\n    dates = pd.date_range(\\\"2022-01-31\\\", periods=n_months, freq=\\\"ME\\\")\\n    rng = np.random.default_rng(42)\\n    data = {\\n        \\\"Date\\\": dates,\\n        \\\"FundA\\\": rng.normal(0.01, 0.02, size=n_months),\\n        \\\"FundB\\\": rng.normal(0.008, 0.02, size=n_months),\\n        \\\"FundC\\\": rng.normal(0.011, 0.02, size=n_months),\\n        \\\"FundD\\\": rng.normal(0.009, 0.02, size=n_months),\\n        \\\"RF\\\": np.zeros(n_months),\\n    }\\n    return pd.DataFrame(data)\\n\\n\\ndef test_pipeline_applies_cash_and_max_weight_constraints():\\n    df = make_dummy_returns()\\n    res = _run_analysis(\\n        df,\\n        in_start=\\\"2022-01\\\",\\n        in_end=\\\"2022-12\\\",\\n        out_start=\\\"2023-01\\\",\\n        out_end=\\\"2023-12\\\",\\n        target_vol=0.10,\\n        monthly_cost=0.0,\\n        selection_mode=\\\"all\\\",\\n        stats_cfg=RiskStatsConfig(),\\n        constraints={\\n            \\\"long_only\\\": True,\\n            \\\"max_weight\\\": 0.4,\\n            \\\"cash_weight\\\": 0.1,\\n        },\\n        **RUN_KWARGS,\\n    )\\n    assert res is not None\\n    weights = res[\\\"fund_weights\\\"]  # mapping fund->weight (excludes CASH synthetic line)\\n    assert isinstance(weights, dict)\\n    total = sum(weights.values())\\n    assert 0.99 <= total <= 1.01\\n    assert all(w <= 0.4 + 1e-9 for w in weights.values())\\n    # Ensure no CASH synthetic line leaked into fund weights\\n    assert \\\"CASH\\\" not in weights\\n\\n\\ndef test_pipeline_max_weight_with_vol_adjust_enabled():\\n    df = make_dummy_returns()\\n    custom_weights = {\\\"FundA\\\": 80.0, \\\"FundB\\\": 10.0, \\\"FundC\\\": 10.0, \\\"FundD\\\": 0.0}\\n    res = _run_analysis(\\n        df,\\n        in_start=\\\"2022-01\\\",\\n        in_end=\\\"2022-12\\\",\\n        out_start=\\\"2023-01\\\",\\n        out_end=\\\"2023-12\\\",\\n        target_vol=0.10,\\n        monthly_cost=0.0,\\n        selection_mode=\\\"all\\\",\\n        custom_weights=custom_weights,\\n        stats_cfg=RiskStatsConfig(),\\n        constraints={\\n            \\\"long_only\\\": True,\\n            \\\"max_weight\\\": 0.35,\\n        },\\n        **RUN_KWARGS,\\n    )\\n    assert res is not None\\n    weights = res[\\\"fund_weights\\\"]\\n    assert isinstance(weights, dict)\\n    assert all(weight <= 0.35 + 1e-9 for weight in weights.values())\\n\\n\\ndef test_pipeline_long_only_blocks_negative_custom_weights():\\n    df = make_dummy_returns()\\n    custom_weights = {\\\"FundA\\\": 70.0, \\\"FundB\\\": -20.0, \\\"FundC\\\": 50.0, \\\"FundD\\\": 0.0}\\n\\n    res_long_only = _run_analysis(\\n        df,\\n        in_start=\\\"2022-01\\\",\\n        in_end=\\\"2022-12\\\",\\n        out_start=\\\"2023-01\\\",\\n        out_end=\\\"2023-12\\\",\\n        target_vol=None,\\n        monthly_cost=0.0,\\n        selection_mode=\\\"all\\\",\\n        custom_weights=custom_weights,\\n        stats_cfg=RiskStatsConfig(),\\n        constraints={\\\"long_only\\\": True},\\n        **RUN_KWARGS,\\n    )\\n    assert res_long_only is not None\\n    weights_long = res_long_only[\\\"fund_weights\\\"]\\n    assert all(weight >= 0 for weight in weights_long.values())\\n\\n    res_short_ok = _run_analysis(\\n        df,\\n        in_start=\\\"2022-01\\\",\\n        in_end=\\\"2022-12\\\",\\n        out_start=\\\"2023-01\\\",\\n        out_end=\\\"2023-12\\\",\\n        target_vol=None,\\n        monthly_cost=0.0,\\n        selection_mode=\\\"all\\\",\\n        custom_weights=custom_weights,\\n        stats_cfg=RiskStatsConfig(),\\n        constraints={\\\"long_only\\\": False},\\n        **RUN_KWARGS,\\n    )\\n    assert res_short_ok is not None\\n    weights_short = res_short_ok[\\\"fund_weights\\\"]\\n    assert any(weight < 0 for weight in weights_short.values())\\n\\n\\ndef test_pipeline_long_only_clips_negative_weight_engine_weights():\\n    df = make_dummy_returns()\\n    res_long_only = _run_analysis(\\n        df,\\n        in_start=\\\"2022-01\\\",\\n        in_end=\\\"2022-12\\\",\\n        out_start=\\\"2023-01\\\",\\n        out_end=\\\"2023-12\\\",\\n        target_vol=None,\\n        monthly_cost=0.0,\\n        selection_mode=\\\"all\\\",\\n        weighting_scheme=\\\"negative_test_engine\\\",\\n        stats_cfg=RiskStatsConfig(),\\n        constraints={\\\"long_only\\\": True},\\n        **RUN_KWARGS,\\n    )\\n    assert res_long_only is not None\\n    weights_long = res_long_only[\\\"fund_weights\\\"]\\n    assert all(weight >= 0 for weight in weights_long.values())\\n\\n    res_short_ok = _run_analysis(\\n        df,\\n        in_start=\\\"2022-01\\\",\\n        in_end=\\\"2022-12\\\",\\n        out_start=\\\"2023-01\\\",\\n        out_end=\\\"2023-12\\\",\\n        target_vol=None,\\n        monthly_cost=0.0,\\n        selection_mode=\\\"all\\\",\\n        weighting_scheme=\\\"negative_test_engine\\\",\\n        stats_cfg=RiskStatsConfig(),\\n        constraints={\\\"long_only\\\": False},\\n        **RUN_KWARGS,\\n    )\\n    assert res_short_ok is not None\\n    weights_short = res_short_ok[\\\"fund_weights\\\"]\\n    assert any(weight < 0 for weight in weights_short.values())\\n\",\"exit_code\":0,\"status\":\"completed\"}}\ncodex-session-4136.jsonl:35:{\"type\":\"item.completed\",\"item\":{\"id\":\"item_20\",\"type\":\"reasoning\",\"text\":\"**Investigating vol_adjust_enabled usage**\"}}\ncodex-session-4136.jsonl:36:{\"type\":\"item.started\",\"item\":{\"id\":\"item_21\",\"type\":\"command_execution\",\"command\":\"/bin/bash -lc 'rg -n \\\"vol_adjust_enabled\\\" -n'\",\"aggregated_output\":\"\",\"exit_code\":null,\"status\":\"in_progress\"}}\npr_body.md:19:- [ ] `max_weight=0.35` with `vol_adjust_enabled=True` produces weights capped at 35%\ntests/test_pipeline_constraints_integration.py:72:def test_pipeline_max_weight_with_vol_adjust_enabled():\nstreamlit_app/components/analysis_runner.py:372:    vol_adjust_enabled = bool(state.get(\"vol_adjust_enabled\", True))\nstreamlit_app/components/analysis_runner.py:630:            \"enabled\": vol_adjust_enabled,\nstreamlit_app/pages/8_Validation.py:93:        key=\"vol_adjust_enabled\",\nstreamlit_app/pages/2_Model.py:60:        \"vol_adjust_enabled\": True,\nstreamlit_app/pages/2_Model.py:304:    \"vol_adjust_enabled\": \"Enable volatility adjustment to scale returns to target vol.\",\nstreamlit_app/pages/2_Model.py:1635:                value=bool(model_state.get(\"vol_adjust_enabled\", True)),\nstreamlit_app/pages/2_Model.py:1636:                help=HELP_TEXT[\"vol_adjust_enabled\"],\nstreamlit_app/pages/2_Model.py:1695:        model_state[\"vol_adjust_enabled\"] = vol_adj_enabled\nstreamlit_app/pages/2_Model.py:2283:                \"vol_adjust_enabled\": vol_adj_enabled,\ntests/app/test_analysis_runner_config.py:120:        \"vol_adjust_enabled\": True,\nscripts/test_settings_wiring.py:149:        name=\"vol_adjust_enabled\",\nscripts/test_settings_wiring.py:438:        \"vol_adjust_enabled\": True,\nscripts/test_settings_wiring.py:869:    vol_adjust_enabled = bool(state.get(\"vol_adjust_enabled\", True))\nscripts/test_settings_wiring.py:933:            \"enabled\": vol_adjust_enabled,\nscripts/test_settings_wiring.py:1237:        baseline_state[\"vol_adjust_enabled\"] = True\nscripts/test_settings_wiring.py:1238:        test_state[\"vol_adjust_enabled\"] = True\ntests/test_volatility_settings_wiring.py:110:def test_vol_adjust_enabled_changes_scaling() -> None:\ndocs/UI_Parameter_Audit.md:540:  - Added `vol_adjust_enabled` checkbox to enable/disable vol scaling\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_22","type":"reasoning","text":"**Analyzing test location for vol_adjust feature**"}}
{"type":"item.started","item":{"id":"item_23","type":"command_execution","command":"/bin/bash -lc \"sed -n '1,180p' tests/test_volatility_settings_wiring.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_23","type":"command_execution","command":"/bin/bash -lc \"sed -n '1,180p' tests/test_volatility_settings_wiring.py\"","aggregated_output":"from __future__ import annotations\n\nfrom dataclasses import dataclass, field\n\nimport numpy as np\nimport pandas as pd\n\nfrom trend_analysis.multi_period import engine as mp_engine\n\n\n@dataclass\nclass VolatilityConfig:\n    multi_period: dict[str, object] = field(\n        default_factory=lambda: {\n            \"frequency\": \"M\",\n            \"in_sample_len\": 6,\n            \"out_sample_len\": 2,\n            \"start\": \"2020-01\",\n            \"end\": \"2021-12\",\n        }\n    )\n    data: dict[str, object] = field(\n        default_factory=lambda: {\n            \"csv_path\": \"unused.csv\",\n            \"risk_free_column\": \"RF\",\n        }\n    )\n    portfolio: dict[str, object] = field(\n        default_factory=lambda: {\n            \"policy\": \"threshold_hold\",\n            \"selection_mode\": \"rank\",\n            \"transaction_cost_bps\": 0.0,\n            \"threshold_hold\": {\n                \"target_n\": 2,\n                \"metric\": \"Sharpe\",\n                \"z_entry_soft\": 0.5,\n                \"z_exit_soft\": -0.5,\n                \"soft_strikes\": 1,\n                \"entry_soft_strikes\": 1,\n            },\n            \"constraints\": {\n                \"max_funds\": 3,\n                \"min_weight\": 0.05,\n                \"max_weight\": 0.8,\n            },\n            \"rank\": {\"inclusion_approach\": \"top_n\"},\n            \"weighting_scheme\": \"equal\",\n        }\n    )\n    vol_adjust: dict[str, object] = field(\n        default_factory=lambda: {\n            \"enabled\": True,\n            \"target_vol\": 0.1,\n            \"window\": {\"length\": 6, \"decay\": \"ewma\", \"lambda\": 0.94},\n        }\n    )\n    benchmarks: dict[str, object] = field(default_factory=dict)\n    run: dict[str, object] = field(default_factory=lambda: {\"monthly_cost\": 0.0})\n    performance: dict[str, object] = field(default_factory=dict)\n    seed: int = 7\n\n    def model_dump(self) -> dict[str, object]:\n        return {\n            \"multi_period\": dict(self.multi_period),\n            \"portfolio\": dict(self.portfolio),\n            \"vol_adjust\": dict(self.vol_adjust),\n        }\n\n\ndef _sample_returns() -> pd.DataFrame:\n    dates = pd.date_range(\"2020-01-31\", periods=24, freq=\"ME\")\n    idx = np.arange(len(dates), dtype=float)\n    fund_a = 0.01 + 0.02 * np.sin(idx / 3.0)\n    fund_b = 0.015 + 0.05 * np.sin(idx / 2.0 + 0.3)\n    fund_c = 0.005 + 0.03 * np.cos(idx / 4.0)\n    rf = np.full(len(dates), 0.001)\n    return pd.DataFrame(\n        {\n            \"Date\": dates,\n            \"FundA\": fund_a,\n            \"FundB\": fund_b,\n            \"FundC\": fund_c,\n            \"RF\": rf,\n        }\n    )\n\n\ndef _mean_scale_factor(results: list[dict[str, object]]) -> float:\n    values: list[float] = []\n    for result in results:\n        diagnostics = result.get(\"risk_diagnostics\", {})\n        scale_factors = diagnostics.get(\"scale_factors\") if diagnostics else None\n        if scale_factors is None:\n            continue\n        if isinstance(scale_factors, pd.Series):\n            values.append(float(scale_factors.mean()))\n        else:\n            values.append(float(pd.Series(scale_factors, dtype=float).mean()))\n    if not values:\n        raise AssertionError(\"No scale factor diagnostics were returned.\")\n    return float(np.mean(values))\n\n\ndef _run_config(cfg: VolatilityConfig) -> float:\n    results = mp_engine.run(cfg, _sample_returns())\n    assert results, \"Expected multi-period results to be returned.\"\n    return _mean_scale_factor(results)\n\n\ndef test_vol_adjust_enabled_changes_scaling() -> None:\n    cfg = VolatilityConfig()\n    enabled_mean = _run_config(cfg)\n    cfg.vol_adjust[\"enabled\"] = False\n    disabled_mean = _run_config(cfg)\n    assert not np.isclose(enabled_mean, disabled_mean, rtol=1e-4, atol=1e-6)\n    assert np.isclose(disabled_mean, 1.0, rtol=1e-4, atol=1e-6)\n\n\ndef test_vol_window_length_changes_scaling() -> None:\n    cfg = VolatilityConfig()\n    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"simple\", \"lambda\": 0.94}\n    baseline_mean = _run_config(cfg)\n    cfg.vol_adjust[\"window\"] = {\"length\": 3, \"decay\": \"simple\", \"lambda\": 0.94}\n    test_mean = _run_config(cfg)\n    assert not np.isclose(baseline_mean, test_mean, rtol=1e-4, atol=1e-6)\n\n\ndef test_vol_window_length_changes_scaling_for_ewma() -> None:\n    cfg = VolatilityConfig()\n    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"ewma\", \"lambda\": 0.9}\n    baseline_mean = _run_config(cfg)\n    cfg.vol_adjust[\"window\"] = {\"length\": 3, \"decay\": \"ewma\", \"lambda\": 0.9}\n    test_mean = _run_config(cfg)\n    assert not np.isclose(baseline_mean, test_mean, rtol=1e-4, atol=1e-6)\n\n\ndef test_vol_window_decay_changes_scaling() -> None:\n    cfg = VolatilityConfig()\n    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"ewma\", \"lambda\": 0.9}\n    baseline_mean = _run_config(cfg)\n    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"simple\", \"lambda\": 0.9}\n    test_mean = _run_config(cfg)\n    assert not np.isclose(baseline_mean, test_mean, rtol=1e-4, atol=1e-6)\n\n\ndef test_vol_ewma_lambda_changes_scaling() -> None:\n    cfg = VolatilityConfig()\n    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"ewma\", \"lambda\": 0.9}\n    baseline_mean = _run_config(cfg)\n    cfg.vol_adjust[\"window\"] = {\"length\": 6, \"decay\": \"ewma\", \"lambda\": 0.6}\n    test_mean = _run_config(cfg)\n    assert not np.isclose(baseline_mean, test_mean, rtol=1e-4, atol=1e-6)\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_24","type":"reasoning","text":"**Evaluating test locations for vol_adjust and max_weight**"}}
{"type":"item.started","item":{"id":"item_25","type":"command_execution","command":"/bin/bash -lc 'rg -n \"max_weight\" tests/test_multi_period_engine_threshold_bounds.py tests/test_multi_period_engine_threshold_events_extended.py tests/test_multi_period_engine_threshold_edgecases.py'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_25","type":"command_execution","command":"/bin/bash -lc 'rg -n \"max_weight\" tests/test_multi_period_engine_threshold_bounds.py tests/test_multi_period_engine_threshold_events_extended.py tests/test_multi_period_engine_threshold_edgecases.py'","aggregated_output":"tests/test_multi_period_engine_threshold_bounds.py:47:                \"max_weight\": 0.55,\ntests/test_multi_period_engine_threshold_events_extended.py:45:                \"max_weight\": 0.6,\ntests/test_multi_period_engine_threshold_events_extended.py:95:                \"max_weight\": 0.35,\ntests/test_multi_period_engine_threshold_edgecases.py:46:                \"max_weight\": 0.8,\ntests/test_multi_period_engine_threshold_edgecases.py:199:        {\"max_funds\": 3, \"min_weight\": 0.05, \"max_weight\": 0.8, \"min_weight_strikes\": 2}\ntests/test_multi_period_engine_threshold_edgecases.py:338:        {\"max_funds\": 2, \"min_weight\": 0.0, \"max_weight\": 1.0, \"min_weight_strikes\": 2}\ntests/test_multi_period_engine_threshold_edgecases.py:429:        {\"max_funds\": 2, \"min_weight\": 0.0, \"max_weight\": 1.0, \"min_weight_strikes\": 2}\ntests/test_multi_period_engine_threshold_edgecases.py:720:            \"max_weight\": 0.6,\ntests/test_multi_period_engine_threshold_edgecases.py:936:            \"max_weight\": 0.6,\ntests/test_multi_period_engine_threshold_edgecases.py:1040:            \"max_weight\": 0.3,\n","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_26","type":"command_execution","command":"/bin/bash -lc \"sed -n '1,140p' tests/test_multi_period_engine_threshold_events_extended.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_26","type":"command_execution","command":"/bin/bash -lc \"sed -n '1,140p' tests/test_multi_period_engine_threshold_events_extended.py\"","aggregated_output":"from __future__ import annotations\n\nimport types\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List, Tuple\n\nimport pandas as pd\nimport pytest\n\nfrom trend_analysis.multi_period import engine as mp_engine\n\n\n@dataclass\nclass ThresholdConfig:\n    multi_period: Dict[str, Any] = field(\n        default_factory=lambda: {\n            \"frequency\": \"M\",\n            \"in_sample_len\": 3,\n            \"out_sample_len\": 1,\n            \"start\": \"2020-01\",\n            \"end\": \"2020-06\",\n        }\n    )\n    data: Dict[str, Any] = field(\n        default_factory=lambda: {\n            \"csv_path\": \"unused.csv\",\n            \"risk_free_column\": \"RF\",\n        }\n    )\n    portfolio: Dict[str, Any] = field(\n        default_factory=lambda: {\n            \"policy\": \"threshold_hold\",\n            \"transaction_cost_bps\": 25.0,\n            \"max_turnover\": 0.05,\n            \"threshold_hold\": {\n                \"target_n\": 4,\n                \"metric\": \"Sharpe\",\n                \"z_exit_soft\": -0.4,\n                \"z_entry_soft\": 0.5,\n                \"min_weight_strikes\": 2,\n            },\n            \"constraints\": {\n                \"max_funds\": 4,\n                \"min_weight\": 0.25,\n                \"max_weight\": 0.6,\n                \"min_weight_strikes\": 2,\n            },\n            \"weighting\": {\"name\": \"adaptive\", \"params\": {}},\n            \"indices_list\": None,\n        }\n    )\n    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\n    benchmarks: Dict[str, Any] = field(default_factory=dict)\n    run: Dict[str, Any] = field(default_factory=lambda: {\"monthly_cost\": 0.0})\n    performance: Dict[str, Any] = field(default_factory=dict)\n    seed: int = 21\n\n    def model_dump(self) -> Dict[str, Any]:\n        return {\n            \"multi_period\": dict(self.multi_period),\n            \"portfolio\": dict(self.portfolio),\n            \"vol_adjust\": dict(self.vol_adjust),\n        }\n\n\n@dataclass\nclass ShortConfig:\n    multi_period: Dict[str, Any] = field(\n        default_factory=lambda: {\n            \"frequency\": \"M\",\n            \"in_sample_len\": 2,\n            \"out_sample_len\": 1,\n            \"start\": \"2020-01\",\n            \"end\": \"2020-04\",\n        }\n    )\n    data: Dict[str, Any] = field(\n        default_factory=lambda: {\n            \"csv_path\": \"unused.csv\",\n            \"risk_free_column\": \"RF\",\n        }\n    )\n    portfolio: Dict[str, Any] = field(\n        default_factory=lambda: {\n            \"policy\": \"threshold_hold\",\n            \"transaction_cost_bps\": 0.0,\n            \"max_turnover\": 1.0,\n            \"threshold_hold\": {\n                \"target_n\": 2,\n                \"metric\": \"Sharpe\",\n            },\n            \"constraints\": {\n                \"max_funds\": 2,\n                \"min_weight\": 0.1,\n                \"max_weight\": 0.35,\n            },\n            \"weighting\": {\"name\": \"adaptive\", \"params\": {}},\n            \"indices_list\": None,\n        }\n    )\n    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\n    benchmarks: Dict[str, Any] = field(default_factory=dict)\n    run: Dict[str, Any] = field(default_factory=lambda: {\"monthly_cost\": 0.0})\n    performance: Dict[str, Any] = field(default_factory=dict)\n    seed: int = 99\n\n    def model_dump(self) -> Dict[str, Any]:\n        return {\n            \"multi_period\": dict(self.multi_period),\n            \"portfolio\": dict(self.portfolio),\n            \"vol_adjust\": dict(self.vol_adjust),\n        }\n\n\nclass SequencedWeighting:\n    def __init__(self, sequences: List[Dict[str, float]]) -> None:\n        self.sequences = sequences\n        self.calls = 0\n        self.updates: List[Tuple[pd.Series, int]] = []\n\n    def weight(self, selected: pd.DataFrame, date: pd.Timestamp) -> pd.DataFrame:\n        idx = min(self.calls, len(self.sequences) - 1)\n        seq = self.sequences[idx]\n        self.calls += 1\n        weights = pd.Series(\n            {name: seq.get(name, 0.02) for name in selected.index},\n            index=selected.index,\n            dtype=float,\n        )\n        return weights.to_frame(\"weight\")\n\n    def update(self, scores: pd.Series, days: int) -> None:\n        self.updates.append((scores.copy(), days))\n\n\nclass ScriptedSelector:\n    def __init__(self, order: List[str], top_n: int) -> None:\n        self._order = order\n        self.top_n = top_n\n        self.rank_column = \"Sharpe\"\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_27","type":"reasoning","text":"**Checking test coverage for pipeline**"}}
{"type":"item.started","item":{"id":"item_28","type":"command_execution","command":"/bin/bash -lc 'rg -n \"max_weight\": 0.35 -n tests/test_multi_period_engine_threshold_events_extended.py'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_28","type":"command_execution","command":"/bin/bash -lc 'rg -n \"max_weight\": 0.35 -n tests/test_multi_period_engine_threshold_events_extended.py'","aggregated_output":"rg: 0.35: No such file or directory (os error 2)\n","exit_code":2,"status":"failed"}}
{"type":"item.completed","item":{"id":"item_29","type":"reasoning","text":"**Switching search method to plain text**"}}
{"type":"item.started","item":{"id":"item_30","type":"command_execution","command":"/bin/bash -lc 'rg -n \"0.35\" tests/test_multi_period_engine_threshold_events_extended.py'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_30","type":"command_execution","command":"/bin/bash -lc 'rg -n \"0.35\" tests/test_multi_period_engine_threshold_events_extended.py'","aggregated_output":"95:                \"max_weight\": 0.35,\n","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_31","type":"command_execution","command":"/bin/bash -lc \"sed -n '80,140p' tests/test_multi_period_engine_threshold_events_extended.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_31","type":"command_execution","command":"/bin/bash -lc \"sed -n '80,140p' tests/test_multi_period_engine_threshold_events_extended.py\"","aggregated_output":"            \"risk_free_column\": \"RF\",\n        }\n    )\n    portfolio: Dict[str, Any] = field(\n        default_factory=lambda: {\n            \"policy\": \"threshold_hold\",\n            \"transaction_cost_bps\": 0.0,\n            \"max_turnover\": 1.0,\n            \"threshold_hold\": {\n                \"target_n\": 2,\n                \"metric\": \"Sharpe\",\n            },\n            \"constraints\": {\n                \"max_funds\": 2,\n                \"min_weight\": 0.1,\n                \"max_weight\": 0.35,\n            },\n            \"weighting\": {\"name\": \"adaptive\", \"params\": {}},\n            \"indices_list\": None,\n        }\n    )\n    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\n    benchmarks: Dict[str, Any] = field(default_factory=dict)\n    run: Dict[str, Any] = field(default_factory=lambda: {\"monthly_cost\": 0.0})\n    performance: Dict[str, Any] = field(default_factory=dict)\n    seed: int = 99\n\n    def model_dump(self) -> Dict[str, Any]:\n        return {\n            \"multi_period\": dict(self.multi_period),\n            \"portfolio\": dict(self.portfolio),\n            \"vol_adjust\": dict(self.vol_adjust),\n        }\n\n\nclass SequencedWeighting:\n    def __init__(self, sequences: List[Dict[str, float]]) -> None:\n        self.sequences = sequences\n        self.calls = 0\n        self.updates: List[Tuple[pd.Series, int]] = []\n\n    def weight(self, selected: pd.DataFrame, date: pd.Timestamp) -> pd.DataFrame:\n        idx = min(self.calls, len(self.sequences) - 1)\n        seq = self.sequences[idx]\n        self.calls += 1\n        weights = pd.Series(\n            {name: seq.get(name, 0.02) for name in selected.index},\n            index=selected.index,\n            dtype=float,\n        )\n        return weights.to_frame(\"weight\")\n\n    def update(self, scores: pd.Series, days: int) -> None:\n        self.updates.append((scores.copy(), days))\n\n\nclass ScriptedSelector:\n    def __init__(self, order: List[str], top_n: int) -> None:\n        self._order = order\n        self.top_n = top_n\n        self.rank_column = \"Sharpe\"\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_32","type":"reasoning","text":"**Checking for tests and asserts**"}}
{"type":"item.started","item":{"id":"item_33","type":"command_execution","command":"/bin/bash -lc 'rg -n \"max_weight\" tests/test_multi_period_engine_threshold_events_extended.py'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_33","type":"command_execution","command":"/bin/bash -lc 'rg -n \"max_weight\" tests/test_multi_period_engine_threshold_events_extended.py'","aggregated_output":"45:                \"max_weight\": 0.6,\n95:                \"max_weight\": 0.35,\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_34","type":"reasoning","text":"**Investigating existing tests related to max_weight and vol_adjust**"}}
{"type":"item.started","item":{"id":"item_35","type":"command_execution","command":"/bin/bash -lc 'rg -n \"vol_adjust\" src/trend_analysis/multi_period/engine.py | head -n 20'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_35","type":"command_execution","command":"/bin/bash -lc 'rg -n \"vol_adjust\" src/trend_analysis/multi_period/engine.py | head -n 20'","aggregated_output":"743:    trend_spec = _build_trend_spec(cfg, getattr(cfg, \"vol_adjust\", {}) or {})\n1003:                _resolve_target_vol(getattr(cfg, \"vol_adjust\", {})),\n1005:                floor_vol=cfg.vol_adjust.get(\"floor_vol\"),\n1006:                warmup_periods=int(cfg.vol_adjust.get(\"warmup_periods\", 0) or 0),\n1017:                risk_window=cfg.vol_adjust.get(\"window\"),\n3472:            _resolve_target_vol(getattr(cfg, \"vol_adjust\", {})),\n3474:            floor_vol=cfg.vol_adjust.get(\"floor_vol\"),\n3475:            warmup_periods=int(cfg.vol_adjust.get(\"warmup_periods\", 0) or 0),\n3484:            risk_window=cfg.vol_adjust.get(\"window\"),\n","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_36","type":"command_execution","command":"/bin/bash -lc \"sed -n '3380,3520p' src/trend_analysis/multi_period/engine.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_36","type":"command_execution","command":"/bin/bash -lc \"sed -n '3380,3520p' src/trend_analysis/multi_period/engine.py\"","aggregated_output":"            and prev_final_weights is not None\n            and float(last_aligned.abs().sum()) > NUMERICAL_TOLERANCE_HIGH\n        ):\n            target_w = _apply_turnover_penalty(\n                target_w, last_aligned, lambda_tc, min_w_bound, max_w_bound\n            )\n\n        # Forced exits must not be diluted by turnover-penalty shrinkage.\n        # Ensure any holdings flagged for z_exit/z_exit_hard are targeted to 0.\n        if forced_exits:\n            for mgr in forced_exits:\n                if mgr in target_w.index:\n                    target_w.loc[mgr] = 0.0\n            target_w = _apply_weight_bounds(target_w, min_w_bound, max_w_bound)\n\n        desired_trades = target_w - last_aligned\n        desired_turnover = float(desired_trades.abs().sum())\n        final_w = target_w.copy()\n        if (\n            max_turnover_cap < 1.0 - NUMERICAL_TOLERANCE_HIGH\n            and desired_turnover > max_turnover_cap + NUMERICAL_TOLERANCE_HIGH\n        ):\n            # Respect turnover cap, but prioritise forced exits (soft/hard z exits).\n            # This prevents below-threshold holdings from lingering indefinitely\n            # solely because turnover is capped.\n            forced_ix = [ix for ix in desired_trades.index if str(ix) in forced_exits]\n            mandatory = desired_trades.copy()\n            if forced_ix:\n                # Keep only forced exit trades in mandatory bucket\n                mandatory.loc[[ix for ix in mandatory.index if ix not in forced_ix]] = (\n                    0.0\n                )\n            else:\n                mandatory[:] = 0.0\n\n            mandatory_turnover = float(mandatory.abs().sum())\n            optional = desired_trades - mandatory\n            optional_turnover = float(optional.abs().sum())\n\n            if mandatory_turnover >= max_turnover_cap - NUMERICAL_TOLERANCE_HIGH:\n                # Forced exits alone consume (or exceed) the cap; execute forced exits\n                # and skip all other trades.\n                final_w = last_aligned + mandatory\n            else:\n                remaining_turnover = max_turnover_cap - mandatory_turnover\n                scale = (\n                    remaining_turnover / optional_turnover\n                    if optional_turnover > 0\n                    else 0.0\n                )\n                scale = max(0.0, min(1.0, scale))\n                final_w = last_aligned + mandatory + optional * scale\n        # Ensure bounds and normalisation remain satisfied\n        final_w = _apply_weight_bounds(final_w, min_w_bound, max_w_bound)\n        final_w = _enforce_max_active_positions(\n            final_w, max_active_positions, protected=min_tenure_guard\n        )\n\n        # Prepare custom weights mapping in percent for _run_analysis.\n        # We keep the internal turnover-cap/bounds logic here, but reconcile the\n        # change log against the *actual* weights returned by the pipeline.\n        eps = 1e-12\n        final_w = final_w[final_w.abs() > eps]\n        if not final_w.empty:\n            total = float(final_w.sum())\n            # Preserve infeasible bound outcomes:\n            # - total > 1.0: min_weight floors too large\n            # - total < 1.0: max_weight caps too tight\n            # Only renormalise when the weights already sum (approximately) to 1.\n            if total > eps and abs(total - 1.0) <= 1e-8:\n                final_w = final_w / total\n        # Only pass the selected holdings (if still present after filtering).\n        manual_funds: list[str] = [\n            str(h) for h in manual_holdings if h in final_w.index\n        ]\n        custom: dict[str, float] = {\n            str(k): float(v) * 100.0 for k, v in final_w.items()\n        }\n\n        # Construct previous weights dict for pipeline (turnover tracking)\n        prev_weights_for_pipeline: dict[str, float] | None = None\n        if prev_final_weights is not None:\n            prev_weights_for_pipeline = {\n                str(k): float(v) * 100.0 for k, v in prev_final_weights.items()\n            }\n\n        res = _call_pipeline_with_diag(\n            df,\n            pt.in_start[:7],\n            pt.in_end[:7],\n            pt.out_start[:7],\n            pt.out_end[:7],\n            _resolve_target_vol(getattr(cfg, \"vol_adjust\", {})),\n            getattr(cfg, \"run\", {}).get(\"monthly_cost\", 0.0),\n            floor_vol=cfg.vol_adjust.get(\"floor_vol\"),\n            warmup_periods=int(cfg.vol_adjust.get(\"warmup_periods\", 0) or 0),\n            selection_mode=\"manual\",\n            random_n=cfg.portfolio.get(\"random_n\", 8),\n            custom_weights=custom,\n            rank_kwargs=None,\n            manual_funds=manual_funds,\n            indices_list=cfg.portfolio.get(\"indices_list\"),\n            benchmarks=cfg.benchmarks,\n            seed=getattr(cfg, \"seed\", 42),\n            risk_window=cfg.vol_adjust.get(\"window\"),\n            constraints=cfg.portfolio.get(\"constraints\"),\n            regime_cfg=regime_cfg,\n            risk_free_column=risk_free_column_cfg,\n            allow_risk_free_fallback=allow_risk_free_fallback_cfg,\n            # Pass turnover parameters for pipeline-level enforcement.\n            # The pipeline applies vol-scaling after which turnover may exceed\n            # the threshold-hold logic's pre-scaled cap; passing these ensures\n            # the final weights respect the turnover constraint.\n            previous_weights=prev_weights_for_pipeline,\n            max_turnover=max_turnover_cap if max_turnover_cap < 1.0 else None,\n            lambda_tc=lambda_tc if lambda_tc > 0 else None,\n            signal_spec=trend_spec,\n        )\n        payload = res.value\n        diag = res.diagnostic\n        if payload is None:\n            if diag is not None:\n                logger.warning(\n                    \"Manual selection period skipped %s/%s (%s): %s\",\n                    pt.in_start,\n                    pt.out_start,\n                    diag.reason_code,\n                    diag.message,\n                )\n            continue\n        res_dict = dict(payload)\n        res_dict.update(missing_policy_metadata)\n        # Persist z-scores into the standard score_frame so downstream\n        # consumers can audit soft-entry/soft-exit decisions without\n        # recomputation.\n        score_frame_payload = res_dict.get(\"score_frame\")\n        if (\n            isinstance(score_frame_payload, pd.DataFrame)\n            and not score_frame_payload.empty\n        ):\n            score_frame_out = score_frame_payload.copy()\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_37","type":"reasoning","text":"**Examining vol_adjust usage in pipeline**"}}
{"type":"item.started","item":{"id":"item_38","type":"command_execution","command":"/bin/bash -lc \"sed -n '1440,1495p' src/trend_analysis/pipeline.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_38","type":"command_execution","command":"/bin/bash -lc \"sed -n '1440,1495p' src/trend_analysis/pipeline.py\"","aggregated_output":"        except KeyError:\n            return default\n    attr_value = getattr(section, key, default)\n    return attr_value\n\n\ndef _resolve_target_vol(vol_adjust_cfg: Mapping[str, Any] | Any) -> float | None:\n    enabled = _section_get(vol_adjust_cfg, \"enabled\")\n    if enabled is False:\n        return None\n    target_raw = _section_get(vol_adjust_cfg, \"target_vol\", 1.0)\n    if target_raw is None:\n        return 1.0\n    try:\n        target = float(target_raw)\n    except (TypeError, ValueError):\n        return 1.0\n    if target <= 0:\n        return None\n    return target\n\n\n# Default multiplier for reducing fund count/selection during risk-off regimes.\n# Must match the value in config/defaults.yml regime.risk_off_fund_count_multiplier\n_DEFAULT_RISK_OFF_FUND_MULTIPLIER = 0.5\n\n\ndef _resolve_regime_label(\n    preprocess: _PreprocessStage,\n    window: _WindowStage,\n    regime_cfg: Mapping[str, Any] | None,\n    benchmarks: Mapping[str, str] | None = None,\n) -> tuple[str | None, Any]:\n    def _resolve_proxy_column(proxy_value: str) -> str | None:\n        columns = window.in_df.columns\n        if proxy_value in columns:\n            return proxy_value\n\n        proxy_lower = proxy_value.lower()\n        if benchmarks:\n            for key, value in benchmarks.items():\n                if proxy_lower == str(key).lower() and value in columns:\n                    return str(value)\n                if proxy_lower == str(value).lower() and value in columns:\n                    return str(value)\n\n        for col in columns:\n            if proxy_lower == str(col).lower():\n                return str(col)\n        return None\n\n    settings = normalise_settings(regime_cfg)\n    if not settings.enabled:\n        return None, settings\n    proxy = settings.proxy\n    if not proxy:\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_39","type":"reasoning","text":"**Analyzing volume adjustment test setup**"}}
{"type":"item.started","item":{"id":"item_40","type":"command_execution","command":"/bin/bash -lc 'rg -n \"max_weight\" scripts/test_settings_wiring.py'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_40","type":"command_execution","command":"/bin/bash -lc 'rg -n \"max_weight\" scripts/test_settings_wiring.py'","aggregated_output":"185:        name=\"max_weight\",\n447:        \"max_weight\": 0.20,  # Aligned with baseline in 8_Validation.py\n635:    max_weight = _coerce_positive_float(state.get(\"max_weight\"), default=0.20)\n699:            \"max_weight\": max_weight,\n1058:            max_weights = []\n1061:                    max_weights.append(max(p[\"weights\"].values()))\n1062:            if max_weights:\n1063:                return float(max(max_weights))\n1236:    if setting.name == \"max_weight\":\n1244:            required_count = int(np.ceil(1.0 / float(test_state[\"max_weight\"])))\n","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_41","type":"command_execution","command":"/bin/bash -lc \"sed -n '1180,1305p' scripts/test_settings_wiring.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_41","type":"command_execution","command":"/bin/bash -lc \"sed -n '1180,1305p' scripts/test_settings_wiring.py\"","aggregated_output":"    \"\"\"Check if the change direction matches expectation.\"\"\"\n    if baseline_val is None or test_val is None:\n        return False\n\n    if expected_direction == \"change\" or expected_direction == \"any\":\n        return bool(baseline_val != test_val)\n\n    try:\n        baseline_num = float(baseline_val)\n        test_num = float(test_val)\n    except (TypeError, ValueError):\n        # For non-numeric values, just check if they changed\n        return bool(baseline_val != test_val)\n\n    if expected_direction == \"increase\":\n        return bool(test_num > baseline_num)\n    elif expected_direction == \"decrease\":\n        return bool(test_num < baseline_num)\n\n    return bool(baseline_val != test_val)\n\n\ndef run_single_test(\n    setting: SettingTest,\n    returns: pd.DataFrame,\n    verbose: bool = False,\n) -> TestResult:\n    \"\"\"Run a single setting test.\"\"\"\n\n    # Build baseline state\n    baseline_state = get_baseline_state()\n\n    # Build test state with only this setting changed\n    test_state = baseline_state.copy()\n    test_state[setting.name] = setting.test_value\n\n    # Also update baseline with the baseline value (in case default differs)\n    baseline_state[setting.name] = setting.baseline_value\n\n    mode_context = MODE_CONTEXT.get(setting.name)\n    if mode_context:\n        baseline_state = _apply_mode_context(baseline_state, mode_context)\n        test_state = _apply_mode_context(test_state, mode_context)\n\n    # Handle special cases for inclusion_approach tests\n    if setting.name == \"inclusion_approach\":\n        if setting.test_value == \"top_pct\":\n            test_state[\"rank_pct\"] = 0.20  # Ensure meaningful selection\n        elif setting.test_value == \"random\":\n            test_state[\"random_seed\"] = 42  # Ensure reproducibility\n\n    # min_weight constraint needs non-equal weighting to have observable effect\n    if setting.name == \"min_weight\":\n        baseline_state[\"weighting_scheme\"] = \"risk_parity\"\n        test_state[\"weighting_scheme\"] = \"risk_parity\"\n\n    if setting.name == \"max_weight\":\n        baseline_state[\"vol_adjust_enabled\"] = True\n        test_state[\"vol_adjust_enabled\"] = True\n        baseline_state[\"weighting_scheme\"] = \"risk_parity\"\n        test_state[\"weighting_scheme\"] = \"risk_parity\"\n        baseline_state[\"inclusion_approach\"] = \"top_n\"\n        test_state[\"inclusion_approach\"] = \"top_n\"\n        try:\n            required_count = int(np.ceil(1.0 / float(test_state[\"max_weight\"])))\n        except (TypeError, ValueError):\n            required_count = None\n        if required_count:\n            if baseline_state.get(\"selection_count\", 0) < required_count:\n                baseline_state[\"selection_count\"] = required_count\n            if test_state.get(\"selection_count\", 0) < required_count:\n                test_state[\"selection_count\"] = required_count\n\n    # random_seed test needs random selection mode to demonstrate effect\n    if setting.name == \"random_seed\":\n        baseline_state[\"inclusion_approach\"] = \"random\"\n        test_state[\"inclusion_approach\"] = \"random\"\n\n    # rank_pct test needs top_pct selection mode\n    if setting.name == \"rank_pct\":\n        baseline_state[\"inclusion_approach\"] = \"top_pct\"\n        test_state[\"inclusion_approach\"] = \"top_pct\"\n\n    # buy_hold_initial test needs buy_and_hold selection mode\n    if setting.name == \"buy_hold_initial\":\n        baseline_state[\"inclusion_approach\"] = \"buy_and_hold\"\n        test_state[\"inclusion_approach\"] = \"buy_and_hold\"\n\n    # shrinkage tests need robust_mv weighting where shrinkage is applied\n    if setting.name in [\"shrinkage_enabled\", \"shrinkage_method\"]:\n        baseline_state[\"weighting_scheme\"] = \"robust_mv\"\n        test_state[\"weighting_scheme\"] = \"robust_mv\"\n\n    # vol_window_length should be tested with simple decay to ensure window length is used\n    if setting.name == \"vol_window_length\":\n        baseline_state[\"vol_window_decay\"] = \"simple\"\n        test_state[\"vol_window_decay\"] = \"simple\"\n    try:\n        if verbose:\n            print(f\"  Running baseline: {setting.name}={setting.baseline_value}\")\n        baseline_result = run_analysis_with_state(returns, baseline_state)\n\n        if verbose:\n            print(f\"  Running test: {setting.name}={setting.test_value}\")\n        test_result = run_analysis_with_state(returns, test_state)\n\n        # Extract metrics\n        baseline_metric = extract_metric(\n            baseline_result, setting.expected_metric, baseline_state\n        )\n        test_metric = extract_metric(test_result, setting.expected_metric, test_state)\n\n        # Check if metric changed\n        metric_changed = baseline_metric != test_metric\n\n        # Check if direction is correct\n        direction_correct = check_direction(\n            baseline_metric, test_metric, setting.expected_direction\n        )\n\n        # Determine status\n        if not metric_changed:\n            status = \"FAIL\"\n            error = f\"Setting had no effect on {setting.expected_metric}\"\n        elif not direction_correct:\n            status = \"WARN\"\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_42","type":"reasoning","text":"**Planning test addition for max_weight with vol_adjust**"}}
{"type":"item.started","item":{"id":"item_43","type":"command_execution","command":"/bin/bash -lc \"sed -n '1,220p' tests/test_multi_period_engine_threshold_bounds.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_43","type":"command_execution","command":"/bin/bash -lc \"sed -n '1,220p' tests/test_multi_period_engine_threshold_bounds.py\"","aggregated_output":"from __future__ import annotations\n\nfrom dataclasses import dataclass, field\nfrom typing import Any, Dict, List\n\nimport pandas as pd\nimport pytest\n\nfrom trend_analysis.multi_period import engine as mp_engine\n\n\n@dataclass\nclass MinimalConfig:\n    \"\"\"Minimal configuration for exercising threshold-hold weight bounds.\"\"\"\n\n    multi_period: Dict[str, Any] = field(\n        default_factory=lambda: {\n            \"frequency\": \"M\",\n            \"in_sample_len\": 2,\n            \"out_sample_len\": 1,\n            \"start\": \"2020-01\",\n            \"end\": \"2020-04\",\n        }\n    )\n    data: Dict[str, Any] = field(\n        default_factory=lambda: {\n            \"csv_path\": \"unused.csv\",\n            \"allow_risk_free_fallback\": True,\n        }\n    )\n    portfolio: Dict[str, Any] = field(\n        default_factory=lambda: {\n            \"policy\": \"threshold_hold\",\n            \"transaction_cost_bps\": 0.0,\n            \"max_turnover\": 1.0,\n            \"threshold_hold\": {\n                \"target_n\": 3,\n                \"metric\": \"Sharpe\",\n                \"soft_strikes\": 1,\n                \"entry_soft_strikes\": 1,\n                \"z_exit_soft\": -5.0,\n                \"z_entry_soft\": -5.0,\n            },\n            \"constraints\": {\n                \"max_funds\": 3,\n                \"min_weight\": 0.2,\n                \"max_weight\": 0.55,\n                \"min_weight_strikes\": 1,\n            },\n            \"weighting\": {\"name\": \"adaptive_bayes\", \"params\": {}},\n            \"indices_list\": None,\n        }\n    )\n    vol_adjust: Dict[str, Any] = field(default_factory=lambda: {\"target_vol\": 1.0})\n    benchmarks: Dict[str, Any] = field(default_factory=dict)\n    run: Dict[str, Any] = field(default_factory=lambda: {\"monthly_cost\": 0.0})\n    seed: int = 123\n\n    def model_dump(self) -> Dict[str, Any]:\n        return {\n            \"multi_period\": self.multi_period,\n            \"portfolio\": self.portfolio,\n            \"vol_adjust\": self.vol_adjust,\n        }\n\n\n@dataclass\nclass DummyPeriod:\n    in_start: str\n    in_end: str\n    out_start: str\n    out_end: str\n\n\nclass ScriptedSelector:\n    \"\"\"Selector that keeps the provided score-frame ordering.\"\"\"\n\n    rank_column = \"Sharpe\"\n\n    def select(self, score_frame: pd.DataFrame) -> tuple[pd.DataFrame, pd.DataFrame]:\n        return score_frame, score_frame\n\n\nclass ScriptedWeighting:\n    \"\"\"Weighting sequence crafted to exercise bound adjustments.\"\"\"\n\n    def __init__(self, *_args: Any, **_kwargs: Any) -> None:\n        self.calls = 0\n        self.sequences: List[Dict[str, float]] = [\n            {\"Alpha One\": 0.6, \"Alpha Two\": 0.4, \"Beta One\": 0.2, \"Gamma One\": 0.1},\n            {\"Alpha One\": 0.4, \"Beta One\": 0.1, \"Gamma One\": 0.05},\n            {\"Alpha One\": 0.9, \"Beta One\": 0.4, \"Gamma One\": 0.35},\n        ]\n\n    def weight(\n        self, selected: pd.DataFrame, date: pd.Timestamp | None = None\n    ) -> pd.DataFrame:\n        del date\n        seq = self.sequences[min(self.calls, len(self.sequences) - 1)]\n        self.calls += 1\n        weights = pd.Series(\n            {idx: seq.get(idx, 0.05) for idx in selected.index},\n            index=selected.index,\n            dtype=float,\n        )\n        return weights.to_frame(\"weight\")\n\n    def update(\n        self, scores: pd.Series, days: int\n    ) -> None:  # pragma: no cover - inert hook\n        pass\n\n\nclass StaticRebalancer:\n    \"\"\"Rebalancer that preserves prior holdings for deterministic tests.\"\"\"\n\n    def __init__(self, *_cfg: Any) -> None:\n        self.calls = 0\n\n    def apply_triggers(\n        self, prev_weights: pd.Series, _sf: pd.DataFrame, **kwargs\n    ) -> pd.Series:\n        self.calls += 1\n        return prev_weights.astype(float)\n\n\ndef test_threshold_hold_weight_bounds(monkeypatch: pytest.MonkeyPatch) -> None:\n    cfg = MinimalConfig()\n\n    dates = pd.to_datetime(\n        [\n            \"2020-01-31\",\n            \"2020-02-29\",\n            \"2020-03-31\",\n            \"2020-04-30\",\n            \"2020-05-31\",\n        ]\n    )\n    df = pd.DataFrame(\n        {\n            \"Date\": dates,\n            \"Alpha One\": [0.05, 0.04, 0.03, 0.02, 0.01],\n            \"Alpha Two\": [0.06, 0.05, 0.04, 0.03, 0.02],\n            \"Beta One\": [0.02, 0.03, 0.02, 0.01, 0.02],\n            \"Gamma One\": [0.04, 0.05, 0.06, 0.07, 0.08],\n        }\n    )\n\n    periods = [\n        DummyPeriod(\"2020-01-31\", \"2020-03-31\", \"2020-04-30\", \"2020-04-30\"),\n        DummyPeriod(\"2020-02-29\", \"2020-04-30\", \"2020-05-31\", \"2020-05-31\"),\n    ]\n\n    monkeypatch.setattr(mp_engine, \"generate_periods\", lambda _cfg: periods)\n    monkeypatch.setattr(mp_engine, \"AdaptiveBayesWeighting\", ScriptedWeighting)\n    monkeypatch.setattr(mp_engine, \"Rebalancer\", StaticRebalancer)\n\n    import trend_analysis.selector as selector_mod\n\n    monkeypatch.setattr(\n        selector_mod, \"create_selector_by_name\", lambda *a, **k: ScriptedSelector()\n    )\n\n    import trend_analysis.core.rank_selection as rank_sel\n\n    metric_maps = {\n        \"AnnualReturn\": {\n            \"Alpha One\": 0.15,\n            \"Alpha Two\": 0.12,\n            \"Beta One\": 0.07,\n            \"Gamma One\": 0.18,\n        },\n        \"Volatility\": {\n            \"Alpha One\": 0.25,\n            \"Alpha Two\": 0.2,\n            \"Beta One\": 0.15,\n            \"Gamma One\": 0.3,\n        },\n        \"Sharpe\": {\n            \"Alpha One\": 0.9,\n            \"Alpha Two\": 0.8,\n            \"Beta One\": 0.4,\n            \"Gamma One\": 1.1,\n        },\n        \"Sortino\": {\n            \"Alpha One\": 1.1,\n            \"Alpha Two\": 0.9,\n            \"Beta One\": 0.45,\n            \"Gamma One\": 1.3,\n        },\n        \"InformationRatio\": {\n            \"Alpha One\": 0.6,\n            \"Alpha Two\": 0.5,\n            \"Beta One\": 0.3,\n            \"Gamma One\": 0.9,\n        },\n        \"MaxDrawdown\": {\n            \"Alpha One\": -0.12,\n            \"Alpha Two\": -0.11,\n            \"Beta One\": -0.05,\n            \"Gamma One\": -0.09,\n        },\n    }\n\n    def fake_metric_series(\n        _frame: pd.DataFrame, metric: str, _stats_cfg: Any\n    ) -> pd.Series:\n        values = metric_maps[metric]\n        return pd.Series(values, dtype=float)\n\n    monkeypatch.setattr(rank_sel, \"_compute_metric_series\", fake_metric_series)\n\n    records: List[Dict[str, Any]] = []\n\n    def fake_run_analysis(\n        _df: pd.DataFrame,\n        in_start: str,\n        in_end: str,\n        out_start: str,\n        out_end: str,\n","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_44","type":"command_execution","command":"/bin/bash -lc \"sed -n '220,420p' tests/test_multi_period_engine_threshold_bounds.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_44","type":"command_execution","command":"/bin/bash -lc \"sed -n '220,420p' tests/test_multi_period_engine_threshold_bounds.py\"","aggregated_output":"        out_end: str,\n        _target_vol: float,\n        _monthly_cost: float,\n        *,\n        custom_weights: Dict[str, float],\n        manual_funds: List[str],\n        **_kwargs: Any,\n    ) -> Dict[str, Any]:\n        records.append(\n            {\n                \"weights\": dict(custom_weights),\n                \"funds\": list(manual_funds),\n                \"period\": (in_start, out_end),\n            }\n        )\n        return {\"metrics\": pd.DataFrame(), \"details\": {}, \"seed\": cfg.seed}\n\n    monkeypatch.setattr(mp_engine, \"_run_analysis\", fake_run_analysis)\n\n    results = mp_engine.run(cfg, df=df)\n\n    assert len(results) == 2\n\n    # The scripted weighting sequences should normalise within the weight bounds.\n    assert records\n    first_weights = records[0][\"weights\"]\n    assert set(first_weights) == {\"Alpha One\", \"Beta One\", \"Gamma One\"}\n    assert pytest.approx(sum(first_weights.values()), rel=1e-9) == 100.0\n\n    second_weights = records[1][\"weights\"]\n    assert pytest.approx(sum(second_weights.values()), rel=1e-9) == 100.0\n    assert set(records[0][\"funds\"]) == {\"Alpha One\", \"Beta One\", \"Gamma One\"}\n    assert set(records[1][\"funds\"]) == {\"Alpha One\", \"Beta One\", \"Gamma One\"}\n\n\ndef test_threshold_hold_max_active_positions(monkeypatch: pytest.MonkeyPatch) -> None:\n    cfg = MinimalConfig()\n    cfg.portfolio[\"constraints\"][\"max_active_positions\"] = 2\n\n    dates = pd.to_datetime(\n        [\n            \"2020-01-31\",\n            \"2020-02-29\",\n            \"2020-03-31\",\n            \"2020-04-30\",\n            \"2020-05-31\",\n        ]\n    )\n    df = pd.DataFrame(\n        {\n            \"Date\": dates,\n            \"Alpha One\": [0.05, 0.04, 0.03, 0.02, 0.01],\n            \"Alpha Two\": [0.06, 0.05, 0.04, 0.03, 0.02],\n            \"Beta One\": [0.02, 0.03, 0.02, 0.01, 0.02],\n            \"Gamma One\": [0.04, 0.05, 0.06, 0.07, 0.08],\n        }\n    )\n\n    periods = [\n        DummyPeriod(\"2020-01-31\", \"2020-03-31\", \"2020-04-30\", \"2020-04-30\"),\n        DummyPeriod(\"2020-02-29\", \"2020-04-30\", \"2020-05-31\", \"2020-05-31\"),\n    ]\n\n    monkeypatch.setattr(mp_engine, \"generate_periods\", lambda _cfg: periods)\n    monkeypatch.setattr(mp_engine, \"AdaptiveBayesWeighting\", ScriptedWeighting)\n    monkeypatch.setattr(mp_engine, \"Rebalancer\", StaticRebalancer)\n\n    import trend_analysis.selector as selector_mod\n\n    monkeypatch.setattr(\n        selector_mod, \"create_selector_by_name\", lambda *a, **k: ScriptedSelector()\n    )\n\n    import trend_analysis.core.rank_selection as rank_sel\n\n    metric_maps = {\n        \"AnnualReturn\": {\n            \"Alpha One\": 0.15,\n            \"Alpha Two\": 0.12,\n            \"Beta One\": 0.07,\n            \"Gamma One\": 0.18,\n        },\n        \"Volatility\": {\n            \"Alpha One\": 0.25,\n            \"Alpha Two\": 0.2,\n            \"Beta One\": 0.15,\n            \"Gamma One\": 0.3,\n        },\n        \"Sharpe\": {\n            \"Alpha One\": 0.9,\n            \"Alpha Two\": 0.8,\n            \"Beta One\": 0.4,\n            \"Gamma One\": 1.1,\n        },\n        \"Sortino\": {\n            \"Alpha One\": 1.1,\n            \"Alpha Two\": 0.9,\n            \"Beta One\": 0.45,\n            \"Gamma One\": 1.3,\n        },\n        \"InformationRatio\": {\n            \"Alpha One\": 0.6,\n            \"Alpha Two\": 0.5,\n            \"Beta One\": 0.3,\n            \"Gamma One\": 0.9,\n        },\n        \"MaxDrawdown\": {\n            \"Alpha One\": -0.12,\n            \"Alpha Two\": -0.11,\n            \"Beta One\": -0.05,\n            \"Gamma One\": -0.09,\n        },\n    }\n\n    def fake_metric_series(\n        _frame: pd.DataFrame, metric: str, _stats_cfg: Any\n    ) -> pd.Series:\n        values = metric_maps[metric]\n        return pd.Series(values, dtype=float)\n\n    monkeypatch.setattr(rank_sel, \"_compute_metric_series\", fake_metric_series)\n\n    records: List[Dict[str, Any]] = []\n\n    def fake_run_analysis(\n        _df: pd.DataFrame,\n        in_start: str,\n        in_end: str,\n        out_start: str,\n        out_end: str,\n        _target_vol: float,\n        _monthly_cost: float,\n        *,\n        custom_weights: Dict[str, float],\n        manual_funds: List[str],\n        **_kwargs: Any,\n    ) -> Dict[str, Any]:\n        records.append(\n            {\n                \"weights\": dict(custom_weights),\n                \"funds\": list(manual_funds),\n                \"period\": (in_start, out_end),\n            }\n        )\n        return {\"metrics\": pd.DataFrame(), \"details\": {}, \"seed\": cfg.seed}\n\n    monkeypatch.setattr(mp_engine, \"_run_analysis\", fake_run_analysis)\n\n    results = mp_engine.run(cfg, df=df)\n\n    assert len(results) == 2\n    assert records\n    for record in records:\n        assert len(record[\"weights\"]) <= 2\n        assert len(record[\"funds\"]) <= 2\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_45","type":"reasoning","text":"**Planning test for volatility adjustment and max_weight**\n\nI'm considering adding a new test to ensure that enabling vol_adjust alongside a max_weight constraint properly caps weights without triggering ConstraintViolation errors. There are existing related tests in risk.py, but the acceptance criteria want integration-level checks, possibly in tests/test_pipeline_constraints_integration or tests/test_volatility_settings_wiring.py, where I can run mp_engine with vol_adjust enabled and verify the results. I'll explore how to pass target_vol and vol_adjust settings in these contexts to effectively test this scenario."}}
{"type":"item.started","item":{"id":"item_46","type":"command_execution","command":"/bin/bash -lc 'rg -n \"fund_weights\" tests/test_multi_period* tests/test_pipeline*'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_46","type":"command_execution","command":"/bin/bash -lc 'rg -n \"fund_weights\" tests/test_multi_period* tests/test_pipeline*'","aggregated_output":"tests/test_pipeline_optional_features.py:614:    weights = result[\"fund_weights\"]\ntests/test_pipeline_optional_features.py:651:    weights = result[\"fund_weights\"]\ntests/test_pipeline_optional_features.py:686:    weights = result[\"fund_weights\"]\ntests/test_pipeline_optional_features.py:720:    weights = result[\"fund_weights\"]\ntests/test_pipeline_optional_features.py:895:    weights = result[\"fund_weights\"]\ntests/test_pipeline_helpers_additional.py:100:        \"fund_weights\",\ntests/test_pipeline_helpers_additional.py:736:    assert set(result[\"fund_weights\"]) == {\"FundA\", \"FundB\"}\ntests/test_pipeline_helpers_additional.py:1313:    assert result[\"fund_weights\"][\"FundA\"] != result[\"fund_weights\"][\"FundB\"]\ntests/test_multi_period_engine_threshold_edgecases.py:151:            \"fund_weights\": {},\ntests/test_multi_period_engine_threshold_edgecases.py:904:            \"fund_weights\": {},\ntests/test_multi_period_engine_additional.py:722:def test_run_reconciles_manager_changes_to_pipeline_fund_weights(\ntests/test_multi_period_engine_additional.py:725:    \"\"\"Ensure `manager_changes` matches realised holdings (pipeline fund_weights).\ntests/test_multi_period_engine_additional.py:837:            \"fund_weights\": weights,\ntests/test_multi_period_engine_additional.py:1068:            \"fund_weights\": {},\ntests/test_multi_period_engine_additional.py:1263:            \"fund_weights\": custom,\ntests/test_pipeline_constraints_integration.py:63:    weights = res[\"fund_weights\"]  # mapping fund->weight (excludes CASH synthetic line)\ntests/test_pipeline_constraints_integration.py:93:    weights = res[\"fund_weights\"]\ntests/test_pipeline_constraints_integration.py:117:    weights_long = res_long_only[\"fund_weights\"]\ntests/test_pipeline_constraints_integration.py:135:    weights_short = res_short_ok[\"fund_weights\"]\ntests/test_pipeline_constraints_integration.py:156:    weights_long = res_long_only[\"fund_weights\"]\ntests/test_pipeline_constraints_integration.py:174:    weights_short = res_short_ok[\"fund_weights\"]\ntests/test_multi_period_inception_filter.py:86:        return SimpleNamespace(value={\"fund_weights\": {}}, diagnostic=None)\ntests/test_pipeline_run_cache_fallbacks.py:278:        \"fund_weights\",\ntests/test_multi_period_engine_branch_coverage.py:166:        \"fund_weights\": {},\ntests/test_multi_period_engine_branch_coverage.py:189:        \"fund_weights\": {},\ntests/test_pipeline.py:281:    assert res[\"fund_weights\"][\"A\"] == 1.0\ntests/test_pipeline.py:313:    weights_rp = res_rp[\"fund_weights\"]\ntests/test_pipeline.py:320:    weights_diag = res_diag[\"fund_weights\"]\ntests/test_pipeline.py:464:    assert res[\"fund_weights\"] == {\"A\": pytest.approx(0.6), \"B\": pytest.approx(0.4)}\ntests/test_pipeline.py:497:    assert res[\"fund_weights\"] == {\"A\": pytest.approx(0.5), \"B\": pytest.approx(0.5)}\ntests/test_pipeline_entrypoints.py:95:            \"fund_weights\": {},\ntests/test_pipeline_entrypoints.py:187:        \"fund_weights\",\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_47","type":"reasoning","text":"**Contemplating test placement for vol_adjust_enabled**"}}
{"type":"item.started","item":{"id":"item_48","type":"command_execution","command":"/bin/bash -lc 'rg -n \"run_analysis_with_state\" tests scripts'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_48","type":"command_execution","command":"/bin/bash -lc 'rg -n \"run_analysis_with_state\" tests scripts'","aggregated_output":"scripts/generate_settings_evidence.py:27:    run_analysis_with_state,\nscripts/generate_settings_evidence.py:97:        baseline_result = run_analysis_with_state(returns, baseline_state)\nscripts/generate_settings_evidence.py:112:        test_result = run_analysis_with_state(returns, test_state)\nscripts/test_settings_wiring.py:506:def run_analysis_with_state(\nscripts/test_settings_wiring.py:1280:        baseline_result = run_analysis_with_state(returns, baseline_state)\nscripts/test_settings_wiring.py:1284:        test_result = run_analysis_with_state(returns, test_state)\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_49","type":"reasoning","text":"**Planning tests for volatility adjustment constraints**"}}
{"type":"item.started","item":{"id":"item_50","type":"command_execution","command":"/bin/bash -lc 'rg -n \"risk_diagnostics\" tests/test_pipeline_constraints_integration.py tests/test_pipeline_optional_features.py tests/test_pipeline.py'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_50","type":"command_execution","command":"/bin/bash -lc 'rg -n \"risk_diagnostics\" tests/test_pipeline_constraints_integration.py tests/test_pipeline_optional_features.py tests/test_pipeline.py'","aggregated_output":"tests/test_pipeline_optional_features.py:280:    weights = result[\"risk_diagnostics\"][\"final_weights\"]\ntests/test_pipeline_optional_features.py:444:    base_scale = base[\"risk_diagnostics\"][\"scale_factors\"]\ntests/test_pipeline_optional_features.py:445:    enabled_scale = enabled[\"risk_diagnostics\"][\"scale_factors\"].reindex(\ntests/test_pipeline.py:284:def test_run_full_includes_risk_diagnostics(tmp_path):\ntests/test_pipeline.py:287:    assert \"risk_diagnostics\" in res\ntests/test_pipeline.py:288:    diag = res[\"risk_diagnostics\"]\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_51","type":"reasoning","text":"**Checking risk_diagnostics scaling in tests**"}}
{"type":"item.started","item":{"id":"item_52","type":"command_execution","command":"/bin/bash -lc \"sed -n '250,330p' tests/test_pipeline_optional_features.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_52","type":"command_execution","command":"/bin/bash -lc \"sed -n '250,330p' tests/test_pipeline_optional_features.py\"","aggregated_output":"\n\ndef test_max_active_positions_caps_weights() -> None:\n    df = _regime_returns_frame()\n    rank_kwargs = {\n        \"inclusion_approach\": \"top_n\",\n        \"n\": 4,\n        \"score_by\": \"Sharpe\",\n        \"transform\": \"raw\",\n    }\n    constraints = {\n        \"long_only\": True,\n        \"max_weight\": 1.0,\n        \"max_active_positions\": 2,\n    }\n    result = pipeline._run_analysis(\n        df,\n        \"2020-01\",\n        \"2020-03\",\n        \"2020-04\",\n        \"2020-06\",\n        target_vol=1.0,\n        monthly_cost=0.0,\n        selection_mode=\"rank\",\n        rank_kwargs=rank_kwargs,\n        constraints=constraints,\n        **RUN_KWARGS,\n    )\n    assert result is not None\n    assert len(result[\"selected_funds\"]) == 4\n    weights = result[\"risk_diagnostics\"][\"final_weights\"]\n    active = weights[weights > 0]\n    assert len(active) <= 2\n\n\ndef test_regime_proxy_resolves_benchmark_alias() -> None:\n    df = _regime_returns_frame()\n    rank_kwargs = {\n        \"inclusion_approach\": \"top_n\",\n        \"n\": 3,\n        \"score_by\": \"Sharpe\",\n        \"transform\": \"raw\",\n    }\n    baseline = pipeline._run_analysis(\n        df,\n        \"2020-01\",\n        \"2020-03\",\n        \"2020-04\",\n        \"2020-06\",\n        target_vol=1.0,\n        monthly_cost=0.0,\n        selection_mode=\"rank\",\n        rank_kwargs=rank_kwargs,\n        benchmarks={\"spx\": \"SPX\"},\n        regime_cfg={\"enabled\": False, \"proxy\": \"spx\"},\n        **RUN_KWARGS,\n    )\n    enabled = pipeline._run_analysis(\n        df,\n        \"2020-01\",\n        \"2020-03\",\n        \"2020-04\",\n        \"2020-06\",\n        target_vol=1.0,\n        monthly_cost=0.0,\n        selection_mode=\"rank\",\n        rank_kwargs=rank_kwargs,\n        benchmarks={\"spx\": \"SPX\"},\n        regime_cfg={\n            \"enabled\": True,\n            \"proxy\": \"spx\",\n            \"lookback\": 1,\n            \"smoothing\": 1,\n            \"threshold\": 0.0,\n            \"neutral_band\": 0.0,\n            \"min_observations\": 1,\n        },\n        **RUN_KWARGS,\n    )\n    assert baseline is not None\n    assert enabled is not None\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_53","type":"reasoning","text":"**Searching for risk_diagnostics usage**"}}
{"type":"item.started","item":{"id":"item_54","type":"command_execution","command":"/bin/bash -lc 'rg -n \"risk_diagnostics\" -n src/trend_analysis/pipeline.py | head -n 20'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_54","type":"command_execution","command":"/bin/bash -lc 'rg -n \"risk_diagnostics\" -n src/trend_analysis/pipeline.py | head -n 20'","aggregated_output":"173:    risk_diagnostics: RiskDiagnostics\n1044:        weights_series, risk_diagnostics = compute_constrained_weights(\n1093:        risk_diagnostics = RiskDiagnostics(\n1132:    scale_factors = risk_diagnostics.scale_factors.reindex(fund_cols).fillna(0.0)\n1225:        risk_diagnostics=risk_diagnostics,\n1390:            \"risk_diagnostics\": {\n1391:                \"asset_volatility\": computation.risk_diagnostics.asset_volatility,\n1392:                \"portfolio_volatility\": computation.risk_diagnostics.portfolio_volatility,\n1393:                \"turnover\": computation.risk_diagnostics.turnover,\n1394:                \"turnover_value\": computation.risk_diagnostics.turnover_value,\n1395:                \"scale_factors\": computation.risk_diagnostics.scale_factors,\n1640:        \"risk_diagnostics\": {},\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_55","type":"reasoning","text":"**Examining output near line 1380**"}}
{"type":"item.started","item":{"id":"item_56","type":"command_execution","command":"/bin/bash -lc \"sed -n '1370,1410p' src/trend_analysis/pipeline.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_56","type":"command_execution","command":"/bin/bash -lc \"sed -n '1370,1410p' src/trend_analysis/pipeline.py\"","aggregated_output":"            \"in_sample_scaled\": computation.in_scaled,\n            \"out_sample_scaled\": computation.out_scaled,\n            \"in_sample_stats\": computation.in_stats,\n            \"out_sample_stats\": computation.out_stats,\n            \"out_sample_stats_raw\": computation.out_stats_raw,\n            \"in_ew_stats\": computation.in_ew_stats,\n            \"out_ew_stats\": computation.out_ew_stats,\n            \"out_ew_stats_raw\": computation.out_ew_stats_raw,\n            \"in_user_stats\": computation.in_user_stats,\n            \"out_user_stats\": computation.out_user_stats,\n            \"out_user_stats_raw\": computation.out_user_stats_raw,\n            \"ew_weights\": computation.ew_weights,\n            \"fund_weights\": computation.user_weights,\n            \"benchmark_stats\": benchmark_stats,\n            \"benchmark_ir\": benchmark_ir,\n            \"score_frame\": computation.score_frame,\n            \"weight_engine_fallback\": computation.weight_engine_fallback,\n            \"weight_engine_diagnostics\": computation.weight_engine_diagnostics,\n            \"preprocessing\": preprocess.preprocess_info,\n            \"preprocessing_summary\": preprocess.preprocess_info.get(\"summary\"),\n            \"risk_diagnostics\": {\n                \"asset_volatility\": computation.risk_diagnostics.asset_volatility,\n                \"portfolio_volatility\": computation.risk_diagnostics.portfolio_volatility,\n                \"turnover\": computation.risk_diagnostics.turnover,\n                \"turnover_value\": computation.risk_diagnostics.turnover_value,\n                \"scale_factors\": computation.risk_diagnostics.scale_factors,\n                \"final_weights\": computation.weights_series,\n            },\n            \"signal_frame\": computation.signal_frame,\n            \"signal_spec\": computation.effective_signal_spec,\n            \"performance_by_regime\": regime_payload.get(\"table\", pd.DataFrame()),\n            \"regime_labels\": regime_payload.get(\"labels\", pd.Series(dtype=\"string\")),\n            \"regime_labels_out\": regime_payload.get(\n                \"out_labels\", pd.Series(dtype=\"string\")\n            ),\n            \"regime_notes\": regime_payload.get(\"notes\", []),\n            \"regime_settings\": regime_payload.get(\"settings\", {}),\n            \"regime_summary\": regime_payload.get(\"summary\"),\n            \"metadata\": metadata,\n        }\n    )\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_57","type":"reasoning","text":"**Planning risk diagnostics test adjustments**"}}
{"type":"item.started","item":{"id":"item_58","type":"command_execution","command":"/bin/bash -lc 'rg -n \"def _scale_factors\" -n src/trend_analysis/risk.py'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_58","type":"command_execution","command":"/bin/bash -lc 'rg -n \"def _scale_factors\" -n src/trend_analysis/risk.py'","aggregated_output":"115:def _scale_factors(\n","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_59","type":"command_execution","command":"/bin/bash -lc \"sed -n '100,160p' src/trend_analysis/risk.py\"","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_59","type":"command_execution","command":"/bin/bash -lc \"sed -n '100,160p' src/trend_analysis/risk.py\"","aggregated_output":"            )\n\n        def _ewma_std(values: np.ndarray) -> float:\n            series = pd.Series(values, dtype=float)\n            return float(series.ewm(alpha=alpha, adjust=False).std(bias=False).iloc[-1])\n\n        vol = returns.rolling(window=window.length, min_periods=min_periods_val).apply(\n            _ewma_std, raw=True\n        )\n    else:\n        vol = returns.rolling(window=window.length, **rolling_kwargs).std(ddof=0)\n\n    return vol.mul(np.sqrt(periods_per_year))\n\n\ndef _scale_factors(\n    latest_vol: pd.Series,\n    target_vol: float | None,\n    *,\n    floor_vol: float | None = None,\n) -> pd.Series:\n    if target_vol is None:\n        return pd.Series(1.0, index=latest_vol.index, dtype=float)\n    try:\n        target = float(target_vol)\n    except (TypeError, ValueError):  # pragma: no cover - defensive\n        return pd.Series(1.0, index=latest_vol.index, dtype=float)\n    if target <= 0:\n        return pd.Series(1.0, index=latest_vol.index, dtype=float)\n\n    vol = latest_vol.astype(float).replace(0.0, np.nan)\n    if floor_vol is not None and floor_vol > 0:\n        vol = vol.clip(lower=float(floor_vol))\n    factors = pd.Series(target, index=vol.index, dtype=float).div(vol)\n    factors = factors.replace([np.inf, -np.inf], 0.0).fillna(0.0)\n    return factors\n\n\ndef _normalise(weights: pd.Series) -> pd.Series:\n    total = float(weights.sum())\n    if total == 0.0:\n        return weights.copy()\n    return weights / total\n\n\ndef _apply_turnover_penalty(\n    target: pd.Series,\n    prev: pd.Series | None,\n    lambda_tc: float | None,\n) -> pd.Series:\n    \"\"\"Blend ``target`` towards ``prev`` when ``lambda_tc`` is positive.\"\"\"\n\n    if prev is None:\n        return target\n    if lambda_tc is None:\n        return target\n    try:\n        lam = float(lambda_tc)\n    except (TypeError, ValueError):  # pragma: no cover - defensive\n        lam = 0.0\n    if lam <= 0.0:\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_60","type":"reasoning","text":"**Adding low-volatility returns helper and related tests**\n\nI'll add a helper function to generate deterministic low-volatility returns for FundA using a small sinusoidal variation, then update the existing integration test to use this helper. The test will check that the scale factor for FundA is greater than 1, weights don't exceed 0.35, and results are valid when volatility adjustment is enabled with a target volatility set. This will help verify behavior when FundAs volatility is near zero but non-zero to avoid zero division issues."}}
{"type":"item.completed","item":{"id":"item_61","type":"file_change","changes":[{"path":"/home/runner/work/Trend_Model_Project/Trend_Model_Project/tests/test_pipeline_constraints_integration.py","kind":"update"}],"status":"completed"}}
{"type":"item.completed","item":{"id":"item_62","type":"reasoning","text":"**Preparing to run targeted pytest**"}}
{"type":"item.started","item":{"id":"item_63","type":"command_execution","command":"/bin/bash -lc 'pytest tests/test_pipeline_constraints_integration.py -m \"not slow\"'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_63","type":"command_execution","command":"/bin/bash -lc 'pytest tests/test_pipeline_constraints_integration.py -m \"not slow\"'","aggregated_output":"mkdir -p failed for path /home/runner/.config/matplotlib: [Errno 13] Permission denied: '/home/runner/.config/matplotlib'\nMatplotlib created a temporary cache directory at /tmp/matplotlib-oyghspna because there was an issue with the default path (/home/runner/.config/matplotlib); it is highly recommended to set the MPLCONFIGDIR environment variable to a writable directory, in particular to speed up the import of Matplotlib and to better support multiprocessing.\nINTERNALERROR> Traceback (most recent call last):\nINTERNALERROR>   File \"/opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/_pytest/main.py\", line 314, in wrap_session\nINTERNALERROR>     config._do_configure()\nINTERNALERROR>   File \"/opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/_pytest/config/__init__.py\", line 1159, in _do_configure\nINTERNALERROR>     self.hook.pytest_configure.call_historic(kwargs=dict(config=self))\nINTERNALERROR>   File \"/opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pluggy/_hooks.py\", line 534, in call_historic\nINTERNALERROR>     res = self._hookexec(self.name, self._hookimpls.copy(), kwargs, False)\nINTERNALERROR>           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nINTERNALERROR>   File \"/opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pluggy/_manager.py\", line 120, in _hookexec\nINTERNALERROR>     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)\nINTERNALERROR>            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nINTERNALERROR>   File \"/opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 167, in _multicall\nINTERNALERROR>     raise exception\nINTERNALERROR>   File \"/opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pluggy/_callers.py\", line 121, in _multicall\nINTERNALERROR>     res = hook_impl.function(*args)\nINTERNALERROR>           ^^^^^^^^^^^^^^^^^^^^^^^^^\nINTERNALERROR>   File \"/opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pytest_rerunfailures.py\", line 347, in pytest_configure\nINTERNALERROR>     config.failures_db = ServerStatusDB()\nINTERNALERROR>                          ^^^^^^^^^^^^^^^^\nINTERNALERROR>   File \"/opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pytest_rerunfailures.py\", line 451, in __init__\nINTERNALERROR>     super().__init__()\nINTERNALERROR>   File \"/opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/site-packages/pytest_rerunfailures.py\", line 432, in __init__\nINTERNALERROR>     self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nINTERNALERROR>                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nINTERNALERROR>   File \"/opt/hostedtoolcache/Python/3.11.14/x64/lib/python3.11/socket.py\", line 232, in __init__\nINTERNALERROR>     _socket.socket.__init__(self, family, type, proto, fileno)\nINTERNALERROR> PermissionError: [Errno 1] Operation not permitted\n","exit_code":3,"status":"failed"}}
{"type":"item.completed","item":{"id":"item_64","type":"reasoning","text":"**Adjusting test environment**"}}
{"type":"item.started","item":{"id":"item_65","type":"command_execution","command":"/bin/bash -lc 'PYTEST_DISABLE_PLUGIN_AUTOLOAD=1 MPLCONFIGDIR=/tmp pytest tests/test_pipeline_constraints_integration.py -m \"not slow\"'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_65","type":"command_execution","command":"/bin/bash -lc 'PYTEST_DISABLE_PLUGIN_AUTOLOAD=1 MPLCONFIGDIR=/tmp pytest tests/test_pipeline_constraints_integration.py -m \"not slow\"'","aggregated_output":"============================= test session starts ==============================\nplatform linux -- Python 3.11.14, pytest-9.0.2, pluggy-1.6.0\nrootdir: /home/runner/work/Trend_Model_Project/Trend_Model_Project\nconfigfile: pytest.ini (WARNING: ignoring pytest config in pyproject.toml!)\ncollected 4 items\n\ntests/test_pipeline_constraints_integration.py ....                      [100%]\n\n============================== 4 passed in 0.44s ===============================\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_66","type":"reasoning","text":"**Preparing to commit changes**"}}
{"type":"item.started","item":{"id":"item_67","type":"command_execution","command":"/bin/bash -lc 'git status -sb'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_67","type":"command_execution","command":"/bin/bash -lc 'git status -sb'","aggregated_output":"## codex/issue-4135...origin/codex/issue-4135\n M codex-session-4136.jsonl\n M tests/test_pipeline_constraints_integration.py\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_68","type":"reasoning","text":"**Handling unintentional file changes**"}}
{"type":"item.started","item":{"id":"item_69","type":"command_execution","command":"/bin/bash -lc 'git add tests/test_pipeline_constraints_integration.py'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_69","type":"command_execution","command":"/bin/bash -lc 'git add tests/test_pipeline_constraints_integration.py'","aggregated_output":"","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_70","type":"reasoning","text":"**Committing changes**"}}
{"type":"item.started","item":{"id":"item_71","type":"command_execution","command":"/bin/bash -lc 'git commit -m \"Test max weight with vol scaling\"'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_71","type":"command_execution","command":"/bin/bash -lc 'git commit -m \"Test max weight with vol scaling\"'","aggregated_output":"Author identity unknown\n\n*** Please tell me who you are.\n\nRun\n\n  git config --global user.email \"you@example.com\"\n  git config --global user.name \"Your Name\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n\nfatal: empty ident name (for <runner@runnervmh13bl.ol4x2y3psyue1kkbfce20tfene.bx.internal.cloudapp.net>) not allowed\n","exit_code":128,"status":"failed"}}
{"type":"item.completed","item":{"id":"item_72","type":"reasoning","text":"**Configuring local git user info**"}}
{"type":"item.started","item":{"id":"item_73","type":"command_execution","command":"/bin/bash -lc 'git config user.email \"codex@example.com\"'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_73","type":"command_execution","command":"/bin/bash -lc 'git config user.email \"codex@example.com\"'","aggregated_output":"","exit_code":0,"status":"completed"}}
{"type":"item.started","item":{"id":"item_74","type":"command_execution","command":"/bin/bash -lc 'git config user.name \"Codex\"'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_74","type":"command_execution","command":"/bin/bash -lc 'git config user.name \"Codex\"'","aggregated_output":"","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_75","type":"reasoning","text":"**Committing changes**"}}
{"type":"item.started","item":{"id":"item_76","type":"command_execution","command":"/bin/bash -lc 'git commit -m \"Test max weight with vol scaling\"'","aggregated_output":"","exit_code":null,"status":"in_progress"}}
{"type":"item.completed","item":{"id":"item_76","type":"command_execution","command":"/bin/bash -lc 'git commit -m \"Test max weight with vol scaling\"'","aggregated_output":"[codex/issue-4135 88685f75] Test max weight with vol scaling\n 1 file changed, 18 insertions(+), 2 deletions(-)\n","exit_code":0,"status":"completed"}}
{"type":"item.completed","item":{"id":"item_77","type":"reasoning","text":"**Preparing final response**"}}
{"type":"item.completed","item":{"id":"item_78","type":"agent_message","text":"Updated `tests/test_pipeline_constraints_integration.py` to use lowvol returns and assert vol scaling actually ramps FundA while max_weight still caps allocations at 0.35.\n\nTests:\n- `PYTEST_DISABLE_PLUGIN_AUTOLOAD=1 MPLCONFIGDIR=/tmp pytest tests/test_pipeline_constraints_integration.py -m \"not slow\"` (initial run failed due to socket permission from an autoloaded plugin)\n\nNotes:\n- There is an unstaged change in `codex-session-4136.jsonl` (left uncommitted).\n\nNext steps:\n1. Run a broader targeted suite if you want extra confidence (e.g., `pytest tests/test_risk.py -m \"not slow\"`)."}}
{"type":"turn.completed","usage":{"input_tokens":1840877,"cached_input_tokens":1733504,"output_tokens":9040}}
